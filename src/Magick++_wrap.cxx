/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.2.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */


#define SWIG_VERSION 0x040200
#define SWIGJAVASCRIPT
/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) do { if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } } while (0) 



#include <node.h>
//Older version of node.h does not include this
#include <node_version.h>


#include <v8.h>

#undef SWIG_V8_VERSION
#define SWIG_V8_VERSION ((V8_MAJOR_VERSION / 10) * 4096 + \
                         (V8_MAJOR_VERSION % 10) * 256 + \
                         (V8_MINOR_VERSION / 10) * 16 + \
                         (V8_MINOR_VERSION % 10))

#include <errno.h>
#include <limits.h>
#include <stdlib.h>
#include <assert.h>

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.

  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2
#define SWIG_POINTER_NO_NULL       0x4
#define SWIG_POINTER_CLEAR         0x8
#define SWIG_POINTER_RELEASE       (SWIG_POINTER_CLEAR | SWIG_POINTER_DISOWN)

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/*
   Flags/methods for returning states.

   The SWIG conversion methods, as ConvertPtr, return an integer
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).

   Use the following macros/flags to set or process the returning
   states.

   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }

   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {
        if (<obj is ok>) {
          if (<need new object>) {
            *ptr = <ptr to new allocated object>;
            return SWIG_NEWOBJ;
          } else {
            *ptr = <ptr to old object>;
            return SWIG_OLDOBJ;
          }
        } else {
          return SWIG_BADOBJ;
        }
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows returning the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call

      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0)
/* Runtime errors are < 0 */
#define SWIG_ERROR                 (-1)
/* Errors in range -1 to -99 are in swigerrors.swg (errors for all languages including those not using the runtime) */
/* Errors in range -100 to -199 are language specific errors defined in *errors.swg */
/* Errors < -200 are generic runtime specific errors */
#define SWIG_ERROR_RELEASE_NOT_OWNED (-200)

#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del object mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) {
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) {
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0;
}
#else /* no cast-rank mode */
#  define SWIG_AddCast(r) (r)
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/*
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCmp(const char *nb, const char *tb) {
  int equiv = 1;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (equiv != 0 && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(const swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/*
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  Choose the last
     name. It should be the most specific; a fully resolved name
     but not necessarily with default template parameters expanded. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;

  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start,
                            swig_module_info *end,
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      size_t l = 0;
      size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	size_t i = (l + r) >> 1;
	const char *iname = iter->types[i]->name;
	if (iname) {
	  int compare = strcmp(name, iname);
	  if (compare == 0) {
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start,
                     swig_module_info *end,
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }

  /* neither found a match */
  return 0;
}

/*
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  const unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/*
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    char d = *(c++);
    unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = (unsigned char)((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = (unsigned char)((d - ('a'-10)) << 4);
    else
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (unsigned char)(d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (unsigned char)(d - ('a'-10));
    else
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/* SWIG Errors applicable to all language modules, values are reserved from -1 to -99 */
#define  SWIG_UnknownError    	   -1
#define  SWIG_IOError        	   -2
#define  SWIG_RuntimeError   	   -3
#define  SWIG_IndexError     	   -4
#define  SWIG_TypeError      	   -5
#define  SWIG_DivisionByZero 	   -6
#define  SWIG_OverflowError  	   -7
#define  SWIG_SyntaxError    	   -8
#define  SWIG_ValueError     	   -9
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12
#define  SWIG_NullReferenceError   -13


/* ---------------------------------------------------------------------------
 * These typedefs and defines are used to deal with v8 API changes
 *
 * Useful table of versions: https://nodejs.org/en/download/releases/
 * ---------------------------------------------------------------------------*/

#if (SWIG_V8_VERSION < 0x0704)
#define SWIGV8_STRING_NEW2(cstr, len) v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), cstr, v8::String::kNormalString, len)
#else
#define SWIGV8_STRING_NEW2(cstr, len) (v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), cstr, v8::NewStringType::kNormal, len)).ToLocalChecked()
#endif

typedef void SwigV8ReturnValue;
typedef v8::FunctionCallbackInfo<v8::Value> SwigV8Arguments;
typedef v8::PropertyCallbackInfo<v8::Value> SwigV8PropertyCallbackInfo;
#define SWIGV8_RETURN(val) args.GetReturnValue().Set(val); return
#define SWIGV8_RETURN_INFO(val, info) info.GetReturnValue().Set(val); return

#define SWIGV8_HANDLESCOPE() v8::HandleScope scope(v8::Isolate::GetCurrent());
#define SWIGV8_HANDLESCOPE_ESC() v8::EscapableHandleScope scope(v8::Isolate::GetCurrent());
#define SWIGV8_ESCAPE(val) return scope.Escape(val)

#define SWIGV8_ADJUST_MEMORY(size) v8::Isolate::GetCurrent()->AdjustAmountOfExternalAllocatedMemory(size)
#define SWIGV8_CURRENT_CONTEXT() v8::Isolate::GetCurrent()->GetCurrentContext()
#define SWIGV8_THROW_EXCEPTION(err) v8::Isolate::GetCurrent()->ThrowException(err)

#if (SWIG_V8_VERSION < 0x0704)
#define SWIGV8_STRING_NEW(str) v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), str, v8::String::kNormalString)
#define SWIGV8_SYMBOL_NEW(sym) v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), sym, v8::String::kNormalString)
#else
#define SWIGV8_STRING_NEW(str) (v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), str, v8::NewStringType::kNormal)).ToLocalChecked()
#define SWIGV8_SYMBOL_NEW(sym) (v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), sym, v8::NewStringType::kNormal)).ToLocalChecked()
#endif

#if (SWIG_V8_VERSION < 0x0704)
#define SWIGV8_MAYBE_CHECK(maybe) maybe.FromJust()
#else
#define SWIGV8_MAYBE_CHECK(maybe) maybe.Check()
#endif

#define SWIGV8_ARRAY_NEW(size) v8::Array::New(v8::Isolate::GetCurrent(), size)
#define SWIGV8_BOOLEAN_NEW(bool) v8::Boolean::New(v8::Isolate::GetCurrent(), bool)
#define SWIGV8_EXTERNAL_NEW(val) v8::External::New(v8::Isolate::GetCurrent(), val)
#define SWIGV8_FUNCTEMPLATE_NEW(func) v8::FunctionTemplate::New(v8::Isolate::GetCurrent(), func)
#define SWIGV8_FUNCTEMPLATE_NEW_VOID() v8::FunctionTemplate::New(v8::Isolate::GetCurrent())
#define SWIGV8_INT32_NEW(num) v8::Int32::New(v8::Isolate::GetCurrent(), num)
#define SWIGV8_INTEGER_NEW(num) v8::Integer::New(v8::Isolate::GetCurrent(), num)
#define SWIGV8_INTEGER_NEW_UNS(num) v8::Integer::NewFromUnsigned(v8::Isolate::GetCurrent(), num)
#define SWIGV8_NUMBER_NEW(num) v8::Number::New(v8::Isolate::GetCurrent(), num)
#define SWIGV8_OBJECT_NEW() v8::Object::New(v8::Isolate::GetCurrent())
#define SWIGV8_UNDEFINED() v8::Undefined(v8::Isolate::GetCurrent())
#define SWIGV8_ARRAY v8::Local<v8::Array>
#define SWIGV8_FUNCTION_TEMPLATE v8::Local<v8::FunctionTemplate>
#define SWIGV8_OBJECT v8::Local<v8::Object>
#define SWIGV8_OBJECT_TEMPLATE v8::Local<v8::ObjectTemplate>
#define SWIGV8_VALUE v8::Local<v8::Value>
#define SWIGV8_NULL() v8::Null(v8::Isolate::GetCurrent())
#define SWIGV8_ARRAY_GET(array, index) (array)->Get(SWIGV8_CURRENT_CONTEXT(), index).ToLocalChecked()
#define SWIGV8_ARRAY_SET(array, index, value) SWIGV8_MAYBE_CHECK((array)->Set(SWIGV8_CURRENT_CONTEXT(), index, value))

#define SWIGV8_SET_CLASS_TEMPL(class_templ, class) class_templ.Reset(v8::Isolate::GetCurrent(), class);

#if SWIG_V8_VERSION < 0x0608
#define SWIGV8_TO_OBJECT(handle) (handle)->ToObject()
#define SWIGV8_TO_STRING(handle) (handle)->ToString()
#define SWIGV8_NUMBER_VALUE(handle) (handle)->NumberValue()
#define SWIGV8_INTEGER_VALUE(handle) (handle)->IntegerValue()
#define SWIGV8_BOOLEAN_VALUE(handle) (handle)->BooleanValue()
#define SWIGV8_WRITE_UTF8(handle, buffer, len) (handle)->WriteUtf8(buffer, len)
#define SWIGV8_UTF8_LENGTH(handle) (handle)->Utf8Length()
#else
#define SWIGV8_TO_OBJECT(handle) (handle)->ToObject(SWIGV8_CURRENT_CONTEXT()).ToLocalChecked()
#define SWIGV8_TO_STRING(handle) (handle)->ToString(SWIGV8_CURRENT_CONTEXT()).ToLocalChecked()
#define SWIGV8_NUMBER_VALUE(handle) (handle)->NumberValue(SWIGV8_CURRENT_CONTEXT()).ToChecked()
#define SWIGV8_INTEGER_VALUE(handle) (handle)->IntegerValue(SWIGV8_CURRENT_CONTEXT()).ToChecked()
#define SWIGV8_WRITE_UTF8(handle, buffer, len) (handle)->WriteUtf8(v8::Isolate::GetCurrent(), buffer, len)
#define SWIGV8_UTF8_LENGTH(handle) (handle)->Utf8Length(v8::Isolate::GetCurrent())
#if (SWIG_V8_VERSION < 0x0704)
#define SWIGV8_BOOLEAN_VALUE(handle) (handle)->BooleanValue(SWIGV8_CURRENT_CONTEXT()).ToChecked()
#else
#define SWIGV8_BOOLEAN_VALUE(handle) (handle)->BooleanValue(v8::Isolate::GetCurrent())
#endif
#endif

/* ---------------------------------------------------------------------------
 * Error handling
 *
 * ---------------------------------------------------------------------------*/

#define SWIG_Error(code, msg)     SWIGV8_ErrorHandler.error(code, msg)
#define SWIG_exception(code, msg) do { SWIGV8_ErrorHandler.error(code, msg); SWIG_fail; } while (0)
#define SWIG_fail                 goto fail
#define SWIGV8_OVERLOAD false

SWIGINTERN void SWIG_V8_Raise(const char *msg) {
  SWIGV8_THROW_EXCEPTION(v8::Exception::Error(SWIGV8_STRING_NEW(msg)));
}

SWIGINTERN void SWIG_V8_Raise(SWIGV8_VALUE obj, const char *msg) {
  SWIGV8_THROW_EXCEPTION(v8::Exception::Error(SWIGV8_TO_STRING(obj)));
}


/*
  Note: There are two contexts for handling errors.
  A static V8ErrorHandler is used in not overloaded methods.
  For overloaded methods the throwing type checking mechanism is used
  during dispatching. As V8 exceptions can not be reset properly
  the trick is to use a dynamic ErrorHandler with same local name as the global
  one.

  - See definition of SWIG_Error above.
  - See code templates 'JS_function_dispatcher', 'JS_functionwrapper_overload',
    and 'JS_function_dispatch_case' in javascriptcode.swg

*/
class V8ErrorHandler {
public:
  virtual ~V8ErrorHandler() {}
  virtual void error(int code, const char *msg) {
    SWIG_V8_Raise(msg);
  }
};
// this is used in usually
SWIGRUNTIME V8ErrorHandler SWIGV8_ErrorHandler;

// instances of this are used in overloaded functions
class OverloadErrorHandler: public V8ErrorHandler {
public:
  virtual void error(int code, const char *msg) {
    err = v8::Exception::Error(SWIGV8_STRING_NEW(msg));
    if(code != SWIG_TypeError) {
        SWIGV8_THROW_EXCEPTION(err);
    }
  }
  SWIGV8_VALUE err;
};

/* ---------------------------------------------------------------------------
 * Basic Proxy object
 *
 * ---------------------------------------------------------------------------*/

// Note: to trigger the v8 gc more often one can tell v8 about the memory consumption
// TODO: we could add a v8 specific parameter to control this value
#define SWIGV8_AVG_OBJ_SIZE 1000

class SWIGV8_Proxy {
public:
  SWIGV8_Proxy(): swigCMemOwn(false), swigCObject(0), info(0) {
    SWIGV8_ADJUST_MEMORY(SWIGV8_AVG_OBJ_SIZE);
  };

  ~SWIGV8_Proxy() {
    handle.ClearWeak();
    handle.Reset();

    SWIGV8_ADJUST_MEMORY(-SWIGV8_AVG_OBJ_SIZE);
  }

  bool swigCMemOwn;
  void *swigCObject;
  swig_type_info *info;
  v8::Persistent<v8::Object> handle;
};

class SWIGV8_ClientData {
public:
  v8::Persistent<v8::FunctionTemplate> class_templ;

  void (*dtor) (const v8::WeakCallbackInfo<SWIGV8_Proxy> &data);
};

SWIGRUNTIME v8::Persistent<v8::FunctionTemplate> SWIGV8_SWIGTYPE_Proxy_class_templ;

SWIGRUNTIME int SWIG_V8_ConvertInstancePtr(SWIGV8_OBJECT objRef, void **ptr, swig_type_info *info, int flags) {
  SWIGV8_HANDLESCOPE();

  if(objRef->InternalFieldCount() < 1) return SWIG_ERROR;

  SWIGV8_Proxy *cdata = static_cast<SWIGV8_Proxy *>(objRef->GetAlignedPointerFromInternalField(0));

  if(cdata == NULL) {
    return SWIG_ERROR;
  }
  if(info && cdata->info != info) {
    swig_cast_info *tc = SWIG_TypeCheckStruct(cdata->info, info);
    if (!tc && cdata->info->name) {
      tc = SWIG_TypeCheck(cdata->info->name, info);
    }
    bool type_valid = tc != 0;
    if(!type_valid) {
      return SWIG_TypeError;
    }
    int newmemory = 0;
    *ptr = SWIG_TypeCast(tc, cdata->swigCObject, &newmemory);
    assert(!newmemory); /* newmemory handling not yet implemented */
  } else {
    *ptr = cdata->swigCObject;
  }

  if (((flags & SWIG_POINTER_RELEASE) == SWIG_POINTER_RELEASE) && !cdata->swigCMemOwn) {
    return SWIG_ERROR_RELEASE_NOT_OWNED;
  } else {
    if (flags & SWIG_POINTER_DISOWN) {
      cdata->swigCMemOwn = false;
    }
    if (flags & SWIG_POINTER_CLEAR) {
      cdata->swigCObject = 0;
    }
  }
  return SWIG_OK;
}


SWIGRUNTIME void SWIGV8_Proxy_DefaultDtor(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  delete proxy;
}

SWIGRUNTIME int SWIG_V8_GetInstancePtr(SWIGV8_VALUE valRef, void **ptr) {
  if(!valRef->IsObject()) {
    return SWIG_TypeError;
  }
  SWIGV8_OBJECT objRef = SWIGV8_OBJECT::Cast(valRef);

  if(objRef->InternalFieldCount() < 1) return SWIG_ERROR;

  SWIGV8_Proxy *cdata = static_cast<SWIGV8_Proxy *>(objRef->GetAlignedPointerFromInternalField(0));

  if(cdata == NULL) {
    return SWIG_ERROR;
  }

  *ptr = cdata->swigCObject;

  return SWIG_OK;
}

SWIGRUNTIME void SWIGV8_SetPrivateData(SWIGV8_OBJECT obj, void *ptr, swig_type_info *info, int flags) {
  SWIGV8_Proxy *cdata = new SWIGV8_Proxy();
  cdata->swigCObject = ptr;
  cdata->swigCMemOwn = (flags & SWIG_POINTER_OWN) ? 1 : 0;
  cdata->info = info;

  obj->SetAlignedPointerInInternalField(0, cdata);

  cdata->handle.Reset(v8::Isolate::GetCurrent(), obj);

  if(cdata->swigCMemOwn && (SWIGV8_ClientData*)info->clientdata) {
    cdata->handle.SetWeak(cdata, ((SWIGV8_ClientData*)info->clientdata)->dtor, v8::WeakCallbackType::kParameter);
  } else {
    cdata->handle.SetWeak(cdata, SWIGV8_Proxy_DefaultDtor, v8::WeakCallbackType::kParameter);
  }

#if (SWIG_V8_VERSION < 0x0704)
  cdata->handle.MarkIndependent();
// Looks like future versions do not require that anymore:
// https://monorail-prod.appspot.com/p/chromium/issues/detail?id=923361#c11
#endif
}

SWIGRUNTIME int SWIG_V8_ConvertPtr(SWIGV8_VALUE valRef, void **ptr, swig_type_info *info, int flags) {
  SWIGV8_HANDLESCOPE();
  
  /* special case: JavaScript null => C NULL pointer */
  if(valRef->IsNull()) {
    *ptr=0;
    return (flags & SWIG_POINTER_NO_NULL) ? SWIG_NullReferenceError : SWIG_OK;
  }
  if(!valRef->IsObject()) {
    return SWIG_TypeError;
  }
  SWIGV8_OBJECT objRef = SWIGV8_OBJECT::Cast(valRef);
  return SWIG_V8_ConvertInstancePtr(objRef, ptr, info, flags);
}

SWIGRUNTIME SWIGV8_VALUE SWIG_V8_NewPointerObj(void *ptr, swig_type_info *info, int flags) {
  SWIGV8_HANDLESCOPE_ESC();
  
  SWIGV8_FUNCTION_TEMPLATE class_templ;

  if (ptr == NULL) {
    v8::Local<v8::Primitive> result = SWIGV8_NULL();
    SWIGV8_ESCAPE(result);
  }

  v8::Isolate *isolate = v8::Isolate::GetCurrent();

  if(info->clientdata != 0) {
    class_templ = v8::Local<v8::FunctionTemplate>::New(isolate, ((SWIGV8_ClientData*) info->clientdata)->class_templ);
  } else {
    class_templ = v8::Local<v8::FunctionTemplate>::New(isolate, SWIGV8_SWIGTYPE_Proxy_class_templ);
  }

  v8::Local<v8::Object> result = class_templ->InstanceTemplate()->NewInstance(SWIGV8_CURRENT_CONTEXT()).ToLocalChecked();

  SWIGV8_SetPrivateData(result, ptr, info, flags);

  SWIGV8_ESCAPE(result);
}

#define SWIG_ConvertPtr(obj, ptr, info, flags)    SWIG_V8_ConvertPtr(obj, ptr, info, flags)
#define SWIG_NewPointerObj(ptr, info, flags)      SWIG_V8_NewPointerObj(ptr, info, flags)

#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_V8_ConvertInstancePtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(thisvalue, type, flags)     SWIG_V8_NewPointerObj(thisvalue, type, flags)

#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_V8_ConvertPtr(obj, pptr, type, 0)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_V8_NewPointerObj(ptr, type, 0)

#define SWIG_GetInstancePtr(obj, ptr)    SWIG_V8_GetInstancePtr(obj, ptr)

SWIGRUNTIME SwigV8ReturnValue _SWIGV8_wrap_equals(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  void *arg1 = (void *) 0 ;
  void *arg2 = (void *) 0 ;
  bool result;
  int res1;
  int res2;

  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for equals.");

  res1 = SWIG_GetInstancePtr(args.Holder(), &arg1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ERROR, "Could not get pointer from 'this' object for equals.");
  }
  res2 = SWIG_GetInstancePtr(args[0], &arg2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equals" "', argument " "1"" of type '" "void *""'");
  }

  result = (bool)(arg1 == arg2);
  jsresult =  SWIGV8_BOOLEAN_NEW(result);

  SWIGV8_RETURN(jsresult);
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}

SWIGRUNTIME SwigV8ReturnValue _wrap_getCPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  void *arg1 = (void *) 0 ;
  long result;
  int res1;

  res1 = SWIG_GetInstancePtr(args.Holder(), &arg1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getCPtr" "', argument " "1"" of type '" "void *""'");
  }

  result = (long)arg1;
  jsresult = SWIGV8_NUMBER_NEW(result);

  SWIGV8_RETURN(jsresult);
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}

/* ---------------------------------------------------------------------------
 * PackedData object
 *
 * ---------------------------------------------------------------------------*/

class SwigV8PackedData {
public:
  SwigV8PackedData(void *data, size_t size, swig_type_info *type): data(data), size(size), type(type) {};

  ~SwigV8PackedData() {
  };

  void *data;
  size_t size;
  swig_type_info *type;

  v8::Persistent<v8::Object> handle;
};

SWIGRUNTIMEINLINE
int SwigV8Packed_Check(SWIGV8_VALUE valRef) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT objRef = SWIGV8_TO_OBJECT(valRef);
  if(objRef->InternalFieldCount() < 1) return false;
  v8::Local<v8::Private> privateKey = v8::Private::ForApi(v8::Isolate::GetCurrent(), SWIGV8_STRING_NEW("__swig__packed_data__"));
  v8::Local<v8::Value> flag;
  if (!objRef->GetPrivate(SWIGV8_CURRENT_CONTEXT(), privateKey).ToLocal(&flag))
    return false;
  return (flag->IsBoolean() && SWIGV8_BOOLEAN_VALUE(flag));
}

SWIGRUNTIME
swig_type_info *SwigV8Packed_UnpackData(SWIGV8_VALUE valRef, void *ptr, size_t size) {
  if (SwigV8Packed_Check(valRef)) {
    SWIGV8_HANDLESCOPE();
    
    SwigV8PackedData *sobj;

    SWIGV8_OBJECT objRef = SWIGV8_TO_OBJECT(valRef);

    sobj = static_cast<SwigV8PackedData*>(objRef->GetAlignedPointerFromInternalField(0));
    if (sobj == NULL || sobj->size != size) return 0;
    memcpy(ptr, sobj->data, size);
    return sobj->type;
  } else {
    return 0;
  }
}

SWIGRUNTIME
int SWIGV8_ConvertPacked(SWIGV8_VALUE valRef, void *ptr, size_t sz, swig_type_info *ty) {
  swig_type_info *to = SwigV8Packed_UnpackData(valRef, ptr, sz);
  if (!to) return SWIG_ERROR;
  if (ty) {
    if (to != ty) {
      /* check type cast? */
      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
      if (!tc) return SWIG_ERROR;
    }
  }
  return SWIG_OK;
}

SWIGRUNTIME void _wrap_SwigV8PackedData_delete(const v8::WeakCallbackInfo<SwigV8PackedData> &data) {
  SwigV8PackedData *cdata = data.GetParameter();
  delete cdata;
}

SWIGRUNTIME
SWIGV8_VALUE SWIGV8_NewPackedObj(void *data, size_t size, swig_type_info *type) {
  SWIGV8_HANDLESCOPE_ESC();

  SwigV8PackedData *cdata = new SwigV8PackedData(data, size, type);
//  v8::Handle<v8::Object> obj = SWIGV8_OBJECT_NEW();
  v8::Local<v8::Object> obj = SWIGV8_OBJECT_NEW();

  v8::Local<v8::Private> privateKey = v8::Private::ForApi(v8::Isolate::GetCurrent(), SWIGV8_STRING_NEW("__swig__packed_data__"));
  obj->SetPrivate(SWIGV8_CURRENT_CONTEXT(), privateKey, SWIGV8_BOOLEAN_NEW(true));

  obj->SetAlignedPointerInInternalField(0, cdata);

  cdata->handle.Reset(v8::Isolate::GetCurrent(), obj);

  cdata->handle.SetWeak(cdata, _wrap_SwigV8PackedData_delete, v8::WeakCallbackType::kParameter);

#if (SWIG_V8_VERSION < 0x0704)
  cdata->handle.MarkIndependent();
// Looks like future versions do not require that anymore:
// https://monorail-prod.appspot.com/p/chromium/issues/detail?id=923361#c11
#endif

  SWIGV8_ESCAPE(obj);

}

#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIGV8_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIGV8_NewPackedObj(ptr, sz, type)


/* ---------------------------------------------------------------------------
 * Support for IN/OUTPUT typemaps (see Lib/typemaps/inoutlist.swg)
 *
 * ---------------------------------------------------------------------------*/

SWIGRUNTIME

SWIGV8_VALUE SWIGV8_AppendOutput(SWIGV8_VALUE result, SWIGV8_VALUE obj) {
  SWIGV8_HANDLESCOPE_ESC();
  
  if (result->IsUndefined()) {
    result = SWIGV8_ARRAY_NEW(0);
  } else if (!result->IsArray()) {
    SWIGV8_ARRAY tmparr = SWIGV8_ARRAY_NEW(0);
    SWIGV8_ARRAY_SET(tmparr, 0, result);
    result = tmparr;
  }

  SWIGV8_ARRAY arr = SWIGV8_ARRAY::Cast(result);
  SWIGV8_ARRAY_SET(arr, arr->Length(), obj);
  SWIGV8_ESCAPE(arr);
}



typedef v8::FunctionCallback            SwigV8FunctionCallback;
typedef v8::AccessorNameGetterCallback  SwigV8AccessorGetterCallback;
typedef v8::AccessorNameSetterCallback  SwigV8AccessorSetterCallback;
typedef v8::PropertyCallbackInfo<void>  SwigV8PropertyCallbackInfoVoid;

/**
 * Creates a class template for a class with specified initialization function.
 */
SWIGRUNTIME SWIGV8_FUNCTION_TEMPLATE SWIGV8_CreateClassTemplate(const char* symbol) {
    SWIGV8_HANDLESCOPE_ESC();
    
    v8::Local<v8::FunctionTemplate> class_templ = SWIGV8_FUNCTEMPLATE_NEW_VOID();
    class_templ->SetClassName(SWIGV8_SYMBOL_NEW(symbol));

    SWIGV8_OBJECT_TEMPLATE inst_templ = class_templ->InstanceTemplate();
    inst_templ->SetInternalFieldCount(1);

    SWIGV8_OBJECT_TEMPLATE equals_templ = class_templ->PrototypeTemplate();
    equals_templ->Set(SWIGV8_SYMBOL_NEW("equals"), SWIGV8_FUNCTEMPLATE_NEW(_SWIGV8_wrap_equals));

    SWIGV8_OBJECT_TEMPLATE cptr_templ = class_templ->PrototypeTemplate();
    cptr_templ->Set(SWIGV8_SYMBOL_NEW("getCPtr"), SWIGV8_FUNCTEMPLATE_NEW(_wrap_getCPtr));

    SWIGV8_ESCAPE(class_templ);
}

/**
 * Registers a class method with given name for a given class template.
 */
SWIGRUNTIME void SWIGV8_AddMemberFunction(SWIGV8_FUNCTION_TEMPLATE class_templ, const char* symbol,
  SwigV8FunctionCallback _func) {
    SWIGV8_OBJECT_TEMPLATE proto_templ = class_templ->PrototypeTemplate();
    proto_templ->Set(SWIGV8_SYMBOL_NEW(symbol), SWIGV8_FUNCTEMPLATE_NEW(_func));
}

/**
 * Registers a class property with given name for a given class template.
 */
SWIGRUNTIME void SWIGV8_AddMemberVariable(SWIGV8_FUNCTION_TEMPLATE class_templ, const char* symbol,
  SwigV8AccessorGetterCallback getter, SwigV8AccessorSetterCallback setter) {
  SWIGV8_OBJECT_TEMPLATE proto_templ = class_templ->InstanceTemplate();
  proto_templ->SetAccessor(SWIGV8_SYMBOL_NEW(symbol), getter, setter);
}

/**
 * Registers a class method with given name for a given object.
 */
SWIGRUNTIME void SWIGV8_AddStaticFunction(SWIGV8_OBJECT obj, const char* symbol,
  const SwigV8FunctionCallback& _func, v8::Local<v8::Context> context) {
  SWIGV8_MAYBE_CHECK(obj->Set(context, SWIGV8_SYMBOL_NEW(symbol), SWIGV8_FUNCTEMPLATE_NEW(_func)->GetFunction(context).ToLocalChecked()));
}

/**
 * Registers a class method with given name for a given object.
 */
SWIGRUNTIME void SWIGV8_AddStaticVariable(SWIGV8_OBJECT obj, const char* symbol,
  SwigV8AccessorGetterCallback getter, SwigV8AccessorSetterCallback setter,
  v8::Local<v8::Context> context) {
  SWIGV8_MAYBE_CHECK(obj->SetAccessor(context, SWIGV8_SYMBOL_NEW(symbol), getter, setter));
}

SWIGRUNTIME void JS_veto_set_variable(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid& info)
{
    char buffer[256];
    char msg[512];
    int res;

    v8::Local<v8::String> sproperty;
    if (property->ToString(SWIGV8_CURRENT_CONTEXT()).ToLocal(&sproperty)) {
      SWIGV8_WRITE_UTF8(sproperty, buffer, 256);
      res = sprintf(msg, "Tried to write read-only variable: %s.", buffer);
    }
    else {
      res = -1;
    }

    if(res<0) {
      SWIG_exception(SWIG_ERROR, "Tried to write read-only variable.");
    } else {
      SWIG_exception(SWIG_ERROR, msg);
    }
fail: ;
}


/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) do { if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } } while (0) 



#include <node.h>
//Older version of node.h does not include this
#include <node_version.h>


#include <v8.h>

#undef SWIG_V8_VERSION
#define SWIG_V8_VERSION ((V8_MAJOR_VERSION / 10) * 4096 + \
                         (V8_MAJOR_VERSION % 10) * 256 + \
                         (V8_MINOR_VERSION / 10) * 16 + \
                         (V8_MINOR_VERSION % 10))

#include <errno.h>
#include <limits.h>
#include <stdlib.h>
#include <assert.h>

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.

  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2
#define SWIG_POINTER_NO_NULL       0x4
#define SWIG_POINTER_CLEAR         0x8
#define SWIG_POINTER_RELEASE       (SWIG_POINTER_CLEAR | SWIG_POINTER_DISOWN)

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/*
   Flags/methods for returning states.

   The SWIG conversion methods, as ConvertPtr, return an integer
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).

   Use the following macros/flags to set or process the returning
   states.

   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }

   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {
        if (<obj is ok>) {
          if (<need new object>) {
            *ptr = <ptr to new allocated object>;
            return SWIG_NEWOBJ;
          } else {
            *ptr = <ptr to old object>;
            return SWIG_OLDOBJ;
          }
        } else {
          return SWIG_BADOBJ;
        }
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows returning the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call

      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0)
/* Runtime errors are < 0 */
#define SWIG_ERROR                 (-1)
/* Errors in range -1 to -99 are in swigerrors.swg (errors for all languages including those not using the runtime) */
/* Errors in range -100 to -199 are language specific errors defined in *errors.swg */
/* Errors < -200 are generic runtime specific errors */
#define SWIG_ERROR_RELEASE_NOT_OWNED (-200)

#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del object mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) {
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) {
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0;
}
#else /* no cast-rank mode */
#  define SWIG_AddCast(r) (r)
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/*
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCmp(const char *nb, const char *tb) {
  int equiv = 1;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (equiv != 0 && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(const swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/*
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  Choose the last
     name. It should be the most specific; a fully resolved name
     but not necessarily with default template parameters expanded. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;

  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start,
                            swig_module_info *end,
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      size_t l = 0;
      size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	size_t i = (l + r) >> 1;
	const char *iname = iter->types[i]->name;
	if (iname) {
	  int compare = strcmp(name, iname);
	  if (compare == 0) {
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start,
                     swig_module_info *end,
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }

  /* neither found a match */
  return 0;
}

/*
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  const unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/*
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    char d = *(c++);
    unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = (unsigned char)((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = (unsigned char)((d - ('a'-10)) << 4);
    else
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (unsigned char)(d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (unsigned char)(d - ('a'-10));
    else
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/* SWIG Errors applicable to all language modules, values are reserved from -1 to -99 */
#define  SWIG_UnknownError    	   -1
#define  SWIG_IOError        	   -2
#define  SWIG_RuntimeError   	   -3
#define  SWIG_IndexError     	   -4
#define  SWIG_TypeError      	   -5
#define  SWIG_DivisionByZero 	   -6
#define  SWIG_OverflowError  	   -7
#define  SWIG_SyntaxError    	   -8
#define  SWIG_ValueError     	   -9
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12
#define  SWIG_NullReferenceError   -13


/* ---------------------------------------------------------------------------
 * These typedefs and defines are used to deal with v8 API changes
 *
 * Useful table of versions: https://nodejs.org/en/download/releases/
 * ---------------------------------------------------------------------------*/

#if (SWIG_V8_VERSION < 0x0704)
#define SWIGV8_STRING_NEW2(cstr, len) v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), cstr, v8::String::kNormalString, len)
#else
#define SWIGV8_STRING_NEW2(cstr, len) (v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), cstr, v8::NewStringType::kNormal, len)).ToLocalChecked()
#endif

typedef void SwigV8ReturnValue;
typedef v8::FunctionCallbackInfo<v8::Value> SwigV8Arguments;
typedef v8::PropertyCallbackInfo<v8::Value> SwigV8PropertyCallbackInfo;
#define SWIGV8_RETURN(val) args.GetReturnValue().Set(val); return
#define SWIGV8_RETURN_INFO(val, info) info.GetReturnValue().Set(val); return

#define SWIGV8_HANDLESCOPE() v8::HandleScope scope(v8::Isolate::GetCurrent());
#define SWIGV8_HANDLESCOPE_ESC() v8::EscapableHandleScope scope(v8::Isolate::GetCurrent());
#define SWIGV8_ESCAPE(val) return scope.Escape(val)

#define SWIGV8_ADJUST_MEMORY(size) v8::Isolate::GetCurrent()->AdjustAmountOfExternalAllocatedMemory(size)
#define SWIGV8_CURRENT_CONTEXT() v8::Isolate::GetCurrent()->GetCurrentContext()
#define SWIGV8_THROW_EXCEPTION(err) v8::Isolate::GetCurrent()->ThrowException(err)

#if (SWIG_V8_VERSION < 0x0704)
#define SWIGV8_STRING_NEW(str) v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), str, v8::String::kNormalString)
#define SWIGV8_SYMBOL_NEW(sym) v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), sym, v8::String::kNormalString)
#else
#define SWIGV8_STRING_NEW(str) (v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), str, v8::NewStringType::kNormal)).ToLocalChecked()
#define SWIGV8_SYMBOL_NEW(sym) (v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), sym, v8::NewStringType::kNormal)).ToLocalChecked()
#endif

#if (SWIG_V8_VERSION < 0x0704)
#define SWIGV8_MAYBE_CHECK(maybe) maybe.FromJust()
#else
#define SWIGV8_MAYBE_CHECK(maybe) maybe.Check()
#endif

#define SWIGV8_ARRAY_NEW(size) v8::Array::New(v8::Isolate::GetCurrent(), size)
#define SWIGV8_BOOLEAN_NEW(bool) v8::Boolean::New(v8::Isolate::GetCurrent(), bool)
#define SWIGV8_EXTERNAL_NEW(val) v8::External::New(v8::Isolate::GetCurrent(), val)
#define SWIGV8_FUNCTEMPLATE_NEW(func) v8::FunctionTemplate::New(v8::Isolate::GetCurrent(), func)
#define SWIGV8_FUNCTEMPLATE_NEW_VOID() v8::FunctionTemplate::New(v8::Isolate::GetCurrent())
#define SWIGV8_INT32_NEW(num) v8::Int32::New(v8::Isolate::GetCurrent(), num)
#define SWIGV8_INTEGER_NEW(num) v8::Integer::New(v8::Isolate::GetCurrent(), num)
#define SWIGV8_INTEGER_NEW_UNS(num) v8::Integer::NewFromUnsigned(v8::Isolate::GetCurrent(), num)
#define SWIGV8_NUMBER_NEW(num) v8::Number::New(v8::Isolate::GetCurrent(), num)
#define SWIGV8_OBJECT_NEW() v8::Object::New(v8::Isolate::GetCurrent())
#define SWIGV8_UNDEFINED() v8::Undefined(v8::Isolate::GetCurrent())
#define SWIGV8_ARRAY v8::Local<v8::Array>
#define SWIGV8_FUNCTION_TEMPLATE v8::Local<v8::FunctionTemplate>
#define SWIGV8_OBJECT v8::Local<v8::Object>
#define SWIGV8_OBJECT_TEMPLATE v8::Local<v8::ObjectTemplate>
#define SWIGV8_VALUE v8::Local<v8::Value>
#define SWIGV8_NULL() v8::Null(v8::Isolate::GetCurrent())
#define SWIGV8_ARRAY_GET(array, index) (array)->Get(SWIGV8_CURRENT_CONTEXT(), index).ToLocalChecked()
#define SWIGV8_ARRAY_SET(array, index, value) SWIGV8_MAYBE_CHECK((array)->Set(SWIGV8_CURRENT_CONTEXT(), index, value))

#define SWIGV8_SET_CLASS_TEMPL(class_templ, class) class_templ.Reset(v8::Isolate::GetCurrent(), class);

#if SWIG_V8_VERSION < 0x0608
#define SWIGV8_TO_OBJECT(handle) (handle)->ToObject()
#define SWIGV8_TO_STRING(handle) (handle)->ToString()
#define SWIGV8_NUMBER_VALUE(handle) (handle)->NumberValue()
#define SWIGV8_INTEGER_VALUE(handle) (handle)->IntegerValue()
#define SWIGV8_BOOLEAN_VALUE(handle) (handle)->BooleanValue()
#define SWIGV8_WRITE_UTF8(handle, buffer, len) (handle)->WriteUtf8(buffer, len)
#define SWIGV8_UTF8_LENGTH(handle) (handle)->Utf8Length()
#else
#define SWIGV8_TO_OBJECT(handle) (handle)->ToObject(SWIGV8_CURRENT_CONTEXT()).ToLocalChecked()
#define SWIGV8_TO_STRING(handle) (handle)->ToString(SWIGV8_CURRENT_CONTEXT()).ToLocalChecked()
#define SWIGV8_NUMBER_VALUE(handle) (handle)->NumberValue(SWIGV8_CURRENT_CONTEXT()).ToChecked()
#define SWIGV8_INTEGER_VALUE(handle) (handle)->IntegerValue(SWIGV8_CURRENT_CONTEXT()).ToChecked()
#define SWIGV8_WRITE_UTF8(handle, buffer, len) (handle)->WriteUtf8(v8::Isolate::GetCurrent(), buffer, len)
#define SWIGV8_UTF8_LENGTH(handle) (handle)->Utf8Length(v8::Isolate::GetCurrent())
#if (SWIG_V8_VERSION < 0x0704)
#define SWIGV8_BOOLEAN_VALUE(handle) (handle)->BooleanValue(SWIGV8_CURRENT_CONTEXT()).ToChecked()
#else
#define SWIGV8_BOOLEAN_VALUE(handle) (handle)->BooleanValue(v8::Isolate::GetCurrent())
#endif
#endif

/* ---------------------------------------------------------------------------
 * Error handling
 *
 * ---------------------------------------------------------------------------*/

#define SWIG_Error(code, msg)     SWIGV8_ErrorHandler.error(code, msg)
#define SWIG_exception(code, msg) do { SWIGV8_ErrorHandler.error(code, msg); SWIG_fail; } while (0)
#define SWIG_fail                 goto fail
#define SWIGV8_OVERLOAD false

SWIGINTERN void SWIG_V8_Raise(const char *msg) {
  SWIGV8_THROW_EXCEPTION(v8::Exception::Error(SWIGV8_STRING_NEW(msg)));
}

SWIGINTERN void SWIG_V8_Raise(SWIGV8_VALUE obj, const char *msg) {
  SWIGV8_THROW_EXCEPTION(v8::Exception::Error(SWIGV8_TO_STRING(obj)));
}


/*
  Note: There are two contexts for handling errors.
  A static V8ErrorHandler is used in not overloaded methods.
  For overloaded methods the throwing type checking mechanism is used
  during dispatching. As V8 exceptions can not be reset properly
  the trick is to use a dynamic ErrorHandler with same local name as the global
  one.

  - See definition of SWIG_Error above.
  - See code templates 'JS_function_dispatcher', 'JS_functionwrapper_overload',
    and 'JS_function_dispatch_case' in javascriptcode.swg

*/
class V8ErrorHandler {
public:
  virtual ~V8ErrorHandler() {}
  virtual void error(int code, const char *msg) {
    SWIG_V8_Raise(msg);
  }
};
// this is used in usually
SWIGRUNTIME V8ErrorHandler SWIGV8_ErrorHandler;

// instances of this are used in overloaded functions
class OverloadErrorHandler: public V8ErrorHandler {
public:
  virtual void error(int code, const char *msg) {
    err = v8::Exception::Error(SWIGV8_STRING_NEW(msg));
    if(code != SWIG_TypeError) {
        SWIGV8_THROW_EXCEPTION(err);
    }
  }
  SWIGV8_VALUE err;
};

/* ---------------------------------------------------------------------------
 * Basic Proxy object
 *
 * ---------------------------------------------------------------------------*/

// Note: to trigger the v8 gc more often one can tell v8 about the memory consumption
// TODO: we could add a v8 specific parameter to control this value
#define SWIGV8_AVG_OBJ_SIZE 1000

class SWIGV8_Proxy {
public:
  SWIGV8_Proxy(): swigCMemOwn(false), swigCObject(0), info(0) {
    SWIGV8_ADJUST_MEMORY(SWIGV8_AVG_OBJ_SIZE);
  };

  ~SWIGV8_Proxy() {
    handle.ClearWeak();
    handle.Reset();

    SWIGV8_ADJUST_MEMORY(-SWIGV8_AVG_OBJ_SIZE);
  }

  bool swigCMemOwn;
  void *swigCObject;
  swig_type_info *info;
  v8::Persistent<v8::Object> handle;
};

class SWIGV8_ClientData {
public:
  v8::Persistent<v8::FunctionTemplate> class_templ;

  void (*dtor) (const v8::WeakCallbackInfo<SWIGV8_Proxy> &data);
};

SWIGRUNTIME v8::Persistent<v8::FunctionTemplate> SWIGV8_SWIGTYPE_Proxy_class_templ;

SWIGRUNTIME int SWIG_V8_ConvertInstancePtr(SWIGV8_OBJECT objRef, void **ptr, swig_type_info *info, int flags) {
  SWIGV8_HANDLESCOPE();

  if(objRef->InternalFieldCount() < 1) return SWIG_ERROR;

  SWIGV8_Proxy *cdata = static_cast<SWIGV8_Proxy *>(objRef->GetAlignedPointerFromInternalField(0));

  if(cdata == NULL) {
    return SWIG_ERROR;
  }
  if(info && cdata->info != info) {
    swig_cast_info *tc = SWIG_TypeCheckStruct(cdata->info, info);
    if (!tc && cdata->info->name) {
      tc = SWIG_TypeCheck(cdata->info->name, info);
    }
    bool type_valid = tc != 0;
    if(!type_valid) {
      return SWIG_TypeError;
    }
    int newmemory = 0;
    *ptr = SWIG_TypeCast(tc, cdata->swigCObject, &newmemory);
    assert(!newmemory); /* newmemory handling not yet implemented */
  } else {
    *ptr = cdata->swigCObject;
  }

  if (((flags & SWIG_POINTER_RELEASE) == SWIG_POINTER_RELEASE) && !cdata->swigCMemOwn) {
    return SWIG_ERROR_RELEASE_NOT_OWNED;
  } else {
    if (flags & SWIG_POINTER_DISOWN) {
      cdata->swigCMemOwn = false;
    }
    if (flags & SWIG_POINTER_CLEAR) {
      cdata->swigCObject = 0;
    }
  }
  return SWIG_OK;
}


SWIGRUNTIME void SWIGV8_Proxy_DefaultDtor(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  delete proxy;
}

SWIGRUNTIME int SWIG_V8_GetInstancePtr(SWIGV8_VALUE valRef, void **ptr) {
  if(!valRef->IsObject()) {
    return SWIG_TypeError;
  }
  SWIGV8_OBJECT objRef = SWIGV8_OBJECT::Cast(valRef);

  if(objRef->InternalFieldCount() < 1) return SWIG_ERROR;

  SWIGV8_Proxy *cdata = static_cast<SWIGV8_Proxy *>(objRef->GetAlignedPointerFromInternalField(0));

  if(cdata == NULL) {
    return SWIG_ERROR;
  }

  *ptr = cdata->swigCObject;

  return SWIG_OK;
}

SWIGRUNTIME void SWIGV8_SetPrivateData(SWIGV8_OBJECT obj, void *ptr, swig_type_info *info, int flags) {
  SWIGV8_Proxy *cdata = new SWIGV8_Proxy();
  cdata->swigCObject = ptr;
  cdata->swigCMemOwn = (flags & SWIG_POINTER_OWN) ? 1 : 0;
  cdata->info = info;

  obj->SetAlignedPointerInInternalField(0, cdata);

  cdata->handle.Reset(v8::Isolate::GetCurrent(), obj);

  if(cdata->swigCMemOwn && (SWIGV8_ClientData*)info->clientdata) {
    cdata->handle.SetWeak(cdata, ((SWIGV8_ClientData*)info->clientdata)->dtor, v8::WeakCallbackType::kParameter);
  } else {
    cdata->handle.SetWeak(cdata, SWIGV8_Proxy_DefaultDtor, v8::WeakCallbackType::kParameter);
  }

#if (SWIG_V8_VERSION < 0x0704)
  cdata->handle.MarkIndependent();
// Looks like future versions do not require that anymore:
// https://monorail-prod.appspot.com/p/chromium/issues/detail?id=923361#c11
#endif
}

SWIGRUNTIME int SWIG_V8_ConvertPtr(SWIGV8_VALUE valRef, void **ptr, swig_type_info *info, int flags) {
  SWIGV8_HANDLESCOPE();
  
  /* special case: JavaScript null => C NULL pointer */
  if(valRef->IsNull()) {
    *ptr=0;
    return (flags & SWIG_POINTER_NO_NULL) ? SWIG_NullReferenceError : SWIG_OK;
  }
  if(!valRef->IsObject()) {
    return SWIG_TypeError;
  }
  SWIGV8_OBJECT objRef = SWIGV8_OBJECT::Cast(valRef);
  return SWIG_V8_ConvertInstancePtr(objRef, ptr, info, flags);
}

SWIGRUNTIME SWIGV8_VALUE SWIG_V8_NewPointerObj(void *ptr, swig_type_info *info, int flags) {
  SWIGV8_HANDLESCOPE_ESC();
  
  SWIGV8_FUNCTION_TEMPLATE class_templ;

  if (ptr == NULL) {
    v8::Local<v8::Primitive> result = SWIGV8_NULL();
    SWIGV8_ESCAPE(result);
  }

  v8::Isolate *isolate = v8::Isolate::GetCurrent();

  if(info->clientdata != 0) {
    class_templ = v8::Local<v8::FunctionTemplate>::New(isolate, ((SWIGV8_ClientData*) info->clientdata)->class_templ);
  } else {
    class_templ = v8::Local<v8::FunctionTemplate>::New(isolate, SWIGV8_SWIGTYPE_Proxy_class_templ);
  }

  v8::Local<v8::Object> result = class_templ->InstanceTemplate()->NewInstance(SWIGV8_CURRENT_CONTEXT()).ToLocalChecked();

  SWIGV8_SetPrivateData(result, ptr, info, flags);

  SWIGV8_ESCAPE(result);
}

#define SWIG_ConvertPtr(obj, ptr, info, flags)    SWIG_V8_ConvertPtr(obj, ptr, info, flags)
#define SWIG_NewPointerObj(ptr, info, flags)      SWIG_V8_NewPointerObj(ptr, info, flags)

#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_V8_ConvertInstancePtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(thisvalue, type, flags)     SWIG_V8_NewPointerObj(thisvalue, type, flags)

#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_V8_ConvertPtr(obj, pptr, type, 0)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_V8_NewPointerObj(ptr, type, 0)

#define SWIG_GetInstancePtr(obj, ptr)    SWIG_V8_GetInstancePtr(obj, ptr)

SWIGRUNTIME SwigV8ReturnValue _SWIGV8_wrap_equals(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  void *arg1 = (void *) 0 ;
  void *arg2 = (void *) 0 ;
  bool result;
  int res1;
  int res2;

  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for equals.");

  res1 = SWIG_GetInstancePtr(args.Holder(), &arg1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ERROR, "Could not get pointer from 'this' object for equals.");
  }
  res2 = SWIG_GetInstancePtr(args[0], &arg2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equals" "', argument " "1"" of type '" "void *""'");
  }

  result = (bool)(arg1 == arg2);
  jsresult =  SWIGV8_BOOLEAN_NEW(result);

  SWIGV8_RETURN(jsresult);
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}

SWIGRUNTIME SwigV8ReturnValue _wrap_getCPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  void *arg1 = (void *) 0 ;
  long result;
  int res1;

  res1 = SWIG_GetInstancePtr(args.Holder(), &arg1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getCPtr" "', argument " "1"" of type '" "void *""'");
  }

  result = (long)arg1;
  jsresult = SWIGV8_NUMBER_NEW(result);

  SWIGV8_RETURN(jsresult);
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}

/* ---------------------------------------------------------------------------
 * PackedData object
 *
 * ---------------------------------------------------------------------------*/

class SwigV8PackedData {
public:
  SwigV8PackedData(void *data, size_t size, swig_type_info *type): data(data), size(size), type(type) {};

  ~SwigV8PackedData() {
  };

  void *data;
  size_t size;
  swig_type_info *type;

  v8::Persistent<v8::Object> handle;
};

SWIGRUNTIMEINLINE
int SwigV8Packed_Check(SWIGV8_VALUE valRef) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT objRef = SWIGV8_TO_OBJECT(valRef);
  if(objRef->InternalFieldCount() < 1) return false;
  v8::Local<v8::Private> privateKey = v8::Private::ForApi(v8::Isolate::GetCurrent(), SWIGV8_STRING_NEW("__swig__packed_data__"));
  v8::Local<v8::Value> flag;
  if (!objRef->GetPrivate(SWIGV8_CURRENT_CONTEXT(), privateKey).ToLocal(&flag))
    return false;
  return (flag->IsBoolean() && SWIGV8_BOOLEAN_VALUE(flag));
}

SWIGRUNTIME
swig_type_info *SwigV8Packed_UnpackData(SWIGV8_VALUE valRef, void *ptr, size_t size) {
  if (SwigV8Packed_Check(valRef)) {
    SWIGV8_HANDLESCOPE();
    
    SwigV8PackedData *sobj;

    SWIGV8_OBJECT objRef = SWIGV8_TO_OBJECT(valRef);

    sobj = static_cast<SwigV8PackedData*>(objRef->GetAlignedPointerFromInternalField(0));
    if (sobj == NULL || sobj->size != size) return 0;
    memcpy(ptr, sobj->data, size);
    return sobj->type;
  } else {
    return 0;
  }
}

SWIGRUNTIME
int SWIGV8_ConvertPacked(SWIGV8_VALUE valRef, void *ptr, size_t sz, swig_type_info *ty) {
  swig_type_info *to = SwigV8Packed_UnpackData(valRef, ptr, sz);
  if (!to) return SWIG_ERROR;
  if (ty) {
    if (to != ty) {
      /* check type cast? */
      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
      if (!tc) return SWIG_ERROR;
    }
  }
  return SWIG_OK;
}

SWIGRUNTIME void _wrap_SwigV8PackedData_delete(const v8::WeakCallbackInfo<SwigV8PackedData> &data) {
  SwigV8PackedData *cdata = data.GetParameter();
  delete cdata;
}

SWIGRUNTIME
SWIGV8_VALUE SWIGV8_NewPackedObj(void *data, size_t size, swig_type_info *type) {
  SWIGV8_HANDLESCOPE_ESC();

  SwigV8PackedData *cdata = new SwigV8PackedData(data, size, type);
//  v8::Handle<v8::Object> obj = SWIGV8_OBJECT_NEW();
  v8::Local<v8::Object> obj = SWIGV8_OBJECT_NEW();

  v8::Local<v8::Private> privateKey = v8::Private::ForApi(v8::Isolate::GetCurrent(), SWIGV8_STRING_NEW("__swig__packed_data__"));
  obj->SetPrivate(SWIGV8_CURRENT_CONTEXT(), privateKey, SWIGV8_BOOLEAN_NEW(true));

  obj->SetAlignedPointerInInternalField(0, cdata);

  cdata->handle.Reset(v8::Isolate::GetCurrent(), obj);

  cdata->handle.SetWeak(cdata, _wrap_SwigV8PackedData_delete, v8::WeakCallbackType::kParameter);

#if (SWIG_V8_VERSION < 0x0704)
  cdata->handle.MarkIndependent();
// Looks like future versions do not require that anymore:
// https://monorail-prod.appspot.com/p/chromium/issues/detail?id=923361#c11
#endif

  SWIGV8_ESCAPE(obj);

}

#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIGV8_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIGV8_NewPackedObj(ptr, sz, type)


/* ---------------------------------------------------------------------------
 * Support for IN/OUTPUT typemaps (see Lib/typemaps/inoutlist.swg)
 *
 * ---------------------------------------------------------------------------*/

SWIGRUNTIME

SWIGV8_VALUE SWIGV8_AppendOutput(SWIGV8_VALUE result, SWIGV8_VALUE obj) {
  SWIGV8_HANDLESCOPE_ESC();
  
  if (result->IsUndefined()) {
    result = SWIGV8_ARRAY_NEW(0);
  } else if (!result->IsArray()) {
    SWIGV8_ARRAY tmparr = SWIGV8_ARRAY_NEW(0);
    SWIGV8_ARRAY_SET(tmparr, 0, result);
    result = tmparr;
  }

  SWIGV8_ARRAY arr = SWIGV8_ARRAY::Cast(result);
  SWIGV8_ARRAY_SET(arr, arr->Length(), obj);
  SWIGV8_ESCAPE(arr);
}



typedef v8::FunctionCallback            SwigV8FunctionCallback;
typedef v8::AccessorNameGetterCallback  SwigV8AccessorGetterCallback;
typedef v8::AccessorNameSetterCallback  SwigV8AccessorSetterCallback;
typedef v8::PropertyCallbackInfo<void>  SwigV8PropertyCallbackInfoVoid;

/**
 * Creates a class template for a class with specified initialization function.
 */
SWIGRUNTIME SWIGV8_FUNCTION_TEMPLATE SWIGV8_CreateClassTemplate(const char* symbol) {
    SWIGV8_HANDLESCOPE_ESC();
    
    v8::Local<v8::FunctionTemplate> class_templ = SWIGV8_FUNCTEMPLATE_NEW_VOID();
    class_templ->SetClassName(SWIGV8_SYMBOL_NEW(symbol));

    SWIGV8_OBJECT_TEMPLATE inst_templ = class_templ->InstanceTemplate();
    inst_templ->SetInternalFieldCount(1);

    SWIGV8_OBJECT_TEMPLATE equals_templ = class_templ->PrototypeTemplate();
    equals_templ->Set(SWIGV8_SYMBOL_NEW("equals"), SWIGV8_FUNCTEMPLATE_NEW(_SWIGV8_wrap_equals));

    SWIGV8_OBJECT_TEMPLATE cptr_templ = class_templ->PrototypeTemplate();
    cptr_templ->Set(SWIGV8_SYMBOL_NEW("getCPtr"), SWIGV8_FUNCTEMPLATE_NEW(_wrap_getCPtr));

    SWIGV8_ESCAPE(class_templ);
}

/**
 * Registers a class method with given name for a given class template.
 */
SWIGRUNTIME void SWIGV8_AddMemberFunction(SWIGV8_FUNCTION_TEMPLATE class_templ, const char* symbol,
  SwigV8FunctionCallback _func) {
    SWIGV8_OBJECT_TEMPLATE proto_templ = class_templ->PrototypeTemplate();
    proto_templ->Set(SWIGV8_SYMBOL_NEW(symbol), SWIGV8_FUNCTEMPLATE_NEW(_func));
}

/**
 * Registers a class property with given name for a given class template.
 */
SWIGRUNTIME void SWIGV8_AddMemberVariable(SWIGV8_FUNCTION_TEMPLATE class_templ, const char* symbol,
  SwigV8AccessorGetterCallback getter, SwigV8AccessorSetterCallback setter) {
  SWIGV8_OBJECT_TEMPLATE proto_templ = class_templ->InstanceTemplate();
  proto_templ->SetAccessor(SWIGV8_SYMBOL_NEW(symbol), getter, setter);
}

/**
 * Registers a class method with given name for a given object.
 */
SWIGRUNTIME void SWIGV8_AddStaticFunction(SWIGV8_OBJECT obj, const char* symbol,
  const SwigV8FunctionCallback& _func, v8::Local<v8::Context> context) {
  SWIGV8_MAYBE_CHECK(obj->Set(context, SWIGV8_SYMBOL_NEW(symbol), SWIGV8_FUNCTEMPLATE_NEW(_func)->GetFunction(context).ToLocalChecked()));
}

/**
 * Registers a class method with given name for a given object.
 */
SWIGRUNTIME void SWIGV8_AddStaticVariable(SWIGV8_OBJECT obj, const char* symbol,
  SwigV8AccessorGetterCallback getter, SwigV8AccessorSetterCallback setter,
  v8::Local<v8::Context> context) {
  SWIGV8_MAYBE_CHECK(obj->SetAccessor(context, SWIGV8_SYMBOL_NEW(symbol), getter, setter));
}

SWIGRUNTIME void JS_veto_set_variable(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid& info)
{
    char buffer[256];
    char msg[512];
    int res;

    v8::Local<v8::String> sproperty;
    if (property->ToString(SWIGV8_CURRENT_CONTEXT()).ToLocal(&sproperty)) {
      SWIGV8_WRITE_UTF8(sproperty, buffer, 256);
      res = sprintf(msg, "Tried to write read-only variable: %s.", buffer);
    }
    else {
      res = -1;
    }

    if(res<0) {
      SWIG_exception(SWIG_ERROR, "Tried to write read-only variable.");
    } else {
      SWIG_exception(SWIG_ERROR, msg);
    }
fail: ;
}



/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_Color swig_types[0]
#define SWIGTYPE_p_Drawable swig_types[1]
#define SWIGTYPE_p_DrawableAffine swig_types[2]
#define SWIGTYPE_p_DrawableList swig_types[3]
#define SWIGTYPE_p_Image swig_types[4]
#define SWIGTYPE_p_ImageChannelStatistics swig_types[5]
#define SWIGTYPE_p_ImageStatistics swig_types[6]
#define SWIGTYPE_p_MagickCore__AlignType swig_types[7]
#define SWIGTYPE_p_MagickCore__AlphaChannelType swig_types[8]
#define SWIGTYPE_p_MagickCore__AutoThresholdMethod swig_types[9]
#define SWIGTYPE_p_MagickCore__CacheType swig_types[10]
#define SWIGTYPE_p_MagickCore__ChannelType swig_types[11]
#define SWIGTYPE_p_MagickCore__ClassType swig_types[12]
#define SWIGTYPE_p_MagickCore__ClipPathUnits swig_types[13]
#define SWIGTYPE_p_MagickCore__ColorspaceType swig_types[14]
#define SWIGTYPE_p_MagickCore__CommandOption swig_types[15]
#define SWIGTYPE_p_MagickCore__CommandOptionFlags swig_types[16]
#define SWIGTYPE_p_MagickCore__ComplexOperator swig_types[17]
#define SWIGTYPE_p_MagickCore__ComplianceType swig_types[18]
#define SWIGTYPE_p_MagickCore__CompositeOperator swig_types[19]
#define SWIGTYPE_p_MagickCore__CompressionType swig_types[20]
#define SWIGTYPE_p_MagickCore__DecorationType swig_types[21]
#define SWIGTYPE_p_MagickCore__DirectionType swig_types[22]
#define SWIGTYPE_p_MagickCore__DisposeType swig_types[23]
#define SWIGTYPE_p_MagickCore__DistortImageMethod swig_types[24]
#define SWIGTYPE_p_MagickCore__DitherMethod swig_types[25]
#define SWIGTYPE_p_MagickCore__EndianType swig_types[26]
#define SWIGTYPE_p_MagickCore__ExceptionType swig_types[27]
#define SWIGTYPE_p_MagickCore__FillRule swig_types[28]
#define SWIGTYPE_p_MagickCore__FilterTypes swig_types[29]
#define SWIGTYPE_p_MagickCore__GeometryFlags swig_types[30]
#define SWIGTYPE_p_MagickCore__GradientType swig_types[31]
#define SWIGTYPE_p_MagickCore__GravityType swig_types[32]
#define SWIGTYPE_p_MagickCore__ImageLayerMethod swig_types[33]
#define SWIGTYPE_p_MagickCore__ImageMagickOpenCLMode swig_types[34]
#define SWIGTYPE_p_MagickCore__ImageType swig_types[35]
#define SWIGTYPE_p_MagickCore__InterlaceType swig_types[36]
#define SWIGTYPE_p_MagickCore__InterpolatePixelMethod swig_types[37]
#define SWIGTYPE_p_MagickCore__KernelInfo swig_types[38]
#define SWIGTYPE_p_MagickCore__KernelInfoType swig_types[39]
#define SWIGTYPE_p_MagickCore__LineCap swig_types[40]
#define SWIGTYPE_p_MagickCore__LineJoin swig_types[41]
#define SWIGTYPE_p_MagickCore__LogEventType swig_types[42]
#define SWIGTYPE_p_MagickCore__MagickBooleanType swig_types[43]
#define SWIGTYPE_p_MagickCore__MagickEvaluateOperator swig_types[44]
#define SWIGTYPE_p_MagickCore__MagickFormatType swig_types[45]
#define SWIGTYPE_p_MagickCore__MagickFunction swig_types[46]
#define SWIGTYPE_p_MagickCore__MagickLayerMethod swig_types[47]
#define SWIGTYPE_p_MagickCore__MagickModuleType swig_types[48]
#define SWIGTYPE_p_MagickCore__MagickOpenCLEnvParam swig_types[49]
#define SWIGTYPE_p_MagickCore__MagickOpenCLProgram swig_types[50]
#define SWIGTYPE_p_MagickCore__MagickThreadSupport swig_types[51]
#define SWIGTYPE_p_MagickCore__MapMode swig_types[52]
#define SWIGTYPE_p_MagickCore__MetricType swig_types[53]
#define SWIGTYPE_p_MagickCore__MontageMode swig_types[54]
#define SWIGTYPE_p_MagickCore__MorphologyMethod swig_types[55]
#define SWIGTYPE_p_MagickCore__NoiseType swig_types[56]
#define SWIGTYPE_p_MagickCore__OrientationType swig_types[57]
#define SWIGTYPE_p_MagickCore__PaintMethod swig_types[58]
#define SWIGTYPE_p_MagickCore__PathType swig_types[59]
#define SWIGTYPE_p_MagickCore__PixelComponent swig_types[60]
#define SWIGTYPE_p_MagickCore__PixelIntensityMethod swig_types[61]
#define SWIGTYPE_p_MagickCore__PolicyDomain swig_types[62]
#define SWIGTYPE_p_MagickCore__PolicyRights swig_types[63]
#define SWIGTYPE_p_MagickCore__PreviewType swig_types[64]
#define SWIGTYPE_p_MagickCore__PrimitiveType swig_types[65]
#define SWIGTYPE_p_MagickCore__QuantumAlphaType swig_types[66]
#define SWIGTYPE_p_MagickCore__QuantumFormatType swig_types[67]
#define SWIGTYPE_p_MagickCore__QuantumType swig_types[68]
#define SWIGTYPE_p_MagickCore__ReferenceType swig_types[69]
#define SWIGTYPE_p_MagickCore__RegistryType swig_types[70]
#define SWIGTYPE_p_MagickCore__RenderingIntent swig_types[71]
#define SWIGTYPE_p_MagickCore__ResolutionType swig_types[72]
#define SWIGTYPE_p_MagickCore__ResourceType swig_types[73]
#define SWIGTYPE_p_MagickCore__SemaphoreInfo swig_types[74]
#define SWIGTYPE_p_MagickCore__SparseColorMethod swig_types[75]
#define SWIGTYPE_p_MagickCore__SpreadMethod swig_types[76]
#define SWIGTYPE_p_MagickCore__StatisticType swig_types[77]
#define SWIGTYPE_p_MagickCore__StorageType swig_types[78]
#define SWIGTYPE_p_MagickCore__StretchType swig_types[79]
#define SWIGTYPE_p_MagickCore__StyleType swig_types[80]
#define SWIGTYPE_p_MagickCore__TimerState swig_types[81]
#define SWIGTYPE_p_MagickCore__TransmitType swig_types[82]
#define SWIGTYPE_p_MagickCore__ValidateType swig_types[83]
#define SWIGTYPE_p_MagickCore__VirtualPixelMethod swig_types[84]
#define SWIGTYPE_p_MagickCore___AffineMatrix swig_types[85]
#define SWIGTYPE_p_MagickCore___ChannelFeatures swig_types[86]
#define SWIGTYPE_p_MagickCore___ChannelMoments swig_types[87]
#define SWIGTYPE_p_MagickCore___ChannelPerceptualHash swig_types[88]
#define SWIGTYPE_p_MagickCore___ChannelStatistics swig_types[89]
#define SWIGTYPE_p_MagickCore___ChromaticityInfo swig_types[90]
#define SWIGTYPE_p_MagickCore___CoderInfo swig_types[91]
#define SWIGTYPE_p_MagickCore___ColorInfo swig_types[92]
#define SWIGTYPE_p_MagickCore___ColorPacket swig_types[93]
#define SWIGTYPE_p_MagickCore___ConfigureInfo swig_types[94]
#define SWIGTYPE_p_MagickCore___DelegateInfo swig_types[95]
#define SWIGTYPE_p_MagickCore___DoublePixelPacket swig_types[96]
#define SWIGTYPE_p_MagickCore___DrawInfo swig_types[97]
#define SWIGTYPE_p_MagickCore___ElementReference swig_types[98]
#define SWIGTYPE_p_MagickCore___ErrorInfo swig_types[99]
#define SWIGTYPE_p_MagickCore___ExceptionInfo swig_types[100]
#define SWIGTYPE_p_MagickCore___FrameInfo swig_types[101]
#define SWIGTYPE_p_MagickCore___GeometryInfo swig_types[102]
#define SWIGTYPE_p_MagickCore___GradientInfo swig_types[103]
#define SWIGTYPE_p_MagickCore___Image swig_types[104]
#define SWIGTYPE_p_MagickCore___ImageAttribute swig_types[105]
#define SWIGTYPE_p_MagickCore___ImageInfo swig_types[106]
#define SWIGTYPE_p_MagickCore___LocaleInfo swig_types[107]
#define SWIGTYPE_p_MagickCore___LongPixelPacket swig_types[108]
#define SWIGTYPE_p_MagickCore___MagicInfo swig_types[109]
#define SWIGTYPE_p_MagickCore___MagickInfo swig_types[110]
#define SWIGTYPE_p_MagickCore___MagickPixelPacket swig_types[111]
#define SWIGTYPE_p_MagickCore___ModuleInfo swig_types[112]
#define SWIGTYPE_p_MagickCore___MontageInfo swig_types[113]
#define SWIGTYPE_p_MagickCore___OffsetInfo swig_types[114]
#define SWIGTYPE_p_MagickCore___OptionInfo swig_types[115]
#define SWIGTYPE_p_MagickCore___PixelPacket swig_types[116]
#define SWIGTYPE_p_MagickCore___PointInfo swig_types[117]
#define SWIGTYPE_p_MagickCore___PrimaryInfo swig_types[118]
#define SWIGTYPE_p_MagickCore___PrimitiveInfo swig_types[119]
#define SWIGTYPE_p_MagickCore___ProfileInfo swig_types[120]
#define SWIGTYPE_p_MagickCore___QuantizeInfo swig_types[121]
#define SWIGTYPE_p_MagickCore___QuantumPixelPacket swig_types[122]
#define SWIGTYPE_p_MagickCore___RectangleInfo swig_types[123]
#define SWIGTYPE_p_MagickCore___SegmentInfo swig_types[124]
#define SWIGTYPE_p_MagickCore___StopInfo swig_types[125]
#define SWIGTYPE_p_MagickCore___StringInfo swig_types[126]
#define SWIGTYPE_p_MagickCore___Timer swig_types[127]
#define SWIGTYPE_p_MagickCore___TimerInfo swig_types[128]
#define SWIGTYPE_p_MagickCore___TypeInfo swig_types[129]
#define SWIGTYPE_p_MagickCore___TypeMetric swig_types[130]
#define SWIGTYPE_p_MagickCore___XImportInfo swig_types[131]
#define SWIGTYPE_p_Magick__Blob swig_types[132]
#define SWIGTYPE_p_Magick__ChannelMoments swig_types[133]
#define SWIGTYPE_p_Magick__CoderInfo swig_types[134]
#define SWIGTYPE_p_Magick__Color swig_types[135]
#define SWIGTYPE_p_Magick__ColorGray swig_types[136]
#define SWIGTYPE_p_Magick__ColorHSL swig_types[137]
#define SWIGTYPE_p_Magick__ColorMono swig_types[138]
#define SWIGTYPE_p_Magick__ColorRGB swig_types[139]
#define SWIGTYPE_p_Magick__ColorYUV swig_types[140]
#define SWIGTYPE_p_Magick__Coordinate swig_types[141]
#define SWIGTYPE_p_Magick__Drawable swig_types[142]
#define SWIGTYPE_p_Magick__DrawableAffine swig_types[143]
#define SWIGTYPE_p_Magick__DrawableArc swig_types[144]
#define SWIGTYPE_p_Magick__DrawableBase swig_types[145]
#define SWIGTYPE_p_Magick__DrawableBezier swig_types[146]
#define SWIGTYPE_p_Magick__DrawableCircle swig_types[147]
#define SWIGTYPE_p_Magick__DrawableClipPath swig_types[148]
#define SWIGTYPE_p_Magick__DrawableColor swig_types[149]
#define SWIGTYPE_p_Magick__DrawableCompositeImage swig_types[150]
#define SWIGTYPE_p_Magick__DrawableDashArray swig_types[151]
#define SWIGTYPE_p_Magick__DrawableDashOffset swig_types[152]
#define SWIGTYPE_p_Magick__DrawableDensity swig_types[153]
#define SWIGTYPE_p_Magick__DrawableEllipse swig_types[154]
#define SWIGTYPE_p_Magick__DrawableFillColor swig_types[155]
#define SWIGTYPE_p_Magick__DrawableFillOpacity swig_types[156]
#define SWIGTYPE_p_Magick__DrawableFillRule swig_types[157]
#define SWIGTYPE_p_Magick__DrawableFont swig_types[158]
#define SWIGTYPE_p_Magick__DrawableGravity swig_types[159]
#define SWIGTYPE_p_Magick__DrawableLine swig_types[160]
#define SWIGTYPE_p_Magick__DrawableMatte swig_types[161]
#define SWIGTYPE_p_Magick__DrawableMiterLimit swig_types[162]
#define SWIGTYPE_p_Magick__DrawablePath swig_types[163]
#define SWIGTYPE_p_Magick__DrawablePoint swig_types[164]
#define SWIGTYPE_p_Magick__DrawablePointSize swig_types[165]
#define SWIGTYPE_p_Magick__DrawablePolygon swig_types[166]
#define SWIGTYPE_p_Magick__DrawablePolyline swig_types[167]
#define SWIGTYPE_p_Magick__DrawablePopClipPath swig_types[168]
#define SWIGTYPE_p_Magick__DrawablePopGraphicContext swig_types[169]
#define SWIGTYPE_p_Magick__DrawablePopPattern swig_types[170]
#define SWIGTYPE_p_Magick__DrawablePushClipPath swig_types[171]
#define SWIGTYPE_p_Magick__DrawablePushGraphicContext swig_types[172]
#define SWIGTYPE_p_Magick__DrawablePushPattern swig_types[173]
#define SWIGTYPE_p_Magick__DrawableRectangle swig_types[174]
#define SWIGTYPE_p_Magick__DrawableRotation swig_types[175]
#define SWIGTYPE_p_Magick__DrawableRoundRectangle swig_types[176]
#define SWIGTYPE_p_Magick__DrawableScaling swig_types[177]
#define SWIGTYPE_p_Magick__DrawableSkewX swig_types[178]
#define SWIGTYPE_p_Magick__DrawableSkewY swig_types[179]
#define SWIGTYPE_p_Magick__DrawableStrokeAntialias swig_types[180]
#define SWIGTYPE_p_Magick__DrawableStrokeColor swig_types[181]
#define SWIGTYPE_p_Magick__DrawableStrokeLineCap swig_types[182]
#define SWIGTYPE_p_Magick__DrawableStrokeLineJoin swig_types[183]
#define SWIGTYPE_p_Magick__DrawableStrokeOpacity swig_types[184]
#define SWIGTYPE_p_Magick__DrawableStrokeWidth swig_types[185]
#define SWIGTYPE_p_Magick__DrawableText swig_types[186]
#define SWIGTYPE_p_Magick__DrawableTextAntialias swig_types[187]
#define SWIGTYPE_p_Magick__DrawableTextDecoration swig_types[188]
#define SWIGTYPE_p_Magick__DrawableTextDirection swig_types[189]
#define SWIGTYPE_p_Magick__DrawableTextInterlineSpacing swig_types[190]
#define SWIGTYPE_p_Magick__DrawableTextInterwordSpacing swig_types[191]
#define SWIGTYPE_p_Magick__DrawableTextKerning swig_types[192]
#define SWIGTYPE_p_Magick__DrawableTextUnderColor swig_types[193]
#define SWIGTYPE_p_Magick__DrawableTranslation swig_types[194]
#define SWIGTYPE_p_Magick__DrawableViewbox swig_types[195]
#define SWIGTYPE_p_Magick__Error swig_types[196]
#define SWIGTYPE_p_Magick__ErrorBlob swig_types[197]
#define SWIGTYPE_p_Magick__ErrorCache swig_types[198]
#define SWIGTYPE_p_Magick__ErrorCoder swig_types[199]
#define SWIGTYPE_p_Magick__ErrorConfigure swig_types[200]
#define SWIGTYPE_p_Magick__ErrorCorruptImage swig_types[201]
#define SWIGTYPE_p_Magick__ErrorDelegate swig_types[202]
#define SWIGTYPE_p_Magick__ErrorDraw swig_types[203]
#define SWIGTYPE_p_Magick__ErrorFileOpen swig_types[204]
#define SWIGTYPE_p_Magick__ErrorImage swig_types[205]
#define SWIGTYPE_p_Magick__ErrorMissingDelegate swig_types[206]
#define SWIGTYPE_p_Magick__ErrorModule swig_types[207]
#define SWIGTYPE_p_Magick__ErrorMonitor swig_types[208]
#define SWIGTYPE_p_Magick__ErrorOption swig_types[209]
#define SWIGTYPE_p_Magick__ErrorPolicy swig_types[210]
#define SWIGTYPE_p_Magick__ErrorRegistry swig_types[211]
#define SWIGTYPE_p_Magick__ErrorResourceLimit swig_types[212]
#define SWIGTYPE_p_Magick__ErrorStream swig_types[213]
#define SWIGTYPE_p_Magick__ErrorType swig_types[214]
#define SWIGTYPE_p_Magick__ErrorUndefined swig_types[215]
#define SWIGTYPE_p_Magick__ErrorXServer swig_types[216]
#define SWIGTYPE_p_Magick__Exception swig_types[217]
#define SWIGTYPE_p_Magick__Geometry swig_types[218]
#define SWIGTYPE_p_Magick__Image swig_types[219]
#define SWIGTYPE_p_Magick__ImageMoments swig_types[220]
#define SWIGTYPE_p_Magick__Image___ImageStatistics swig_types[221]
#define SWIGTYPE_p_Magick__Montage swig_types[222]
#define SWIGTYPE_p_Magick__MontageFramed swig_types[223]
#define SWIGTYPE_p_Magick__Offset swig_types[224]
#define SWIGTYPE_p_Magick__Options swig_types[225]
#define SWIGTYPE_p_Magick__PathArcAbs swig_types[226]
#define SWIGTYPE_p_Magick__PathArcArgs swig_types[227]
#define SWIGTYPE_p_Magick__PathArcRel swig_types[228]
#define SWIGTYPE_p_Magick__PathClosePath swig_types[229]
#define SWIGTYPE_p_Magick__PathCurvetoAbs swig_types[230]
#define SWIGTYPE_p_Magick__PathCurvetoArgs swig_types[231]
#define SWIGTYPE_p_Magick__PathCurvetoRel swig_types[232]
#define SWIGTYPE_p_Magick__PathLinetoAbs swig_types[233]
#define SWIGTYPE_p_Magick__PathLinetoHorizontalAbs swig_types[234]
#define SWIGTYPE_p_Magick__PathLinetoHorizontalRel swig_types[235]
#define SWIGTYPE_p_Magick__PathLinetoRel swig_types[236]
#define SWIGTYPE_p_Magick__PathLinetoVerticalAbs swig_types[237]
#define SWIGTYPE_p_Magick__PathLinetoVerticalRel swig_types[238]
#define SWIGTYPE_p_Magick__PathMovetoAbs swig_types[239]
#define SWIGTYPE_p_Magick__PathMovetoRel swig_types[240]
#define SWIGTYPE_p_Magick__PathQuadraticCurvetoAbs swig_types[241]
#define SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs swig_types[242]
#define SWIGTYPE_p_Magick__PathQuadraticCurvetoRel swig_types[243]
#define SWIGTYPE_p_Magick__PathSmoothCurvetoAbs swig_types[244]
#define SWIGTYPE_p_Magick__PathSmoothCurvetoRel swig_types[245]
#define SWIGTYPE_p_Magick__PathSmoothQuadraticCurvetoAbs swig_types[246]
#define SWIGTYPE_p_Magick__PathSmoothQuadraticCurvetoRel swig_types[247]
#define SWIGTYPE_p_Magick__PixelData swig_types[248]
#define SWIGTYPE_p_Magick__Pixels swig_types[249]
#define SWIGTYPE_p_Magick__ReadOptions swig_types[250]
#define SWIGTYPE_p_Magick__ResourceLimits swig_types[251]
#define SWIGTYPE_p_Magick__TypeMetric swig_types[252]
#define SWIGTYPE_p_Magick__VPath swig_types[253]
#define SWIGTYPE_p_Magick__VPathBase swig_types[254]
#define SWIGTYPE_p_Magick__Warning swig_types[255]
#define SWIGTYPE_p_Magick__WarningBlob swig_types[256]
#define SWIGTYPE_p_Magick__WarningCache swig_types[257]
#define SWIGTYPE_p_Magick__WarningCoder swig_types[258]
#define SWIGTYPE_p_Magick__WarningConfigure swig_types[259]
#define SWIGTYPE_p_Magick__WarningCorruptImage swig_types[260]
#define SWIGTYPE_p_Magick__WarningDelegate swig_types[261]
#define SWIGTYPE_p_Magick__WarningDraw swig_types[262]
#define SWIGTYPE_p_Magick__WarningFileOpen swig_types[263]
#define SWIGTYPE_p_Magick__WarningImage swig_types[264]
#define SWIGTYPE_p_Magick__WarningMissingDelegate swig_types[265]
#define SWIGTYPE_p_Magick__WarningModule swig_types[266]
#define SWIGTYPE_p_Magick__WarningMonitor swig_types[267]
#define SWIGTYPE_p_Magick__WarningOption swig_types[268]
#define SWIGTYPE_p_Magick__WarningPolicy swig_types[269]
#define SWIGTYPE_p_Magick__WarningRegistry swig_types[270]
#define SWIGTYPE_p_Magick__WarningResourceLimit swig_types[271]
#define SWIGTYPE_p_Magick__WarningStream swig_types[272]
#define SWIGTYPE_p_Magick__WarningType swig_types[273]
#define SWIGTYPE_p_Magick__WarningUndefined swig_types[274]
#define SWIGTYPE_p_Magick__WarningXServer swig_types[275]
#define SWIGTYPE_p_Magick__adaptiveBlurImage swig_types[276]
#define SWIGTYPE_p_Magick__adaptiveThresholdImage swig_types[277]
#define SWIGTYPE_p_Magick__addNoiseImage swig_types[278]
#define SWIGTYPE_p_Magick__adjoinImage swig_types[279]
#define SWIGTYPE_p_Magick__affineTransformImage swig_types[280]
#define SWIGTYPE_p_Magick__animationDelayImage swig_types[281]
#define SWIGTYPE_p_Magick__animationIterationsImage swig_types[282]
#define SWIGTYPE_p_Magick__annotateImage swig_types[283]
#define SWIGTYPE_p_Magick__antiAliasImage swig_types[284]
#define SWIGTYPE_p_Magick__backgroundColorImage swig_types[285]
#define SWIGTYPE_p_Magick__backgroundTextureImage swig_types[286]
#define SWIGTYPE_p_Magick__blurImage swig_types[287]
#define SWIGTYPE_p_Magick__borderColorImage swig_types[288]
#define SWIGTYPE_p_Magick__borderImage swig_types[289]
#define SWIGTYPE_p_Magick__boxColorImage swig_types[290]
#define SWIGTYPE_p_Magick__cdlImage swig_types[291]
#define SWIGTYPE_p_Magick__channelImage swig_types[292]
#define SWIGTYPE_p_Magick__charcoalImage swig_types[293]
#define SWIGTYPE_p_Magick__chopImage swig_types[294]
#define SWIGTYPE_p_Magick__chromaBluePrimaryImage swig_types[295]
#define SWIGTYPE_p_Magick__chromaGreenPrimaryImage swig_types[296]
#define SWIGTYPE_p_Magick__chromaRedPrimaryImage swig_types[297]
#define SWIGTYPE_p_Magick__chromaWhitePointImage swig_types[298]
#define SWIGTYPE_p_Magick__colorFuzzImage swig_types[299]
#define SWIGTYPE_p_Magick__colorMapImage swig_types[300]
#define SWIGTYPE_p_Magick__colorMatrixImage swig_types[301]
#define SWIGTYPE_p_Magick__colorSpaceImage swig_types[302]
#define SWIGTYPE_p_Magick__colorizeImage swig_types[303]
#define SWIGTYPE_p_Magick__commentImage swig_types[304]
#define SWIGTYPE_p_Magick__composeImage swig_types[305]
#define SWIGTYPE_p_Magick__compositeImage swig_types[306]
#define SWIGTYPE_p_Magick__compressTypeImage swig_types[307]
#define SWIGTYPE_p_Magick__contrastImage swig_types[308]
#define SWIGTYPE_p_Magick__cropImage swig_types[309]
#define SWIGTYPE_p_Magick__cycleColormapImage swig_types[310]
#define SWIGTYPE_p_Magick__densityImage swig_types[311]
#define SWIGTYPE_p_Magick__depthImage swig_types[312]
#define SWIGTYPE_p_Magick__despeckleImage swig_types[313]
#define SWIGTYPE_p_Magick__distortImage swig_types[314]
#define SWIGTYPE_p_Magick__drawImage swig_types[315]
#define SWIGTYPE_p_Magick__edgeImage swig_types[316]
#define SWIGTYPE_p_Magick__embossImage swig_types[317]
#define SWIGTYPE_p_Magick__endianImage swig_types[318]
#define SWIGTYPE_p_Magick__enhanceImage swig_types[319]
#define SWIGTYPE_p_Magick__equalizeImage swig_types[320]
#define SWIGTYPE_p_Magick__fileNameImage swig_types[321]
#define SWIGTYPE_p_Magick__fillColorImage swig_types[322]
#define SWIGTYPE_p_Magick__filterTypeImage swig_types[323]
#define SWIGTYPE_p_Magick__flipImage swig_types[324]
#define SWIGTYPE_p_Magick__floodFillColorImage swig_types[325]
#define SWIGTYPE_p_Magick__floodFillTextureImage swig_types[326]
#define SWIGTYPE_p_Magick__flopImage swig_types[327]
#define SWIGTYPE_p_Magick__fontImage swig_types[328]
#define SWIGTYPE_p_Magick__fontPointsizeImage swig_types[329]
#define SWIGTYPE_p_Magick__frameImage swig_types[330]
#define SWIGTYPE_p_Magick__gammaImage swig_types[331]
#define SWIGTYPE_p_Magick__gaussianBlurImage swig_types[332]
#define SWIGTYPE_p_Magick__gifDisposeMethodImage swig_types[333]
#define SWIGTYPE_p_Magick__haldClutImage swig_types[334]
#define SWIGTYPE_p_Magick__implodeImage swig_types[335]
#define SWIGTYPE_p_Magick__interlaceTypeImage swig_types[336]
#define SWIGTYPE_p_Magick__inverseFourierTransformImage swig_types[337]
#define SWIGTYPE_p_Magick__isValidImage swig_types[338]
#define SWIGTYPE_p_Magick__labelImage swig_types[339]
#define SWIGTYPE_p_Magick__levelChannelImage swig_types[340]
#define SWIGTYPE_p_Magick__levelImage swig_types[341]
#define SWIGTYPE_p_Magick__lineWidthImage swig_types[342]
#define SWIGTYPE_p_Magick__magickImage swig_types[343]
#define SWIGTYPE_p_Magick__magnifyImage swig_types[344]
#define SWIGTYPE_p_Magick__mapImage swig_types[345]
#define SWIGTYPE_p_Magick__matteColorImage swig_types[346]
#define SWIGTYPE_p_Magick__matteFloodfillImage swig_types[347]
#define SWIGTYPE_p_Magick__matteImage swig_types[348]
#define SWIGTYPE_p_Magick__medianFilterImage swig_types[349]
#define SWIGTYPE_p_Magick__mergeLayersImage swig_types[350]
#define SWIGTYPE_p_Magick__minifyImage swig_types[351]
#define SWIGTYPE_p_Magick__modulateImage swig_types[352]
#define SWIGTYPE_p_Magick__monochromeImage swig_types[353]
#define SWIGTYPE_p_Magick__negateImage swig_types[354]
#define SWIGTYPE_p_Magick__normalizeImage swig_types[355]
#define SWIGTYPE_p_Magick__oilPaintImage swig_types[356]
#define SWIGTYPE_p_Magick__opacityImage swig_types[357]
#define SWIGTYPE_p_Magick__opaqueImage swig_types[358]
#define SWIGTYPE_p_Magick__pageImage swig_types[359]
#define SWIGTYPE_p_Magick__penColorImage swig_types[360]
#define SWIGTYPE_p_Magick__penTextureImage swig_types[361]
#define SWIGTYPE_p_Magick__pixelColorImage swig_types[362]
#define SWIGTYPE_p_Magick__qualityImage swig_types[363]
#define SWIGTYPE_p_Magick__quantizeColorSpaceImage swig_types[364]
#define SWIGTYPE_p_Magick__quantizeColorsImage swig_types[365]
#define SWIGTYPE_p_Magick__quantizeDitherImage swig_types[366]
#define SWIGTYPE_p_Magick__quantizeImage swig_types[367]
#define SWIGTYPE_p_Magick__quantizeTreeDepthImage swig_types[368]
#define SWIGTYPE_p_Magick__raiseImage swig_types[369]
#define SWIGTYPE_p_Magick__reduceNoiseImage swig_types[370]
#define SWIGTYPE_p_Magick__renderingIntentImage swig_types[371]
#define SWIGTYPE_p_Magick__resizeImage swig_types[372]
#define SWIGTYPE_p_Magick__resolutionUnitsImage swig_types[373]
#define SWIGTYPE_p_Magick__rollImage swig_types[374]
#define SWIGTYPE_p_Magick__rotateImage swig_types[375]
#define SWIGTYPE_p_Magick__sampleImage swig_types[376]
#define SWIGTYPE_p_Magick__scaleImage swig_types[377]
#define SWIGTYPE_p_Magick__sceneImage swig_types[378]
#define SWIGTYPE_p_Magick__segmentImage swig_types[379]
#define SWIGTYPE_p_Magick__shadeImage swig_types[380]
#define SWIGTYPE_p_Magick__shadowImage swig_types[381]
#define SWIGTYPE_p_Magick__sharpenImage swig_types[382]
#define SWIGTYPE_p_Magick__shaveImage swig_types[383]
#define SWIGTYPE_p_Magick__shearImage swig_types[384]
#define SWIGTYPE_p_Magick__sigmoidalContrastImage swig_types[385]
#define SWIGTYPE_p_Magick__sizeImage swig_types[386]
#define SWIGTYPE_p_Magick__solarizeImage swig_types[387]
#define SWIGTYPE_p_Magick__spliceImage swig_types[388]
#define SWIGTYPE_p_Magick__spreadImage swig_types[389]
#define SWIGTYPE_p_Magick__steganoImage swig_types[390]
#define SWIGTYPE_p_Magick__stereoImage swig_types[391]
#define SWIGTYPE_p_Magick__stripImage swig_types[392]
#define SWIGTYPE_p_Magick__strokeColorImage swig_types[393]
#define SWIGTYPE_p_Magick__subImageImage swig_types[394]
#define SWIGTYPE_p_Magick__subRangeImage swig_types[395]
#define SWIGTYPE_p_Magick__swirlImage swig_types[396]
#define SWIGTYPE_p_Magick__textureImage swig_types[397]
#define SWIGTYPE_p_Magick__thresholdImage swig_types[398]
#define SWIGTYPE_p_Magick__tileNameImage swig_types[399]
#define SWIGTYPE_p_Magick__transformImage swig_types[400]
#define SWIGTYPE_p_Magick__transparentImage swig_types[401]
#define SWIGTYPE_p_Magick__trimImage swig_types[402]
#define SWIGTYPE_p_Magick__typeImage swig_types[403]
#define SWIGTYPE_p_Magick__verboseImage swig_types[404]
#define SWIGTYPE_p_Magick__viewImage swig_types[405]
#define SWIGTYPE_p_Magick__waveImage swig_types[406]
#define SWIGTYPE_p_Magick__x11DisplayImage swig_types[407]
#define SWIGTYPE_p_Magick__zoomImage swig_types[408]
#define SWIGTYPE_p_PixelPacket swig_types[409]
#define SWIGTYPE_p__Ascii85Info swig_types[410]
#define SWIGTYPE_p__BlobInfo swig_types[411]
#define SWIGTYPE_p__CacheView swig_types[412]
#define SWIGTYPE_p__DrawingWand swig_types[413]
#define SWIGTYPE_p__HashmapInfo swig_types[414]
#define SWIGTYPE_p__ImageView swig_types[415]
#define SWIGTYPE_p__LinkedListInfo swig_types[416]
#define SWIGTYPE_p__LogInfo swig_types[417]
#define SWIGTYPE_p__MagickWand swig_types[418]
#define SWIGTYPE_p__MatrixInfo swig_types[419]
#define SWIGTYPE_p__MemoryInfo swig_types[420]
#define SWIGTYPE_p__MimeInfo swig_types[421]
#define SWIGTYPE_p__PixelIterator swig_types[422]
#define SWIGTYPE_p__PixelView swig_types[423]
#define SWIGTYPE_p__PixelWand swig_types[424]
#define SWIGTYPE_p__PolicyInfo swig_types[425]
#define SWIGTYPE_p__QuantumInfo swig_types[426]
#define SWIGTYPE_p__RandomInfo swig_types[427]
#define SWIGTYPE_p__ResampleFilter swig_types[428]
#define SWIGTYPE_p__ResizeFilter swig_types[429]
#define SWIGTYPE_p__SplayTreeInfo swig_types[430]
#define SWIGTYPE_p__ThresholdMap swig_types[431]
#define SWIGTYPE_p__TokenInfo swig_types[432]
#define SWIGTYPE_p__ViewInfo swig_types[433]
#define SWIGTYPE_p__WandView swig_types[434]
#define SWIGTYPE_p__XMLTreeInfo swig_types[435]
#define SWIGTYPE_p_char swig_types[436]
#define SWIGTYPE_p_double swig_types[437]
#define SWIGTYPE_p_f_p_p_MagickCore___Image_q_const__int_p_p_q_const__char_p_MagickCore___ExceptionInfo__size_t swig_types[438]
#define SWIGTYPE_p_f_p_q_const__MagickCore__ImageInfo_p_MagickCore__ExceptionInfo__p_MagickCore___Image swig_types[439]
#define SWIGTYPE_p_f_p_q_const__MagickCore__ImageInfo_p_MagickCore__Image__MagickCore__MagickBooleanType swig_types[440]
#define SWIGTYPE_p_f_p_q_const__unsigned_char_q_const__size_t__MagickCore__MagickBooleanType swig_types[441]
#define SWIGTYPE_p_float swig_types[442]
#define SWIGTYPE_p_long_long swig_types[443]
#define SWIGTYPE_p_off_t swig_types[444]
#define SWIGTYPE_p_p_MagickCore___Image swig_types[445]
#define SWIGTYPE_p_p_char swig_types[446]
#define SWIGTYPE_p_size_t swig_types[447]
#define SWIGTYPE_p_ssize_t swig_types[448]
#define SWIGTYPE_p_std__exception swig_types[449]
#define SWIGTYPE_p_std__listT_Magick__Coordinate_t swig_types[450]
#define SWIGTYPE_p_std__listT_Magick__Drawable_t swig_types[451]
#define SWIGTYPE_p_std__listT_Magick__PathArcArgs_t swig_types[452]
#define SWIGTYPE_p_std__listT_Magick__PathCurvetoArgs_t swig_types[453]
#define SWIGTYPE_p_std__listT_Magick__PathQuadraticCurvetoArgs_t swig_types[454]
#define SWIGTYPE_p_std__listT_Magick__VPath_t swig_types[455]
#define SWIGTYPE_p_unsigned_char swig_types[456]
#define SWIGTYPE_p_unsigned_int swig_types[457]
#define SWIGTYPE_p_unsigned_long_long swig_types[458]
#define SWIGTYPE_p_unsigned_short swig_types[459]
#define SWIGTYPE_p_void swig_types[460]
static swig_type_info *swig_types[462];
static swig_module_info swig_module = {swig_types, 461, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */



#ifdef __cplusplus
#include <utility>
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigSmartPointer {
    T *ptr;
    SwigSmartPointer(T *p) : ptr(p) { }
    ~SwigSmartPointer() { delete ptr; }
    SwigSmartPointer& operator=(SwigSmartPointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
    void reset(T *p) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = p; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigSmartPointer tmp(new T(t)); pointer = tmp; return *this; }
#if __cplusplus >=201103L
  SwigValueWrapper& operator=(T&& t) { SwigSmartPointer tmp(new T(std::move(t))); pointer = tmp; return *this; }
  operator T&&() const { return std::move(*pointer.ptr); }
#else
  operator T&() const { return *pointer.ptr; }
#endif
  T *operator&() const { return pointer.ptr; }
  static void reset(SwigValueWrapper& t, T *p) { t.pointer.reset(p); }
};

/*
 * SwigValueInit() is a generic initialisation solution as the following approach:
 * 
 *       T c_result = T();
 * 
 * doesn't compile for all types for example:
 * 
 *       unsigned int c_result = unsigned int();
 */
template <typename T> T SwigValueInit() {
  return T();
}

#if __cplusplus >=201103L
# define SWIG_STD_MOVE(OBJ) std::move(OBJ)
#else
# define SWIG_STD_MOVE(OBJ) OBJ
#endif

#endif


#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 


#include <stdexcept>


#include <assert.h>


#ifdef __cplusplus
#include <utility>
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigSmartPointer {
    T *ptr;
    SwigSmartPointer(T *p) : ptr(p) { }
    ~SwigSmartPointer() { delete ptr; }
    SwigSmartPointer& operator=(SwigSmartPointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
    void reset(T *p) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = p; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigSmartPointer tmp(new T(t)); pointer = tmp; return *this; }
#if __cplusplus >=201103L
  SwigValueWrapper& operator=(T&& t) { SwigSmartPointer tmp(new T(std::move(t))); pointer = tmp; return *this; }
  operator T&&() const { return std::move(*pointer.ptr); }
#else
  operator T&() const { return *pointer.ptr; }
#endif
  T *operator&() const { return pointer.ptr; }
  static void reset(SwigValueWrapper& t, T *p) { t.pointer.reset(p); }
};

/*
 * SwigValueInit() is a generic initialisation solution as the following approach:
 * 
 *       T c_result = T();
 * 
 * doesn't compile for all types for example:
 * 
 *       unsigned int c_result = unsigned int();
 */
template <typename T> T SwigValueInit() {
  return T();
}

#if __cplusplus >=201103L
# define SWIG_STD_MOVE(OBJ) std::move(OBJ)
#else
# define SWIG_STD_MOVE(OBJ) OBJ
#endif

#endif


#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 


#include <assert.h>


/* Includes the header in the wrapper code */
#include <Magick++.h> 
#include <iostream>


#include <string>


#include <typeinfo>
#include <stdexcept>


#include <vector>
#include <stdexcept>


SWIGINTERNINLINE
SWIGV8_VALUE SWIG_From_int  (int value)
{
  return SWIGV8_INT32_NEW(value);
}


SWIGINTERN
SWIGV8_VALUE SWIG_From_double   (double val)
{
  return SWIGV8_NUMBER_NEW(val);
}


SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}


SWIGINTERN int
SWIG_AsCharPtrAndSize(SWIGV8_VALUE valRef, char** cptr, size_t* psize, int *alloc)
{
  if(valRef->IsString()) {
    v8::Local<v8::String> js_str = v8::Local<v8::String>::Cast(valRef);

    size_t len = SWIGV8_UTF8_LENGTH(js_str) + 1;
    char* cstr = (char*) (new char[len]());
    SWIGV8_WRITE_UTF8(js_str, cstr, len);
    
    if(alloc) *alloc = SWIG_NEWOBJ;
    if(psize) *psize = len;
    if(cptr) *cptr = cstr;
    
    return SWIG_OK;
  } else {
    if(valRef->IsObject()) {
      SWIGV8_OBJECT obj = SWIGV8_OBJECT::Cast(valRef);
      // try if the object is a wrapped char[]
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      if (pchar_descriptor) {
        void* vptr = 0;
        if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
          if (cptr) *cptr = (char *) vptr;
          if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
          if (alloc) *alloc = SWIG_OLDOBJ;
          return SWIG_OK;
        }
      }
      return SWIG_TypeError;
    } else {
      return SWIG_TypeError;
    }
  }
}





SWIGINTERN int
SWIG_AsPtr_std_string (SWIGV8_VALUE obj, std::string **val) 
{
  char* buf = 0 ; size_t size = 0; int alloc = SWIG_OLDOBJ;
  if (SWIG_IsOK((SWIG_AsCharPtrAndSize(obj, &buf, &size, &alloc)))) {
    if (buf) {
      if (val) *val = new std::string(buf, size - 1);
      if (alloc == SWIG_NEWOBJ) delete[] buf;
      return SWIG_NEWOBJ;
    } else {
      if (val) *val = 0;
      return SWIG_OLDOBJ;
    }
  } else {
    static int init = 0;
    static swig_type_info* descriptor = 0;
    if (!init) {
      descriptor = SWIG_TypeQuery("std::string" " *");
      init = 1;
    }
    if (descriptor) {
      std::string *vptr;
      int res = SWIG_ConvertPtr(obj, (void**)&vptr, descriptor, 0);
      if (SWIG_IsOK(res) && val) *val = vptr;
      return res;
    }
  }
  return SWIG_ERROR;
}


SWIGINTERN
int SWIG_AsVal_double (SWIGV8_VALUE obj, double *val)
{
  if(!obj->IsNumber()) {
    return SWIG_TypeError;
  }
  if(val) *val = SWIGV8_NUMBER_VALUE(obj);

  return SWIG_OK;
}


#include <float.h>


#include <math.h>


SWIGINTERNINLINE int
SWIG_CanCastAsInteger(double *d, double min, double max) {
  double x = *d;
  if ((min <= x && x <= max)) {
   double fx = floor(x);
   double cx = ceil(x);
   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
   if ((errno == EDOM) || (errno == ERANGE)) {
     errno = 0;
   } else {
     double summ, reps, diff;
     if (rd < x) {
       diff = x - rd;
     } else if (rd > x) {
       diff = rd - x;
     } else {
       return 1;
     }
     summ = rd + x;
     reps = diff/summ;
     if (reps < 8*DBL_EPSILON) {
       *d = rd;
       return 1;
     }
   }
  }
  return 0;
}


SWIGINTERN
int SWIG_AsVal_unsigned_SS_long (SWIGV8_VALUE obj, unsigned long *val)
{
  if(!obj->IsNumber()) {
    return SWIG_TypeError;
  }

  long longVal = (long) SWIGV8_NUMBER_VALUE(obj);

  if(longVal < 0) {
      return SWIG_OverflowError;
  }

  if(val) *val = longVal;

  return SWIG_OK;
}


#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


#if defined(LLONG_MAX) && !defined(SWIG_LONG_LONG_AVAILABLE)
#  define SWIG_LONG_LONG_AVAILABLE
#endif


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERN
int SWIG_AsVal_unsigned_SS_long_SS_long (SWIGV8_VALUE obj, unsigned long long *val)
{
  if(!obj->IsNumber()) {
    return SWIG_TypeError;
  }

  long long longVal = (long long) SWIGV8_NUMBER_VALUE(obj);

  if(longVal < 0) {
      return SWIG_OverflowError;
  }

  if(val) *val = longVal;

  return SWIG_OK;
}
#endif


SWIGINTERNINLINE int
SWIG_AsVal_size_t (SWIGV8_VALUE obj, size_t *val)
{
  int res = SWIG_TypeError;
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(size_t) <= sizeof(unsigned long)) {
#endif
    unsigned long v;
    res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else if (sizeof(size_t) <= sizeof(unsigned long long)) {
    unsigned long long v;
    res = SWIG_AsVal_unsigned_SS_long_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
  }
#endif
  return res;
}


SWIGINTERN
int SWIG_AsVal_long (SWIGV8_VALUE obj, long* val)
{
  if (!obj->IsNumber()) {
    return SWIG_TypeError;
  }
  if(val) *val = (long) SWIGV8_INTEGER_VALUE(obj);

  return SWIG_OK;
}


SWIGINTERN
int SWIG_AsVal_bool (SWIGV8_VALUE obj, bool *val)
{
  if(!obj->IsBoolean()) {
    return SWIG_ERROR;
  }

  if (val) *val = SWIGV8_BOOLEAN_VALUE(obj);
  return SWIG_OK;
}


SWIGINTERNINLINE
SWIGV8_VALUE
SWIG_From_bool  (bool value)
{
  return SWIGV8_BOOLEAN_NEW(value);
}


SWIGINTERNINLINE
SWIGV8_VALUE SWIG_From_long  (long value)
{
  return SWIGV8_NUMBER_NEW(value);
}


SWIGINTERNINLINE
SWIGV8_VALUE SWIG_From_unsigned_SS_long  (unsigned long value)
{
  return value <= UINT32_MAX ? (SWIGV8_VALUE)SWIGV8_INTEGER_NEW_UNS(value) : (SWIGV8_VALUE)SWIGV8_NUMBER_NEW(static_cast<double>(value));
}


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERNINLINE
SWIGV8_VALUE SWIG_From_long_SS_long  (long long value)
{
  return SWIGV8_NUMBER_NEW(value);
}
#endif


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERNINLINE
SWIGV8_VALUE SWIG_From_unsigned_SS_long_SS_long  (unsigned long long value)
{
  return value <= UINT32_MAX ? (SWIGV8_VALUE)SWIGV8_INTEGER_NEW_UNS(value) : (SWIGV8_VALUE)SWIGV8_NUMBER_NEW(static_cast<double>(value));
}
#endif


SWIGINTERNINLINE SWIGV8_VALUE
SWIG_From_size_t  (size_t value)
{    
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(size_t) <= sizeof(unsigned long)) {
#endif
    return SWIG_From_unsigned_SS_long  (static_cast< unsigned long >(value));
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else {
    /* assume sizeof(size_t) <= sizeof(unsigned long long) */
    return SWIG_From_unsigned_SS_long_SS_long  (static_cast< unsigned long long >(value));
  }
#endif
}


SWIGINTERN
int SWIG_AsVal_int (SWIGV8_VALUE valRef, int* val)
{
  if (!valRef->IsNumber()) {
    return SWIG_TypeError;
  }
  if(val) *val = SWIGV8_INTEGER_VALUE(valRef);

  return SWIG_OK;
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_int (SWIGV8_VALUE obj, unsigned int *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UINT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned int >(v);
    }
  }  
  return res;
}


SWIGINTERNINLINE SWIGV8_VALUE
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > INT_MAX) {
      // TODO: handle extra long strings
      return SWIGV8_UNDEFINED();
    } else {
      v8::Local<v8::String> js_str = SWIGV8_STRING_NEW2(carray, size);
      return js_str;
    }
  } else {
    return SWIGV8_UNDEFINED();
  }
}


SWIGINTERNINLINE SWIGV8_VALUE
SWIG_From_std_string  (const std::string& s)
{
  return SWIG_FromCharPtrAndSize(s.data(), s.size());
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_short (SWIGV8_VALUE obj, unsigned short *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > USHRT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned short >(v);
    }
  }  
  return res;
}


SWIGINTERNINLINE SWIGV8_VALUE
SWIG_From_unsigned_SS_short  (unsigned short value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}


SWIGINTERNINLINE SWIGV8_VALUE 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}


#define SWIGV8_INIT magickwand_initialize


SWIGV8_ClientData _exports_TypeMetric_clientData;
SWIGV8_ClientData _exports_Geometry_clientData;
SWIGV8_ClientData _exports_Offset_clientData;
SWIGV8_ClientData _exports_Pixels_clientData;
SWIGV8_ClientData _exports_PixelData_clientData;
SWIGV8_ClientData _exports_ResourceLimits_clientData;
SWIGV8_ClientData _exports_adaptiveBlurImage_clientData;
SWIGV8_ClientData _exports_adaptiveThresholdImage_clientData;
SWIGV8_ClientData _exports_addNoiseImage_clientData;
SWIGV8_ClientData _exports_affineTransformImage_clientData;
SWIGV8_ClientData _exports_annotateImage_clientData;
SWIGV8_ClientData _exports_blurImage_clientData;
SWIGV8_ClientData _exports_borderImage_clientData;
SWIGV8_ClientData _exports_channelImage_clientData;
SWIGV8_ClientData _exports_charcoalImage_clientData;
SWIGV8_ClientData _exports_chopImage_clientData;
SWIGV8_ClientData _exports_cdlImage_clientData;
SWIGV8_ClientData _exports_colorizeImage_clientData;
SWIGV8_ClientData _exports_colorMatrixImage_clientData;
SWIGV8_ClientData _exports_colorSpaceImage_clientData;
SWIGV8_ClientData _exports_commentImage_clientData;
SWIGV8_ClientData _exports_compositeImage_clientData;
SWIGV8_ClientData _exports_contrastImage_clientData;
SWIGV8_ClientData _exports_cropImage_clientData;
SWIGV8_ClientData _exports_cycleColormapImage_clientData;
SWIGV8_ClientData _exports_despeckleImage_clientData;
SWIGV8_ClientData _exports_distortImage_clientData;
SWIGV8_ClientData _exports_drawImage_clientData;
SWIGV8_ClientData _exports_edgeImage_clientData;
SWIGV8_ClientData _exports_embossImage_clientData;
SWIGV8_ClientData _exports_enhanceImage_clientData;
SWIGV8_ClientData _exports_equalizeImage_clientData;
SWIGV8_ClientData _exports_fillColorImage_clientData;
SWIGV8_ClientData _exports_flipImage_clientData;
SWIGV8_ClientData _exports_floodFillColorImage_clientData;
SWIGV8_ClientData _exports_floodFillTextureImage_clientData;
SWIGV8_ClientData _exports_flopImage_clientData;
SWIGV8_ClientData _exports_frameImage_clientData;
SWIGV8_ClientData _exports_gammaImage_clientData;
SWIGV8_ClientData _exports_gaussianBlurImage_clientData;
SWIGV8_ClientData _exports_haldClutImage_clientData;
SWIGV8_ClientData _exports_implodeImage_clientData;
SWIGV8_ClientData _exports_inverseFourierTransformImage_clientData;
SWIGV8_ClientData _exports_isValidImage_clientData;
SWIGV8_ClientData _exports_labelImage_clientData;
SWIGV8_ClientData _exports_levelImage_clientData;
SWIGV8_ClientData _exports_levelChannelImage_clientData;
SWIGV8_ClientData _exports_magnifyImage_clientData;
SWIGV8_ClientData _exports_mapImage_clientData;
SWIGV8_ClientData _exports_matteFloodfillImage_clientData;
SWIGV8_ClientData _exports_medianFilterImage_clientData;
SWIGV8_ClientData _exports_mergeLayersImage_clientData;
SWIGV8_ClientData _exports_minifyImage_clientData;
SWIGV8_ClientData _exports_modulateImage_clientData;
SWIGV8_ClientData _exports_negateImage_clientData;
SWIGV8_ClientData _exports_normalizeImage_clientData;
SWIGV8_ClientData _exports_oilPaintImage_clientData;
SWIGV8_ClientData _exports_opacityImage_clientData;
SWIGV8_ClientData _exports_opaqueImage_clientData;
SWIGV8_ClientData _exports_quantizeImage_clientData;
SWIGV8_ClientData _exports_raiseImage_clientData;
SWIGV8_ClientData _exports_ReadOptions_clientData;
SWIGV8_ClientData _exports_reduceNoiseImage_clientData;
SWIGV8_ClientData _exports_resizeImage_clientData;
SWIGV8_ClientData _exports_rollImage_clientData;
SWIGV8_ClientData _exports_rotateImage_clientData;
SWIGV8_ClientData _exports_sampleImage_clientData;
SWIGV8_ClientData _exports_scaleImage_clientData;
SWIGV8_ClientData _exports_segmentImage_clientData;
SWIGV8_ClientData _exports_shadeImage_clientData;
SWIGV8_ClientData _exports_shadowImage_clientData;
SWIGV8_ClientData _exports_sharpenImage_clientData;
SWIGV8_ClientData _exports_shaveImage_clientData;
SWIGV8_ClientData _exports_shearImage_clientData;
SWIGV8_ClientData _exports_solarizeImage_clientData;
SWIGV8_ClientData _exports_spliceImage_clientData;
SWIGV8_ClientData _exports_spreadImage_clientData;
SWIGV8_ClientData _exports_steganoImage_clientData;
SWIGV8_ClientData _exports_stereoImage_clientData;
SWIGV8_ClientData _exports_strokeColorImage_clientData;
SWIGV8_ClientData _exports_swirlImage_clientData;
SWIGV8_ClientData _exports_textureImage_clientData;
SWIGV8_ClientData _exports_thresholdImage_clientData;
SWIGV8_ClientData _exports_transformImage_clientData;
SWIGV8_ClientData _exports_transparentImage_clientData;
SWIGV8_ClientData _exports_trimImage_clientData;
SWIGV8_ClientData _exports_waveImage_clientData;
SWIGV8_ClientData _exports_zoomImage_clientData;
SWIGV8_ClientData _exports_antiAliasImage_clientData;
SWIGV8_ClientData _exports_adjoinImage_clientData;
SWIGV8_ClientData _exports_animationDelayImage_clientData;
SWIGV8_ClientData _exports_animationIterationsImage_clientData;
SWIGV8_ClientData _exports_backgroundColorImage_clientData;
SWIGV8_ClientData _exports_backgroundTextureImage_clientData;
SWIGV8_ClientData _exports_borderColorImage_clientData;
SWIGV8_ClientData _exports_boxColorImage_clientData;
SWIGV8_ClientData _exports_chromaBluePrimaryImage_clientData;
SWIGV8_ClientData _exports_chromaGreenPrimaryImage_clientData;
SWIGV8_ClientData _exports_chromaRedPrimaryImage_clientData;
SWIGV8_ClientData _exports_chromaWhitePointImage_clientData;
SWIGV8_ClientData _exports_colorFuzzImage_clientData;
SWIGV8_ClientData _exports_colorMapImage_clientData;
SWIGV8_ClientData _exports_composeImage_clientData;
SWIGV8_ClientData _exports_compressTypeImage_clientData;
SWIGV8_ClientData _exports_densityImage_clientData;
SWIGV8_ClientData _exports_depthImage_clientData;
SWIGV8_ClientData _exports_endianImage_clientData;
SWIGV8_ClientData _exports_fileNameImage_clientData;
SWIGV8_ClientData _exports_filterTypeImage_clientData;
SWIGV8_ClientData _exports_fontImage_clientData;
SWIGV8_ClientData _exports_fontPointsizeImage_clientData;
SWIGV8_ClientData _exports_gifDisposeMethodImage_clientData;
SWIGV8_ClientData _exports_interlaceTypeImage_clientData;
SWIGV8_ClientData _exports_lineWidthImage_clientData;
SWIGV8_ClientData _exports_magickImage_clientData;
SWIGV8_ClientData _exports_matteImage_clientData;
SWIGV8_ClientData _exports_matteColorImage_clientData;
SWIGV8_ClientData _exports_monochromeImage_clientData;
SWIGV8_ClientData _exports_penColorImage_clientData;
SWIGV8_ClientData _exports_penTextureImage_clientData;
SWIGV8_ClientData _exports_pixelColorImage_clientData;
SWIGV8_ClientData _exports_pageImage_clientData;
SWIGV8_ClientData _exports_qualityImage_clientData;
SWIGV8_ClientData _exports_quantizeColorsImage_clientData;
SWIGV8_ClientData _exports_quantizeColorSpaceImage_clientData;
SWIGV8_ClientData _exports_quantizeDitherImage_clientData;
SWIGV8_ClientData _exports_quantizeTreeDepthImage_clientData;
SWIGV8_ClientData _exports_renderingIntentImage_clientData;
SWIGV8_ClientData _exports_resolutionUnitsImage_clientData;
SWIGV8_ClientData _exports_sceneImage_clientData;
SWIGV8_ClientData _exports_sigmoidalContrastImage_clientData;
SWIGV8_ClientData _exports_sizeImage_clientData;
SWIGV8_ClientData _exports_stripImage_clientData;
SWIGV8_ClientData _exports_subImageImage_clientData;
SWIGV8_ClientData _exports_subRangeImage_clientData;
SWIGV8_ClientData _exports_tileNameImage_clientData;
SWIGV8_ClientData _exports_typeImage_clientData;
SWIGV8_ClientData _exports_verboseImage_clientData;
SWIGV8_ClientData _exports_viewImage_clientData;
SWIGV8_ClientData _exports_x11DisplayImage_clientData;
SWIGV8_ClientData _exports_Blob_clientData;
SWIGV8_ClientData _exports_ChannelMoments_clientData;
SWIGV8_ClientData _exports_ImageMoments_clientData;
SWIGV8_ClientData _exports_CoderInfo_clientData;
SWIGV8_ClientData _exports_Color_clientData;
SWIGV8_ClientData _exports_ColorGray_clientData;
SWIGV8_ClientData _exports_ColorHSL_clientData;
SWIGV8_ClientData _exports_ColorMono_clientData;
SWIGV8_ClientData _exports_ColorRGB_clientData;
SWIGV8_ClientData _exports_ColorYUV_clientData;
SWIGV8_ClientData _exports_Coordinate_clientData;
SWIGV8_ClientData _exports_DrawableBase_clientData;
SWIGV8_ClientData _exports_Drawable_clientData;
SWIGV8_ClientData _exports_VPathBase_clientData;
SWIGV8_ClientData _exports_VPath_clientData;
SWIGV8_ClientData _exports_DrawableAffine_clientData;
SWIGV8_ClientData _exports_DrawableArc_clientData;
SWIGV8_ClientData _exports_DrawableBezier_clientData;
SWIGV8_ClientData _exports_DrawablePopClipPath_clientData;
SWIGV8_ClientData _exports_DrawablePushClipPath_clientData;
SWIGV8_ClientData _exports_DrawableClipPath_clientData;
SWIGV8_ClientData _exports_DrawableCircle_clientData;
SWIGV8_ClientData _exports_DrawableColor_clientData;
SWIGV8_ClientData _exports_DrawableCompositeImage_clientData;
SWIGV8_ClientData _exports_DrawableDensity_clientData;
SWIGV8_ClientData _exports_DrawableEllipse_clientData;
SWIGV8_ClientData _exports_DrawableFillColor_clientData;
SWIGV8_ClientData _exports_DrawableFillRule_clientData;
SWIGV8_ClientData _exports_DrawableFillOpacity_clientData;
SWIGV8_ClientData _exports_DrawableFont_clientData;
SWIGV8_ClientData _exports_DrawableGravity_clientData;
SWIGV8_ClientData _exports_DrawableLine_clientData;
SWIGV8_ClientData _exports_DrawableMatte_clientData;
SWIGV8_ClientData _exports_DrawablePath_clientData;
SWIGV8_ClientData _exports_DrawablePoint_clientData;
SWIGV8_ClientData _exports_DrawablePointSize_clientData;
SWIGV8_ClientData _exports_DrawablePolygon_clientData;
SWIGV8_ClientData _exports_DrawablePolyline_clientData;
SWIGV8_ClientData _exports_DrawablePopGraphicContext_clientData;
SWIGV8_ClientData _exports_DrawablePushGraphicContext_clientData;
SWIGV8_ClientData _exports_DrawablePopPattern_clientData;
SWIGV8_ClientData _exports_DrawablePushPattern_clientData;
SWIGV8_ClientData _exports_DrawableRectangle_clientData;
SWIGV8_ClientData _exports_DrawableRotation_clientData;
SWIGV8_ClientData _exports_DrawableRoundRectangle_clientData;
SWIGV8_ClientData _exports_DrawableScaling_clientData;
SWIGV8_ClientData _exports_DrawableSkewX_clientData;
SWIGV8_ClientData _exports_DrawableSkewY_clientData;
SWIGV8_ClientData _exports_DrawableDashArray_clientData;
SWIGV8_ClientData _exports_DrawableDashOffset_clientData;
SWIGV8_ClientData _exports_DrawableStrokeLineCap_clientData;
SWIGV8_ClientData _exports_DrawableStrokeLineJoin_clientData;
SWIGV8_ClientData _exports_DrawableMiterLimit_clientData;
SWIGV8_ClientData _exports_DrawableStrokeAntialias_clientData;
SWIGV8_ClientData _exports_DrawableStrokeColor_clientData;
SWIGV8_ClientData _exports_DrawableStrokeOpacity_clientData;
SWIGV8_ClientData _exports_DrawableStrokeWidth_clientData;
SWIGV8_ClientData _exports_DrawableText_clientData;
SWIGV8_ClientData _exports_DrawableTextAntialias_clientData;
SWIGV8_ClientData _exports_DrawableTextDecoration_clientData;
SWIGV8_ClientData _exports_DrawableTextDirection_clientData;
SWIGV8_ClientData _exports_DrawableTextInterlineSpacing_clientData;
SWIGV8_ClientData _exports_DrawableTextInterwordSpacing_clientData;
SWIGV8_ClientData _exports_DrawableTextKerning_clientData;
SWIGV8_ClientData _exports_DrawableTextUnderColor_clientData;
SWIGV8_ClientData _exports_DrawableTranslation_clientData;
SWIGV8_ClientData _exports_DrawableViewbox_clientData;
SWIGV8_ClientData _exports_PathArcArgs_clientData;
SWIGV8_ClientData _exports_PathArcAbs_clientData;
SWIGV8_ClientData _exports_PathArcRel_clientData;
SWIGV8_ClientData _exports_PathClosePath_clientData;
SWIGV8_ClientData _exports_PathCurvetoArgs_clientData;
SWIGV8_ClientData _exports_PathCurvetoAbs_clientData;
SWIGV8_ClientData _exports_PathCurvetoRel_clientData;
SWIGV8_ClientData _exports_PathSmoothCurvetoAbs_clientData;
SWIGV8_ClientData _exports_PathSmoothCurvetoRel_clientData;
SWIGV8_ClientData _exports_PathQuadraticCurvetoArgs_clientData;
SWIGV8_ClientData _exports_PathQuadraticCurvetoAbs_clientData;
SWIGV8_ClientData _exports_PathQuadraticCurvetoRel_clientData;
SWIGV8_ClientData _exports_PathSmoothQuadraticCurvetoAbs_clientData;
SWIGV8_ClientData _exports_PathSmoothQuadraticCurvetoRel_clientData;
SWIGV8_ClientData _exports_PathLinetoAbs_clientData;
SWIGV8_ClientData _exports_PathLinetoRel_clientData;
SWIGV8_ClientData _exports_PathLinetoHorizontalAbs_clientData;
SWIGV8_ClientData _exports_PathLinetoHorizontalRel_clientData;
SWIGV8_ClientData _exports_PathLinetoVerticalAbs_clientData;
SWIGV8_ClientData _exports_PathLinetoVerticalRel_clientData;
SWIGV8_ClientData _exports_PathMovetoAbs_clientData;
SWIGV8_ClientData _exports_PathMovetoRel_clientData;
SWIGV8_ClientData _exports_Exception_clientData;
SWIGV8_ClientData _exports_Error_clientData;
SWIGV8_ClientData _exports_ErrorBlob_clientData;
SWIGV8_ClientData _exports_ErrorCache_clientData;
SWIGV8_ClientData _exports_ErrorCoder_clientData;
SWIGV8_ClientData _exports_ErrorConfigure_clientData;
SWIGV8_ClientData _exports_ErrorCorruptImage_clientData;
SWIGV8_ClientData _exports_ErrorDelegate_clientData;
SWIGV8_ClientData _exports_ErrorDraw_clientData;
SWIGV8_ClientData _exports_ErrorFileOpen_clientData;
SWIGV8_ClientData _exports_ErrorImage_clientData;
SWIGV8_ClientData _exports_ErrorMissingDelegate_clientData;
SWIGV8_ClientData _exports_ErrorModule_clientData;
SWIGV8_ClientData _exports_ErrorMonitor_clientData;
SWIGV8_ClientData _exports_ErrorOption_clientData;
SWIGV8_ClientData _exports_ErrorPolicy_clientData;
SWIGV8_ClientData _exports_ErrorRegistry_clientData;
SWIGV8_ClientData _exports_ErrorResourceLimit_clientData;
SWIGV8_ClientData _exports_ErrorStream_clientData;
SWIGV8_ClientData _exports_ErrorType_clientData;
SWIGV8_ClientData _exports_ErrorUndefined_clientData;
SWIGV8_ClientData _exports_ErrorXServer_clientData;
SWIGV8_ClientData _exports_Warning_clientData;
SWIGV8_ClientData _exports_WarningBlob_clientData;
SWIGV8_ClientData _exports_WarningCache_clientData;
SWIGV8_ClientData _exports_WarningCoder_clientData;
SWIGV8_ClientData _exports_WarningConfigure_clientData;
SWIGV8_ClientData _exports_WarningCorruptImage_clientData;
SWIGV8_ClientData _exports_WarningDelegate_clientData;
SWIGV8_ClientData _exports_WarningDraw_clientData;
SWIGV8_ClientData _exports_WarningFileOpen_clientData;
SWIGV8_ClientData _exports_WarningImage_clientData;
SWIGV8_ClientData _exports_WarningMissingDelegate_clientData;
SWIGV8_ClientData _exports_WarningModule_clientData;
SWIGV8_ClientData _exports_WarningMonitor_clientData;
SWIGV8_ClientData _exports_WarningOption_clientData;
SWIGV8_ClientData _exports_WarningPolicy_clientData;
SWIGV8_ClientData _exports_WarningRegistry_clientData;
SWIGV8_ClientData _exports_WarningResourceLimit_clientData;
SWIGV8_ClientData _exports_WarningStream_clientData;
SWIGV8_ClientData _exports_WarningType_clientData;
SWIGV8_ClientData _exports_WarningUndefined_clientData;
SWIGV8_ClientData _exports_WarningXServer_clientData;
SWIGV8_ClientData _exports_Montage_clientData;
SWIGV8_ClientData _exports_MontageFramed_clientData;
SWIGV8_ClientData _exports_Image_clientData;


static SwigV8ReturnValue _wrap_MAGICKCORE_QUANTUM_DEPTH(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  
  jsresult = SWIG_From_int(static_cast< int >(16));
  
  SWIGV8_RETURN_INFO(jsresult, info);
  
  goto fail;
fail:
  SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
}


static SwigV8ReturnValue _wrap_MAGICKCORE_HDRI_ENABLE(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  
  jsresult = SWIG_From_int(static_cast< int >(0));
  
  SWIGV8_RETURN_INFO(jsresult, info);
  
  goto fail;
fail:
  SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
}


static SwigV8ReturnValue _wrap_new_TypeMetric(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::TypeMetric *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_TypeMetric.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_TypeMetric.");
  {
    try {
      result = (Magick::TypeMetric *)new Magick::TypeMetric();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__TypeMetric, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_TypeMetric(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::TypeMetric * arg1 = (Magick::TypeMetric *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_TypeMetric_ascent(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::TypeMetric *arg1 = (Magick::TypeMetric *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_TypeMetric_ascent.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__TypeMetric, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TypeMetric_ascent" "', argument " "1"" of type '" "Magick::TypeMetric const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::TypeMetric * >(argp1);
  {
    try {
      result = (double)((Magick::TypeMetric const *)arg1)->ascent();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_TypeMetric_descent(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::TypeMetric *arg1 = (Magick::TypeMetric *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_TypeMetric_descent.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__TypeMetric, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TypeMetric_descent" "', argument " "1"" of type '" "Magick::TypeMetric const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::TypeMetric * >(argp1);
  {
    try {
      result = (double)((Magick::TypeMetric const *)arg1)->descent();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_TypeMetric_maxHorizontalAdvance(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::TypeMetric *arg1 = (Magick::TypeMetric *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_TypeMetric_maxHorizontalAdvance.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__TypeMetric, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TypeMetric_maxHorizontalAdvance" "', argument " "1"" of type '" "Magick::TypeMetric const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::TypeMetric * >(argp1);
  {
    try {
      result = (double)((Magick::TypeMetric const *)arg1)->maxHorizontalAdvance();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_TypeMetric_textHeight(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::TypeMetric *arg1 = (Magick::TypeMetric *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_TypeMetric_textHeight.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__TypeMetric, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TypeMetric_textHeight" "', argument " "1"" of type '" "Magick::TypeMetric const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::TypeMetric * >(argp1);
  {
    try {
      result = (double)((Magick::TypeMetric const *)arg1)->textHeight();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_TypeMetric_textWidth(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::TypeMetric *arg1 = (Magick::TypeMetric *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_TypeMetric_textWidth.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__TypeMetric, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TypeMetric_textWidth" "', argument " "1"" of type '" "Magick::TypeMetric const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::TypeMetric * >(argp1);
  {
    try {
      result = (double)((Magick::TypeMetric const *)arg1)->textWidth();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_TypeMetric_underlinePosition(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::TypeMetric *arg1 = (Magick::TypeMetric *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_TypeMetric_underlinePosition.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__TypeMetric, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TypeMetric_underlinePosition" "', argument " "1"" of type '" "Magick::TypeMetric const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::TypeMetric * >(argp1);
  {
    try {
      result = (double)((Magick::TypeMetric const *)arg1)->underlinePosition();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_TypeMetric_underlineThickness(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::TypeMetric *arg1 = (Magick::TypeMetric *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_TypeMetric_underlineThickness.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__TypeMetric, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TypeMetric_underlineThickness" "', argument " "1"" of type '" "Magick::TypeMetric const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::TypeMetric * >(argp1);
  {
    try {
      result = (double)((Magick::TypeMetric const *)arg1)->underlineThickness();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_equal__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equal" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equal" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      result = (int)Magick::operator ==((Magick::Geometry const &)*arg1,(Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_notEqual__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      result = (int)Magick::operator !=((Magick::Geometry const &)*arg1,(Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_gt__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gt" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gt" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      result = (int)Magick::operator >((Magick::Geometry const &)*arg1,(Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_lt__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lt" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lt" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      result = (int)Magick::operator <((Magick::Geometry const &)*arg1,(Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_gte__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gte" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gte" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      result = (int)Magick::operator >=((Magick::Geometry const &)*arg1,(Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_lte__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lte" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lte" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      result = (int)Magick::operator <=((Magick::Geometry const &)*arg1,(Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Geometry__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Geometry *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Geometry__SWIG_0.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Geometry__SWIG_0.");
  {
    try {
      result = (Magick::Geometry *)new Magick::Geometry();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Geometry, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Geometry__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  Magick::Geometry *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Geometry__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Geometry__SWIG_1.");
  res1 = SWIG_AsCharPtrAndSize(args[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Geometry" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (Magick::Geometry *)new Magick::Geometry((char const *)arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Geometry, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Geometry__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Geometry *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Geometry *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Geometry__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Geometry__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Geometry" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Geometry" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = (Magick::Geometry *)new Magick::Geometry((Magick::Geometry const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Geometry, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Geometry__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::Geometry *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Geometry__SWIG_3.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Geometry__SWIG_3.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Geometry" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Geometry" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::Geometry *)new Magick::Geometry((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Geometry, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Geometry__SWIG_4(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  size_t arg2 ;
  ::ssize_t arg3 ;
  ::ssize_t arg4 ;
  bool arg5 ;
  bool arg6 ;
  size_t val1 ;
  int ecode1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  Magick::Geometry *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Geometry__SWIG_4.");
  if(args.Length() != 6) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Geometry__SWIG_4.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Geometry" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  ecode2 = SWIG_AsVal_size_t(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Geometry" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Geometry" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  ecode4 = SWIG_AsVal_long(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_Geometry" "', argument " "4"" of type '" "::ssize_t""'");
  } 
  arg4 = static_cast< ::ssize_t >(val4);
  ecode5 = SWIG_AsVal_bool(args[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_Geometry" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  ecode6 = SWIG_AsVal_bool(args[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_Geometry" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  {
    try {
      result = (Magick::Geometry *)new Magick::Geometry(arg1,arg2,arg3,arg4,arg5,arg6);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Geometry, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Geometry__SWIG_5(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  size_t arg2 ;
  ::ssize_t arg3 ;
  ::ssize_t arg4 ;
  bool arg5 ;
  size_t val1 ;
  int ecode1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  Magick::Geometry *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Geometry__SWIG_5.");
  if(args.Length() != 5) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Geometry__SWIG_5.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Geometry" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  ecode2 = SWIG_AsVal_size_t(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Geometry" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Geometry" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  ecode4 = SWIG_AsVal_long(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_Geometry" "', argument " "4"" of type '" "::ssize_t""'");
  } 
  arg4 = static_cast< ::ssize_t >(val4);
  ecode5 = SWIG_AsVal_bool(args[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_Geometry" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  {
    try {
      result = (Magick::Geometry *)new Magick::Geometry(arg1,arg2,arg3,arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Geometry, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Geometry__SWIG_6(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  size_t arg2 ;
  ::ssize_t arg3 ;
  ::ssize_t arg4 ;
  size_t val1 ;
  int ecode1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  Magick::Geometry *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Geometry__SWIG_6.");
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Geometry__SWIG_6.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Geometry" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  ecode2 = SWIG_AsVal_size_t(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Geometry" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Geometry" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  ecode4 = SWIG_AsVal_long(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_Geometry" "', argument " "4"" of type '" "::ssize_t""'");
  } 
  arg4 = static_cast< ::ssize_t >(val4);
  {
    try {
      result = (Magick::Geometry *)new Magick::Geometry(arg1,arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Geometry, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Geometry__SWIG_7(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  size_t arg2 ;
  ::ssize_t arg3 ;
  size_t val1 ;
  int ecode1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  Magick::Geometry *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Geometry__SWIG_7.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Geometry__SWIG_7.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Geometry" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  ecode2 = SWIG_AsVal_size_t(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Geometry" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Geometry" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  {
    try {
      result = (Magick::Geometry *)new Magick::Geometry(arg1,arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Geometry, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Geometry__SWIG_8(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  size_t arg2 ;
  size_t val1 ;
  int ecode1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  Magick::Geometry *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Geometry__SWIG_8.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Geometry__SWIG_8.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Geometry" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  ecode2 = SWIG_AsVal_size_t(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Geometry" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      result = (Magick::Geometry *)new Magick::Geometry(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Geometry, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_Geometry(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::Geometry * arg1 = (Magick::Geometry *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_Geometry_clone__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  Magick::Geometry *result = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_clone" "', argument " "1"" of type '" "Magick::Geometry *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(args[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Geometry_clone" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (Magick::Geometry *) &(arg1)->operator =((char const *)arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_clone__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::Geometry *result = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_clone" "', argument " "1"" of type '" "Magick::Geometry *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Geometry_clone" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Geometry_clone" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      result = (Magick::Geometry *) &(arg1)->operator =((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_clone__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Magick::Geometry *result = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_clone" "', argument " "1"" of type '" "Magick::Geometry *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Geometry_clone" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Geometry_clone" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      result = (Magick::Geometry *) &(arg1)->operator =((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_aspect__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_aspect" "', argument " "1"" of type '" "Magick::Geometry *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Geometry_aspect" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->aspect(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_aspect__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_aspect" "', argument " "1"" of type '" "Magick::Geometry const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = (bool)((Magick::Geometry const *)arg1)->aspect();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry__wrap_Geometry_aspect(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Geometry_aspect__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Geometry_aspect__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function aspect.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_fillArea__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_fillArea" "', argument " "1"" of type '" "Magick::Geometry *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Geometry_fillArea" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->fillArea(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_fillArea__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_fillArea" "', argument " "1"" of type '" "Magick::Geometry const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = (bool)((Magick::Geometry const *)arg1)->fillArea();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry__wrap_Geometry_fillArea(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Geometry_fillArea__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Geometry_fillArea__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function fillArea.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_greater__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_greater" "', argument " "1"" of type '" "Magick::Geometry *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Geometry_greater" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->greater(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_greater__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_greater" "', argument " "1"" of type '" "Magick::Geometry const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = (bool)((Magick::Geometry const *)arg1)->greater();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry__wrap_Geometry_greater(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Geometry_greater__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Geometry_greater__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function greater.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_height__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_height" "', argument " "1"" of type '" "Magick::Geometry *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Geometry_height" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      (arg1)->height(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_height__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_height" "', argument " "1"" of type '" "Magick::Geometry const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = ((Magick::Geometry const *)arg1)->height();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry__wrap_Geometry_height(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Geometry_height__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Geometry_height__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function height.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_isValid__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_isValid" "', argument " "1"" of type '" "Magick::Geometry *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Geometry_isValid" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->isValid(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_isValid__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_isValid" "', argument " "1"" of type '" "Magick::Geometry const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = (bool)((Magick::Geometry const *)arg1)->isValid();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry__wrap_Geometry_isValid(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Geometry_isValid__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Geometry_isValid__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function isValid.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_less__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_less" "', argument " "1"" of type '" "Magick::Geometry *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Geometry_less" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->less(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_less__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_less" "', argument " "1"" of type '" "Magick::Geometry const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = (bool)((Magick::Geometry const *)arg1)->less();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry__wrap_Geometry_less(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Geometry_less__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Geometry_less__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function less.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_limitPixels__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_limitPixels" "', argument " "1"" of type '" "Magick::Geometry *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Geometry_limitPixels" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->limitPixels(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_limitPixels__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_limitPixels" "', argument " "1"" of type '" "Magick::Geometry const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = (bool)((Magick::Geometry const *)arg1)->limitPixels();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry__wrap_Geometry_limitPixels(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Geometry_limitPixels__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Geometry_limitPixels__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function limitPixels.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_percent__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_percent" "', argument " "1"" of type '" "Magick::Geometry *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Geometry_percent" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->percent(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_percent__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_percent" "', argument " "1"" of type '" "Magick::Geometry const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = (bool)((Magick::Geometry const *)arg1)->percent();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry__wrap_Geometry_percent(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Geometry_percent__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Geometry_percent__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function percent.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_width__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_width" "', argument " "1"" of type '" "Magick::Geometry *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Geometry_width" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      (arg1)->width(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_width__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_width" "', argument " "1"" of type '" "Magick::Geometry const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = ((Magick::Geometry const *)arg1)->width();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry__wrap_Geometry_width(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Geometry_width__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Geometry_width__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function width.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_xNegative__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_xNegative" "', argument " "1"" of type '" "Magick::Geometry *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Geometry_xNegative" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->xNegative(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_xNegative__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_xNegative" "', argument " "1"" of type '" "Magick::Geometry const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = (bool)((Magick::Geometry const *)arg1)->xNegative();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry__wrap_Geometry_xNegative(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Geometry_xNegative__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Geometry_xNegative__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function xNegative.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_xOff__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  ::ssize_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_xOff" "', argument " "1"" of type '" "Magick::Geometry *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Geometry_xOff" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  {
    try {
      (arg1)->xOff(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_xOff__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ::ssize_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_xOff" "', argument " "1"" of type '" "Magick::Geometry const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = ((Magick::Geometry const *)arg1)->xOff();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_long(static_cast< long >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry__wrap_Geometry_xOff(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Geometry_xOff__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Geometry_xOff__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function xOff.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_yNegative__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_yNegative" "', argument " "1"" of type '" "Magick::Geometry *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Geometry_yNegative" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->yNegative(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_yNegative__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_yNegative" "', argument " "1"" of type '" "Magick::Geometry const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = (bool)((Magick::Geometry const *)arg1)->yNegative();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry__wrap_Geometry_yNegative(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Geometry_yNegative__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Geometry_yNegative__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function yNegative.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_yOff__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  ::ssize_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_yOff" "', argument " "1"" of type '" "Magick::Geometry *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Geometry_yOff" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  {
    try {
      (arg1)->yOff(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_yOff__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ::ssize_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_yOff" "', argument " "1"" of type '" "Magick::Geometry const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = ((Magick::Geometry const *)arg1)->yOff();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_long(static_cast< long >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry__wrap_Geometry_yOff(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Geometry_yOff__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Geometry_yOff__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function yOff.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Geometry__SWIG_9(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  MagickCore::RectangleInfo *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Geometry *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Geometry__SWIG_9.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Geometry__SWIG_9.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_MagickCore___RectangleInfo,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Geometry" "', argument " "1"" of type '" "MagickCore::RectangleInfo const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Geometry" "', argument " "1"" of type '" "MagickCore::RectangleInfo const &""'"); 
  }
  arg1 = reinterpret_cast< MagickCore::RectangleInfo * >(argp1);
  {
    try {
      result = (Magick::Geometry *)new Magick::Geometry((MagickCore::RectangleInfo const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Geometry, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Geometry(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_Geometry__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_Geometry__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_Geometry__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_Geometry__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 6) {
    errorHandler.err.Clear();
    _wrap_new_Geometry__SWIG_4(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 5) {
    errorHandler.err.Clear();
    _wrap_new_Geometry__SWIG_5(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_new_Geometry__SWIG_6(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_Geometry__SWIG_7(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_Geometry__SWIG_8(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_Geometry__SWIG_9(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_Geometry");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry_clone__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Geometry *arg1 = (Magick::Geometry *) 0 ;
  MagickCore::RectangleInfo *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::Geometry *result = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Geometry_clone" "', argument " "1"" of type '" "Magick::Geometry *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_MagickCore___RectangleInfo,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Geometry_clone" "', argument " "2"" of type '" "MagickCore::RectangleInfo const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Geometry_clone" "', argument " "2"" of type '" "MagickCore::RectangleInfo const &""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::RectangleInfo * >(argp2);
  {
    try {
      result = (Magick::Geometry *) &(arg1)->operator =((MagickCore::RectangleInfo const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Geometry__wrap_Geometry_clone(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Geometry_clone__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Geometry_clone__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Geometry_clone__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Geometry_clone__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function clone.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_equal__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Offset *arg1 = 0 ;
  Magick::Offset *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Offset,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equal" "', argument " "1"" of type '" "Magick::Offset const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "1"" of type '" "Magick::Offset const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Offset * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Offset,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equal" "', argument " "2"" of type '" "Magick::Offset const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "2"" of type '" "Magick::Offset const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Offset * >(argp2);
  {
    try {
      result = (int)Magick::operator ==((Magick::Offset const &)*arg1,(Magick::Offset const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_notEqual__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Offset *arg1 = 0 ;
  Magick::Offset *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Offset,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Offset const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Offset const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Offset * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Offset,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Offset const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Offset const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Offset * >(argp2);
  {
    try {
      result = (int)Magick::operator !=((Magick::Offset const &)*arg1,(Magick::Offset const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Offset__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Offset *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Offset__SWIG_0.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Offset__SWIG_0.");
  {
    try {
      result = (Magick::Offset *)new Magick::Offset();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Offset, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Offset__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  Magick::Offset *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Offset__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Offset__SWIG_1.");
  res1 = SWIG_AsCharPtrAndSize(args[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Offset" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (Magick::Offset *)new Magick::Offset((char const *)arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Offset, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Offset__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Offset *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Offset *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Offset__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Offset__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Offset,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Offset" "', argument " "1"" of type '" "Magick::Offset const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Offset" "', argument " "1"" of type '" "Magick::Offset const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Offset * >(argp1);
  {
    try {
      result = (Magick::Offset *)new Magick::Offset((Magick::Offset const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Offset, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Offset__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::Offset *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Offset__SWIG_3.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Offset__SWIG_3.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Offset" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Offset" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::Offset *)new Magick::Offset((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Offset, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Offset__SWIG_4(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  ssize_t arg1 ;
  ssize_t arg2 ;
  long val1 ;
  int ecode1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  Magick::Offset *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Offset__SWIG_4.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Offset__SWIG_4.");
  ecode1 = SWIG_AsVal_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Offset" "', argument " "1"" of type '" "ssize_t""'");
  } 
  arg1 = static_cast< ssize_t >(val1);
  ecode2 = SWIG_AsVal_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Offset" "', argument " "2"" of type '" "ssize_t""'");
  } 
  arg2 = static_cast< ssize_t >(val2);
  {
    try {
      result = (Magick::Offset *)new Magick::Offset(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Offset, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Offset(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_Offset__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_Offset__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_Offset__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_Offset__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_Offset__SWIG_4(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_Offset");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_Offset(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::Offset * arg1 = (Magick::Offset *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_Offset_clone__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Offset *arg1 = (Magick::Offset *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  Magick::Offset *result = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Offset, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Offset_clone" "', argument " "1"" of type '" "Magick::Offset *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Offset * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(args[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Offset_clone" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (Magick::Offset *) &(arg1)->operator =((char const *)arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__Offset, 0 |  0 );
  
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Offset_clone__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Offset *arg1 = (Magick::Offset *) 0 ;
  Magick::Offset *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::Offset *result = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Offset, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Offset_clone" "', argument " "1"" of type '" "Magick::Offset *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Offset * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Offset,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Offset_clone" "', argument " "2"" of type '" "Magick::Offset const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Offset_clone" "', argument " "2"" of type '" "Magick::Offset const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Offset * >(argp2);
  {
    try {
      result = (Magick::Offset *) &(arg1)->operator =((Magick::Offset const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__Offset, 0 |  0 );
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Offset_clone__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Offset *arg1 = (Magick::Offset *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Magick::Offset *result = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Offset, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Offset_clone" "', argument " "1"" of type '" "Magick::Offset *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Offset * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Offset_clone" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Offset_clone" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      result = (Magick::Offset *) &(arg1)->operator =((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__Offset, 0 |  0 );
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Offset__wrap_Offset_clone(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Offset_clone__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Offset_clone__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Offset_clone__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function clone.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Offset_x(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Offset *arg1 = (Magick::Offset *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ssize_t result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Offset_x.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Offset, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Offset_x" "', argument " "1"" of type '" "Magick::Offset const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Offset * >(argp1);
  {
    try {
      result = ((Magick::Offset const *)arg1)->x();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_long(static_cast< long >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Offset_y(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Offset *arg1 = (Magick::Offset *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ssize_t result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Offset_y.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Offset, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Offset_y" "', argument " "1"" of type '" "Magick::Offset const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Offset * >(argp1);
  {
    try {
      result = ((Magick::Offset const *)arg1)->y();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_long(static_cast< long >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_CloneString(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  char **arg1 = (char **) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_CloneString.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CloneString" "', argument " "1"" of type '" "char **""'"); 
  }
  arg1 = reinterpret_cast< char ** >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CloneString" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CloneString" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      Magick::CloneString(arg1,(std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DisableOpenCL(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DisableOpenCL.");
  
  {
    try {
      Magick::DisableOpenCL();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_EnableOpenCL__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  bool result;
  
  ecode1 = SWIG_AsVal_bool(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "EnableOpenCL" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      result = (bool)Magick::EnableOpenCL(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_EnableOpenCL__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  bool result;
  
  {
    try {
      result = (bool)Magick::EnableOpenCL();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Magick__wrap_EnableOpenCL(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_EnableOpenCL__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_EnableOpenCL__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function EnableOpenCL.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_InitializeMagick(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_InitializeMagick.");
  
  res1 = SWIG_AsCharPtrAndSize(args[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitializeMagick" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      Magick::InitializeMagick((char const *)arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SetRandomSeed(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  unsigned long arg1 ;
  unsigned long val1 ;
  int ecode1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SetRandomSeed.");
  
  ecode1 = SWIG_AsVal_unsigned_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SetRandomSeed" "', argument " "1"" of type '" "unsigned long""'");
  } 
  arg1 = static_cast< unsigned long >(val1);
  {
    try {
      Magick::SetRandomSeed(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_TerminateMagick(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_TerminateMagick.");
  
  {
    try {
      Magick::TerminateMagick();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Pixels(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Image *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Pixels *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Pixels.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Pixels.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Pixels" "', argument " "1"" of type '" "Magick::Image &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Pixels" "', argument " "1"" of type '" "Magick::Image &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::Pixels *)new Magick::Pixels(*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Pixels, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_Pixels(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::Pixels * arg1 = (Magick::Pixels *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_Pixels_get(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Pixels *arg1 = (Magick::Pixels *) 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  size_t arg4 ;
  size_t arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PixelPacket *result = 0 ;
  
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Pixels_get.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Pixels, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixels_get" "', argument " "1"" of type '" "Magick::Pixels *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Pixels * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixels_get" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pixels_get" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  ecode4 = SWIG_AsVal_size_t(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Pixels_get" "', argument " "4"" of type '" "size_t""'");
  } 
  arg4 = static_cast< size_t >(val4);
  ecode5 = SWIG_AsVal_size_t(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Pixels_get" "', argument " "5"" of type '" "size_t""'");
  } 
  arg5 = static_cast< size_t >(val5);
  {
    try {
      result = (PixelPacket *)(arg1)->get(arg2,arg3,arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_PixelPacket, 0 |  0 );
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Pixels_getConst(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Pixels *arg1 = (Magick::Pixels *) 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  size_t arg4 ;
  size_t arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PixelPacket *result = 0 ;
  
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Pixels_getConst.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Pixels, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixels_getConst" "', argument " "1"" of type '" "Magick::Pixels *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Pixels * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixels_getConst" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pixels_getConst" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  ecode4 = SWIG_AsVal_size_t(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Pixels_getConst" "', argument " "4"" of type '" "size_t""'");
  } 
  arg4 = static_cast< size_t >(val4);
  ecode5 = SWIG_AsVal_size_t(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Pixels_getConst" "', argument " "5"" of type '" "size_t""'");
  } 
  arg5 = static_cast< size_t >(val5);
  {
    try {
      result = (PixelPacket *)(arg1)->getConst(arg2,arg3,arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_PixelPacket, 0 |  0 );
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Pixels_set(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Pixels *arg1 = (Magick::Pixels *) 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  size_t arg4 ;
  size_t arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PixelPacket *result = 0 ;
  
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Pixels_set.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Pixels, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixels_set" "', argument " "1"" of type '" "Magick::Pixels *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Pixels * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixels_set" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pixels_set" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  ecode4 = SWIG_AsVal_size_t(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Pixels_set" "', argument " "4"" of type '" "size_t""'");
  } 
  arg4 = static_cast< size_t >(val4);
  ecode5 = SWIG_AsVal_size_t(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Pixels_set" "', argument " "5"" of type '" "size_t""'");
  } 
  arg5 = static_cast< size_t >(val5);
  {
    try {
      result = (PixelPacket *)(arg1)->set(arg2,arg3,arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_PixelPacket, 0 |  0 );
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Pixels_sync(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Pixels *arg1 = (Magick::Pixels *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Pixels_sync.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Pixels, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixels_sync" "', argument " "1"" of type '" "Magick::Pixels *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Pixels * >(argp1);
  {
    try {
      (arg1)->sync();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Pixels_columns(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Pixels *arg1 = (Magick::Pixels *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Pixels_columns.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Pixels, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixels_columns" "', argument " "1"" of type '" "Magick::Pixels const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Pixels * >(argp1);
  {
    try {
      result = ((Magick::Pixels const *)arg1)->columns();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Pixels_indexes(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Pixels *arg1 = (Magick::Pixels *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::IndexPacket *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Pixels_indexes.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Pixels, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixels_indexes" "', argument " "1"" of type '" "Magick::Pixels *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Pixels * >(argp1);
  {
    try {
      result = (Magick::IndexPacket *)(arg1)->indexes();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_short, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Pixels_rows(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Pixels *arg1 = (Magick::Pixels *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Pixels_rows.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Pixels, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixels_rows" "', argument " "1"" of type '" "Magick::Pixels const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Pixels * >(argp1);
  {
    try {
      result = ((Magick::Pixels const *)arg1)->rows();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Pixels_x(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Pixels *arg1 = (Magick::Pixels *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ::ssize_t result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Pixels_x.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Pixels, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixels_x" "', argument " "1"" of type '" "Magick::Pixels const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Pixels * >(argp1);
  {
    try {
      result = ((Magick::Pixels const *)arg1)->x();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_long(static_cast< long >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Pixels_y(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Pixels *arg1 = (Magick::Pixels *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ::ssize_t result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Pixels_y.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Pixels, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixels_y" "', argument " "1"" of type '" "Magick::Pixels const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Pixels * >(argp1);
  {
    try {
      result = ((Magick::Pixels const *)arg1)->y();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_long(static_cast< long >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PixelData__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Image *arg1 = 0 ;
  std::string arg2 ;
  Magick::StorageType arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  Magick::PixelData *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PixelData__SWIG_0.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PixelData__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PixelData" "', argument " "1"" of type '" "Magick::Image &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PixelData" "', argument " "1"" of type '" "Magick::Image &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(args[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "new_PixelData" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  ecode3 = SWIG_AsVal_int(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_PixelData" "', argument " "3"" of type '" "Magick::StorageType""'");
  } 
  arg3 = static_cast< Magick::StorageType >(val3);
  {
    try {
      result = (Magick::PixelData *)new Magick::PixelData(*arg1,arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PixelData, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PixelData__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Image *arg1 = 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  size_t arg4 ;
  size_t arg5 ;
  std::string arg6 ;
  Magick::StorageType arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  Magick::PixelData *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PixelData__SWIG_1.");
  if(args.Length() != 7) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PixelData__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PixelData" "', argument " "1"" of type '" "Magick::Image &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PixelData" "', argument " "1"" of type '" "Magick::Image &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_PixelData" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_PixelData" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  ecode4 = SWIG_AsVal_size_t(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_PixelData" "', argument " "4"" of type '" "size_t""'");
  } 
  arg4 = static_cast< size_t >(val4);
  ecode5 = SWIG_AsVal_size_t(args[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_PixelData" "', argument " "5"" of type '" "size_t""'");
  } 
  arg5 = static_cast< size_t >(val5);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(args[5], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "new_PixelData" "', argument " "6"" of type '" "std::string""'"); 
    }
    arg6 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  ecode7 = SWIG_AsVal_int(args[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_PixelData" "', argument " "7"" of type '" "Magick::StorageType""'");
  } 
  arg7 = static_cast< Magick::StorageType >(val7);
  {
    try {
      result = (Magick::PixelData *)new Magick::PixelData(*arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PixelData, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PixelData(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_PixelData__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 7) {
    errorHandler.err.Clear();
    _wrap_new_PixelData__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_PixelData");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_PixelData(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::PixelData * arg1 = (Magick::PixelData *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_PixelData_data(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PixelData *arg1 = (Magick::PixelData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PixelData_data.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PixelData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PixelData_data" "', argument " "1"" of type '" "Magick::PixelData const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PixelData * >(argp1);
  {
    try {
      result = (void *)((Magick::PixelData const *)arg1)->data();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PixelData_length(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PixelData *arg1 = (Magick::PixelData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ::ssize_t result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PixelData_length.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PixelData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PixelData_length" "', argument " "1"" of type '" "Magick::PixelData const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PixelData * >(argp1);
  {
    try {
      result = ((Magick::PixelData const *)arg1)->length();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_long(static_cast< long >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PixelData_size(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PixelData *arg1 = (Magick::PixelData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ::ssize_t result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PixelData_size.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PixelData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PixelData_size" "', argument " "1"" of type '" "Magick::PixelData const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PixelData * >(argp1);
  {
    try {
      result = ((Magick::PixelData const *)arg1)->size();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_long(static_cast< long >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits_area__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MagickSizeType arg1 ;
  unsigned long long val1 ;
  int ecode1 = 0 ;
  
  ecode1 = SWIG_AsVal_unsigned_SS_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "ResourceLimits_area" "', argument " "1"" of type '" "Magick::MagickSizeType""'");
  } 
  arg1 = static_cast< Magick::MagickSizeType >(val1);
  {
    try {
      Magick::ResourceLimits::area(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits_area__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MagickSizeType result;
  
  {
    try {
      result = (Magick::MagickSizeType)Magick::ResourceLimits::area();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits__wrap_ResourceLimits_area(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_ResourceLimits_area__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_ResourceLimits_area__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function area.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits_disk__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MagickSizeType arg1 ;
  unsigned long long val1 ;
  int ecode1 = 0 ;
  
  ecode1 = SWIG_AsVal_unsigned_SS_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "ResourceLimits_disk" "', argument " "1"" of type '" "Magick::MagickSizeType""'");
  } 
  arg1 = static_cast< Magick::MagickSizeType >(val1);
  {
    try {
      Magick::ResourceLimits::disk(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits_disk__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MagickSizeType result;
  
  {
    try {
      result = (Magick::MagickSizeType)Magick::ResourceLimits::disk();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits__wrap_ResourceLimits_disk(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_ResourceLimits_disk__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_ResourceLimits_disk__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function disk.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits_file__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MagickSizeType arg1 ;
  unsigned long long val1 ;
  int ecode1 = 0 ;
  
  ecode1 = SWIG_AsVal_unsigned_SS_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "ResourceLimits_file" "', argument " "1"" of type '" "Magick::MagickSizeType""'");
  } 
  arg1 = static_cast< Magick::MagickSizeType >(val1);
  {
    try {
      Magick::ResourceLimits::file(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits_file__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MagickSizeType result;
  
  {
    try {
      result = (Magick::MagickSizeType)Magick::ResourceLimits::file();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits__wrap_ResourceLimits_file(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_ResourceLimits_file__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_ResourceLimits_file__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function file.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits_height__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MagickSizeType arg1 ;
  unsigned long long val1 ;
  int ecode1 = 0 ;
  
  ecode1 = SWIG_AsVal_unsigned_SS_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "ResourceLimits_height" "', argument " "1"" of type '" "Magick::MagickSizeType""'");
  } 
  arg1 = static_cast< Magick::MagickSizeType >(val1);
  {
    try {
      Magick::ResourceLimits::height(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits_height__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MagickSizeType result;
  
  {
    try {
      result = (Magick::MagickSizeType)Magick::ResourceLimits::height();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits__wrap_ResourceLimits_height(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_ResourceLimits_height__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_ResourceLimits_height__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function height.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits_listLength__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MagickSizeType arg1 ;
  unsigned long long val1 ;
  int ecode1 = 0 ;
  
  ecode1 = SWIG_AsVal_unsigned_SS_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "ResourceLimits_listLength" "', argument " "1"" of type '" "Magick::MagickSizeType""'");
  } 
  arg1 = static_cast< Magick::MagickSizeType >(val1);
  {
    try {
      Magick::ResourceLimits::listLength(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits_listLength__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MagickSizeType result;
  
  {
    try {
      result = (Magick::MagickSizeType)Magick::ResourceLimits::listLength();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits__wrap_ResourceLimits_listLength(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_ResourceLimits_listLength__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_ResourceLimits_listLength__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function listLength.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits_map__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MagickSizeType arg1 ;
  unsigned long long val1 ;
  int ecode1 = 0 ;
  
  ecode1 = SWIG_AsVal_unsigned_SS_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "ResourceLimits_map" "', argument " "1"" of type '" "Magick::MagickSizeType""'");
  } 
  arg1 = static_cast< Magick::MagickSizeType >(val1);
  {
    try {
      Magick::ResourceLimits::map(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits_map__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MagickSizeType result;
  
  {
    try {
      result = (Magick::MagickSizeType)Magick::ResourceLimits::map();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits__wrap_ResourceLimits_map(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_ResourceLimits_map__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_ResourceLimits_map__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function map.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits_memory__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MagickSizeType arg1 ;
  unsigned long long val1 ;
  int ecode1 = 0 ;
  
  ecode1 = SWIG_AsVal_unsigned_SS_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "ResourceLimits_memory" "', argument " "1"" of type '" "Magick::MagickSizeType""'");
  } 
  arg1 = static_cast< Magick::MagickSizeType >(val1);
  {
    try {
      Magick::ResourceLimits::memory(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits_memory__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MagickSizeType result;
  
  {
    try {
      result = (Magick::MagickSizeType)Magick::ResourceLimits::memory();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits__wrap_ResourceLimits_memory(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_ResourceLimits_memory__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_ResourceLimits_memory__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function memory.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits_thread__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MagickSizeType arg1 ;
  unsigned long long val1 ;
  int ecode1 = 0 ;
  
  ecode1 = SWIG_AsVal_unsigned_SS_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "ResourceLimits_thread" "', argument " "1"" of type '" "Magick::MagickSizeType""'");
  } 
  arg1 = static_cast< Magick::MagickSizeType >(val1);
  {
    try {
      Magick::ResourceLimits::thread(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits_thread__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MagickSizeType result;
  
  {
    try {
      result = (Magick::MagickSizeType)Magick::ResourceLimits::thread();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits__wrap_ResourceLimits_thread(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_ResourceLimits_thread__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_ResourceLimits_thread__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function thread.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits_throttle__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MagickSizeType arg1 ;
  unsigned long long val1 ;
  int ecode1 = 0 ;
  
  ecode1 = SWIG_AsVal_unsigned_SS_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "ResourceLimits_throttle" "', argument " "1"" of type '" "Magick::MagickSizeType""'");
  } 
  arg1 = static_cast< Magick::MagickSizeType >(val1);
  {
    try {
      Magick::ResourceLimits::throttle(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits_throttle__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MagickSizeType result;
  
  {
    try {
      result = (Magick::MagickSizeType)Magick::ResourceLimits::throttle();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits__wrap_ResourceLimits_throttle(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_ResourceLimits_throttle__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_ResourceLimits_throttle__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function throttle.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits_width__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MagickSizeType arg1 ;
  unsigned long long val1 ;
  int ecode1 = 0 ;
  
  ecode1 = SWIG_AsVal_unsigned_SS_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "ResourceLimits_width" "', argument " "1"" of type '" "Magick::MagickSizeType""'");
  } 
  arg1 = static_cast< Magick::MagickSizeType >(val1);
  {
    try {
      Magick::ResourceLimits::width(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits_width__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MagickSizeType result;
  
  {
    try {
      result = (Magick::MagickSizeType)Magick::ResourceLimits::width();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ResourceLimits__wrap_ResourceLimits_width(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_ResourceLimits_width__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_ResourceLimits_width__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function width.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ResourceLimits(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ResourceLimits * arg1 = (Magick::ResourceLimits *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_veto_ResourceLimits(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIG_exception(SWIG_ERROR, "Class ResourceLimits can not be instantiated");
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_adaptiveBlurImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  Magick::adaptiveBlurImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_adaptiveBlurImage__SWIG_0.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_adaptiveBlurImage__SWIG_0.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_adaptiveBlurImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_adaptiveBlurImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      result = (Magick::adaptiveBlurImage *)new Magick::adaptiveBlurImage(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__adaptiveBlurImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_adaptiveBlurImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::adaptiveBlurImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_adaptiveBlurImage__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_adaptiveBlurImage__SWIG_1.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_adaptiveBlurImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::adaptiveBlurImage *)new Magick::adaptiveBlurImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__adaptiveBlurImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_adaptiveBlurImage__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::adaptiveBlurImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_adaptiveBlurImage__SWIG_2.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_adaptiveBlurImage__SWIG_2.");
  {
    try {
      result = (Magick::adaptiveBlurImage *)new Magick::adaptiveBlurImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__adaptiveBlurImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_adaptiveBlurImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_adaptiveBlurImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_adaptiveBlurImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_adaptiveBlurImage__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_adaptiveBlurImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_adaptiveBlurImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::adaptiveBlurImage *arg1 = (Magick::adaptiveBlurImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_adaptiveBlurImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__adaptiveBlurImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "adaptiveBlurImage_call" "', argument " "1"" of type '" "Magick::adaptiveBlurImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::adaptiveBlurImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "adaptiveBlurImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "adaptiveBlurImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::adaptiveBlurImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_adaptiveBlurImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::adaptiveBlurImage * arg1 = (Magick::adaptiveBlurImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_adaptiveThresholdImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  size_t arg2 ;
  ::ssize_t arg3 ;
  size_t val1 ;
  int ecode1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  Magick::adaptiveThresholdImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_adaptiveThresholdImage__SWIG_0.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_adaptiveThresholdImage__SWIG_0.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_adaptiveThresholdImage" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  ecode2 = SWIG_AsVal_size_t(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_adaptiveThresholdImage" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_adaptiveThresholdImage" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  {
    try {
      result = (Magick::adaptiveThresholdImage *)new Magick::adaptiveThresholdImage(arg1,arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__adaptiveThresholdImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_adaptiveThresholdImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  size_t arg2 ;
  size_t val1 ;
  int ecode1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  Magick::adaptiveThresholdImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_adaptiveThresholdImage__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_adaptiveThresholdImage__SWIG_1.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_adaptiveThresholdImage" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  ecode2 = SWIG_AsVal_size_t(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_adaptiveThresholdImage" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      result = (Magick::adaptiveThresholdImage *)new Magick::adaptiveThresholdImage(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__adaptiveThresholdImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_adaptiveThresholdImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_adaptiveThresholdImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_adaptiveThresholdImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_adaptiveThresholdImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_adaptiveThresholdImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::adaptiveThresholdImage *arg1 = (Magick::adaptiveThresholdImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_adaptiveThresholdImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__adaptiveThresholdImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "adaptiveThresholdImage_call" "', argument " "1"" of type '" "Magick::adaptiveThresholdImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::adaptiveThresholdImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "adaptiveThresholdImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "adaptiveThresholdImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::adaptiveThresholdImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_adaptiveThresholdImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::adaptiveThresholdImage * arg1 = (Magick::adaptiveThresholdImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_addNoiseImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::NoiseType arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  Magick::addNoiseImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_addNoiseImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_addNoiseImage.");
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_addNoiseImage" "', argument " "1"" of type '" "Magick::NoiseType""'");
  } 
  arg1 = static_cast< Magick::NoiseType >(val1);
  {
    try {
      result = (Magick::addNoiseImage *)new Magick::addNoiseImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__addNoiseImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_addNoiseImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::addNoiseImage *arg1 = (Magick::addNoiseImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_addNoiseImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__addNoiseImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "addNoiseImage_call" "', argument " "1"" of type '" "Magick::addNoiseImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::addNoiseImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "addNoiseImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "addNoiseImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::addNoiseImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_addNoiseImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::addNoiseImage * arg1 = (Magick::addNoiseImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_affineTransformImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  DrawableAffine *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::affineTransformImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_affineTransformImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_affineTransformImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_DrawableAffine,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_affineTransformImage" "', argument " "1"" of type '" "DrawableAffine const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_affineTransformImage" "', argument " "1"" of type '" "DrawableAffine const &""'"); 
  }
  arg1 = reinterpret_cast< DrawableAffine * >(argp1);
  {
    try {
      result = (Magick::affineTransformImage *)new Magick::affineTransformImage((DrawableAffine const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__affineTransformImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_affineTransformImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::affineTransformImage *arg1 = (Magick::affineTransformImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_affineTransformImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__affineTransformImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "affineTransformImage_call" "', argument " "1"" of type '" "Magick::affineTransformImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::affineTransformImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "affineTransformImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "affineTransformImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::affineTransformImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_affineTransformImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::affineTransformImage * arg1 = (Magick::affineTransformImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_annotateImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::annotateImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_annotateImage__SWIG_0.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_annotateImage__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_annotateImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_annotateImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_annotateImage" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_annotateImage" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      result = (Magick::annotateImage *)new Magick::annotateImage((std::string const &)*arg1,(Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__annotateImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_annotateImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  Magick::GravityType arg3 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  Magick::annotateImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_annotateImage__SWIG_1.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_annotateImage__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_annotateImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_annotateImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_annotateImage" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_annotateImage" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  ecode3 = SWIG_AsVal_int(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_annotateImage" "', argument " "3"" of type '" "Magick::GravityType""'");
  } 
  arg3 = static_cast< Magick::GravityType >(val3);
  {
    try {
      result = (Magick::annotateImage *)new Magick::annotateImage((std::string const &)*arg1,(Magick::Geometry const &)*arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__annotateImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_annotateImage__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  Magick::GravityType arg3 ;
  double arg4 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  Magick::annotateImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_annotateImage__SWIG_2.");
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_annotateImage__SWIG_2.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_annotateImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_annotateImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_annotateImage" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_annotateImage" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  ecode3 = SWIG_AsVal_int(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_annotateImage" "', argument " "3"" of type '" "Magick::GravityType""'");
  } 
  arg3 = static_cast< Magick::GravityType >(val3);
  ecode4 = SWIG_AsVal_double(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_annotateImage" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    try {
      result = (Magick::annotateImage *)new Magick::annotateImage((std::string const &)*arg1,(Magick::Geometry const &)*arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__annotateImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_annotateImage__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::GravityType arg2 ;
  int res1 = SWIG_OLDOBJ ;
  int val2 ;
  int ecode2 = 0 ;
  Magick::annotateImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_annotateImage__SWIG_3.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_annotateImage__SWIG_3.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_annotateImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_annotateImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_int(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_annotateImage" "', argument " "2"" of type '" "Magick::GravityType""'");
  } 
  arg2 = static_cast< Magick::GravityType >(val2);
  {
    try {
      result = (Magick::annotateImage *)new Magick::annotateImage((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__annotateImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_annotateImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_annotateImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_annotateImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_new_annotateImage__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_annotateImage__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_annotateImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_annotateImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::annotateImage *arg1 = (Magick::annotateImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_annotateImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__annotateImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "annotateImage_call" "', argument " "1"" of type '" "Magick::annotateImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::annotateImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "annotateImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "annotateImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::annotateImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_annotateImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::annotateImage * arg1 = (Magick::annotateImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_blurImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  Magick::blurImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_blurImage__SWIG_0.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_blurImage__SWIG_0.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_blurImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_blurImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      result = (Magick::blurImage *)new Magick::blurImage(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__blurImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_blurImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::blurImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_blurImage__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_blurImage__SWIG_1.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_blurImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::blurImage *)new Magick::blurImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__blurImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_blurImage__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::blurImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_blurImage__SWIG_2.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_blurImage__SWIG_2.");
  {
    try {
      result = (Magick::blurImage *)new Magick::blurImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__blurImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_blurImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_blurImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_blurImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_blurImage__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_blurImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_blurImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::blurImage *arg1 = (Magick::blurImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_blurImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__blurImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "blurImage_call" "', argument " "1"" of type '" "Magick::blurImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::blurImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "blurImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "blurImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::blurImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_blurImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::blurImage * arg1 = (Magick::blurImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_borderImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Geometry *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::borderImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_borderImage__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_borderImage__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_borderImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_borderImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = (Magick::borderImage *)new Magick::borderImage((Magick::Geometry const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__borderImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_borderImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::borderImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_borderImage__SWIG_1.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_borderImage__SWIG_1.");
  {
    try {
      result = (Magick::borderImage *)new Magick::borderImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__borderImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_borderImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_borderImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_borderImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_borderImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_borderImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::borderImage *arg1 = (Magick::borderImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_borderImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__borderImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "borderImage_call" "', argument " "1"" of type '" "Magick::borderImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::borderImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "borderImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "borderImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::borderImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_borderImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::borderImage * arg1 = (Magick::borderImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_channelImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::ChannelType arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  Magick::channelImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_channelImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_channelImage.");
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_channelImage" "', argument " "1"" of type '" "Magick::ChannelType""'");
  } 
  arg1 = static_cast< Magick::ChannelType >(val1);
  {
    try {
      result = (Magick::channelImage *)new Magick::channelImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__channelImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_channelImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::channelImage *arg1 = (Magick::channelImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_channelImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__channelImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "channelImage_call" "', argument " "1"" of type '" "Magick::channelImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::channelImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "channelImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "channelImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::channelImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_channelImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::channelImage * arg1 = (Magick::channelImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_charcoalImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  Magick::charcoalImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_charcoalImage__SWIG_0.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_charcoalImage__SWIG_0.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_charcoalImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_charcoalImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      result = (Magick::charcoalImage *)new Magick::charcoalImage(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__charcoalImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_charcoalImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::charcoalImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_charcoalImage__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_charcoalImage__SWIG_1.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_charcoalImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::charcoalImage *)new Magick::charcoalImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__charcoalImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_charcoalImage__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::charcoalImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_charcoalImage__SWIG_2.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_charcoalImage__SWIG_2.");
  {
    try {
      result = (Magick::charcoalImage *)new Magick::charcoalImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__charcoalImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_charcoalImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_charcoalImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_charcoalImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_charcoalImage__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_charcoalImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_charcoalImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::charcoalImage *arg1 = (Magick::charcoalImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_charcoalImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__charcoalImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "charcoalImage_call" "', argument " "1"" of type '" "Magick::charcoalImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::charcoalImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "charcoalImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "charcoalImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::charcoalImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_charcoalImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::charcoalImage * arg1 = (Magick::charcoalImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_chopImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Geometry *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::chopImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_chopImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_chopImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_chopImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_chopImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = (Magick::chopImage *)new Magick::chopImage((Magick::Geometry const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__chopImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_chopImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::chopImage *arg1 = (Magick::chopImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_chopImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__chopImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "chopImage_call" "', argument " "1"" of type '" "Magick::chopImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::chopImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "chopImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "chopImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::chopImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_chopImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::chopImage * arg1 = (Magick::chopImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_cdlImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::cdlImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_cdlImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_cdlImage.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_cdlImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_cdlImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::cdlImage *)new Magick::cdlImage((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__cdlImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_cdlImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::cdlImage *arg1 = (Magick::cdlImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_cdlImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__cdlImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cdlImage_call" "', argument " "1"" of type '" "Magick::cdlImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::cdlImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cdlImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cdlImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::cdlImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_cdlImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::cdlImage * arg1 = (Magick::cdlImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_colorizeImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  Color *arg4 = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  Magick::colorizeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_colorizeImage__SWIG_0.");
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_colorizeImage__SWIG_0.");
  ecode1 = SWIG_AsVal_unsigned_SS_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_colorizeImage" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_colorizeImage" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_colorizeImage" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  res4 = SWIG_ConvertPtr(args[3], &argp4, SWIGTYPE_p_Color,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_colorizeImage" "', argument " "4"" of type '" "Color const &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_colorizeImage" "', argument " "4"" of type '" "Color const &""'"); 
  }
  arg4 = reinterpret_cast< Color * >(argp4);
  {
    try {
      result = (Magick::colorizeImage *)new Magick::colorizeImage(arg1,arg2,arg3,(Color const &)*arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__colorizeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_colorizeImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  unsigned int arg1 ;
  Color *arg2 = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::colorizeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_colorizeImage__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_colorizeImage__SWIG_1.");
  ecode1 = SWIG_AsVal_unsigned_SS_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_colorizeImage" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_colorizeImage" "', argument " "2"" of type '" "Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_colorizeImage" "', argument " "2"" of type '" "Color const &""'"); 
  }
  arg2 = reinterpret_cast< Color * >(argp2);
  {
    try {
      result = (Magick::colorizeImage *)new Magick::colorizeImage(arg1,(Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__colorizeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_colorizeImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_new_colorizeImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_colorizeImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_colorizeImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_colorizeImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::colorizeImage *arg1 = (Magick::colorizeImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_colorizeImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__colorizeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "colorizeImage_call" "', argument " "1"" of type '" "Magick::colorizeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::colorizeImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "colorizeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "colorizeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::colorizeImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_colorizeImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::colorizeImage * arg1 = (Magick::colorizeImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_colorMatrixImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  double *arg2 = (double *) 0 ;
  size_t val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::colorMatrixImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_colorMatrixImage.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_colorMatrixImage.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_colorMatrixImage" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_colorMatrixImage" "', argument " "2"" of type '" "double const *""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  {
    try {
      result = (Magick::colorMatrixImage *)new Magick::colorMatrixImage(arg1,(double const *)arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__colorMatrixImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_colorMatrixImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::colorMatrixImage *arg1 = (Magick::colorMatrixImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_colorMatrixImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__colorMatrixImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "colorMatrixImage_call" "', argument " "1"" of type '" "Magick::colorMatrixImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::colorMatrixImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "colorMatrixImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "colorMatrixImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::colorMatrixImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_colorMatrixImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::colorMatrixImage * arg1 = (Magick::colorMatrixImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_colorSpaceImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::ColorspaceType arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  Magick::colorSpaceImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_colorSpaceImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_colorSpaceImage.");
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_colorSpaceImage" "', argument " "1"" of type '" "Magick::ColorspaceType""'");
  } 
  arg1 = static_cast< Magick::ColorspaceType >(val1);
  {
    try {
      result = (Magick::colorSpaceImage *)new Magick::colorSpaceImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__colorSpaceImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_colorSpaceImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::colorSpaceImage *arg1 = (Magick::colorSpaceImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_colorSpaceImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__colorSpaceImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "colorSpaceImage_call" "', argument " "1"" of type '" "Magick::colorSpaceImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::colorSpaceImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "colorSpaceImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "colorSpaceImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::colorSpaceImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_colorSpaceImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::colorSpaceImage * arg1 = (Magick::colorSpaceImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_commentImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::commentImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_commentImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_commentImage.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_commentImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_commentImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::commentImage *)new Magick::commentImage((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__commentImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_commentImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::commentImage *arg1 = (Magick::commentImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_commentImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__commentImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "commentImage_call" "', argument " "1"" of type '" "Magick::commentImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::commentImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "commentImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "commentImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::commentImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_commentImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::commentImage * arg1 = (Magick::commentImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_compositeImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Image *arg1 = 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  Magick::CompositeOperator arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  Magick::compositeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_compositeImage__SWIG_0.");
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_compositeImage__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_compositeImage" "', argument " "1"" of type '" "Image const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_compositeImage" "', argument " "1"" of type '" "Image const &""'"); 
  }
  arg1 = reinterpret_cast< Image * >(argp1);
  ecode2 = SWIG_AsVal_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_compositeImage" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_compositeImage" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  ecode4 = SWIG_AsVal_int(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_compositeImage" "', argument " "4"" of type '" "Magick::CompositeOperator""'");
  } 
  arg4 = static_cast< Magick::CompositeOperator >(val4);
  {
    try {
      result = (Magick::compositeImage *)new Magick::compositeImage((Image const &)*arg1,arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__compositeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_compositeImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Image *arg1 = 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  Magick::compositeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_compositeImage__SWIG_1.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_compositeImage__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_compositeImage" "', argument " "1"" of type '" "Image const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_compositeImage" "', argument " "1"" of type '" "Image const &""'"); 
  }
  arg1 = reinterpret_cast< Image * >(argp1);
  ecode2 = SWIG_AsVal_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_compositeImage" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_compositeImage" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  {
    try {
      result = (Magick::compositeImage *)new Magick::compositeImage((Image const &)*arg1,arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__compositeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_compositeImage__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Image *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  Magick::CompositeOperator arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  Magick::compositeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_compositeImage__SWIG_2.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_compositeImage__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_compositeImage" "', argument " "1"" of type '" "Image const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_compositeImage" "', argument " "1"" of type '" "Image const &""'"); 
  }
  arg1 = reinterpret_cast< Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_compositeImage" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_compositeImage" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  ecode3 = SWIG_AsVal_int(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_compositeImage" "', argument " "3"" of type '" "Magick::CompositeOperator""'");
  } 
  arg3 = static_cast< Magick::CompositeOperator >(val3);
  {
    try {
      result = (Magick::compositeImage *)new Magick::compositeImage((Image const &)*arg1,(Magick::Geometry const &)*arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__compositeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_compositeImage__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Image *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::compositeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_compositeImage__SWIG_3.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_compositeImage__SWIG_3.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_compositeImage" "', argument " "1"" of type '" "Image const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_compositeImage" "', argument " "1"" of type '" "Image const &""'"); 
  }
  arg1 = reinterpret_cast< Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_compositeImage" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_compositeImage" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      result = (Magick::compositeImage *)new Magick::compositeImage((Image const &)*arg1,(Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__compositeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_compositeImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_new_compositeImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_compositeImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_compositeImage__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_compositeImage__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_compositeImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_compositeImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::compositeImage *arg1 = (Magick::compositeImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_compositeImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__compositeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "compositeImage_call" "', argument " "1"" of type '" "Magick::compositeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::compositeImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "compositeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "compositeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::compositeImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_compositeImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::compositeImage * arg1 = (Magick::compositeImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_contrastImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  Magick::contrastImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_contrastImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_contrastImage.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_contrastImage" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  {
    try {
      result = (Magick::contrastImage *)new Magick::contrastImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__contrastImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_contrastImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::contrastImage *arg1 = (Magick::contrastImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_contrastImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__contrastImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "contrastImage_call" "', argument " "1"" of type '" "Magick::contrastImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::contrastImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "contrastImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "contrastImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::contrastImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_contrastImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::contrastImage * arg1 = (Magick::contrastImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_cropImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Geometry *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::cropImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_cropImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_cropImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_cropImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_cropImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = (Magick::cropImage *)new Magick::cropImage((Magick::Geometry const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__cropImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_cropImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::cropImage *arg1 = (Magick::cropImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_cropImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__cropImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cropImage_call" "', argument " "1"" of type '" "Magick::cropImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::cropImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cropImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cropImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::cropImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_cropImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::cropImage * arg1 = (Magick::cropImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_cycleColormapImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  ::ssize_t arg1 ;
  long val1 ;
  int ecode1 = 0 ;
  Magick::cycleColormapImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_cycleColormapImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_cycleColormapImage.");
  ecode1 = SWIG_AsVal_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_cycleColormapImage" "', argument " "1"" of type '" "::ssize_t""'");
  } 
  arg1 = static_cast< ::ssize_t >(val1);
  {
    try {
      result = (Magick::cycleColormapImage *)new Magick::cycleColormapImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__cycleColormapImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_cycleColormapImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::cycleColormapImage *arg1 = (Magick::cycleColormapImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_cycleColormapImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__cycleColormapImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cycleColormapImage_call" "', argument " "1"" of type '" "Magick::cycleColormapImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::cycleColormapImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cycleColormapImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cycleColormapImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::cycleColormapImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_cycleColormapImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::cycleColormapImage * arg1 = (Magick::cycleColormapImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_despeckleImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::despeckleImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_despeckleImage.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_despeckleImage.");
  {
    try {
      result = (Magick::despeckleImage *)new Magick::despeckleImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__despeckleImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_despeckleImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::despeckleImage *arg1 = (Magick::despeckleImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_despeckleImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__despeckleImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "despeckleImage_call" "', argument " "1"" of type '" "Magick::despeckleImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::despeckleImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "despeckleImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "despeckleImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::despeckleImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_despeckleImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::despeckleImage * arg1 = (Magick::despeckleImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_distortImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::DistortImageMethod arg1 ;
  size_t arg2 ;
  double *arg3 = (double *) 0 ;
  bool arg4 ;
  int val1 ;
  int ecode1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  Magick::distortImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_distortImage__SWIG_0.");
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_distortImage__SWIG_0.");
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_distortImage" "', argument " "1"" of type '" "Magick::DistortImageMethod""'");
  } 
  arg1 = static_cast< Magick::DistortImageMethod >(val1);
  ecode2 = SWIG_AsVal_size_t(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_distortImage" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_distortImage" "', argument " "3"" of type '" "double const *""'"); 
  }
  arg3 = reinterpret_cast< double * >(argp3);
  ecode4 = SWIG_AsVal_bool(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_distortImage" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      result = (Magick::distortImage *)new Magick::distortImage(arg1,arg2,(double const *)arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__distortImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_distortImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::DistortImageMethod arg1 ;
  size_t arg2 ;
  double *arg3 = (double *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  Magick::distortImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_distortImage__SWIG_1.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_distortImage__SWIG_1.");
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_distortImage" "', argument " "1"" of type '" "Magick::DistortImageMethod""'");
  } 
  arg1 = static_cast< Magick::DistortImageMethod >(val1);
  ecode2 = SWIG_AsVal_size_t(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_distortImage" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_distortImage" "', argument " "3"" of type '" "double const *""'"); 
  }
  arg3 = reinterpret_cast< double * >(argp3);
  {
    try {
      result = (Magick::distortImage *)new Magick::distortImage(arg1,arg2,(double const *)arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__distortImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_distortImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_new_distortImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_distortImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_distortImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_distortImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::distortImage *arg1 = (Magick::distortImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_distortImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__distortImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "distortImage_call" "', argument " "1"" of type '" "Magick::distortImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::distortImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "distortImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "distortImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::distortImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_distortImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::distortImage * arg1 = (Magick::distortImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_drawImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Drawable *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::drawImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_drawImage__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_drawImage__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Drawable,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_drawImage" "', argument " "1"" of type '" "Drawable const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_drawImage" "', argument " "1"" of type '" "Drawable const &""'"); 
  }
  arg1 = reinterpret_cast< Drawable * >(argp1);
  {
    try {
      result = (Magick::drawImage *)new Magick::drawImage((Drawable const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__drawImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_drawImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  DrawableList *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::drawImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_drawImage__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_drawImage__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_DrawableList,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_drawImage" "', argument " "1"" of type '" "DrawableList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_drawImage" "', argument " "1"" of type '" "DrawableList const &""'"); 
  }
  arg1 = reinterpret_cast< DrawableList * >(argp1);
  {
    try {
      result = (Magick::drawImage *)new Magick::drawImage((DrawableList const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__drawImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_drawImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_drawImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_drawImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_drawImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_drawImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::drawImage *arg1 = (Magick::drawImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_drawImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__drawImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "drawImage_call" "', argument " "1"" of type '" "Magick::drawImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::drawImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "drawImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "drawImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::drawImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_drawImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::drawImage * arg1 = (Magick::drawImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_edgeImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::edgeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_edgeImage__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_edgeImage__SWIG_0.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_edgeImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::edgeImage *)new Magick::edgeImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__edgeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_edgeImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::edgeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_edgeImage__SWIG_1.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_edgeImage__SWIG_1.");
  {
    try {
      result = (Magick::edgeImage *)new Magick::edgeImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__edgeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_edgeImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_edgeImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_edgeImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_edgeImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_edgeImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::edgeImage *arg1 = (Magick::edgeImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_edgeImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__edgeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "edgeImage_call" "', argument " "1"" of type '" "Magick::edgeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::edgeImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "edgeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "edgeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::edgeImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_edgeImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::edgeImage * arg1 = (Magick::edgeImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_embossImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::embossImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_embossImage__SWIG_0.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_embossImage__SWIG_0.");
  {
    try {
      result = (Magick::embossImage *)new Magick::embossImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__embossImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_embossImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  Magick::embossImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_embossImage__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_embossImage__SWIG_1.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_embossImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_embossImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      result = (Magick::embossImage *)new Magick::embossImage(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__embossImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_embossImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_embossImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_embossImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_embossImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_embossImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::embossImage *arg1 = (Magick::embossImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_embossImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__embossImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "embossImage_call" "', argument " "1"" of type '" "Magick::embossImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::embossImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "embossImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "embossImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::embossImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_embossImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::embossImage * arg1 = (Magick::embossImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_enhanceImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::enhanceImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_enhanceImage.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_enhanceImage.");
  {
    try {
      result = (Magick::enhanceImage *)new Magick::enhanceImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__enhanceImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_enhanceImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::enhanceImage *arg1 = (Magick::enhanceImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_enhanceImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__enhanceImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "enhanceImage_call" "', argument " "1"" of type '" "Magick::enhanceImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::enhanceImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "enhanceImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "enhanceImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::enhanceImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_enhanceImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::enhanceImage * arg1 = (Magick::enhanceImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_equalizeImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::equalizeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_equalizeImage.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_equalizeImage.");
  {
    try {
      result = (Magick::equalizeImage *)new Magick::equalizeImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__equalizeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_equalizeImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::equalizeImage *arg1 = (Magick::equalizeImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_equalizeImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__equalizeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equalizeImage_call" "', argument " "1"" of type '" "Magick::equalizeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::equalizeImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equalizeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equalizeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::equalizeImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_equalizeImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::equalizeImage * arg1 = (Magick::equalizeImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_fillColorImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Color *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::fillColorImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_fillColorImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_fillColorImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Color,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_fillColorImage" "', argument " "1"" of type '" "Color const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_fillColorImage" "', argument " "1"" of type '" "Color const &""'"); 
  }
  arg1 = reinterpret_cast< Color * >(argp1);
  {
    try {
      result = (Magick::fillColorImage *)new Magick::fillColorImage((Color const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__fillColorImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_fillColorImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::fillColorImage *arg1 = (Magick::fillColorImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_fillColorImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__fillColorImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fillColorImage_call" "', argument " "1"" of type '" "Magick::fillColorImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::fillColorImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "fillColorImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "fillColorImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::fillColorImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_fillColorImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::fillColorImage * arg1 = (Magick::fillColorImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_flipImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::flipImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_flipImage.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_flipImage.");
  {
    try {
      result = (Magick::flipImage *)new Magick::flipImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__flipImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_flipImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::flipImage *arg1 = (Magick::flipImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_flipImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__flipImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "flipImage_call" "', argument " "1"" of type '" "Magick::flipImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::flipImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "flipImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "flipImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::flipImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_flipImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::flipImage * arg1 = (Magick::flipImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_floodFillColorImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  ::ssize_t arg1 ;
  ::ssize_t arg2 ;
  Color *arg3 = 0 ;
  long val1 ;
  int ecode1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  Magick::floodFillColorImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_floodFillColorImage__SWIG_0.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_floodFillColorImage__SWIG_0.");
  ecode1 = SWIG_AsVal_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_floodFillColorImage" "', argument " "1"" of type '" "::ssize_t""'");
  } 
  arg1 = static_cast< ::ssize_t >(val1);
  ecode2 = SWIG_AsVal_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_floodFillColorImage" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3, SWIGTYPE_p_Color,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_floodFillColorImage" "', argument " "3"" of type '" "Color const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_floodFillColorImage" "', argument " "3"" of type '" "Color const &""'"); 
  }
  arg3 = reinterpret_cast< Color * >(argp3);
  {
    try {
      result = (Magick::floodFillColorImage *)new Magick::floodFillColorImage(arg1,arg2,(Color const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__floodFillColorImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_floodFillColorImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Geometry *arg1 = 0 ;
  Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::floodFillColorImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_floodFillColorImage__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_floodFillColorImage__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_floodFillColorImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_floodFillColorImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_floodFillColorImage" "', argument " "2"" of type '" "Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_floodFillColorImage" "', argument " "2"" of type '" "Color const &""'"); 
  }
  arg2 = reinterpret_cast< Color * >(argp2);
  {
    try {
      result = (Magick::floodFillColorImage *)new Magick::floodFillColorImage((Magick::Geometry const &)*arg1,(Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__floodFillColorImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_floodFillColorImage__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  ::ssize_t arg1 ;
  ::ssize_t arg2 ;
  Color *arg3 = 0 ;
  Color *arg4 = 0 ;
  long val1 ;
  int ecode1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  Magick::floodFillColorImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_floodFillColorImage__SWIG_2.");
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_floodFillColorImage__SWIG_2.");
  ecode1 = SWIG_AsVal_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_floodFillColorImage" "', argument " "1"" of type '" "::ssize_t""'");
  } 
  arg1 = static_cast< ::ssize_t >(val1);
  ecode2 = SWIG_AsVal_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_floodFillColorImage" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3, SWIGTYPE_p_Color,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_floodFillColorImage" "', argument " "3"" of type '" "Color const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_floodFillColorImage" "', argument " "3"" of type '" "Color const &""'"); 
  }
  arg3 = reinterpret_cast< Color * >(argp3);
  res4 = SWIG_ConvertPtr(args[3], &argp4, SWIGTYPE_p_Color,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_floodFillColorImage" "', argument " "4"" of type '" "Color const &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_floodFillColorImage" "', argument " "4"" of type '" "Color const &""'"); 
  }
  arg4 = reinterpret_cast< Color * >(argp4);
  {
    try {
      result = (Magick::floodFillColorImage *)new Magick::floodFillColorImage(arg1,arg2,(Color const &)*arg3,(Color const &)*arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__floodFillColorImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_floodFillColorImage__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Geometry *arg1 = 0 ;
  Color *arg2 = 0 ;
  Color *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  Magick::floodFillColorImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_floodFillColorImage__SWIG_3.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_floodFillColorImage__SWIG_3.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_floodFillColorImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_floodFillColorImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_floodFillColorImage" "', argument " "2"" of type '" "Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_floodFillColorImage" "', argument " "2"" of type '" "Color const &""'"); 
  }
  arg2 = reinterpret_cast< Color * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3, SWIGTYPE_p_Color,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_floodFillColorImage" "', argument " "3"" of type '" "Color const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_floodFillColorImage" "', argument " "3"" of type '" "Color const &""'"); 
  }
  arg3 = reinterpret_cast< Color * >(argp3);
  {
    try {
      result = (Magick::floodFillColorImage *)new Magick::floodFillColorImage((Magick::Geometry const &)*arg1,(Color const &)*arg2,(Color const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__floodFillColorImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_floodFillColorImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_floodFillColorImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_floodFillColorImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_new_floodFillColorImage__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_floodFillColorImage__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_floodFillColorImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_floodFillColorImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::floodFillColorImage *arg1 = (Magick::floodFillColorImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_floodFillColorImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__floodFillColorImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "floodFillColorImage_call" "', argument " "1"" of type '" "Magick::floodFillColorImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::floodFillColorImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "floodFillColorImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "floodFillColorImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::floodFillColorImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_floodFillColorImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::floodFillColorImage * arg1 = (Magick::floodFillColorImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_floodFillTextureImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  ::ssize_t arg1 ;
  ::ssize_t arg2 ;
  Image *arg3 = 0 ;
  long val1 ;
  int ecode1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  Magick::floodFillTextureImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_floodFillTextureImage__SWIG_0.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_floodFillTextureImage__SWIG_0.");
  ecode1 = SWIG_AsVal_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_floodFillTextureImage" "', argument " "1"" of type '" "::ssize_t""'");
  } 
  arg1 = static_cast< ::ssize_t >(val1);
  ecode2 = SWIG_AsVal_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_floodFillTextureImage" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_floodFillTextureImage" "', argument " "3"" of type '" "Image const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_floodFillTextureImage" "', argument " "3"" of type '" "Image const &""'"); 
  }
  arg3 = reinterpret_cast< Image * >(argp3);
  {
    try {
      result = (Magick::floodFillTextureImage *)new Magick::floodFillTextureImage(arg1,arg2,(Image const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__floodFillTextureImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_floodFillTextureImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Geometry *arg1 = 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::floodFillTextureImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_floodFillTextureImage__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_floodFillTextureImage__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_floodFillTextureImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_floodFillTextureImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_floodFillTextureImage" "', argument " "2"" of type '" "Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_floodFillTextureImage" "', argument " "2"" of type '" "Image const &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      result = (Magick::floodFillTextureImage *)new Magick::floodFillTextureImage((Magick::Geometry const &)*arg1,(Image const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__floodFillTextureImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_floodFillTextureImage__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  ::ssize_t arg1 ;
  ::ssize_t arg2 ;
  Image *arg3 = 0 ;
  Color *arg4 = 0 ;
  long val1 ;
  int ecode1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  Magick::floodFillTextureImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_floodFillTextureImage__SWIG_2.");
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_floodFillTextureImage__SWIG_2.");
  ecode1 = SWIG_AsVal_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_floodFillTextureImage" "', argument " "1"" of type '" "::ssize_t""'");
  } 
  arg1 = static_cast< ::ssize_t >(val1);
  ecode2 = SWIG_AsVal_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_floodFillTextureImage" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_floodFillTextureImage" "', argument " "3"" of type '" "Image const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_floodFillTextureImage" "', argument " "3"" of type '" "Image const &""'"); 
  }
  arg3 = reinterpret_cast< Image * >(argp3);
  res4 = SWIG_ConvertPtr(args[3], &argp4, SWIGTYPE_p_Color,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_floodFillTextureImage" "', argument " "4"" of type '" "Color const &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_floodFillTextureImage" "', argument " "4"" of type '" "Color const &""'"); 
  }
  arg4 = reinterpret_cast< Color * >(argp4);
  {
    try {
      result = (Magick::floodFillTextureImage *)new Magick::floodFillTextureImage(arg1,arg2,(Image const &)*arg3,(Color const &)*arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__floodFillTextureImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_floodFillTextureImage__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Geometry *arg1 = 0 ;
  Image *arg2 = 0 ;
  Color *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  Magick::floodFillTextureImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_floodFillTextureImage__SWIG_3.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_floodFillTextureImage__SWIG_3.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_floodFillTextureImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_floodFillTextureImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_floodFillTextureImage" "', argument " "2"" of type '" "Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_floodFillTextureImage" "', argument " "2"" of type '" "Image const &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3, SWIGTYPE_p_Color,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_floodFillTextureImage" "', argument " "3"" of type '" "Color const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_floodFillTextureImage" "', argument " "3"" of type '" "Color const &""'"); 
  }
  arg3 = reinterpret_cast< Color * >(argp3);
  {
    try {
      result = (Magick::floodFillTextureImage *)new Magick::floodFillTextureImage((Magick::Geometry const &)*arg1,(Image const &)*arg2,(Color const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__floodFillTextureImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_floodFillTextureImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_floodFillTextureImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_floodFillTextureImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_new_floodFillTextureImage__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_floodFillTextureImage__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_floodFillTextureImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_floodFillTextureImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::floodFillTextureImage *arg1 = (Magick::floodFillTextureImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_floodFillTextureImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__floodFillTextureImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "floodFillTextureImage_call" "', argument " "1"" of type '" "Magick::floodFillTextureImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::floodFillTextureImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "floodFillTextureImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "floodFillTextureImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::floodFillTextureImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_floodFillTextureImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::floodFillTextureImage * arg1 = (Magick::floodFillTextureImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_flopImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::flopImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_flopImage.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_flopImage.");
  {
    try {
      result = (Magick::flopImage *)new Magick::flopImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__flopImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_flopImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::flopImage *arg1 = (Magick::flopImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_flopImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__flopImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "flopImage_call" "', argument " "1"" of type '" "Magick::flopImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::flopImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "flopImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "flopImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::flopImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_flopImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::flopImage * arg1 = (Magick::flopImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_frameImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Geometry *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::frameImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_frameImage__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_frameImage__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_frameImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_frameImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = (Magick::frameImage *)new Magick::frameImage((Magick::Geometry const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__frameImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_frameImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::frameImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_frameImage__SWIG_1.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_frameImage__SWIG_1.");
  {
    try {
      result = (Magick::frameImage *)new Magick::frameImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__frameImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_frameImage__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  size_t arg2 ;
  ::ssize_t arg3 ;
  ::ssize_t arg4 ;
  size_t val1 ;
  int ecode1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  Magick::frameImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_frameImage__SWIG_2.");
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_frameImage__SWIG_2.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_frameImage" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  ecode2 = SWIG_AsVal_size_t(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_frameImage" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_frameImage" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  ecode4 = SWIG_AsVal_long(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_frameImage" "', argument " "4"" of type '" "::ssize_t""'");
  } 
  arg4 = static_cast< ::ssize_t >(val4);
  {
    try {
      result = (Magick::frameImage *)new Magick::frameImage(arg1,arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__frameImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_frameImage__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  size_t arg2 ;
  ::ssize_t arg3 ;
  size_t val1 ;
  int ecode1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  Magick::frameImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_frameImage__SWIG_3.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_frameImage__SWIG_3.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_frameImage" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  ecode2 = SWIG_AsVal_size_t(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_frameImage" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_frameImage" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  {
    try {
      result = (Magick::frameImage *)new Magick::frameImage(arg1,arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__frameImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_frameImage__SWIG_4(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  size_t arg2 ;
  size_t val1 ;
  int ecode1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  Magick::frameImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_frameImage__SWIG_4.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_frameImage__SWIG_4.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_frameImage" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  ecode2 = SWIG_AsVal_size_t(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_frameImage" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      result = (Magick::frameImage *)new Magick::frameImage(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__frameImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_frameImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_frameImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_frameImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_new_frameImage__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_frameImage__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_frameImage__SWIG_4(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_frameImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_frameImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::frameImage *arg1 = (Magick::frameImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_frameImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__frameImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "frameImage_call" "', argument " "1"" of type '" "Magick::frameImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::frameImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "frameImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "frameImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::frameImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_frameImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::frameImage * arg1 = (Magick::frameImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_gammaImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::gammaImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_gammaImage__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_gammaImage__SWIG_0.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_gammaImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::gammaImage *)new Magick::gammaImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__gammaImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_gammaImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  Magick::gammaImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_gammaImage__SWIG_1.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_gammaImage__SWIG_1.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_gammaImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_gammaImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_gammaImage" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      result = (Magick::gammaImage *)new Magick::gammaImage(arg1,arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__gammaImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_gammaImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_gammaImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_gammaImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_gammaImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_gammaImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::gammaImage *arg1 = (Magick::gammaImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_gammaImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__gammaImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gammaImage_call" "', argument " "1"" of type '" "Magick::gammaImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::gammaImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gammaImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gammaImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::gammaImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_gammaImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::gammaImage * arg1 = (Magick::gammaImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_gaussianBlurImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  Magick::gaussianBlurImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_gaussianBlurImage.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_gaussianBlurImage.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_gaussianBlurImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_gaussianBlurImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      result = (Magick::gaussianBlurImage *)new Magick::gaussianBlurImage(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__gaussianBlurImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_gaussianBlurImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::gaussianBlurImage *arg1 = (Magick::gaussianBlurImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_gaussianBlurImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__gaussianBlurImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gaussianBlurImage_call" "', argument " "1"" of type '" "Magick::gaussianBlurImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::gaussianBlurImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gaussianBlurImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gaussianBlurImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::gaussianBlurImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_gaussianBlurImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::gaussianBlurImage * arg1 = (Magick::gaussianBlurImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_haldClutImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Image *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::haldClutImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_haldClutImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_haldClutImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_haldClutImage" "', argument " "1"" of type '" "Image const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_haldClutImage" "', argument " "1"" of type '" "Image const &""'"); 
  }
  arg1 = reinterpret_cast< Image * >(argp1);
  {
    try {
      result = (Magick::haldClutImage *)new Magick::haldClutImage((Image const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__haldClutImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_haldClutImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::haldClutImage *arg1 = (Magick::haldClutImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_haldClutImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__haldClutImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "haldClutImage_call" "', argument " "1"" of type '" "Magick::haldClutImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::haldClutImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "haldClutImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "haldClutImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::haldClutImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_haldClutImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::haldClutImage * arg1 = (Magick::haldClutImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_implodeImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::implodeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_implodeImage__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_implodeImage__SWIG_0.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_implodeImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::implodeImage *)new Magick::implodeImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__implodeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_implodeImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::implodeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_implodeImage__SWIG_1.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_implodeImage__SWIG_1.");
  {
    try {
      result = (Magick::implodeImage *)new Magick::implodeImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__implodeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_implodeImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_implodeImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_implodeImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_implodeImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_implodeImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::implodeImage *arg1 = (Magick::implodeImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_implodeImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__implodeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "implodeImage_call" "', argument " "1"" of type '" "Magick::implodeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::implodeImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "implodeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "implodeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::implodeImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_implodeImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::implodeImage * arg1 = (Magick::implodeImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_inverseFourierTransformImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Image *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::inverseFourierTransformImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_inverseFourierTransformImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_inverseFourierTransformImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_inverseFourierTransformImage" "', argument " "1"" of type '" "Image const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_inverseFourierTransformImage" "', argument " "1"" of type '" "Image const &""'"); 
  }
  arg1 = reinterpret_cast< Image * >(argp1);
  {
    try {
      result = (Magick::inverseFourierTransformImage *)new Magick::inverseFourierTransformImage((Image const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__inverseFourierTransformImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_inverseFourierTransformImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::inverseFourierTransformImage *arg1 = (Magick::inverseFourierTransformImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_inverseFourierTransformImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__inverseFourierTransformImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "inverseFourierTransformImage_call" "', argument " "1"" of type '" "Magick::inverseFourierTransformImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::inverseFourierTransformImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "inverseFourierTransformImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "inverseFourierTransformImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::inverseFourierTransformImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_inverseFourierTransformImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::inverseFourierTransformImage * arg1 = (Magick::inverseFourierTransformImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_isValidImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  Magick::isValidImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_isValidImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_isValidImage.");
  ecode1 = SWIG_AsVal_bool(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_isValidImage" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      result = (Magick::isValidImage *)new Magick::isValidImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__isValidImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_isValidImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::isValidImage *arg1 = (Magick::isValidImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_isValidImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__isValidImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "isValidImage_call" "', argument " "1"" of type '" "Magick::isValidImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::isValidImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "isValidImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "isValidImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::isValidImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_isValidImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::isValidImage * arg1 = (Magick::isValidImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_labelImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::labelImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_labelImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_labelImage.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_labelImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_labelImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::labelImage *)new Magick::labelImage((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__labelImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_labelImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::labelImage *arg1 = (Magick::labelImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_labelImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__labelImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "labelImage_call" "', argument " "1"" of type '" "Magick::labelImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::labelImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "labelImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "labelImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::labelImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_labelImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::labelImage * arg1 = (Magick::labelImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_levelImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  Magick::levelImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_levelImage__SWIG_0.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_levelImage__SWIG_0.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_levelImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_levelImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_levelImage" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      result = (Magick::levelImage *)new Magick::levelImage(arg1,arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__levelImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_levelImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  Magick::levelImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_levelImage__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_levelImage__SWIG_1.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_levelImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_levelImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      result = (Magick::levelImage *)new Magick::levelImage(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__levelImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_levelImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_levelImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_levelImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_levelImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_levelImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::levelImage *arg1 = (Magick::levelImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_levelImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__levelImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "levelImage_call" "', argument " "1"" of type '" "Magick::levelImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::levelImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "levelImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "levelImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::levelImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_levelImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::levelImage * arg1 = (Magick::levelImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_levelChannelImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::ChannelType arg1 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  int val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  Magick::levelChannelImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_levelChannelImage__SWIG_0.");
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_levelChannelImage__SWIG_0.");
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_levelChannelImage" "', argument " "1"" of type '" "Magick::ChannelType""'");
  } 
  arg1 = static_cast< Magick::ChannelType >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_levelChannelImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_levelChannelImage" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_levelChannelImage" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    try {
      result = (Magick::levelChannelImage *)new Magick::levelChannelImage(arg1,arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__levelChannelImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_levelChannelImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::ChannelType arg1 ;
  double arg2 ;
  double arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  Magick::levelChannelImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_levelChannelImage__SWIG_1.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_levelChannelImage__SWIG_1.");
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_levelChannelImage" "', argument " "1"" of type '" "Magick::ChannelType""'");
  } 
  arg1 = static_cast< Magick::ChannelType >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_levelChannelImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_levelChannelImage" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      result = (Magick::levelChannelImage *)new Magick::levelChannelImage(arg1,arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__levelChannelImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_levelChannelImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_new_levelChannelImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_levelChannelImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_levelChannelImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_levelChannelImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::levelChannelImage *arg1 = (Magick::levelChannelImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_levelChannelImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__levelChannelImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "levelChannelImage_call" "', argument " "1"" of type '" "Magick::levelChannelImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::levelChannelImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "levelChannelImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "levelChannelImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::levelChannelImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_levelChannelImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::levelChannelImage * arg1 = (Magick::levelChannelImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_magnifyImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::magnifyImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_magnifyImage.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_magnifyImage.");
  {
    try {
      result = (Magick::magnifyImage *)new Magick::magnifyImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__magnifyImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_magnifyImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::magnifyImage *arg1 = (Magick::magnifyImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_magnifyImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__magnifyImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "magnifyImage_call" "', argument " "1"" of type '" "Magick::magnifyImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::magnifyImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "magnifyImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "magnifyImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::magnifyImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_magnifyImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::magnifyImage * arg1 = (Magick::magnifyImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_mapImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Image *arg1 = 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  Magick::mapImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_mapImage__SWIG_0.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_mapImage__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_mapImage" "', argument " "1"" of type '" "Image const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_mapImage" "', argument " "1"" of type '" "Image const &""'"); 
  }
  arg1 = reinterpret_cast< Image * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_mapImage" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      result = (Magick::mapImage *)new Magick::mapImage((Image const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__mapImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_mapImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Image *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::mapImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_mapImage__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_mapImage__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_mapImage" "', argument " "1"" of type '" "Image const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_mapImage" "', argument " "1"" of type '" "Image const &""'"); 
  }
  arg1 = reinterpret_cast< Image * >(argp1);
  {
    try {
      result = (Magick::mapImage *)new Magick::mapImage((Image const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__mapImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_mapImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_mapImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_mapImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_mapImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_mapImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::mapImage *arg1 = (Magick::mapImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_mapImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__mapImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mapImage_call" "', argument " "1"" of type '" "Magick::mapImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::mapImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mapImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "mapImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::mapImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_mapImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::mapImage * arg1 = (Magick::mapImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_matteFloodfillImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Color *arg1 = 0 ;
  unsigned int arg2 ;
  ::ssize_t arg3 ;
  ::ssize_t arg4 ;
  Magick::PaintMethod arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  Magick::matteFloodfillImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_matteFloodfillImage.");
  if(args.Length() != 5) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_matteFloodfillImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Color,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_matteFloodfillImage" "', argument " "1"" of type '" "Color const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_matteFloodfillImage" "', argument " "1"" of type '" "Color const &""'"); 
  }
  arg1 = reinterpret_cast< Color * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_matteFloodfillImage" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_matteFloodfillImage" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  ecode4 = SWIG_AsVal_long(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_matteFloodfillImage" "', argument " "4"" of type '" "::ssize_t""'");
  } 
  arg4 = static_cast< ::ssize_t >(val4);
  ecode5 = SWIG_AsVal_int(args[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_matteFloodfillImage" "', argument " "5"" of type '" "Magick::PaintMethod""'");
  } 
  arg5 = static_cast< Magick::PaintMethod >(val5);
  {
    try {
      result = (Magick::matteFloodfillImage *)new Magick::matteFloodfillImage((Color const &)*arg1,arg2,arg3,arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__matteFloodfillImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_matteFloodfillImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::matteFloodfillImage *arg1 = (Magick::matteFloodfillImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_matteFloodfillImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__matteFloodfillImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "matteFloodfillImage_call" "', argument " "1"" of type '" "Magick::matteFloodfillImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::matteFloodfillImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "matteFloodfillImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "matteFloodfillImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::matteFloodfillImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_matteFloodfillImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::matteFloodfillImage * arg1 = (Magick::matteFloodfillImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_medianFilterImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::medianFilterImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_medianFilterImage__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_medianFilterImage__SWIG_0.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_medianFilterImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::medianFilterImage *)new Magick::medianFilterImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__medianFilterImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_medianFilterImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::medianFilterImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_medianFilterImage__SWIG_1.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_medianFilterImage__SWIG_1.");
  {
    try {
      result = (Magick::medianFilterImage *)new Magick::medianFilterImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__medianFilterImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_medianFilterImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_medianFilterImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_medianFilterImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_medianFilterImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_medianFilterImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::medianFilterImage *arg1 = (Magick::medianFilterImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_medianFilterImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__medianFilterImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "medianFilterImage_call" "', argument " "1"" of type '" "Magick::medianFilterImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::medianFilterImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "medianFilterImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "medianFilterImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::medianFilterImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_medianFilterImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::medianFilterImage * arg1 = (Magick::medianFilterImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_mergeLayersImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::ImageLayerMethod arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  Magick::mergeLayersImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_mergeLayersImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_mergeLayersImage.");
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_mergeLayersImage" "', argument " "1"" of type '" "Magick::ImageLayerMethod""'");
  } 
  arg1 = static_cast< Magick::ImageLayerMethod >(val1);
  {
    try {
      result = (Magick::mergeLayersImage *)new Magick::mergeLayersImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__mergeLayersImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_mergeLayersImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::mergeLayersImage *arg1 = (Magick::mergeLayersImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_mergeLayersImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__mergeLayersImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "mergeLayersImage_call" "', argument " "1"" of type '" "Magick::mergeLayersImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::mergeLayersImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "mergeLayersImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "mergeLayersImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::mergeLayersImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_mergeLayersImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::mergeLayersImage * arg1 = (Magick::mergeLayersImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_minifyImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::minifyImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_minifyImage.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_minifyImage.");
  {
    try {
      result = (Magick::minifyImage *)new Magick::minifyImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__minifyImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_minifyImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::minifyImage *arg1 = (Magick::minifyImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_minifyImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__minifyImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "minifyImage_call" "', argument " "1"" of type '" "Magick::minifyImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::minifyImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "minifyImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "minifyImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::minifyImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_minifyImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::minifyImage * arg1 = (Magick::minifyImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_modulateImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  Magick::modulateImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_modulateImage.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_modulateImage.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_modulateImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_modulateImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_modulateImage" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      result = (Magick::modulateImage *)new Magick::modulateImage(arg1,arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__modulateImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_modulateImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::modulateImage *arg1 = (Magick::modulateImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_modulateImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__modulateImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "modulateImage_call" "', argument " "1"" of type '" "Magick::modulateImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::modulateImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "modulateImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "modulateImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::modulateImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_modulateImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::modulateImage * arg1 = (Magick::modulateImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_negateImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  Magick::negateImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_negateImage__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_negateImage__SWIG_0.");
  ecode1 = SWIG_AsVal_bool(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_negateImage" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      result = (Magick::negateImage *)new Magick::negateImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__negateImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_negateImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::negateImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_negateImage__SWIG_1.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_negateImage__SWIG_1.");
  {
    try {
      result = (Magick::negateImage *)new Magick::negateImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__negateImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_negateImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_negateImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_negateImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_negateImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_negateImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::negateImage *arg1 = (Magick::negateImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_negateImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__negateImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "negateImage_call" "', argument " "1"" of type '" "Magick::negateImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::negateImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "negateImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "negateImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::negateImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_negateImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::negateImage * arg1 = (Magick::negateImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_normalizeImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::normalizeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_normalizeImage.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_normalizeImage.");
  {
    try {
      result = (Magick::normalizeImage *)new Magick::normalizeImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__normalizeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_normalizeImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::normalizeImage *arg1 = (Magick::normalizeImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_normalizeImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__normalizeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "normalizeImage_call" "', argument " "1"" of type '" "Magick::normalizeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::normalizeImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "normalizeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "normalizeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::normalizeImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_normalizeImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::normalizeImage * arg1 = (Magick::normalizeImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_oilPaintImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::oilPaintImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_oilPaintImage__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_oilPaintImage__SWIG_0.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_oilPaintImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::oilPaintImage *)new Magick::oilPaintImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__oilPaintImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_oilPaintImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::oilPaintImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_oilPaintImage__SWIG_1.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_oilPaintImage__SWIG_1.");
  {
    try {
      result = (Magick::oilPaintImage *)new Magick::oilPaintImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__oilPaintImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_oilPaintImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_oilPaintImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_oilPaintImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_oilPaintImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_oilPaintImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::oilPaintImage *arg1 = (Magick::oilPaintImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_oilPaintImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__oilPaintImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "oilPaintImage_call" "', argument " "1"" of type '" "Magick::oilPaintImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::oilPaintImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "oilPaintImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "oilPaintImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::oilPaintImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_oilPaintImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::oilPaintImage * arg1 = (Magick::oilPaintImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_opacityImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  Magick::opacityImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_opacityImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_opacityImage.");
  ecode1 = SWIG_AsVal_unsigned_SS_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_opacityImage" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  {
    try {
      result = (Magick::opacityImage *)new Magick::opacityImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__opacityImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_opacityImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::opacityImage *arg1 = (Magick::opacityImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_opacityImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__opacityImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "opacityImage_call" "', argument " "1"" of type '" "Magick::opacityImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::opacityImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "opacityImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "opacityImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::opacityImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_opacityImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::opacityImage * arg1 = (Magick::opacityImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_opaqueImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Color *arg1 = 0 ;
  Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::opaqueImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_opaqueImage.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_opaqueImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Color,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_opaqueImage" "', argument " "1"" of type '" "Color const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_opaqueImage" "', argument " "1"" of type '" "Color const &""'"); 
  }
  arg1 = reinterpret_cast< Color * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_opaqueImage" "', argument " "2"" of type '" "Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_opaqueImage" "', argument " "2"" of type '" "Color const &""'"); 
  }
  arg2 = reinterpret_cast< Color * >(argp2);
  {
    try {
      result = (Magick::opaqueImage *)new Magick::opaqueImage((Color const &)*arg1,(Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__opaqueImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_opaqueImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::opaqueImage *arg1 = (Magick::opaqueImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_opaqueImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__opaqueImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "opaqueImage_call" "', argument " "1"" of type '" "Magick::opaqueImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::opaqueImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "opaqueImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "opaqueImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::opaqueImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_opaqueImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::opaqueImage * arg1 = (Magick::opaqueImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_quantizeImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  Magick::quantizeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_quantizeImage__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_quantizeImage__SWIG_0.");
  ecode1 = SWIG_AsVal_bool(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_quantizeImage" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      result = (Magick::quantizeImage *)new Magick::quantizeImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__quantizeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_quantizeImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::quantizeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_quantizeImage__SWIG_1.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_quantizeImage__SWIG_1.");
  {
    try {
      result = (Magick::quantizeImage *)new Magick::quantizeImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__quantizeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_quantizeImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_quantizeImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_quantizeImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_quantizeImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_quantizeImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::quantizeImage *arg1 = (Magick::quantizeImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_quantizeImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__quantizeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "quantizeImage_call" "', argument " "1"" of type '" "Magick::quantizeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::quantizeImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "quantizeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "quantizeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::quantizeImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_quantizeImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::quantizeImage * arg1 = (Magick::quantizeImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_raiseImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Geometry *arg1 = 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  Magick::raiseImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_raiseImage__SWIG_0.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_raiseImage__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_raiseImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_raiseImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_raiseImage" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      result = (Magick::raiseImage *)new Magick::raiseImage((Magick::Geometry const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__raiseImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_raiseImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Geometry *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::raiseImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_raiseImage__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_raiseImage__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_raiseImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_raiseImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = (Magick::raiseImage *)new Magick::raiseImage((Magick::Geometry const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__raiseImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_raiseImage__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::raiseImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_raiseImage__SWIG_2.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_raiseImage__SWIG_2.");
  {
    try {
      result = (Magick::raiseImage *)new Magick::raiseImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__raiseImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_raiseImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_raiseImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_raiseImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_raiseImage__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_raiseImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_raiseImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::raiseImage *arg1 = (Magick::raiseImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_raiseImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__raiseImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "raiseImage_call" "', argument " "1"" of type '" "Magick::raiseImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::raiseImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "raiseImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "raiseImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::raiseImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_raiseImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::raiseImage * arg1 = (Magick::raiseImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_ReadOptions__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::ReadOptions *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ReadOptions__SWIG_0.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ReadOptions__SWIG_0.");
  {
    try {
      result = (Magick::ReadOptions *)new Magick::ReadOptions();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ReadOptions, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ReadOptions__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::ReadOptions *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::ReadOptions *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ReadOptions__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ReadOptions__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__ReadOptions,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ReadOptions" "', argument " "1"" of type '" "Magick::ReadOptions const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ReadOptions" "', argument " "1"" of type '" "Magick::ReadOptions const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::ReadOptions * >(argp1);
  {
    try {
      result = (Magick::ReadOptions *)new Magick::ReadOptions((Magick::ReadOptions const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ReadOptions, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ReadOptions(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_ReadOptions__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ReadOptions__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ReadOptions");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ReadOptions(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ReadOptions * arg1 = (Magick::ReadOptions *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_ReadOptions_density__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ReadOptions *arg1 = (Magick::ReadOptions *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ReadOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReadOptions_density" "', argument " "1"" of type '" "Magick::ReadOptions *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ReadOptions * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ReadOptions_density" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ReadOptions_density" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->density((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ReadOptions_density__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ReadOptions *arg1 = (Magick::ReadOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Geometry result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ReadOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReadOptions_density" "', argument " "1"" of type '" "Magick::ReadOptions const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ReadOptions * >(argp1);
  {
    try {
      result = ((Magick::ReadOptions const *)arg1)->density();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Geometry(result)), SWIGTYPE_p_Magick__Geometry, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ReadOptions__wrap_ReadOptions_density(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_ReadOptions_density__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_ReadOptions_density__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function density.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ReadOptions_depth__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ReadOptions *arg1 = (Magick::ReadOptions *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ReadOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReadOptions_depth" "', argument " "1"" of type '" "Magick::ReadOptions *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ReadOptions * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ReadOptions_depth" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      (arg1)->depth(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ReadOptions_depth__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ReadOptions *arg1 = (Magick::ReadOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ReadOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReadOptions_depth" "', argument " "1"" of type '" "Magick::ReadOptions const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ReadOptions * >(argp1);
  {
    try {
      result = ((Magick::ReadOptions const *)arg1)->depth();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ReadOptions__wrap_ReadOptions_depth(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_ReadOptions_depth__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_ReadOptions_depth__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function depth.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ReadOptions_quiet__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ReadOptions *arg1 = (Magick::ReadOptions *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ReadOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReadOptions_quiet" "', argument " "1"" of type '" "Magick::ReadOptions *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ReadOptions * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ReadOptions_quiet" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->quiet(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ReadOptions_quiet__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ReadOptions *arg1 = (Magick::ReadOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ReadOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReadOptions_quiet" "', argument " "1"" of type '" "Magick::ReadOptions const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ReadOptions * >(argp1);
  {
    try {
      result = (bool)((Magick::ReadOptions const *)arg1)->quiet();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ReadOptions__wrap_ReadOptions_quiet(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_ReadOptions_quiet__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_ReadOptions_quiet__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function quiet.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ReadOptions_size__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ReadOptions *arg1 = (Magick::ReadOptions *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ReadOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReadOptions_size" "', argument " "1"" of type '" "Magick::ReadOptions *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ReadOptions * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ReadOptions_size" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ReadOptions_size" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->size((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ReadOptions_size__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ReadOptions *arg1 = (Magick::ReadOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Geometry result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ReadOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReadOptions_size" "', argument " "1"" of type '" "Magick::ReadOptions const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ReadOptions * >(argp1);
  {
    try {
      result = ((Magick::ReadOptions const *)arg1)->size();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Geometry(result)), SWIGTYPE_p_Magick__Geometry, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ReadOptions__wrap_ReadOptions_size(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_ReadOptions_size__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_ReadOptions_size__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function size.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ReadOptions_imageInfo(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ReadOptions *arg1 = (Magick::ReadOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  MagickCore::ImageInfo *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_ReadOptions_imageInfo.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ReadOptions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReadOptions_imageInfo" "', argument " "1"" of type '" "Magick::ReadOptions *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ReadOptions * >(argp1);
  {
    try {
      result = (MagickCore::ImageInfo *)(arg1)->imageInfo();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_MagickCore___ImageInfo, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_reduceNoiseImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::reduceNoiseImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_reduceNoiseImage__SWIG_0.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_reduceNoiseImage__SWIG_0.");
  {
    try {
      result = (Magick::reduceNoiseImage *)new Magick::reduceNoiseImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__reduceNoiseImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_reduceNoiseImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  Magick::reduceNoiseImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_reduceNoiseImage__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_reduceNoiseImage__SWIG_1.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_reduceNoiseImage" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  {
    try {
      result = (Magick::reduceNoiseImage *)new Magick::reduceNoiseImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__reduceNoiseImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_reduceNoiseImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_reduceNoiseImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_reduceNoiseImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_reduceNoiseImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_reduceNoiseImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::reduceNoiseImage *arg1 = (Magick::reduceNoiseImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_reduceNoiseImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__reduceNoiseImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "reduceNoiseImage_call" "', argument " "1"" of type '" "Magick::reduceNoiseImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::reduceNoiseImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "reduceNoiseImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "reduceNoiseImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::reduceNoiseImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_reduceNoiseImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::reduceNoiseImage * arg1 = (Magick::reduceNoiseImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_resizeImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Geometry *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::resizeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_resizeImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_resizeImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_resizeImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_resizeImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = (Magick::resizeImage *)new Magick::resizeImage((Magick::Geometry const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__resizeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_resizeImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::resizeImage *arg1 = (Magick::resizeImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_resizeImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__resizeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "resizeImage_call" "', argument " "1"" of type '" "Magick::resizeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::resizeImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "resizeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "resizeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::resizeImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_resizeImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::resizeImage * arg1 = (Magick::resizeImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_rollImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Geometry *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::rollImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_rollImage__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_rollImage__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_rollImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_rollImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = (Magick::rollImage *)new Magick::rollImage((Magick::Geometry const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__rollImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_rollImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  ::ssize_t arg1 ;
  ::ssize_t arg2 ;
  long val1 ;
  int ecode1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  Magick::rollImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_rollImage__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_rollImage__SWIG_1.");
  ecode1 = SWIG_AsVal_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_rollImage" "', argument " "1"" of type '" "::ssize_t""'");
  } 
  arg1 = static_cast< ::ssize_t >(val1);
  ecode2 = SWIG_AsVal_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_rollImage" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  {
    try {
      result = (Magick::rollImage *)new Magick::rollImage(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__rollImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_rollImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_rollImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_rollImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_rollImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_rollImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::rollImage *arg1 = (Magick::rollImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_rollImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__rollImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "rollImage_call" "', argument " "1"" of type '" "Magick::rollImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::rollImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "rollImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "rollImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::rollImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_rollImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::rollImage * arg1 = (Magick::rollImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_rotateImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::rotateImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_rotateImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_rotateImage.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_rotateImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::rotateImage *)new Magick::rotateImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__rotateImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_rotateImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::rotateImage *arg1 = (Magick::rotateImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_rotateImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__rotateImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "rotateImage_call" "', argument " "1"" of type '" "Magick::rotateImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::rotateImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "rotateImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "rotateImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::rotateImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_rotateImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::rotateImage * arg1 = (Magick::rotateImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_sampleImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Geometry *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::sampleImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_sampleImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_sampleImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_sampleImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_sampleImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = (Magick::sampleImage *)new Magick::sampleImage((Magick::Geometry const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__sampleImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_sampleImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::sampleImage *arg1 = (Magick::sampleImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_sampleImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__sampleImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "sampleImage_call" "', argument " "1"" of type '" "Magick::sampleImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::sampleImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "sampleImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "sampleImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::sampleImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_sampleImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::sampleImage * arg1 = (Magick::sampleImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_scaleImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Geometry *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::scaleImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_scaleImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_scaleImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_scaleImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_scaleImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = (Magick::scaleImage *)new Magick::scaleImage((Magick::Geometry const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__scaleImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_scaleImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::scaleImage *arg1 = (Magick::scaleImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_scaleImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__scaleImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "scaleImage_call" "', argument " "1"" of type '" "Magick::scaleImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::scaleImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "scaleImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "scaleImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::scaleImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_scaleImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::scaleImage * arg1 = (Magick::scaleImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_segmentImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  Magick::segmentImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_segmentImage__SWIG_0.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_segmentImage__SWIG_0.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_segmentImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_segmentImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      result = (Magick::segmentImage *)new Magick::segmentImage(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__segmentImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_segmentImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::segmentImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_segmentImage__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_segmentImage__SWIG_1.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_segmentImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::segmentImage *)new Magick::segmentImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__segmentImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_segmentImage__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::segmentImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_segmentImage__SWIG_2.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_segmentImage__SWIG_2.");
  {
    try {
      result = (Magick::segmentImage *)new Magick::segmentImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__segmentImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_segmentImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_segmentImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_segmentImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_segmentImage__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_segmentImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_segmentImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::segmentImage *arg1 = (Magick::segmentImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_segmentImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__segmentImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "segmentImage_call" "', argument " "1"" of type '" "Magick::segmentImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::segmentImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "segmentImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "segmentImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::segmentImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_segmentImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::segmentImage * arg1 = (Magick::segmentImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_shadeImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  bool arg3 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  Magick::shadeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_shadeImage__SWIG_0.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_shadeImage__SWIG_0.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_shadeImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_shadeImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_bool(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_shadeImage" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      result = (Magick::shadeImage *)new Magick::shadeImage(arg1,arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__shadeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_shadeImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  Magick::shadeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_shadeImage__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_shadeImage__SWIG_1.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_shadeImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_shadeImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      result = (Magick::shadeImage *)new Magick::shadeImage(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__shadeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_shadeImage__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::shadeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_shadeImage__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_shadeImage__SWIG_2.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_shadeImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::shadeImage *)new Magick::shadeImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__shadeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_shadeImage__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::shadeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_shadeImage__SWIG_3.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_shadeImage__SWIG_3.");
  {
    try {
      result = (Magick::shadeImage *)new Magick::shadeImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__shadeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_shadeImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_shadeImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_shadeImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_shadeImage__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_shadeImage__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_shadeImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_shadeImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::shadeImage *arg1 = (Magick::shadeImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_shadeImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__shadeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "shadeImage_call" "', argument " "1"" of type '" "Magick::shadeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::shadeImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "shadeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "shadeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::shadeImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_shadeImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::shadeImage * arg1 = (Magick::shadeImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_shadowImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  ssize_t arg3 ;
  ssize_t arg4 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  Magick::shadowImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_shadowImage__SWIG_0.");
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_shadowImage__SWIG_0.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_shadowImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_shadowImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_shadowImage" "', argument " "3"" of type '" "ssize_t""'");
  } 
  arg3 = static_cast< ssize_t >(val3);
  ecode4 = SWIG_AsVal_long(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_shadowImage" "', argument " "4"" of type '" "ssize_t""'");
  } 
  arg4 = static_cast< ssize_t >(val4);
  {
    try {
      result = (Magick::shadowImage *)new Magick::shadowImage(arg1,arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__shadowImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_shadowImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  ssize_t arg3 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  Magick::shadowImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_shadowImage__SWIG_1.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_shadowImage__SWIG_1.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_shadowImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_shadowImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_shadowImage" "', argument " "3"" of type '" "ssize_t""'");
  } 
  arg3 = static_cast< ssize_t >(val3);
  {
    try {
      result = (Magick::shadowImage *)new Magick::shadowImage(arg1,arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__shadowImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_shadowImage__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  Magick::shadowImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_shadowImage__SWIG_2.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_shadowImage__SWIG_2.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_shadowImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_shadowImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      result = (Magick::shadowImage *)new Magick::shadowImage(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__shadowImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_shadowImage__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::shadowImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_shadowImage__SWIG_3.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_shadowImage__SWIG_3.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_shadowImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::shadowImage *)new Magick::shadowImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__shadowImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_shadowImage__SWIG_4(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::shadowImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_shadowImage__SWIG_4.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_shadowImage__SWIG_4.");
  {
    try {
      result = (Magick::shadowImage *)new Magick::shadowImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__shadowImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_shadowImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_new_shadowImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_shadowImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_shadowImage__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_shadowImage__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_shadowImage__SWIG_4(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_shadowImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_shadowImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::shadowImage *arg1 = (Magick::shadowImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_shadowImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__shadowImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "shadowImage_call" "', argument " "1"" of type '" "Magick::shadowImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::shadowImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "shadowImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "shadowImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::shadowImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_shadowImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::shadowImage * arg1 = (Magick::shadowImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_sharpenImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  Magick::sharpenImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_sharpenImage__SWIG_0.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_sharpenImage__SWIG_0.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_sharpenImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_sharpenImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      result = (Magick::sharpenImage *)new Magick::sharpenImage(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__sharpenImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_sharpenImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::sharpenImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_sharpenImage__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_sharpenImage__SWIG_1.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_sharpenImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::sharpenImage *)new Magick::sharpenImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__sharpenImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_sharpenImage__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::sharpenImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_sharpenImage__SWIG_2.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_sharpenImage__SWIG_2.");
  {
    try {
      result = (Magick::sharpenImage *)new Magick::sharpenImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__sharpenImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_sharpenImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_sharpenImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_sharpenImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_sharpenImage__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_sharpenImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_sharpenImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::sharpenImage *arg1 = (Magick::sharpenImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_sharpenImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__sharpenImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "sharpenImage_call" "', argument " "1"" of type '" "Magick::sharpenImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::sharpenImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "sharpenImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "sharpenImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::sharpenImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_sharpenImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::sharpenImage * arg1 = (Magick::sharpenImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_shaveImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Geometry *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::shaveImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_shaveImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_shaveImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_shaveImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_shaveImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = (Magick::shaveImage *)new Magick::shaveImage((Magick::Geometry const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__shaveImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_shaveImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::shaveImage *arg1 = (Magick::shaveImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_shaveImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__shaveImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "shaveImage_call" "', argument " "1"" of type '" "Magick::shaveImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::shaveImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "shaveImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "shaveImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::shaveImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_shaveImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::shaveImage * arg1 = (Magick::shaveImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_shearImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  Magick::shearImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_shearImage.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_shearImage.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_shearImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_shearImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      result = (Magick::shearImage *)new Magick::shearImage(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__shearImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_shearImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::shearImage *arg1 = (Magick::shearImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_shearImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__shearImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "shearImage_call" "', argument " "1"" of type '" "Magick::shearImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::shearImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "shearImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "shearImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::shearImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_shearImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::shearImage * arg1 = (Magick::shearImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_solarizeImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::solarizeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_solarizeImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_solarizeImage.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_solarizeImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::solarizeImage *)new Magick::solarizeImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__solarizeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_solarizeImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::solarizeImage *arg1 = (Magick::solarizeImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_solarizeImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__solarizeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "solarizeImage_call" "', argument " "1"" of type '" "Magick::solarizeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::solarizeImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "solarizeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "solarizeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::solarizeImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_solarizeImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::solarizeImage * arg1 = (Magick::solarizeImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_spliceImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Geometry *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::spliceImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_spliceImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_spliceImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_spliceImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_spliceImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = (Magick::spliceImage *)new Magick::spliceImage((Magick::Geometry const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__spliceImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_spliceImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::spliceImage *arg1 = (Magick::spliceImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_spliceImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__spliceImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "spliceImage_call" "', argument " "1"" of type '" "Magick::spliceImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::spliceImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "spliceImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "spliceImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::spliceImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_spliceImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::spliceImage * arg1 = (Magick::spliceImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_spreadImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  Magick::spreadImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_spreadImage__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_spreadImage__SWIG_0.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_spreadImage" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  {
    try {
      result = (Magick::spreadImage *)new Magick::spreadImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__spreadImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_spreadImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::spreadImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_spreadImage__SWIG_1.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_spreadImage__SWIG_1.");
  {
    try {
      result = (Magick::spreadImage *)new Magick::spreadImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__spreadImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_spreadImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_spreadImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_spreadImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_spreadImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_spreadImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::spreadImage *arg1 = (Magick::spreadImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_spreadImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__spreadImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "spreadImage_call" "', argument " "1"" of type '" "Magick::spreadImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::spreadImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "spreadImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "spreadImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::spreadImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_spreadImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::spreadImage * arg1 = (Magick::spreadImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_steganoImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Image *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::steganoImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_steganoImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_steganoImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_steganoImage" "', argument " "1"" of type '" "Image const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_steganoImage" "', argument " "1"" of type '" "Image const &""'"); 
  }
  arg1 = reinterpret_cast< Image * >(argp1);
  {
    try {
      result = (Magick::steganoImage *)new Magick::steganoImage((Image const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__steganoImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_steganoImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::steganoImage *arg1 = (Magick::steganoImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_steganoImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__steganoImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "steganoImage_call" "', argument " "1"" of type '" "Magick::steganoImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::steganoImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "steganoImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "steganoImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::steganoImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_steganoImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::steganoImage * arg1 = (Magick::steganoImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_stereoImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Image *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::stereoImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_stereoImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_stereoImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_stereoImage" "', argument " "1"" of type '" "Image const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_stereoImage" "', argument " "1"" of type '" "Image const &""'"); 
  }
  arg1 = reinterpret_cast< Image * >(argp1);
  {
    try {
      result = (Magick::stereoImage *)new Magick::stereoImage((Image const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__stereoImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_stereoImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::stereoImage *arg1 = (Magick::stereoImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_stereoImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__stereoImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "stereoImage_call" "', argument " "1"" of type '" "Magick::stereoImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::stereoImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "stereoImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "stereoImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::stereoImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_stereoImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::stereoImage * arg1 = (Magick::stereoImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_strokeColorImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Color *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::strokeColorImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_strokeColorImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_strokeColorImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Color,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_strokeColorImage" "', argument " "1"" of type '" "Color const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_strokeColorImage" "', argument " "1"" of type '" "Color const &""'"); 
  }
  arg1 = reinterpret_cast< Color * >(argp1);
  {
    try {
      result = (Magick::strokeColorImage *)new Magick::strokeColorImage((Color const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__strokeColorImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_strokeColorImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::strokeColorImage *arg1 = (Magick::strokeColorImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_strokeColorImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__strokeColorImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "strokeColorImage_call" "', argument " "1"" of type '" "Magick::strokeColorImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::strokeColorImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "strokeColorImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "strokeColorImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::strokeColorImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_strokeColorImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::strokeColorImage * arg1 = (Magick::strokeColorImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_swirlImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::swirlImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_swirlImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_swirlImage.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_swirlImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::swirlImage *)new Magick::swirlImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__swirlImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_swirlImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::swirlImage *arg1 = (Magick::swirlImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_swirlImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__swirlImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "swirlImage_call" "', argument " "1"" of type '" "Magick::swirlImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::swirlImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "swirlImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "swirlImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::swirlImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_swirlImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::swirlImage * arg1 = (Magick::swirlImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_textureImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Image *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::textureImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_textureImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_textureImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_textureImage" "', argument " "1"" of type '" "Image const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_textureImage" "', argument " "1"" of type '" "Image const &""'"); 
  }
  arg1 = reinterpret_cast< Image * >(argp1);
  {
    try {
      result = (Magick::textureImage *)new Magick::textureImage((Image const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__textureImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_textureImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::textureImage *arg1 = (Magick::textureImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_textureImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__textureImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "textureImage_call" "', argument " "1"" of type '" "Magick::textureImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::textureImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "textureImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "textureImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::textureImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_textureImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::textureImage * arg1 = (Magick::textureImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_thresholdImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::thresholdImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_thresholdImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_thresholdImage.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_thresholdImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::thresholdImage *)new Magick::thresholdImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__thresholdImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_thresholdImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::thresholdImage *arg1 = (Magick::thresholdImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_thresholdImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__thresholdImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "thresholdImage_call" "', argument " "1"" of type '" "Magick::thresholdImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::thresholdImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "thresholdImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "thresholdImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::thresholdImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_thresholdImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::thresholdImage * arg1 = (Magick::thresholdImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_transformImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Geometry *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::transformImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_transformImage__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_transformImage__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_transformImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_transformImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = (Magick::transformImage *)new Magick::transformImage((Magick::Geometry const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__transformImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_transformImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Geometry *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::transformImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_transformImage__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_transformImage__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_transformImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_transformImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_transformImage" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_transformImage" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      result = (Magick::transformImage *)new Magick::transformImage((Magick::Geometry const &)*arg1,(Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__transformImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_transformImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_transformImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_transformImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_transformImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_transformImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::transformImage *arg1 = (Magick::transformImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_transformImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__transformImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "transformImage_call" "', argument " "1"" of type '" "Magick::transformImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::transformImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "transformImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "transformImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::transformImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_transformImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::transformImage * arg1 = (Magick::transformImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_transparentImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Color *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::transparentImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_transparentImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_transparentImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Color,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_transparentImage" "', argument " "1"" of type '" "Color const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_transparentImage" "', argument " "1"" of type '" "Color const &""'"); 
  }
  arg1 = reinterpret_cast< Color * >(argp1);
  {
    try {
      result = (Magick::transparentImage *)new Magick::transparentImage((Color const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__transparentImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_transparentImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::transparentImage *arg1 = (Magick::transparentImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_transparentImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__transparentImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "transparentImage_call" "', argument " "1"" of type '" "Magick::transparentImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::transparentImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "transparentImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "transparentImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::transparentImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_transparentImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::transparentImage * arg1 = (Magick::transparentImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_trimImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::trimImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_trimImage.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_trimImage.");
  {
    try {
      result = (Magick::trimImage *)new Magick::trimImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__trimImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_trimImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::trimImage *arg1 = (Magick::trimImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_trimImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__trimImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "trimImage_call" "', argument " "1"" of type '" "Magick::trimImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::trimImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "trimImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "trimImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::trimImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_trimImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::trimImage * arg1 = (Magick::trimImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_waveImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  Magick::waveImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_waveImage__SWIG_0.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_waveImage__SWIG_0.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_waveImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_waveImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      result = (Magick::waveImage *)new Magick::waveImage(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__waveImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_waveImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::waveImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_waveImage__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_waveImage__SWIG_1.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_waveImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::waveImage *)new Magick::waveImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__waveImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_waveImage__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::waveImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_waveImage__SWIG_2.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_waveImage__SWIG_2.");
  {
    try {
      result = (Magick::waveImage *)new Magick::waveImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__waveImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_waveImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_waveImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_waveImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_waveImage__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_waveImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_waveImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::waveImage *arg1 = (Magick::waveImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_waveImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__waveImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "waveImage_call" "', argument " "1"" of type '" "Magick::waveImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::waveImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "waveImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "waveImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::waveImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_waveImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::waveImage * arg1 = (Magick::waveImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_zoomImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Geometry *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::zoomImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_zoomImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_zoomImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_zoomImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_zoomImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = (Magick::zoomImage *)new Magick::zoomImage((Magick::Geometry const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__zoomImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_zoomImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::zoomImage *arg1 = (Magick::zoomImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_zoomImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__zoomImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "zoomImage_call" "', argument " "1"" of type '" "Magick::zoomImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::zoomImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "zoomImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "zoomImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::zoomImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_zoomImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::zoomImage * arg1 = (Magick::zoomImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_antiAliasImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  Magick::antiAliasImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_antiAliasImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_antiAliasImage.");
  ecode1 = SWIG_AsVal_bool(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_antiAliasImage" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      result = (Magick::antiAliasImage *)new Magick::antiAliasImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__antiAliasImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_antiAliasImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::antiAliasImage *arg1 = (Magick::antiAliasImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_antiAliasImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__antiAliasImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "antiAliasImage_call" "', argument " "1"" of type '" "Magick::antiAliasImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::antiAliasImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "antiAliasImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "antiAliasImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::antiAliasImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_antiAliasImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::antiAliasImage * arg1 = (Magick::antiAliasImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_adjoinImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  Magick::adjoinImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_adjoinImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_adjoinImage.");
  ecode1 = SWIG_AsVal_bool(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_adjoinImage" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      result = (Magick::adjoinImage *)new Magick::adjoinImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__adjoinImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_adjoinImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::adjoinImage *arg1 = (Magick::adjoinImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_adjoinImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__adjoinImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "adjoinImage_call" "', argument " "1"" of type '" "Magick::adjoinImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::adjoinImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "adjoinImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "adjoinImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::adjoinImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_adjoinImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::adjoinImage * arg1 = (Magick::adjoinImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_animationDelayImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  Magick::animationDelayImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_animationDelayImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_animationDelayImage.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_animationDelayImage" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  {
    try {
      result = (Magick::animationDelayImage *)new Magick::animationDelayImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__animationDelayImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_animationDelayImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::animationDelayImage *arg1 = (Magick::animationDelayImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_animationDelayImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__animationDelayImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "animationDelayImage_call" "', argument " "1"" of type '" "Magick::animationDelayImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::animationDelayImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "animationDelayImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "animationDelayImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::animationDelayImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_animationDelayImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::animationDelayImage * arg1 = (Magick::animationDelayImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_animationIterationsImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  Magick::animationIterationsImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_animationIterationsImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_animationIterationsImage.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_animationIterationsImage" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  {
    try {
      result = (Magick::animationIterationsImage *)new Magick::animationIterationsImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__animationIterationsImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_animationIterationsImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::animationIterationsImage *arg1 = (Magick::animationIterationsImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_animationIterationsImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__animationIterationsImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "animationIterationsImage_call" "', argument " "1"" of type '" "Magick::animationIterationsImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::animationIterationsImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "animationIterationsImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "animationIterationsImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::animationIterationsImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_animationIterationsImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::animationIterationsImage * arg1 = (Magick::animationIterationsImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_backgroundColorImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Color *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::backgroundColorImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_backgroundColorImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_backgroundColorImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Color,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_backgroundColorImage" "', argument " "1"" of type '" "Color const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_backgroundColorImage" "', argument " "1"" of type '" "Color const &""'"); 
  }
  arg1 = reinterpret_cast< Color * >(argp1);
  {
    try {
      result = (Magick::backgroundColorImage *)new Magick::backgroundColorImage((Color const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__backgroundColorImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_backgroundColorImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::backgroundColorImage *arg1 = (Magick::backgroundColorImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_backgroundColorImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__backgroundColorImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "backgroundColorImage_call" "', argument " "1"" of type '" "Magick::backgroundColorImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::backgroundColorImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "backgroundColorImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "backgroundColorImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::backgroundColorImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_backgroundColorImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::backgroundColorImage * arg1 = (Magick::backgroundColorImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_backgroundTextureImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::backgroundTextureImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_backgroundTextureImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_backgroundTextureImage.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_backgroundTextureImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_backgroundTextureImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::backgroundTextureImage *)new Magick::backgroundTextureImage((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__backgroundTextureImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_backgroundTextureImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::backgroundTextureImage *arg1 = (Magick::backgroundTextureImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_backgroundTextureImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__backgroundTextureImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "backgroundTextureImage_call" "', argument " "1"" of type '" "Magick::backgroundTextureImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::backgroundTextureImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "backgroundTextureImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "backgroundTextureImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::backgroundTextureImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_backgroundTextureImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::backgroundTextureImage * arg1 = (Magick::backgroundTextureImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_borderColorImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Color *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::borderColorImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_borderColorImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_borderColorImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Color,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_borderColorImage" "', argument " "1"" of type '" "Color const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_borderColorImage" "', argument " "1"" of type '" "Color const &""'"); 
  }
  arg1 = reinterpret_cast< Color * >(argp1);
  {
    try {
      result = (Magick::borderColorImage *)new Magick::borderColorImage((Color const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__borderColorImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_borderColorImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::borderColorImage *arg1 = (Magick::borderColorImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_borderColorImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__borderColorImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "borderColorImage_call" "', argument " "1"" of type '" "Magick::borderColorImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::borderColorImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "borderColorImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "borderColorImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::borderColorImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_borderColorImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::borderColorImage * arg1 = (Magick::borderColorImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_boxColorImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Color *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::boxColorImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_boxColorImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_boxColorImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Color,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_boxColorImage" "', argument " "1"" of type '" "Color const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_boxColorImage" "', argument " "1"" of type '" "Color const &""'"); 
  }
  arg1 = reinterpret_cast< Color * >(argp1);
  {
    try {
      result = (Magick::boxColorImage *)new Magick::boxColorImage((Color const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__boxColorImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_boxColorImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::boxColorImage *arg1 = (Magick::boxColorImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_boxColorImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__boxColorImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "boxColorImage_call" "', argument " "1"" of type '" "Magick::boxColorImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::boxColorImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "boxColorImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "boxColorImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::boxColorImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_boxColorImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::boxColorImage * arg1 = (Magick::boxColorImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_chromaBluePrimaryImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  Magick::chromaBluePrimaryImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_chromaBluePrimaryImage.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_chromaBluePrimaryImage.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_chromaBluePrimaryImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_chromaBluePrimaryImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      result = (Magick::chromaBluePrimaryImage *)new Magick::chromaBluePrimaryImage(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__chromaBluePrimaryImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_chromaBluePrimaryImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::chromaBluePrimaryImage *arg1 = (Magick::chromaBluePrimaryImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_chromaBluePrimaryImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__chromaBluePrimaryImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "chromaBluePrimaryImage_call" "', argument " "1"" of type '" "Magick::chromaBluePrimaryImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::chromaBluePrimaryImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "chromaBluePrimaryImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "chromaBluePrimaryImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::chromaBluePrimaryImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_chromaBluePrimaryImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::chromaBluePrimaryImage * arg1 = (Magick::chromaBluePrimaryImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_chromaGreenPrimaryImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  Magick::chromaGreenPrimaryImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_chromaGreenPrimaryImage.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_chromaGreenPrimaryImage.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_chromaGreenPrimaryImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_chromaGreenPrimaryImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      result = (Magick::chromaGreenPrimaryImage *)new Magick::chromaGreenPrimaryImage(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__chromaGreenPrimaryImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_chromaGreenPrimaryImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::chromaGreenPrimaryImage *arg1 = (Magick::chromaGreenPrimaryImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_chromaGreenPrimaryImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__chromaGreenPrimaryImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "chromaGreenPrimaryImage_call" "', argument " "1"" of type '" "Magick::chromaGreenPrimaryImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::chromaGreenPrimaryImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "chromaGreenPrimaryImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "chromaGreenPrimaryImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::chromaGreenPrimaryImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_chromaGreenPrimaryImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::chromaGreenPrimaryImage * arg1 = (Magick::chromaGreenPrimaryImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_chromaRedPrimaryImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  Magick::chromaRedPrimaryImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_chromaRedPrimaryImage.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_chromaRedPrimaryImage.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_chromaRedPrimaryImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_chromaRedPrimaryImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      result = (Magick::chromaRedPrimaryImage *)new Magick::chromaRedPrimaryImage(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__chromaRedPrimaryImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_chromaRedPrimaryImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::chromaRedPrimaryImage *arg1 = (Magick::chromaRedPrimaryImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_chromaRedPrimaryImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__chromaRedPrimaryImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "chromaRedPrimaryImage_call" "', argument " "1"" of type '" "Magick::chromaRedPrimaryImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::chromaRedPrimaryImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "chromaRedPrimaryImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "chromaRedPrimaryImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::chromaRedPrimaryImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_chromaRedPrimaryImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::chromaRedPrimaryImage * arg1 = (Magick::chromaRedPrimaryImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_chromaWhitePointImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  Magick::chromaWhitePointImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_chromaWhitePointImage.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_chromaWhitePointImage.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_chromaWhitePointImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_chromaWhitePointImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      result = (Magick::chromaWhitePointImage *)new Magick::chromaWhitePointImage(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__chromaWhitePointImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_chromaWhitePointImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::chromaWhitePointImage *arg1 = (Magick::chromaWhitePointImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_chromaWhitePointImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__chromaWhitePointImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "chromaWhitePointImage_call" "', argument " "1"" of type '" "Magick::chromaWhitePointImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::chromaWhitePointImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "chromaWhitePointImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "chromaWhitePointImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::chromaWhitePointImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_chromaWhitePointImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::chromaWhitePointImage * arg1 = (Magick::chromaWhitePointImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_colorFuzzImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::colorFuzzImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_colorFuzzImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_colorFuzzImage.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_colorFuzzImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::colorFuzzImage *)new Magick::colorFuzzImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__colorFuzzImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_colorFuzzImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::colorFuzzImage *arg1 = (Magick::colorFuzzImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_colorFuzzImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__colorFuzzImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "colorFuzzImage_call" "', argument " "1"" of type '" "Magick::colorFuzzImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::colorFuzzImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "colorFuzzImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "colorFuzzImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::colorFuzzImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_colorFuzzImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::colorFuzzImage * arg1 = (Magick::colorFuzzImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_colorMapImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  Color *arg2 = 0 ;
  size_t val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::colorMapImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_colorMapImage.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_colorMapImage.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_colorMapImage" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_colorMapImage" "', argument " "2"" of type '" "Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_colorMapImage" "', argument " "2"" of type '" "Color const &""'"); 
  }
  arg2 = reinterpret_cast< Color * >(argp2);
  {
    try {
      result = (Magick::colorMapImage *)new Magick::colorMapImage(arg1,(Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__colorMapImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_colorMapImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::colorMapImage *arg1 = (Magick::colorMapImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_colorMapImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__colorMapImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "colorMapImage_call" "', argument " "1"" of type '" "Magick::colorMapImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::colorMapImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "colorMapImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "colorMapImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::colorMapImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_colorMapImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::colorMapImage * arg1 = (Magick::colorMapImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_composeImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::CompositeOperator arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  Magick::composeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_composeImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_composeImage.");
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_composeImage" "', argument " "1"" of type '" "Magick::CompositeOperator""'");
  } 
  arg1 = static_cast< Magick::CompositeOperator >(val1);
  {
    try {
      result = (Magick::composeImage *)new Magick::composeImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__composeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_composeImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::composeImage *arg1 = (Magick::composeImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_composeImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__composeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "composeImage_call" "', argument " "1"" of type '" "Magick::composeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::composeImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "composeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "composeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::composeImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_composeImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::composeImage * arg1 = (Magick::composeImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_compressTypeImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::CompressionType arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  Magick::compressTypeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_compressTypeImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_compressTypeImage.");
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_compressTypeImage" "', argument " "1"" of type '" "Magick::CompressionType""'");
  } 
  arg1 = static_cast< Magick::CompressionType >(val1);
  {
    try {
      result = (Magick::compressTypeImage *)new Magick::compressTypeImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__compressTypeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_compressTypeImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::compressTypeImage *arg1 = (Magick::compressTypeImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_compressTypeImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__compressTypeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "compressTypeImage_call" "', argument " "1"" of type '" "Magick::compressTypeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::compressTypeImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "compressTypeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "compressTypeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::compressTypeImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_compressTypeImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::compressTypeImage * arg1 = (Magick::compressTypeImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_densityImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Geometry *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::densityImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_densityImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_densityImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_densityImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_densityImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = (Magick::densityImage *)new Magick::densityImage((Magick::Geometry const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__densityImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_densityImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::densityImage *arg1 = (Magick::densityImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_densityImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__densityImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "densityImage_call" "', argument " "1"" of type '" "Magick::densityImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::densityImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "densityImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "densityImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::densityImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_densityImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::densityImage * arg1 = (Magick::densityImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_depthImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  Magick::depthImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_depthImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_depthImage.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_depthImage" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  {
    try {
      result = (Magick::depthImage *)new Magick::depthImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__depthImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_depthImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::depthImage *arg1 = (Magick::depthImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_depthImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__depthImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "depthImage_call" "', argument " "1"" of type '" "Magick::depthImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::depthImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "depthImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "depthImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::depthImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_depthImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::depthImage * arg1 = (Magick::depthImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_endianImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::EndianType arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  Magick::endianImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_endianImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_endianImage.");
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_endianImage" "', argument " "1"" of type '" "Magick::EndianType""'");
  } 
  arg1 = static_cast< Magick::EndianType >(val1);
  {
    try {
      result = (Magick::endianImage *)new Magick::endianImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__endianImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_endianImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::endianImage *arg1 = (Magick::endianImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_endianImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__endianImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "endianImage_call" "', argument " "1"" of type '" "Magick::endianImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::endianImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "endianImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "endianImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::endianImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_endianImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::endianImage * arg1 = (Magick::endianImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_fileNameImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::fileNameImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_fileNameImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_fileNameImage.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_fileNameImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_fileNameImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::fileNameImage *)new Magick::fileNameImage((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__fileNameImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_fileNameImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::fileNameImage *arg1 = (Magick::fileNameImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_fileNameImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__fileNameImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fileNameImage_call" "', argument " "1"" of type '" "Magick::fileNameImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::fileNameImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "fileNameImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "fileNameImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::fileNameImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_fileNameImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::fileNameImage * arg1 = (Magick::fileNameImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_filterTypeImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::FilterTypes arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  Magick::filterTypeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_filterTypeImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_filterTypeImage.");
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_filterTypeImage" "', argument " "1"" of type '" "Magick::FilterTypes""'");
  } 
  arg1 = static_cast< Magick::FilterTypes >(val1);
  {
    try {
      result = (Magick::filterTypeImage *)new Magick::filterTypeImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__filterTypeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_filterTypeImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::filterTypeImage *arg1 = (Magick::filterTypeImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_filterTypeImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__filterTypeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "filterTypeImage_call" "', argument " "1"" of type '" "Magick::filterTypeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::filterTypeImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "filterTypeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "filterTypeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::filterTypeImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_filterTypeImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::filterTypeImage * arg1 = (Magick::filterTypeImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_fontImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::fontImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_fontImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_fontImage.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_fontImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_fontImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::fontImage *)new Magick::fontImage((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__fontImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_fontImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::fontImage *arg1 = (Magick::fontImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_fontImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__fontImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fontImage_call" "', argument " "1"" of type '" "Magick::fontImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::fontImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "fontImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "fontImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::fontImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_fontImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::fontImage * arg1 = (Magick::fontImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_fontPointsizeImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  Magick::fontPointsizeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_fontPointsizeImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_fontPointsizeImage.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_fontPointsizeImage" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  {
    try {
      result = (Magick::fontPointsizeImage *)new Magick::fontPointsizeImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__fontPointsizeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_fontPointsizeImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::fontPointsizeImage *arg1 = (Magick::fontPointsizeImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_fontPointsizeImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__fontPointsizeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fontPointsizeImage_call" "', argument " "1"" of type '" "Magick::fontPointsizeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::fontPointsizeImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "fontPointsizeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "fontPointsizeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::fontPointsizeImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_fontPointsizeImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::fontPointsizeImage * arg1 = (Magick::fontPointsizeImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_gifDisposeMethodImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  Magick::gifDisposeMethodImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_gifDisposeMethodImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_gifDisposeMethodImage.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_gifDisposeMethodImage" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  {
    try {
      result = (Magick::gifDisposeMethodImage *)new Magick::gifDisposeMethodImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__gifDisposeMethodImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_gifDisposeMethodImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::gifDisposeMethodImage *arg1 = (Magick::gifDisposeMethodImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_gifDisposeMethodImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__gifDisposeMethodImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gifDisposeMethodImage_call" "', argument " "1"" of type '" "Magick::gifDisposeMethodImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::gifDisposeMethodImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gifDisposeMethodImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gifDisposeMethodImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::gifDisposeMethodImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_gifDisposeMethodImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::gifDisposeMethodImage * arg1 = (Magick::gifDisposeMethodImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_interlaceTypeImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::InterlaceType arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  Magick::interlaceTypeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_interlaceTypeImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_interlaceTypeImage.");
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_interlaceTypeImage" "', argument " "1"" of type '" "Magick::InterlaceType""'");
  } 
  arg1 = static_cast< Magick::InterlaceType >(val1);
  {
    try {
      result = (Magick::interlaceTypeImage *)new Magick::interlaceTypeImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__interlaceTypeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_interlaceTypeImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::interlaceTypeImage *arg1 = (Magick::interlaceTypeImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_interlaceTypeImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__interlaceTypeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "interlaceTypeImage_call" "', argument " "1"" of type '" "Magick::interlaceTypeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::interlaceTypeImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "interlaceTypeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "interlaceTypeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::interlaceTypeImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_interlaceTypeImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::interlaceTypeImage * arg1 = (Magick::interlaceTypeImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_lineWidthImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::lineWidthImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_lineWidthImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_lineWidthImage.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_lineWidthImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::lineWidthImage *)new Magick::lineWidthImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__lineWidthImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_lineWidthImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::lineWidthImage *arg1 = (Magick::lineWidthImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_lineWidthImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__lineWidthImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lineWidthImage_call" "', argument " "1"" of type '" "Magick::lineWidthImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::lineWidthImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lineWidthImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lineWidthImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::lineWidthImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_lineWidthImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::lineWidthImage * arg1 = (Magick::lineWidthImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_magickImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::magickImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_magickImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_magickImage.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_magickImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_magickImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::magickImage *)new Magick::magickImage((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__magickImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_magickImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::magickImage *arg1 = (Magick::magickImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_magickImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__magickImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "magickImage_call" "', argument " "1"" of type '" "Magick::magickImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::magickImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "magickImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "magickImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::magickImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_magickImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::magickImage * arg1 = (Magick::magickImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_matteImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  Magick::matteImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_matteImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_matteImage.");
  ecode1 = SWIG_AsVal_bool(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_matteImage" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      result = (Magick::matteImage *)new Magick::matteImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__matteImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_matteImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::matteImage *arg1 = (Magick::matteImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_matteImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__matteImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "matteImage_call" "', argument " "1"" of type '" "Magick::matteImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::matteImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "matteImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "matteImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::matteImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_matteImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::matteImage * arg1 = (Magick::matteImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_matteColorImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Color *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::matteColorImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_matteColorImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_matteColorImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Color,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_matteColorImage" "', argument " "1"" of type '" "Color const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_matteColorImage" "', argument " "1"" of type '" "Color const &""'"); 
  }
  arg1 = reinterpret_cast< Color * >(argp1);
  {
    try {
      result = (Magick::matteColorImage *)new Magick::matteColorImage((Color const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__matteColorImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_matteColorImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::matteColorImage *arg1 = (Magick::matteColorImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_matteColorImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__matteColorImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "matteColorImage_call" "', argument " "1"" of type '" "Magick::matteColorImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::matteColorImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "matteColorImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "matteColorImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::matteColorImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_matteColorImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::matteColorImage * arg1 = (Magick::matteColorImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_monochromeImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  Magick::monochromeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_monochromeImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_monochromeImage.");
  ecode1 = SWIG_AsVal_bool(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_monochromeImage" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      result = (Magick::monochromeImage *)new Magick::monochromeImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__monochromeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_monochromeImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::monochromeImage *arg1 = (Magick::monochromeImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_monochromeImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__monochromeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "monochromeImage_call" "', argument " "1"" of type '" "Magick::monochromeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::monochromeImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "monochromeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "monochromeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::monochromeImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_monochromeImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::monochromeImage * arg1 = (Magick::monochromeImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_penColorImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Color *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::penColorImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_penColorImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_penColorImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Color,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_penColorImage" "', argument " "1"" of type '" "Color const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_penColorImage" "', argument " "1"" of type '" "Color const &""'"); 
  }
  arg1 = reinterpret_cast< Color * >(argp1);
  {
    try {
      result = (Magick::penColorImage *)new Magick::penColorImage((Color const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__penColorImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_penColorImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::penColorImage *arg1 = (Magick::penColorImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_penColorImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__penColorImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "penColorImage_call" "', argument " "1"" of type '" "Magick::penColorImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::penColorImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "penColorImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "penColorImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::penColorImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_penColorImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::penColorImage * arg1 = (Magick::penColorImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_penTextureImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Image *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::penTextureImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_penTextureImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_penTextureImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_penTextureImage" "', argument " "1"" of type '" "Image const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_penTextureImage" "', argument " "1"" of type '" "Image const &""'"); 
  }
  arg1 = reinterpret_cast< Image * >(argp1);
  {
    try {
      result = (Magick::penTextureImage *)new Magick::penTextureImage((Image const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__penTextureImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_penTextureImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::penTextureImage *arg1 = (Magick::penTextureImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_penTextureImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__penTextureImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "penTextureImage_call" "', argument " "1"" of type '" "Magick::penTextureImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::penTextureImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "penTextureImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "penTextureImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::penTextureImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_penTextureImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::penTextureImage * arg1 = (Magick::penTextureImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_pixelColorImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  ::ssize_t arg1 ;
  ::ssize_t arg2 ;
  Color *arg3 = 0 ;
  long val1 ;
  int ecode1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  Magick::pixelColorImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_pixelColorImage.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_pixelColorImage.");
  ecode1 = SWIG_AsVal_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_pixelColorImage" "', argument " "1"" of type '" "::ssize_t""'");
  } 
  arg1 = static_cast< ::ssize_t >(val1);
  ecode2 = SWIG_AsVal_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_pixelColorImage" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3, SWIGTYPE_p_Color,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_pixelColorImage" "', argument " "3"" of type '" "Color const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_pixelColorImage" "', argument " "3"" of type '" "Color const &""'"); 
  }
  arg3 = reinterpret_cast< Color * >(argp3);
  {
    try {
      result = (Magick::pixelColorImage *)new Magick::pixelColorImage(arg1,arg2,(Color const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__pixelColorImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_pixelColorImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::pixelColorImage *arg1 = (Magick::pixelColorImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_pixelColorImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__pixelColorImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pixelColorImage_call" "', argument " "1"" of type '" "Magick::pixelColorImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::pixelColorImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "pixelColorImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "pixelColorImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::pixelColorImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_pixelColorImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::pixelColorImage * arg1 = (Magick::pixelColorImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_pageImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Geometry *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::pageImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_pageImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_pageImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_pageImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_pageImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = (Magick::pageImage *)new Magick::pageImage((Magick::Geometry const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__pageImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_pageImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::pageImage *arg1 = (Magick::pageImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_pageImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__pageImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pageImage_call" "', argument " "1"" of type '" "Magick::pageImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::pageImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "pageImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "pageImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::pageImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_pageImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::pageImage * arg1 = (Magick::pageImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_qualityImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  Magick::qualityImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_qualityImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_qualityImage.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_qualityImage" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  {
    try {
      result = (Magick::qualityImage *)new Magick::qualityImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__qualityImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_qualityImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::qualityImage *arg1 = (Magick::qualityImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_qualityImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__qualityImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "qualityImage_call" "', argument " "1"" of type '" "Magick::qualityImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::qualityImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "qualityImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "qualityImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::qualityImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_qualityImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::qualityImage * arg1 = (Magick::qualityImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_quantizeColorsImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  Magick::quantizeColorsImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_quantizeColorsImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_quantizeColorsImage.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_quantizeColorsImage" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  {
    try {
      result = (Magick::quantizeColorsImage *)new Magick::quantizeColorsImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__quantizeColorsImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_quantizeColorsImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::quantizeColorsImage *arg1 = (Magick::quantizeColorsImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_quantizeColorsImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__quantizeColorsImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "quantizeColorsImage_call" "', argument " "1"" of type '" "Magick::quantizeColorsImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::quantizeColorsImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "quantizeColorsImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "quantizeColorsImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::quantizeColorsImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_quantizeColorsImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::quantizeColorsImage * arg1 = (Magick::quantizeColorsImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_quantizeColorSpaceImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::ColorspaceType arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  Magick::quantizeColorSpaceImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_quantizeColorSpaceImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_quantizeColorSpaceImage.");
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_quantizeColorSpaceImage" "', argument " "1"" of type '" "Magick::ColorspaceType""'");
  } 
  arg1 = static_cast< Magick::ColorspaceType >(val1);
  {
    try {
      result = (Magick::quantizeColorSpaceImage *)new Magick::quantizeColorSpaceImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__quantizeColorSpaceImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_quantizeColorSpaceImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::quantizeColorSpaceImage *arg1 = (Magick::quantizeColorSpaceImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_quantizeColorSpaceImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__quantizeColorSpaceImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "quantizeColorSpaceImage_call" "', argument " "1"" of type '" "Magick::quantizeColorSpaceImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::quantizeColorSpaceImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "quantizeColorSpaceImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "quantizeColorSpaceImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::quantizeColorSpaceImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_quantizeColorSpaceImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::quantizeColorSpaceImage * arg1 = (Magick::quantizeColorSpaceImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_quantizeDitherImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  Magick::quantizeDitherImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_quantizeDitherImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_quantizeDitherImage.");
  ecode1 = SWIG_AsVal_bool(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_quantizeDitherImage" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      result = (Magick::quantizeDitherImage *)new Magick::quantizeDitherImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__quantizeDitherImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_quantizeDitherImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::quantizeDitherImage *arg1 = (Magick::quantizeDitherImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_quantizeDitherImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__quantizeDitherImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "quantizeDitherImage_call" "', argument " "1"" of type '" "Magick::quantizeDitherImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::quantizeDitherImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "quantizeDitherImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "quantizeDitherImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::quantizeDitherImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_quantizeDitherImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::quantizeDitherImage * arg1 = (Magick::quantizeDitherImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_quantizeTreeDepthImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  Magick::quantizeTreeDepthImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_quantizeTreeDepthImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_quantizeTreeDepthImage.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_quantizeTreeDepthImage" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  {
    try {
      result = (Magick::quantizeTreeDepthImage *)new Magick::quantizeTreeDepthImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__quantizeTreeDepthImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_quantizeTreeDepthImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::quantizeTreeDepthImage *arg1 = (Magick::quantizeTreeDepthImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_quantizeTreeDepthImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__quantizeTreeDepthImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "quantizeTreeDepthImage_call" "', argument " "1"" of type '" "Magick::quantizeTreeDepthImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::quantizeTreeDepthImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "quantizeTreeDepthImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "quantizeTreeDepthImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::quantizeTreeDepthImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_quantizeTreeDepthImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::quantizeTreeDepthImage * arg1 = (Magick::quantizeTreeDepthImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_renderingIntentImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::RenderingIntent arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  Magick::renderingIntentImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_renderingIntentImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_renderingIntentImage.");
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_renderingIntentImage" "', argument " "1"" of type '" "Magick::RenderingIntent""'");
  } 
  arg1 = static_cast< Magick::RenderingIntent >(val1);
  {
    try {
      result = (Magick::renderingIntentImage *)new Magick::renderingIntentImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__renderingIntentImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_renderingIntentImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::renderingIntentImage *arg1 = (Magick::renderingIntentImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_renderingIntentImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__renderingIntentImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "renderingIntentImage_call" "', argument " "1"" of type '" "Magick::renderingIntentImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::renderingIntentImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "renderingIntentImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "renderingIntentImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::renderingIntentImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_renderingIntentImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::renderingIntentImage * arg1 = (Magick::renderingIntentImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_resolutionUnitsImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::ResolutionType arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  Magick::resolutionUnitsImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_resolutionUnitsImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_resolutionUnitsImage.");
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_resolutionUnitsImage" "', argument " "1"" of type '" "Magick::ResolutionType""'");
  } 
  arg1 = static_cast< Magick::ResolutionType >(val1);
  {
    try {
      result = (Magick::resolutionUnitsImage *)new Magick::resolutionUnitsImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__resolutionUnitsImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_resolutionUnitsImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::resolutionUnitsImage *arg1 = (Magick::resolutionUnitsImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_resolutionUnitsImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__resolutionUnitsImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "resolutionUnitsImage_call" "', argument " "1"" of type '" "Magick::resolutionUnitsImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::resolutionUnitsImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "resolutionUnitsImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "resolutionUnitsImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::resolutionUnitsImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_resolutionUnitsImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::resolutionUnitsImage * arg1 = (Magick::resolutionUnitsImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_sceneImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  Magick::sceneImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_sceneImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_sceneImage.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_sceneImage" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  {
    try {
      result = (Magick::sceneImage *)new Magick::sceneImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__sceneImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_sceneImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::sceneImage *arg1 = (Magick::sceneImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_sceneImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__sceneImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "sceneImage_call" "', argument " "1"" of type '" "Magick::sceneImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::sceneImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "sceneImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "sceneImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::sceneImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_sceneImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::sceneImage * arg1 = (Magick::sceneImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_sigmoidalContrastImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  double arg2 ;
  double arg3 ;
  size_t val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  Magick::sigmoidalContrastImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_sigmoidalContrastImage__SWIG_0.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_sigmoidalContrastImage__SWIG_0.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_sigmoidalContrastImage" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_sigmoidalContrastImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_sigmoidalContrastImage" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      result = (Magick::sigmoidalContrastImage *)new Magick::sigmoidalContrastImage(arg1,arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__sigmoidalContrastImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_sigmoidalContrastImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  double arg2 ;
  size_t val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  Magick::sigmoidalContrastImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_sigmoidalContrastImage__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_sigmoidalContrastImage__SWIG_1.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_sigmoidalContrastImage" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_sigmoidalContrastImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      result = (Magick::sigmoidalContrastImage *)new Magick::sigmoidalContrastImage(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__sigmoidalContrastImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_sigmoidalContrastImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_sigmoidalContrastImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_sigmoidalContrastImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_sigmoidalContrastImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_sigmoidalContrastImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::sigmoidalContrastImage *arg1 = (Magick::sigmoidalContrastImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_sigmoidalContrastImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__sigmoidalContrastImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "sigmoidalContrastImage_call" "', argument " "1"" of type '" "Magick::sigmoidalContrastImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::sigmoidalContrastImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "sigmoidalContrastImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "sigmoidalContrastImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::sigmoidalContrastImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_sigmoidalContrastImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::sigmoidalContrastImage * arg1 = (Magick::sigmoidalContrastImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_sizeImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Geometry *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::sizeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_sizeImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_sizeImage.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_sizeImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_sizeImage" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  {
    try {
      result = (Magick::sizeImage *)new Magick::sizeImage((Magick::Geometry const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__sizeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_sizeImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::sizeImage *arg1 = (Magick::sizeImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_sizeImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__sizeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "sizeImage_call" "', argument " "1"" of type '" "Magick::sizeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::sizeImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "sizeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "sizeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::sizeImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_sizeImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::sizeImage * arg1 = (Magick::sizeImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_stripImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::stripImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_stripImage.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_stripImage.");
  {
    try {
      result = (Magick::stripImage *)new Magick::stripImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__stripImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_stripImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::stripImage *arg1 = (Magick::stripImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_stripImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__stripImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "stripImage_call" "', argument " "1"" of type '" "Magick::stripImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::stripImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "stripImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "stripImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::stripImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_stripImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::stripImage * arg1 = (Magick::stripImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_subImageImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  Magick::subImageImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_subImageImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_subImageImage.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_subImageImage" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  {
    try {
      result = (Magick::subImageImage *)new Magick::subImageImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__subImageImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_subImageImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::subImageImage *arg1 = (Magick::subImageImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_subImageImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__subImageImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "subImageImage_call" "', argument " "1"" of type '" "Magick::subImageImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::subImageImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "subImageImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "subImageImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::subImageImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_subImageImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::subImageImage * arg1 = (Magick::subImageImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_subRangeImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  Magick::subRangeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_subRangeImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_subRangeImage.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_subRangeImage" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  {
    try {
      result = (Magick::subRangeImage *)new Magick::subRangeImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__subRangeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_subRangeImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::subRangeImage *arg1 = (Magick::subRangeImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_subRangeImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__subRangeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "subRangeImage_call" "', argument " "1"" of type '" "Magick::subRangeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::subRangeImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "subRangeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "subRangeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::subRangeImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_subRangeImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::subRangeImage * arg1 = (Magick::subRangeImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_tileNameImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::tileNameImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_tileNameImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_tileNameImage.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_tileNameImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_tileNameImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::tileNameImage *)new Magick::tileNameImage((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__tileNameImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_tileNameImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::tileNameImage *arg1 = (Magick::tileNameImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_tileNameImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__tileNameImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "tileNameImage_call" "', argument " "1"" of type '" "Magick::tileNameImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::tileNameImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "tileNameImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "tileNameImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::tileNameImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_tileNameImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::tileNameImage * arg1 = (Magick::tileNameImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_typeImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::ImageType arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  Magick::typeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_typeImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_typeImage.");
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_typeImage" "', argument " "1"" of type '" "Magick::ImageType""'");
  } 
  arg1 = static_cast< Magick::ImageType >(val1);
  {
    try {
      result = (Magick::typeImage *)new Magick::typeImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__typeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_typeImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::typeImage *arg1 = (Magick::typeImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_typeImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__typeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "typeImage_call" "', argument " "1"" of type '" "Magick::typeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::typeImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "typeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "typeImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::typeImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_typeImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::typeImage * arg1 = (Magick::typeImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_verboseImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  Magick::verboseImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_verboseImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_verboseImage.");
  ecode1 = SWIG_AsVal_bool(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_verboseImage" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      result = (Magick::verboseImage *)new Magick::verboseImage(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__verboseImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_verboseImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::verboseImage *arg1 = (Magick::verboseImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_verboseImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__verboseImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "verboseImage_call" "', argument " "1"" of type '" "Magick::verboseImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::verboseImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "verboseImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "verboseImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::verboseImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_verboseImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::verboseImage * arg1 = (Magick::verboseImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_viewImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::viewImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_viewImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_viewImage.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_viewImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_viewImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::viewImage *)new Magick::viewImage((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__viewImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_viewImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::viewImage *arg1 = (Magick::viewImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_viewImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__viewImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "viewImage_call" "', argument " "1"" of type '" "Magick::viewImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::viewImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "viewImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "viewImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::viewImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_viewImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::viewImage * arg1 = (Magick::viewImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_x11DisplayImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::x11DisplayImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_x11DisplayImage.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_x11DisplayImage.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_x11DisplayImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_x11DisplayImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::x11DisplayImage *)new Magick::x11DisplayImage((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__x11DisplayImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_x11DisplayImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::x11DisplayImage *arg1 = (Magick::x11DisplayImage *) 0 ;
  Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_x11DisplayImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__x11DisplayImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "x11DisplayImage_call" "', argument " "1"" of type '" "Magick::x11DisplayImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::x11DisplayImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "x11DisplayImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "x11DisplayImage_call" "', argument " "2"" of type '" "Image &""'"); 
  }
  arg2 = reinterpret_cast< Image * >(argp2);
  {
    try {
      ((Magick::x11DisplayImage const *)arg1)->operator ()(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_x11DisplayImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::x11DisplayImage * arg1 = (Magick::x11DisplayImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_Magick_Blob_MallocAllocator(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  
  jsresult = SWIG_From_int(static_cast< int >(Magick::Blob::MallocAllocator));
  
  SWIGV8_RETURN_INFO(jsresult, info);
  
  goto fail;
fail:
  SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
}


static SwigV8ReturnValue _wrap_Magick_Blob_NewAllocator(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  
  jsresult = SWIG_From_int(static_cast< int >(Magick::Blob::NewAllocator));
  
  SWIGV8_RETURN_INFO(jsresult, info);
  
  goto fail;
fail:
  SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
}


static SwigV8ReturnValue _wrap_new_Blob__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Blob *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Blob__SWIG_0.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Blob__SWIG_0.");
  {
    try {
      result = (Magick::Blob *)new Magick::Blob();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Blob, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Blob__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  void *arg1 = (void *) 0 ;
  size_t arg2 ;
  int res1 ;
  size_t val2 ;
  int ecode2 = 0 ;
  Magick::Blob *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Blob__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Blob__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0],SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Blob" "', argument " "1"" of type '" "void const *""'"); 
  }
  ecode2 = SWIG_AsVal_size_t(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Blob" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      result = (Magick::Blob *)new Magick::Blob((void const *)arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Blob, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Blob__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Blob *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Blob *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Blob__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Blob__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Blob,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Blob" "', argument " "1"" of type '" "Magick::Blob const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Blob" "', argument " "1"" of type '" "Magick::Blob const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Blob * >(argp1);
  {
    try {
      result = (Magick::Blob *)new Magick::Blob((Magick::Blob const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Blob, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Blob(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_Blob__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_Blob__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_Blob__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_Blob");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_Blob(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::Blob * arg1 = (Magick::Blob *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_Blob_clone(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Blob *arg1 = (Magick::Blob *) 0 ;
  Magick::Blob *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::Blob *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Blob_clone.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Blob, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Blob_clone" "', argument " "1"" of type '" "Magick::Blob *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Blob * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Blob,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Blob_clone" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Blob_clone" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Blob * >(argp2);
  {
    try {
      result = (Magick::Blob *) &(arg1)->operator =((Magick::Blob const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__Blob, 0 |  0 );
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Blob_base64__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Blob *arg1 = (Magick::Blob *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Blob, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Blob_base64" "', argument " "1"" of type '" "Magick::Blob *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Blob * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Blob_base64" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      (arg1)->base64(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Blob_base64__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Blob *arg1 = (Magick::Blob *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Blob, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Blob_base64" "', argument " "1"" of type '" "Magick::Blob *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Blob * >(argp1);
  {
    try {
      result = (arg1)->base64();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Blob__wrap_Blob_base64(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Blob_base64__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Blob_base64__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function base64.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Blob_data(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Blob *arg1 = (Magick::Blob *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Blob_data.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Blob, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Blob_data" "', argument " "1"" of type '" "Magick::Blob const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Blob * >(argp1);
  {
    try {
      result = (void *)((Magick::Blob const *)arg1)->data();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Blob_length(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Blob *arg1 = (Magick::Blob *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Blob_length.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Blob, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Blob_length" "', argument " "1"" of type '" "Magick::Blob const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Blob * >(argp1);
  {
    try {
      result = ((Magick::Blob const *)arg1)->length();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Blob_update(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Blob *arg1 = (Magick::Blob *) 0 ;
  void *arg2 = (void *) 0 ;
  size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  size_t val3 ;
  int ecode3 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Blob_update.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Blob, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Blob_update" "', argument " "1"" of type '" "Magick::Blob *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Blob * >(argp1);
  res2 = SWIG_ConvertPtr(args[0],SWIG_as_voidptrptr(&arg2), 0, 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Blob_update" "', argument " "2"" of type '" "void const *""'"); 
  }
  ecode3 = SWIG_AsVal_size_t(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Blob_update" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  {
    try {
      (arg1)->update((void const *)arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Blob_updateNoCopy__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Blob *arg1 = (Magick::Blob *) 0 ;
  void *arg2 = (void *) 0 ;
  size_t arg3 ;
  Magick::Blob::Allocator arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  size_t val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Blob, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Blob_updateNoCopy" "', argument " "1"" of type '" "Magick::Blob *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Blob * >(argp1);
  res2 = SWIG_ConvertPtr(args[0],SWIG_as_voidptrptr(&arg2), 0, 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Blob_updateNoCopy" "', argument " "2"" of type '" "void *""'"); 
  }
  ecode3 = SWIG_AsVal_size_t(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Blob_updateNoCopy" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  ecode4 = SWIG_AsVal_int(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Blob_updateNoCopy" "', argument " "4"" of type '" "Magick::Blob::Allocator""'");
  } 
  arg4 = static_cast< Magick::Blob::Allocator >(val4);
  {
    try {
      (arg1)->updateNoCopy(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Blob_updateNoCopy__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Blob *arg1 = (Magick::Blob *) 0 ;
  void *arg2 = (void *) 0 ;
  size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  size_t val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Blob, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Blob_updateNoCopy" "', argument " "1"" of type '" "Magick::Blob *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Blob * >(argp1);
  res2 = SWIG_ConvertPtr(args[0],SWIG_as_voidptrptr(&arg2), 0, 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Blob_updateNoCopy" "', argument " "2"" of type '" "void *""'"); 
  }
  ecode3 = SWIG_AsVal_size_t(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Blob_updateNoCopy" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  {
    try {
      (arg1)->updateNoCopy(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Blob__wrap_Blob_updateNoCopy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Blob_updateNoCopy__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Blob_updateNoCopy__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function updateNoCopy.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ChannelMoments__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::ChannelMoments *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ChannelMoments__SWIG_0.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ChannelMoments__SWIG_0.");
  {
    try {
      result = (Magick::ChannelMoments *)new Magick::ChannelMoments();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ChannelMoments, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ChannelMoments__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::ChannelMoments *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::ChannelMoments *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ChannelMoments__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ChannelMoments__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__ChannelMoments,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ChannelMoments" "', argument " "1"" of type '" "Magick::ChannelMoments const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ChannelMoments" "', argument " "1"" of type '" "Magick::ChannelMoments const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::ChannelMoments * >(argp1);
  {
    try {
      result = (Magick::ChannelMoments *)new Magick::ChannelMoments((Magick::ChannelMoments const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ChannelMoments, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ChannelMoments(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ChannelMoments * arg1 = (Magick::ChannelMoments *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_ChannelMoments__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::ChannelType arg1 ;
  MagickCore::ChannelMoments *arg2 = (MagickCore::ChannelMoments *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::ChannelMoments *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ChannelMoments__SWIG_2.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ChannelMoments__SWIG_2.");
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_ChannelMoments" "', argument " "1"" of type '" "Magick::ChannelType""'");
  } 
  arg1 = static_cast< Magick::ChannelType >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_MagickCore___ChannelMoments, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ChannelMoments" "', argument " "2"" of type '" "MagickCore::ChannelMoments const *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::ChannelMoments * >(argp2);
  {
    try {
      result = (Magick::ChannelMoments *)new Magick::ChannelMoments(arg1,(MagickCore::ChannelMoments const *)arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ChannelMoments, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ChannelMoments(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_ChannelMoments__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ChannelMoments__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_ChannelMoments__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ChannelMoments");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ChannelMoments_centroidX(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ChannelMoments *arg1 = (Magick::ChannelMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_ChannelMoments_centroidX.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ChannelMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ChannelMoments_centroidX" "', argument " "1"" of type '" "Magick::ChannelMoments const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ChannelMoments * >(argp1);
  {
    try {
      result = (double)((Magick::ChannelMoments const *)arg1)->centroidX();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ChannelMoments_centroidY(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ChannelMoments *arg1 = (Magick::ChannelMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_ChannelMoments_centroidY.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ChannelMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ChannelMoments_centroidY" "', argument " "1"" of type '" "Magick::ChannelMoments const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ChannelMoments * >(argp1);
  {
    try {
      result = (double)((Magick::ChannelMoments const *)arg1)->centroidY();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ChannelMoments_channel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ChannelMoments *arg1 = (Magick::ChannelMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::ChannelType result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_ChannelMoments_channel.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ChannelMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ChannelMoments_channel" "', argument " "1"" of type '" "Magick::ChannelMoments const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ChannelMoments * >(argp1);
  {
    try {
      result = (Magick::ChannelType)((Magick::ChannelMoments const *)arg1)->channel();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ChannelMoments_ellipseAxisX(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ChannelMoments *arg1 = (Magick::ChannelMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_ChannelMoments_ellipseAxisX.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ChannelMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ChannelMoments_ellipseAxisX" "', argument " "1"" of type '" "Magick::ChannelMoments const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ChannelMoments * >(argp1);
  {
    try {
      result = (double)((Magick::ChannelMoments const *)arg1)->ellipseAxisX();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ChannelMoments_ellipseAxisY(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ChannelMoments *arg1 = (Magick::ChannelMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_ChannelMoments_ellipseAxisY.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ChannelMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ChannelMoments_ellipseAxisY" "', argument " "1"" of type '" "Magick::ChannelMoments const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ChannelMoments * >(argp1);
  {
    try {
      result = (double)((Magick::ChannelMoments const *)arg1)->ellipseAxisY();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ChannelMoments_ellipseAngle(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ChannelMoments *arg1 = (Magick::ChannelMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_ChannelMoments_ellipseAngle.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ChannelMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ChannelMoments_ellipseAngle" "', argument " "1"" of type '" "Magick::ChannelMoments const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ChannelMoments * >(argp1);
  {
    try {
      result = (double)((Magick::ChannelMoments const *)arg1)->ellipseAngle();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ChannelMoments_ellipseEccentricity(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ChannelMoments *arg1 = (Magick::ChannelMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_ChannelMoments_ellipseEccentricity.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ChannelMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ChannelMoments_ellipseEccentricity" "', argument " "1"" of type '" "Magick::ChannelMoments const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ChannelMoments * >(argp1);
  {
    try {
      result = (double)((Magick::ChannelMoments const *)arg1)->ellipseEccentricity();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ChannelMoments_ellipseIntensity(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ChannelMoments *arg1 = (Magick::ChannelMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_ChannelMoments_ellipseIntensity.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ChannelMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ChannelMoments_ellipseIntensity" "', argument " "1"" of type '" "Magick::ChannelMoments const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ChannelMoments * >(argp1);
  {
    try {
      result = (double)((Magick::ChannelMoments const *)arg1)->ellipseIntensity();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ChannelMoments_huInvariants(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ChannelMoments *arg1 = (Magick::ChannelMoments *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  double result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_ChannelMoments_huInvariants.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ChannelMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ChannelMoments_huInvariants" "', argument " "1"" of type '" "Magick::ChannelMoments const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ChannelMoments * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ChannelMoments_huInvariants" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      result = (double)((Magick::ChannelMoments const *)arg1)->huInvariants(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ImageMoments__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::ImageMoments *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ImageMoments__SWIG_0.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ImageMoments__SWIG_0.");
  {
    try {
      result = (Magick::ImageMoments *)new Magick::ImageMoments();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ImageMoments, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ImageMoments__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::ImageMoments *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::ImageMoments *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ImageMoments__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ImageMoments__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__ImageMoments,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ImageMoments" "', argument " "1"" of type '" "Magick::ImageMoments const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ImageMoments" "', argument " "1"" of type '" "Magick::ImageMoments const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::ImageMoments * >(argp1);
  {
    try {
      result = (Magick::ImageMoments *)new Magick::ImageMoments((Magick::ImageMoments const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ImageMoments, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ImageMoments(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ImageMoments * arg1 = (Magick::ImageMoments *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_ImageMoments_channel__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ImageMoments *arg1 = (Magick::ImageMoments *) 0 ;
  Magick::ChannelType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  Magick::ChannelMoments result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ImageMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageMoments_channel" "', argument " "1"" of type '" "Magick::ImageMoments const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ImageMoments * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ImageMoments_channel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  {
    try {
      result = ((Magick::ImageMoments const *)arg1)->channel(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::ChannelMoments(result)), SWIGTYPE_p_Magick__ChannelMoments, SWIG_POINTER_OWN |  0 );
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ImageMoments_channel__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ImageMoments *arg1 = (Magick::ImageMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::ChannelMoments result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ImageMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageMoments_channel" "', argument " "1"" of type '" "Magick::ImageMoments const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ImageMoments * >(argp1);
  {
    try {
      result = ((Magick::ImageMoments const *)arg1)->channel();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::ChannelMoments(result)), SWIGTYPE_p_Magick__ChannelMoments, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ImageMoments__wrap_ImageMoments_channel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_ImageMoments_channel__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_ImageMoments_channel__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function channel.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ImageMoments__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Image *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::ImageMoments *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ImageMoments__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ImageMoments__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ImageMoments" "', argument " "1"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ImageMoments" "', argument " "1"" of type '" "Magick::Image const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::ImageMoments *)new Magick::ImageMoments((Magick::Image const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ImageMoments, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ImageMoments(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_ImageMoments__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ImageMoments__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ImageMoments__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ImageMoments");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Magick_CoderInfo_header(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  
  jsresult = SWIG_From_int(static_cast< int >(1));
  
  SWIGV8_RETURN_INFO(jsresult, info);
  
  goto fail;
fail:
  SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
}


static SwigV8ReturnValue _wrap_Magick_CoderInfo_AnyMatch(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  
  jsresult = SWIG_From_int(static_cast< int >(Magick::CoderInfo::AnyMatch));
  
  SWIGV8_RETURN_INFO(jsresult, info);
  
  goto fail;
fail:
  SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
}


static SwigV8ReturnValue _wrap_Magick_CoderInfo_TrueMatch(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  
  jsresult = SWIG_From_int(static_cast< int >(Magick::CoderInfo::TrueMatch));
  
  SWIGV8_RETURN_INFO(jsresult, info);
  
  goto fail;
fail:
  SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
}


static SwigV8ReturnValue _wrap_Magick_CoderInfo_FalseMatch(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  
  jsresult = SWIG_From_int(static_cast< int >(Magick::CoderInfo::FalseMatch));
  
  SWIGV8_RETURN_INFO(jsresult, info);
  
  goto fail;
fail:
  SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
}


static SwigV8ReturnValue _wrap_new_CoderInfo__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::CoderInfo *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_CoderInfo__SWIG_0.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_CoderInfo__SWIG_0.");
  {
    try {
      result = (Magick::CoderInfo *)new Magick::CoderInfo();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__CoderInfo, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_CoderInfo__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::CoderInfo *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::CoderInfo *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_CoderInfo__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_CoderInfo__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__CoderInfo,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CoderInfo" "', argument " "1"" of type '" "Magick::CoderInfo const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CoderInfo" "', argument " "1"" of type '" "Magick::CoderInfo const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::CoderInfo * >(argp1);
  {
    try {
      result = (Magick::CoderInfo *)new Magick::CoderInfo((Magick::CoderInfo const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__CoderInfo, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_CoderInfo__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::CoderInfo *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_CoderInfo__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_CoderInfo__SWIG_2.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CoderInfo" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CoderInfo" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::CoderInfo *)new Magick::CoderInfo((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__CoderInfo, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_CoderInfo(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::CoderInfo * arg1 = (Magick::CoderInfo *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_CoderInfo_clone(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::CoderInfo *arg1 = (Magick::CoderInfo *) 0 ;
  Magick::CoderInfo *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::CoderInfo *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_CoderInfo_clone.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__CoderInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CoderInfo_clone" "', argument " "1"" of type '" "Magick::CoderInfo *""'"); 
  }
  arg1 = reinterpret_cast< Magick::CoderInfo * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__CoderInfo,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CoderInfo_clone" "', argument " "2"" of type '" "Magick::CoderInfo const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CoderInfo_clone" "', argument " "2"" of type '" "Magick::CoderInfo const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::CoderInfo * >(argp2);
  {
    try {
      result = (Magick::CoderInfo *) &(arg1)->operator =((Magick::CoderInfo const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__CoderInfo, 0 |  0 );
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_CoderInfo_description(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::CoderInfo *arg1 = (Magick::CoderInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_CoderInfo_description.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__CoderInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CoderInfo_description" "', argument " "1"" of type '" "Magick::CoderInfo const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::CoderInfo * >(argp1);
  {
    try {
      result = ((Magick::CoderInfo const *)arg1)->description();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_CoderInfo_isMultiFrame(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::CoderInfo *arg1 = (Magick::CoderInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_CoderInfo_isMultiFrame.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__CoderInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CoderInfo_isMultiFrame" "', argument " "1"" of type '" "Magick::CoderInfo const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::CoderInfo * >(argp1);
  {
    try {
      result = (bool)((Magick::CoderInfo const *)arg1)->isMultiFrame();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_CoderInfo_isReadable(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::CoderInfo *arg1 = (Magick::CoderInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_CoderInfo_isReadable.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__CoderInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CoderInfo_isReadable" "', argument " "1"" of type '" "Magick::CoderInfo const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::CoderInfo * >(argp1);
  {
    try {
      result = (bool)((Magick::CoderInfo const *)arg1)->isReadable();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_CoderInfo_isWritable(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::CoderInfo *arg1 = (Magick::CoderInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_CoderInfo_isWritable.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__CoderInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CoderInfo_isWritable" "', argument " "1"" of type '" "Magick::CoderInfo const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::CoderInfo * >(argp1);
  {
    try {
      result = (bool)((Magick::CoderInfo const *)arg1)->isWritable();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_CoderInfo_mimeType(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::CoderInfo *arg1 = (Magick::CoderInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_CoderInfo_mimeType.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__CoderInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CoderInfo_mimeType" "', argument " "1"" of type '" "Magick::CoderInfo const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::CoderInfo * >(argp1);
  {
    try {
      result = ((Magick::CoderInfo const *)arg1)->mimeType();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_CoderInfo_name(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::CoderInfo *arg1 = (Magick::CoderInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_CoderInfo_name.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__CoderInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CoderInfo_name" "', argument " "1"" of type '" "Magick::CoderInfo const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::CoderInfo * >(argp1);
  {
    try {
      result = ((Magick::CoderInfo const *)arg1)->name();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_CoderInfo_unregister(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::CoderInfo *arg1 = (Magick::CoderInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_CoderInfo_unregister.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__CoderInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CoderInfo_unregister" "', argument " "1"" of type '" "Magick::CoderInfo const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::CoderInfo * >(argp1);
  {
    try {
      result = (bool)((Magick::CoderInfo const *)arg1)->unregister();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_CoderInfo__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  MagickCore::MagickInfo *arg1 = (MagickCore::MagickInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::CoderInfo *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_CoderInfo__SWIG_3.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_CoderInfo__SWIG_3.");
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_MagickCore___MagickInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CoderInfo" "', argument " "1"" of type '" "MagickCore::MagickInfo const *""'"); 
  }
  arg1 = reinterpret_cast< MagickCore::MagickInfo * >(argp1);
  {
    try {
      result = (Magick::CoderInfo *)new Magick::CoderInfo((MagickCore::MagickInfo const *)arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__CoderInfo, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_CoderInfo(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_CoderInfo__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_CoderInfo__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_CoderInfo__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_CoderInfo__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_CoderInfo");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_equal__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Color *arg1 = 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equal" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equal" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      result = (int)Magick::operator ==((Magick::Color const &)*arg1,(Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_notEqual__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Color *arg1 = 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      result = (int)Magick::operator !=((Magick::Color const &)*arg1,(Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_gt__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Color *arg1 = 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gt" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gt" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      result = (int)Magick::operator >((Magick::Color const &)*arg1,(Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_lt__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Color *arg1 = 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lt" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lt" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      result = (int)Magick::operator <((Magick::Color const &)*arg1,(Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_gte__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Color *arg1 = 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gte" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gte" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      result = (int)Magick::operator >=((Magick::Color const &)*arg1,(Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_lte__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Color *arg1 = 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lte" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lte" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      result = (int)Magick::operator <=((Magick::Color const &)*arg1,(Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Color__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Color *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Color__SWIG_0.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Color__SWIG_0.");
  {
    try {
      result = (Magick::Color *)new Magick::Color();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Color__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Quantum arg1 ;
  Magick::Quantum arg2 ;
  Magick::Quantum arg3 ;
  unsigned short val1 ;
  int ecode1 = 0 ;
  unsigned short val2 ;
  int ecode2 = 0 ;
  unsigned short val3 ;
  int ecode3 = 0 ;
  Magick::Color *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Color__SWIG_1.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Color__SWIG_1.");
  ecode1 = SWIG_AsVal_unsigned_SS_short(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Color" "', argument " "1"" of type '" "Magick::Quantum""'");
  } 
  arg1 = static_cast< Magick::Quantum >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_short(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Color" "', argument " "2"" of type '" "Magick::Quantum""'");
  } 
  arg2 = static_cast< Magick::Quantum >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_short(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Color" "', argument " "3"" of type '" "Magick::Quantum""'");
  } 
  arg3 = static_cast< Magick::Quantum >(val3);
  {
    try {
      result = (Magick::Color *)new Magick::Color(arg1,arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Color__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Quantum arg1 ;
  Magick::Quantum arg2 ;
  Magick::Quantum arg3 ;
  Magick::Quantum arg4 ;
  unsigned short val1 ;
  int ecode1 = 0 ;
  unsigned short val2 ;
  int ecode2 = 0 ;
  unsigned short val3 ;
  int ecode3 = 0 ;
  unsigned short val4 ;
  int ecode4 = 0 ;
  Magick::Color *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Color__SWIG_2.");
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Color__SWIG_2.");
  ecode1 = SWIG_AsVal_unsigned_SS_short(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Color" "', argument " "1"" of type '" "Magick::Quantum""'");
  } 
  arg1 = static_cast< Magick::Quantum >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_short(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Color" "', argument " "2"" of type '" "Magick::Quantum""'");
  } 
  arg2 = static_cast< Magick::Quantum >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_short(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Color" "', argument " "3"" of type '" "Magick::Quantum""'");
  } 
  arg3 = static_cast< Magick::Quantum >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_short(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_Color" "', argument " "4"" of type '" "Magick::Quantum""'");
  } 
  arg4 = static_cast< Magick::Quantum >(val4);
  {
    try {
      result = (Magick::Color *)new Magick::Color(arg1,arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Color__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  Magick::Color *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Color__SWIG_3.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Color__SWIG_3.");
  res1 = SWIG_AsCharPtrAndSize(args[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Color" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (Magick::Color *)new Magick::Color((char const *)arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Color__SWIG_4(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Color *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Color *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Color__SWIG_4.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Color__SWIG_4.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Color" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Color" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  {
    try {
      result = (Magick::Color *)new Magick::Color((Magick::Color const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Color__SWIG_5(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  PixelPacket *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Color *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Color__SWIG_5.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Color__SWIG_5.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_PixelPacket,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Color" "', argument " "1"" of type '" "PixelPacket const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Color" "', argument " "1"" of type '" "PixelPacket const &""'"); 
  }
  arg1 = reinterpret_cast< PixelPacket * >(argp1);
  {
    try {
      result = (Magick::Color *)new Magick::Color((PixelPacket const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Color__SWIG_6(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::Color *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Color__SWIG_6.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Color__SWIG_6.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Color" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Color" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::Color *)new Magick::Color((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Color(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_Color__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_Color__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_new_Color__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_Color__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_Color__SWIG_4(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_Color__SWIG_5(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_Color__SWIG_6(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_Color");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_Color(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::Color * arg1 = (Magick::Color *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_Color_clone__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Color *arg1 = (Magick::Color *) 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::Color *result = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Color, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Color_clone" "', argument " "1"" of type '" "Magick::Color *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Color_clone" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Color_clone" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      result = (Magick::Color *) &(arg1)->operator =((Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__Color, 0 |  0 );
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Color_clone__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Color *arg1 = (Magick::Color *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  Magick::Color *result = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Color, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Color_clone" "', argument " "1"" of type '" "Magick::Color *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(args[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Color_clone" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (Magick::Color *) &(arg1)->operator =((char const *)arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__Color, 0 |  0 );
  
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Color_clone__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Color *arg1 = (Magick::Color *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Magick::Color *result = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Color, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Color_clone" "', argument " "1"" of type '" "Magick::Color *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Color_clone" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Color_clone" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      result = (Magick::Color *) &(arg1)->operator =((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__Color, 0 |  0 );
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Color_clone__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Color *arg1 = (Magick::Color *) 0 ;
  PixelPacket *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::Color *result = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Color, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Color_clone" "', argument " "1"" of type '" "Magick::Color *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_PixelPacket,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Color_clone" "', argument " "2"" of type '" "PixelPacket const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Color_clone" "', argument " "2"" of type '" "PixelPacket const &""'"); 
  }
  arg2 = reinterpret_cast< PixelPacket * >(argp2);
  {
    try {
      result = (Magick::Color *) &(arg1)->operator =((PixelPacket const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__Color, 0 |  0 );
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Color__wrap_Color_clone(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Color_clone__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Color_clone__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Color_clone__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Color_clone__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function clone.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Color_alpha__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Color *arg1 = (Magick::Color *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Color, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Color_alpha" "', argument " "1"" of type '" "Magick::Color *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Color_alpha" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->alpha(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Color_alpha__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Color *arg1 = (Magick::Color *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Color, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Color_alpha" "', argument " "1"" of type '" "Magick::Color const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  {
    try {
      result = (double)((Magick::Color const *)arg1)->alpha();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Color__wrap_Color_alpha(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Color_alpha__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Color_alpha__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function alpha.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Color_alphaQuantum__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Color *arg1 = (Magick::Color *) 0 ;
  Magick::Quantum arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned short val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Color, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Color_alphaQuantum" "', argument " "1"" of type '" "Magick::Color *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_short(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Color_alphaQuantum" "', argument " "2"" of type '" "Magick::Quantum""'");
  } 
  arg2 = static_cast< Magick::Quantum >(val2);
  {
    try {
      (arg1)->alphaQuantum(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Color_alphaQuantum__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Color *arg1 = (Magick::Color *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Quantum result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Color, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Color_alphaQuantum" "', argument " "1"" of type '" "Magick::Color const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  {
    try {
      result = (Magick::Quantum)((Magick::Color const *)arg1)->alphaQuantum();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Color__wrap_Color_alphaQuantum(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Color_alphaQuantum__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Color_alphaQuantum__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function alphaQuantum.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Color_blueQuantum__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Color *arg1 = (Magick::Color *) 0 ;
  Magick::Quantum arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned short val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Color, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Color_blueQuantum" "', argument " "1"" of type '" "Magick::Color *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_short(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Color_blueQuantum" "', argument " "2"" of type '" "Magick::Quantum""'");
  } 
  arg2 = static_cast< Magick::Quantum >(val2);
  {
    try {
      (arg1)->blueQuantum(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Color_blueQuantum__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Color *arg1 = (Magick::Color *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Quantum result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Color, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Color_blueQuantum" "', argument " "1"" of type '" "Magick::Color const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  {
    try {
      result = (Magick::Quantum)((Magick::Color const *)arg1)->blueQuantum();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Color__wrap_Color_blueQuantum(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Color_blueQuantum__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Color_blueQuantum__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function blueQuantum.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Color_greenQuantum__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Color *arg1 = (Magick::Color *) 0 ;
  Magick::Quantum arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned short val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Color, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Color_greenQuantum" "', argument " "1"" of type '" "Magick::Color *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_short(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Color_greenQuantum" "', argument " "2"" of type '" "Magick::Quantum""'");
  } 
  arg2 = static_cast< Magick::Quantum >(val2);
  {
    try {
      (arg1)->greenQuantum(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Color_greenQuantum__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Color *arg1 = (Magick::Color *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Quantum result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Color, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Color_greenQuantum" "', argument " "1"" of type '" "Magick::Color const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  {
    try {
      result = (Magick::Quantum)((Magick::Color const *)arg1)->greenQuantum();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Color__wrap_Color_greenQuantum(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Color_greenQuantum__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Color_greenQuantum__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function greenQuantum.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Color_isValid__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Color *arg1 = (Magick::Color *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Color, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Color_isValid" "', argument " "1"" of type '" "Magick::Color *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Color_isValid" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->isValid(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Color_isValid__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Color *arg1 = (Magick::Color *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Color, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Color_isValid" "', argument " "1"" of type '" "Magick::Color const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  {
    try {
      result = (bool)((Magick::Color const *)arg1)->isValid();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Color__wrap_Color_isValid(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Color_isValid__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Color_isValid__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function isValid.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Color_redQuantum__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Color *arg1 = (Magick::Color *) 0 ;
  Magick::Quantum arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned short val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Color, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Color_redQuantum" "', argument " "1"" of type '" "Magick::Color *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_short(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Color_redQuantum" "', argument " "2"" of type '" "Magick::Quantum""'");
  } 
  arg2 = static_cast< Magick::Quantum >(val2);
  {
    try {
      (arg1)->redQuantum(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Color_redQuantum__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Color *arg1 = (Magick::Color *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Quantum result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Color, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Color_redQuantum" "', argument " "1"" of type '" "Magick::Color const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  {
    try {
      result = (Magick::Quantum)((Magick::Color const *)arg1)->redQuantum();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Color__wrap_Color_redQuantum(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Color_redQuantum__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Color_redQuantum__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function redQuantum.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Color_intensity(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Color *arg1 = (Magick::Color *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Color_intensity.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Color, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Color_intensity" "', argument " "1"" of type '" "Magick::Color const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  {
    try {
      result = (double)((Magick::Color const *)arg1)->intensity();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Color_scaleDoubleToQuantum(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::Quantum result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Color_scaleDoubleToQuantum.");
  
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "Color_scaleDoubleToQuantum" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::Quantum)Magick::Color::scaleDoubleToQuantum(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Color_scaleQuantumToDouble(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Quantum arg1 ;
  unsigned short val1 ;
  int ecode1 = 0 ;
  double result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Color_scaleQuantumToDouble.");
  
  ecode1 = SWIG_AsVal_unsigned_SS_short(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "Color_scaleQuantumToDouble" "', argument " "1"" of type '" "Magick::Quantum""'");
  } 
  arg1 = static_cast< Magick::Quantum >(val1);
  {
    try {
      result = (double)Magick::Color::scaleQuantumToDouble(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ColorGray__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::ColorGray *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ColorGray__SWIG_0.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ColorGray__SWIG_0.");
  {
    try {
      result = (Magick::ColorGray *)new Magick::ColorGray();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ColorGray, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ColorGray__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Color *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::ColorGray *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ColorGray__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ColorGray__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ColorGray" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ColorGray" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  {
    try {
      result = (Magick::ColorGray *)new Magick::ColorGray((Magick::Color const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ColorGray, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ColorGray__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::ColorGray *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ColorGray__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ColorGray__SWIG_2.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_ColorGray" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::ColorGray *)new Magick::ColorGray(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ColorGray, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ColorGray(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_ColorGray__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ColorGray__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ColorGray__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ColorGray");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ColorGray(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ColorGray * arg1 = (Magick::ColorGray *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_ColorGray_shade__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorGray *arg1 = (Magick::ColorGray *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorGray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorGray_shade" "', argument " "1"" of type '" "Magick::ColorGray *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorGray * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ColorGray_shade" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->shade(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorGray_shade__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorGray *arg1 = (Magick::ColorGray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorGray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorGray_shade" "', argument " "1"" of type '" "Magick::ColorGray const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorGray * >(argp1);
  {
    try {
      result = (double)((Magick::ColorGray const *)arg1)->shade();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorGray__wrap_ColorGray_shade(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_ColorGray_shade__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_ColorGray_shade__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function shade.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorGray_clone(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorGray *arg1 = (Magick::ColorGray *) 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::ColorGray *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_ColorGray_clone.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorGray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorGray_clone" "', argument " "1"" of type '" "Magick::ColorGray *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorGray * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ColorGray_clone" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ColorGray_clone" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      result = (Magick::ColorGray *) &(arg1)->operator =((Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__ColorGray, 0 |  0 );
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ColorHSL__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::ColorHSL *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ColorHSL__SWIG_0.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ColorHSL__SWIG_0.");
  {
    try {
      result = (Magick::ColorHSL *)new Magick::ColorHSL();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ColorHSL, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ColorHSL__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Color *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::ColorHSL *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ColorHSL__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ColorHSL__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ColorHSL" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ColorHSL" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  {
    try {
      result = (Magick::ColorHSL *)new Magick::ColorHSL((Magick::Color const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ColorHSL, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ColorHSL__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  Magick::ColorHSL *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ColorHSL__SWIG_2.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ColorHSL__SWIG_2.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_ColorHSL" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_ColorHSL" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_ColorHSL" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      result = (Magick::ColorHSL *)new Magick::ColorHSL(arg1,arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ColorHSL, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ColorHSL(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_ColorHSL__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ColorHSL__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_ColorHSL__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ColorHSL");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ColorHSL(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ColorHSL * arg1 = (Magick::ColorHSL *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_ColorHSL_clone(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorHSL *arg1 = (Magick::ColorHSL *) 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::ColorHSL *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_ColorHSL_clone.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorHSL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorHSL_clone" "', argument " "1"" of type '" "Magick::ColorHSL *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorHSL * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ColorHSL_clone" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ColorHSL_clone" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      result = (Magick::ColorHSL *) &(arg1)->operator =((Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__ColorHSL, 0 |  0 );
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorHSL_hue__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorHSL *arg1 = (Magick::ColorHSL *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorHSL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorHSL_hue" "', argument " "1"" of type '" "Magick::ColorHSL *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorHSL * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ColorHSL_hue" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->hue(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorHSL_hue__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorHSL *arg1 = (Magick::ColorHSL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorHSL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorHSL_hue" "', argument " "1"" of type '" "Magick::ColorHSL const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorHSL * >(argp1);
  {
    try {
      result = (double)((Magick::ColorHSL const *)arg1)->hue();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorHSL__wrap_ColorHSL_hue(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_ColorHSL_hue__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_ColorHSL_hue__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function hue.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorHSL_luminosity__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorHSL *arg1 = (Magick::ColorHSL *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorHSL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorHSL_luminosity" "', argument " "1"" of type '" "Magick::ColorHSL *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorHSL * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ColorHSL_luminosity" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->luminosity(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorHSL_luminosity__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorHSL *arg1 = (Magick::ColorHSL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorHSL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorHSL_luminosity" "', argument " "1"" of type '" "Magick::ColorHSL const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorHSL * >(argp1);
  {
    try {
      result = (double)((Magick::ColorHSL const *)arg1)->luminosity();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorHSL__wrap_ColorHSL_luminosity(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_ColorHSL_luminosity__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_ColorHSL_luminosity__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function luminosity.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorHSL_saturation__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorHSL *arg1 = (Magick::ColorHSL *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorHSL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorHSL_saturation" "', argument " "1"" of type '" "Magick::ColorHSL *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorHSL * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ColorHSL_saturation" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->saturation(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorHSL_saturation__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorHSL *arg1 = (Magick::ColorHSL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorHSL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorHSL_saturation" "', argument " "1"" of type '" "Magick::ColorHSL const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorHSL * >(argp1);
  {
    try {
      result = (double)((Magick::ColorHSL const *)arg1)->saturation();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorHSL__wrap_ColorHSL_saturation(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_ColorHSL_saturation__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_ColorHSL_saturation__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function saturation.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ColorMono__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::ColorMono *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ColorMono__SWIG_0.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ColorMono__SWIG_0.");
  {
    try {
      result = (Magick::ColorMono *)new Magick::ColorMono();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ColorMono, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ColorMono__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  Magick::ColorMono *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ColorMono__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ColorMono__SWIG_1.");
  ecode1 = SWIG_AsVal_bool(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_ColorMono" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      result = (Magick::ColorMono *)new Magick::ColorMono(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ColorMono, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ColorMono__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Color *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::ColorMono *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ColorMono__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ColorMono__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ColorMono" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ColorMono" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  {
    try {
      result = (Magick::ColorMono *)new Magick::ColorMono((Magick::Color const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ColorMono, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ColorMono(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_ColorMono__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ColorMono__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ColorMono__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ColorMono");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ColorMono(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ColorMono * arg1 = (Magick::ColorMono *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_ColorMono_clone(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorMono *arg1 = (Magick::ColorMono *) 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::ColorMono *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_ColorMono_clone.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorMono, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorMono_clone" "', argument " "1"" of type '" "Magick::ColorMono *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorMono * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ColorMono_clone" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ColorMono_clone" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      result = (Magick::ColorMono *) &(arg1)->operator =((Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__ColorMono, 0 |  0 );
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorMono_mono__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorMono *arg1 = (Magick::ColorMono *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorMono, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorMono_mono" "', argument " "1"" of type '" "Magick::ColorMono *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorMono * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ColorMono_mono" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->mono(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorMono_mono__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorMono *arg1 = (Magick::ColorMono *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorMono, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorMono_mono" "', argument " "1"" of type '" "Magick::ColorMono const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorMono * >(argp1);
  {
    try {
      result = (bool)((Magick::ColorMono const *)arg1)->mono();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorMono__wrap_ColorMono_mono(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_ColorMono_mono__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_ColorMono_mono__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function mono.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ColorRGB__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::ColorRGB *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ColorRGB__SWIG_0.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ColorRGB__SWIG_0.");
  {
    try {
      result = (Magick::ColorRGB *)new Magick::ColorRGB();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ColorRGB, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ColorRGB__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Color *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::ColorRGB *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ColorRGB__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ColorRGB__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ColorRGB" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ColorRGB" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  {
    try {
      result = (Magick::ColorRGB *)new Magick::ColorRGB((Magick::Color const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ColorRGB, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ColorRGB__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  Magick::ColorRGB *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ColorRGB__SWIG_2.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ColorRGB__SWIG_2.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_ColorRGB" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_ColorRGB" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_ColorRGB" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      result = (Magick::ColorRGB *)new Magick::ColorRGB(arg1,arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ColorRGB, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ColorRGB(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_ColorRGB__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ColorRGB__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_ColorRGB__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ColorRGB");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ColorRGB(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ColorRGB * arg1 = (Magick::ColorRGB *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_ColorRGB_clone(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorRGB *arg1 = (Magick::ColorRGB *) 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::ColorRGB *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_ColorRGB_clone.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorRGB, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorRGB_clone" "', argument " "1"" of type '" "Magick::ColorRGB *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorRGB * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ColorRGB_clone" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ColorRGB_clone" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      result = (Magick::ColorRGB *) &(arg1)->operator =((Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__ColorRGB, 0 |  0 );
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorRGB_blue__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorRGB *arg1 = (Magick::ColorRGB *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorRGB, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorRGB_blue" "', argument " "1"" of type '" "Magick::ColorRGB *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorRGB * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ColorRGB_blue" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->blue(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorRGB_blue__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorRGB *arg1 = (Magick::ColorRGB *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorRGB, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorRGB_blue" "', argument " "1"" of type '" "Magick::ColorRGB const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorRGB * >(argp1);
  {
    try {
      result = (double)((Magick::ColorRGB const *)arg1)->blue();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorRGB__wrap_ColorRGB_blue(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_ColorRGB_blue__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_ColorRGB_blue__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function blue.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorRGB_green__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorRGB *arg1 = (Magick::ColorRGB *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorRGB, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorRGB_green" "', argument " "1"" of type '" "Magick::ColorRGB *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorRGB * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ColorRGB_green" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->green(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorRGB_green__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorRGB *arg1 = (Magick::ColorRGB *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorRGB, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorRGB_green" "', argument " "1"" of type '" "Magick::ColorRGB const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorRGB * >(argp1);
  {
    try {
      result = (double)((Magick::ColorRGB const *)arg1)->green();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorRGB__wrap_ColorRGB_green(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_ColorRGB_green__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_ColorRGB_green__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function green.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorRGB_red__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorRGB *arg1 = (Magick::ColorRGB *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorRGB, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorRGB_red" "', argument " "1"" of type '" "Magick::ColorRGB *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorRGB * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ColorRGB_red" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->red(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorRGB_red__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorRGB *arg1 = (Magick::ColorRGB *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorRGB, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorRGB_red" "', argument " "1"" of type '" "Magick::ColorRGB const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorRGB * >(argp1);
  {
    try {
      result = (double)((Magick::ColorRGB const *)arg1)->red();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorRGB__wrap_ColorRGB_red(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_ColorRGB_red__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_ColorRGB_red__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function red.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ColorYUV__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::ColorYUV *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ColorYUV__SWIG_0.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ColorYUV__SWIG_0.");
  {
    try {
      result = (Magick::ColorYUV *)new Magick::ColorYUV();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ColorYUV, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ColorYUV__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Color *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::ColorYUV *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ColorYUV__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ColorYUV__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ColorYUV" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ColorYUV" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  {
    try {
      result = (Magick::ColorYUV *)new Magick::ColorYUV((Magick::Color const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ColorYUV, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ColorYUV__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  Magick::ColorYUV *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ColorYUV__SWIG_2.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ColorYUV__SWIG_2.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_ColorYUV" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_ColorYUV" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_ColorYUV" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      result = (Magick::ColorYUV *)new Magick::ColorYUV(arg1,arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ColorYUV, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ColorYUV(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_ColorYUV__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ColorYUV__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_ColorYUV__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ColorYUV");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ColorYUV(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ColorYUV * arg1 = (Magick::ColorYUV *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_ColorYUV_clone(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorYUV *arg1 = (Magick::ColorYUV *) 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::ColorYUV *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_ColorYUV_clone.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorYUV, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorYUV_clone" "', argument " "1"" of type '" "Magick::ColorYUV *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorYUV * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ColorYUV_clone" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ColorYUV_clone" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      result = (Magick::ColorYUV *) &(arg1)->operator =((Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__ColorYUV, 0 |  0 );
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorYUV_u__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorYUV *arg1 = (Magick::ColorYUV *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorYUV, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorYUV_u" "', argument " "1"" of type '" "Magick::ColorYUV *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorYUV * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ColorYUV_u" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->u(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorYUV_u__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorYUV *arg1 = (Magick::ColorYUV *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorYUV, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorYUV_u" "', argument " "1"" of type '" "Magick::ColorYUV const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorYUV * >(argp1);
  {
    try {
      result = (double)((Magick::ColorYUV const *)arg1)->u();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorYUV__wrap_ColorYUV_u(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_ColorYUV_u__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_ColorYUV_u__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function u.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorYUV_v__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorYUV *arg1 = (Magick::ColorYUV *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorYUV, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorYUV_v" "', argument " "1"" of type '" "Magick::ColorYUV *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorYUV * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ColorYUV_v" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->v(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorYUV_v__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorYUV *arg1 = (Magick::ColorYUV *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorYUV, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorYUV_v" "', argument " "1"" of type '" "Magick::ColorYUV const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorYUV * >(argp1);
  {
    try {
      result = (double)((Magick::ColorYUV const *)arg1)->v();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorYUV__wrap_ColorYUV_v(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_ColorYUV_v__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_ColorYUV_v__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function v.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorYUV_y__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorYUV *arg1 = (Magick::ColorYUV *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorYUV, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorYUV_y" "', argument " "1"" of type '" "Magick::ColorYUV *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorYUV * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ColorYUV_y" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->y(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorYUV_y__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::ColorYUV *arg1 = (Magick::ColorYUV *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__ColorYUV, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColorYUV_y" "', argument " "1"" of type '" "Magick::ColorYUV const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::ColorYUV * >(argp1);
  {
    try {
      result = (double)((Magick::ColorYUV const *)arg1)->y();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_ColorYUV__wrap_ColorYUV_y(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_ColorYUV_y__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_ColorYUV_y__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function y.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Coordinate__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Coordinate *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Coordinate__SWIG_0.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Coordinate__SWIG_0.");
  {
    try {
      result = (Magick::Coordinate *)new Magick::Coordinate();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Coordinate, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Coordinate__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  Magick::Coordinate *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Coordinate__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Coordinate__SWIG_1.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Coordinate" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Coordinate" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      result = (Magick::Coordinate *)new Magick::Coordinate(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Coordinate, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Coordinate(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_Coordinate__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_Coordinate__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_Coordinate");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_Coordinate(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::Coordinate * arg1 = (Magick::Coordinate *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_Coordinate_x__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Coordinate *arg1 = (Magick::Coordinate *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Coordinate, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Coordinate_x" "', argument " "1"" of type '" "Magick::Coordinate *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Coordinate * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Coordinate_x" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->x(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Coordinate_x__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Coordinate *arg1 = (Magick::Coordinate *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Coordinate, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Coordinate_x" "', argument " "1"" of type '" "Magick::Coordinate const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Coordinate * >(argp1);
  {
    try {
      result = (double)((Magick::Coordinate const *)arg1)->x();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Coordinate__wrap_Coordinate_x(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Coordinate_x__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Coordinate_x__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function x.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Coordinate_y__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Coordinate *arg1 = (Magick::Coordinate *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Coordinate, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Coordinate_y" "', argument " "1"" of type '" "Magick::Coordinate *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Coordinate * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Coordinate_y" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->y(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Coordinate_y__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Coordinate *arg1 = (Magick::Coordinate *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Coordinate, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Coordinate_y" "', argument " "1"" of type '" "Magick::Coordinate const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Coordinate * >(argp1);
  {
    try {
      result = (double)((Magick::Coordinate const *)arg1)->y();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Coordinate__wrap_Coordinate_y(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Coordinate_y__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Coordinate_y__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function y.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_equal__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Coordinate *arg1 = 0 ;
  Magick::Coordinate *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Coordinate,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equal" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Coordinate * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Coordinate,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equal" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Coordinate * >(argp2);
  {
    try {
      result = (int)Magick::operator ==((Magick::Coordinate const &)*arg1,(Magick::Coordinate const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_notEqual__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Coordinate *arg1 = 0 ;
  Magick::Coordinate *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Coordinate,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Coordinate * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Coordinate,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Coordinate * >(argp2);
  {
    try {
      result = (int)Magick::operator !=((Magick::Coordinate const &)*arg1,(Magick::Coordinate const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_gt__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Coordinate *arg1 = 0 ;
  Magick::Coordinate *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Coordinate,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gt" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Coordinate * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Coordinate,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gt" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Coordinate * >(argp2);
  {
    try {
      result = (int)Magick::operator >((Magick::Coordinate const &)*arg1,(Magick::Coordinate const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_lt__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Coordinate *arg1 = 0 ;
  Magick::Coordinate *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Coordinate,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lt" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Coordinate * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Coordinate,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lt" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Coordinate * >(argp2);
  {
    try {
      result = (int)Magick::operator <((Magick::Coordinate const &)*arg1,(Magick::Coordinate const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_gte__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Coordinate *arg1 = 0 ;
  Magick::Coordinate *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Coordinate,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gte" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Coordinate * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Coordinate,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gte" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Coordinate * >(argp2);
  {
    try {
      result = (int)Magick::operator >=((Magick::Coordinate const &)*arg1,(Magick::Coordinate const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_lte__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Coordinate *arg1 = 0 ;
  Magick::Coordinate *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Coordinate,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lte" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Coordinate * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Coordinate,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lte" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Coordinate * >(argp2);
  {
    try {
      result = (int)Magick::operator <=((Magick::Coordinate const &)*arg1,(Magick::Coordinate const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableBase(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableBase * arg1 = (Magick::DrawableBase *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableBase_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableBase *arg1 = (Magick::DrawableBase *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableBase_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableBase_call" "', argument " "1"" of type '" "Magick::DrawableBase const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableBase * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableBase_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableBase const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableBase_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableBase *arg1 = (Magick::DrawableBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableBase_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableBase_copy" "', argument " "1"" of type '" "Magick::DrawableBase const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableBase * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableBase const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_veto_DrawableBase(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIG_exception(SWIG_ERROR, "Class DrawableBase can not be instantiated");
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Drawable__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Drawable *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Drawable__SWIG_0.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Drawable__SWIG_0.");
  {
    try {
      result = (Magick::Drawable *)new Magick::Drawable();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Drawable, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Drawable__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::DrawableBase *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Drawable *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Drawable__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Drawable__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__DrawableBase,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Drawable" "', argument " "1"" of type '" "Magick::DrawableBase const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Drawable" "', argument " "1"" of type '" "Magick::DrawableBase const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableBase * >(argp1);
  {
    try {
      result = (Magick::Drawable *)new Magick::Drawable((Magick::DrawableBase const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Drawable, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_Drawable(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::Drawable * arg1 = (Magick::Drawable *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_Drawable__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Drawable *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Drawable *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Drawable__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Drawable__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Drawable,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Drawable" "', argument " "1"" of type '" "Magick::Drawable const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Drawable" "', argument " "1"" of type '" "Magick::Drawable const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Drawable * >(argp1);
  {
    try {
      result = (Magick::Drawable *)new Magick::Drawable((Magick::Drawable const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Drawable, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Drawable(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_Drawable__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_Drawable__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_Drawable__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_Drawable");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Drawable_clone(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Drawable *arg1 = (Magick::Drawable *) 0 ;
  Magick::Drawable *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::Drawable *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Drawable_clone.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Drawable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Drawable_clone" "', argument " "1"" of type '" "Magick::Drawable *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Drawable * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Drawable,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Drawable_clone" "', argument " "2"" of type '" "Magick::Drawable const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Drawable_clone" "', argument " "2"" of type '" "Magick::Drawable const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Drawable * >(argp2);
  {
    try {
      result = (Magick::Drawable *) &(arg1)->operator =((Magick::Drawable const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__Drawable, 0 |  0 );
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Drawable_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Drawable *arg1 = (Magick::Drawable *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Drawable_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Drawable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Drawable_call" "', argument " "1"" of type '" "Magick::Drawable const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Drawable * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Drawable_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::Drawable const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_equal__SWIG_4(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Drawable *arg1 = 0 ;
  Magick::Drawable *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Drawable,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equal" "', argument " "1"" of type '" "Magick::Drawable const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "1"" of type '" "Magick::Drawable const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Drawable * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Drawable,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equal" "', argument " "2"" of type '" "Magick::Drawable const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "2"" of type '" "Magick::Drawable const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Drawable * >(argp2);
  {
    try {
      result = (int)Magick::operator ==((Magick::Drawable const &)*arg1,(Magick::Drawable const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_notEqual__SWIG_4(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Drawable *arg1 = 0 ;
  Magick::Drawable *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Drawable,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Drawable const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Drawable const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Drawable * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Drawable,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Drawable const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Drawable const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Drawable * >(argp2);
  {
    try {
      result = (int)Magick::operator !=((Magick::Drawable const &)*arg1,(Magick::Drawable const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_gt__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Drawable *arg1 = 0 ;
  Magick::Drawable *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Drawable,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gt" "', argument " "1"" of type '" "Magick::Drawable const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "1"" of type '" "Magick::Drawable const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Drawable * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Drawable,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gt" "', argument " "2"" of type '" "Magick::Drawable const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "2"" of type '" "Magick::Drawable const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Drawable * >(argp2);
  {
    try {
      result = (int)Magick::operator >((Magick::Drawable const &)*arg1,(Magick::Drawable const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_lt__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Drawable *arg1 = 0 ;
  Magick::Drawable *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Drawable,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lt" "', argument " "1"" of type '" "Magick::Drawable const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "1"" of type '" "Magick::Drawable const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Drawable * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Drawable,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lt" "', argument " "2"" of type '" "Magick::Drawable const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "2"" of type '" "Magick::Drawable const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Drawable * >(argp2);
  {
    try {
      result = (int)Magick::operator <((Magick::Drawable const &)*arg1,(Magick::Drawable const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_gte__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Drawable *arg1 = 0 ;
  Magick::Drawable *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Drawable,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gte" "', argument " "1"" of type '" "Magick::Drawable const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "1"" of type '" "Magick::Drawable const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Drawable * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Drawable,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gte" "', argument " "2"" of type '" "Magick::Drawable const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "2"" of type '" "Magick::Drawable const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Drawable * >(argp2);
  {
    try {
      result = (int)Magick::operator >=((Magick::Drawable const &)*arg1,(Magick::Drawable const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_lte__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Drawable *arg1 = 0 ;
  Magick::Drawable *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Drawable,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lte" "', argument " "1"" of type '" "Magick::Drawable const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "1"" of type '" "Magick::Drawable const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Drawable * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Drawable,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lte" "', argument " "2"" of type '" "Magick::Drawable const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "2"" of type '" "Magick::Drawable const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Drawable * >(argp2);
  {
    try {
      result = (int)Magick::operator <=((Magick::Drawable const &)*arg1,(Magick::Drawable const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_VPathBase(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::VPathBase * arg1 = (Magick::VPathBase *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_VPathBase_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::VPathBase *arg1 = (Magick::VPathBase *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_VPathBase_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__VPathBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VPathBase_call" "', argument " "1"" of type '" "Magick::VPathBase const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::VPathBase * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VPathBase_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::VPathBase const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_VPathBase_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::VPathBase *arg1 = (Magick::VPathBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::VPathBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_VPathBase_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__VPathBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VPathBase_copy" "', argument " "1"" of type '" "Magick::VPathBase const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::VPathBase * >(argp1);
  {
    try {
      result = (Magick::VPathBase *)((Magick::VPathBase const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__VPathBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_veto_VPathBase(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIG_exception(SWIG_ERROR, "Class VPathBase can not be instantiated");
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_VPath__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::VPath *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_VPath__SWIG_0.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_VPath__SWIG_0.");
  {
    try {
      result = (Magick::VPath *)new Magick::VPath();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__VPath, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_VPath__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::VPathBase *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::VPath *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_VPath__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_VPath__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__VPathBase,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_VPath" "', argument " "1"" of type '" "Magick::VPathBase const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_VPath" "', argument " "1"" of type '" "Magick::VPathBase const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::VPathBase * >(argp1);
  {
    try {
      result = (Magick::VPath *)new Magick::VPath((Magick::VPathBase const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__VPath, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_VPath(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::VPath * arg1 = (Magick::VPath *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_VPath__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::VPath *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::VPath *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_VPath__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_VPath__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__VPath,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_VPath" "', argument " "1"" of type '" "Magick::VPath const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_VPath" "', argument " "1"" of type '" "Magick::VPath const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::VPath * >(argp1);
  {
    try {
      result = (Magick::VPath *)new Magick::VPath((Magick::VPath const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__VPath, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_VPath(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_VPath__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_VPath__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_VPath__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_VPath");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_VPath_clone(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::VPath *arg1 = (Magick::VPath *) 0 ;
  Magick::VPath *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::VPath *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_VPath_clone.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__VPath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VPath_clone" "', argument " "1"" of type '" "Magick::VPath *""'"); 
  }
  arg1 = reinterpret_cast< Magick::VPath * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__VPath,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VPath_clone" "', argument " "2"" of type '" "Magick::VPath const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VPath_clone" "', argument " "2"" of type '" "Magick::VPath const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::VPath * >(argp2);
  {
    try {
      result = (Magick::VPath *) &(arg1)->operator =((Magick::VPath const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__VPath, 0 |  0 );
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_VPath_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::VPath *arg1 = (Magick::VPath *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_VPath_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__VPath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VPath_call" "', argument " "1"" of type '" "Magick::VPath const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::VPath * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VPath_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::VPath const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_equal__SWIG_5(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::VPath *arg1 = 0 ;
  Magick::VPath *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__VPath,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equal" "', argument " "1"" of type '" "Magick::VPath const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "1"" of type '" "Magick::VPath const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::VPath * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__VPath,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equal" "', argument " "2"" of type '" "Magick::VPath const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "2"" of type '" "Magick::VPath const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::VPath * >(argp2);
  {
    try {
      result = (int)Magick::operator ==((Magick::VPath const &)*arg1,(Magick::VPath const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_notEqual__SWIG_5(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::VPath *arg1 = 0 ;
  Magick::VPath *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__VPath,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "notEqual" "', argument " "1"" of type '" "Magick::VPath const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "1"" of type '" "Magick::VPath const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::VPath * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__VPath,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "notEqual" "', argument " "2"" of type '" "Magick::VPath const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "2"" of type '" "Magick::VPath const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::VPath * >(argp2);
  {
    try {
      result = (int)Magick::operator !=((Magick::VPath const &)*arg1,(Magick::VPath const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_gt__SWIG_4(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::VPath *arg1 = 0 ;
  Magick::VPath *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__VPath,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gt" "', argument " "1"" of type '" "Magick::VPath const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "1"" of type '" "Magick::VPath const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::VPath * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__VPath,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gt" "', argument " "2"" of type '" "Magick::VPath const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "2"" of type '" "Magick::VPath const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::VPath * >(argp2);
  {
    try {
      result = (int)Magick::operator >((Magick::VPath const &)*arg1,(Magick::VPath const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_lt__SWIG_4(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::VPath *arg1 = 0 ;
  Magick::VPath *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__VPath,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lt" "', argument " "1"" of type '" "Magick::VPath const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "1"" of type '" "Magick::VPath const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::VPath * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__VPath,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lt" "', argument " "2"" of type '" "Magick::VPath const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "2"" of type '" "Magick::VPath const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::VPath * >(argp2);
  {
    try {
      result = (int)Magick::operator <((Magick::VPath const &)*arg1,(Magick::VPath const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_gte__SWIG_4(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::VPath *arg1 = 0 ;
  Magick::VPath *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__VPath,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gte" "', argument " "1"" of type '" "Magick::VPath const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "1"" of type '" "Magick::VPath const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::VPath * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__VPath,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gte" "', argument " "2"" of type '" "Magick::VPath const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "2"" of type '" "Magick::VPath const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::VPath * >(argp2);
  {
    try {
      result = (int)Magick::operator >=((Magick::VPath const &)*arg1,(Magick::VPath const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_lte__SWIG_4(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::VPath *arg1 = 0 ;
  Magick::VPath *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__VPath,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lte" "', argument " "1"" of type '" "Magick::VPath const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "1"" of type '" "Magick::VPath const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::VPath * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__VPath,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lte" "', argument " "2"" of type '" "Magick::VPath const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "2"" of type '" "Magick::VPath const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::VPath * >(argp2);
  {
    try {
      result = (int)Magick::operator <=((Magick::VPath const &)*arg1,(Magick::VPath const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableAffine__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  Magick::DrawableAffine *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableAffine__SWIG_0.");
  if(args.Length() != 6) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableAffine__SWIG_0.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableAffine" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_DrawableAffine" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_DrawableAffine" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_DrawableAffine" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  ecode5 = SWIG_AsVal_double(args[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_DrawableAffine" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = static_cast< double >(val5);
  ecode6 = SWIG_AsVal_double(args[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_DrawableAffine" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = static_cast< double >(val6);
  {
    try {
      result = (Magick::DrawableAffine *)new Magick::DrawableAffine(arg1,arg2,arg3,arg4,arg5,arg6);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableAffine, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableAffine__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::DrawableAffine *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableAffine__SWIG_1.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableAffine__SWIG_1.");
  {
    try {
      result = (Magick::DrawableAffine *)new Magick::DrawableAffine();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableAffine, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableAffine(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 6) {
    errorHandler.err.Clear();
    _wrap_new_DrawableAffine__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_DrawableAffine__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_DrawableAffine");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableAffine(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableAffine * arg1 = (Magick::DrawableAffine *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableAffine_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableAffine *arg1 = (Magick::DrawableAffine *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableAffine_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableAffine, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableAffine_call" "', argument " "1"" of type '" "Magick::DrawableAffine const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableAffine * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableAffine_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableAffine const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableAffine_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableAffine *arg1 = (Magick::DrawableAffine *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableAffine_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableAffine, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableAffine_copy" "', argument " "1"" of type '" "Magick::DrawableAffine const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableAffine * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableAffine const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableAffine_sx__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableAffine *arg1 = (Magick::DrawableAffine *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableAffine, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableAffine_sx" "', argument " "1"" of type '" "Magick::DrawableAffine *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableAffine * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableAffine_sx" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->sx(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableAffine_sx__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableAffine *arg1 = (Magick::DrawableAffine *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableAffine, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableAffine_sx" "', argument " "1"" of type '" "Magick::DrawableAffine const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableAffine * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableAffine const *)arg1)->sx();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableAffine__wrap_DrawableAffine_sx(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableAffine_sx__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableAffine_sx__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function sx.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableAffine_sy__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableAffine *arg1 = (Magick::DrawableAffine *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableAffine, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableAffine_sy" "', argument " "1"" of type '" "Magick::DrawableAffine *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableAffine * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableAffine_sy" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->sy(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableAffine_sy__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableAffine *arg1 = (Magick::DrawableAffine *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableAffine, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableAffine_sy" "', argument " "1"" of type '" "Magick::DrawableAffine const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableAffine * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableAffine const *)arg1)->sy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableAffine__wrap_DrawableAffine_sy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableAffine_sy__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableAffine_sy__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function sy.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableAffine_rx__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableAffine *arg1 = (Magick::DrawableAffine *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableAffine, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableAffine_rx" "', argument " "1"" of type '" "Magick::DrawableAffine *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableAffine * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableAffine_rx" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->rx(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableAffine_rx__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableAffine *arg1 = (Magick::DrawableAffine *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableAffine, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableAffine_rx" "', argument " "1"" of type '" "Magick::DrawableAffine const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableAffine * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableAffine const *)arg1)->rx();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableAffine__wrap_DrawableAffine_rx(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableAffine_rx__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableAffine_rx__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function rx.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableAffine_ry__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableAffine *arg1 = (Magick::DrawableAffine *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableAffine, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableAffine_ry" "', argument " "1"" of type '" "Magick::DrawableAffine *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableAffine * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableAffine_ry" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->ry(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableAffine_ry__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableAffine *arg1 = (Magick::DrawableAffine *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableAffine, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableAffine_ry" "', argument " "1"" of type '" "Magick::DrawableAffine const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableAffine * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableAffine const *)arg1)->ry();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableAffine__wrap_DrawableAffine_ry(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableAffine_ry__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableAffine_ry__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function ry.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableAffine_tx__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableAffine *arg1 = (Magick::DrawableAffine *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableAffine, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableAffine_tx" "', argument " "1"" of type '" "Magick::DrawableAffine *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableAffine * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableAffine_tx" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->tx(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableAffine_tx__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableAffine *arg1 = (Magick::DrawableAffine *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableAffine, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableAffine_tx" "', argument " "1"" of type '" "Magick::DrawableAffine const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableAffine * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableAffine const *)arg1)->tx();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableAffine__wrap_DrawableAffine_tx(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableAffine_tx__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableAffine_tx__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function tx.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableAffine_ty__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableAffine *arg1 = (Magick::DrawableAffine *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableAffine, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableAffine_ty" "', argument " "1"" of type '" "Magick::DrawableAffine *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableAffine * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableAffine_ty" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->ty(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableAffine_ty__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableAffine *arg1 = (Magick::DrawableAffine *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableAffine, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableAffine_ty" "', argument " "1"" of type '" "Magick::DrawableAffine const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableAffine * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableAffine const *)arg1)->ty();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableAffine__wrap_DrawableAffine_ty(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableAffine_ty__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableAffine_ty__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function ty.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableArc(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  Magick::DrawableArc *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableArc.");
  if(args.Length() != 6) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableArc.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableArc" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_DrawableArc" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_DrawableArc" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_DrawableArc" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  ecode5 = SWIG_AsVal_double(args[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_DrawableArc" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = static_cast< double >(val5);
  ecode6 = SWIG_AsVal_double(args[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_DrawableArc" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = static_cast< double >(val6);
  {
    try {
      result = (Magick::DrawableArc *)new Magick::DrawableArc(arg1,arg2,arg3,arg4,arg5,arg6);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableArc, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableArc(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableArc * arg1 = (Magick::DrawableArc *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableArc_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableArc *arg1 = (Magick::DrawableArc *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableArc_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableArc_call" "', argument " "1"" of type '" "Magick::DrawableArc const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableArc * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableArc_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableArc const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableArc_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableArc *arg1 = (Magick::DrawableArc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableArc_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableArc_copy" "', argument " "1"" of type '" "Magick::DrawableArc const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableArc * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableArc const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableArc_startX__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableArc *arg1 = (Magick::DrawableArc *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableArc_startX" "', argument " "1"" of type '" "Magick::DrawableArc *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableArc * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableArc_startX" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->startX(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableArc_startX__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableArc *arg1 = (Magick::DrawableArc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableArc_startX" "', argument " "1"" of type '" "Magick::DrawableArc const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableArc * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableArc const *)arg1)->startX();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableArc__wrap_DrawableArc_startX(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableArc_startX__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableArc_startX__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function startX.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableArc_startY__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableArc *arg1 = (Magick::DrawableArc *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableArc_startY" "', argument " "1"" of type '" "Magick::DrawableArc *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableArc * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableArc_startY" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->startY(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableArc_startY__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableArc *arg1 = (Magick::DrawableArc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableArc_startY" "', argument " "1"" of type '" "Magick::DrawableArc const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableArc * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableArc const *)arg1)->startY();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableArc__wrap_DrawableArc_startY(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableArc_startY__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableArc_startY__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function startY.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableArc_endX__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableArc *arg1 = (Magick::DrawableArc *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableArc_endX" "', argument " "1"" of type '" "Magick::DrawableArc *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableArc * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableArc_endX" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->endX(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableArc_endX__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableArc *arg1 = (Magick::DrawableArc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableArc_endX" "', argument " "1"" of type '" "Magick::DrawableArc const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableArc * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableArc const *)arg1)->endX();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableArc__wrap_DrawableArc_endX(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableArc_endX__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableArc_endX__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function endX.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableArc_endY__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableArc *arg1 = (Magick::DrawableArc *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableArc_endY" "', argument " "1"" of type '" "Magick::DrawableArc *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableArc * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableArc_endY" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->endY(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableArc_endY__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableArc *arg1 = (Magick::DrawableArc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableArc_endY" "', argument " "1"" of type '" "Magick::DrawableArc const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableArc * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableArc const *)arg1)->endY();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableArc__wrap_DrawableArc_endY(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableArc_endY__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableArc_endY__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function endY.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableArc_startDegrees__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableArc *arg1 = (Magick::DrawableArc *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableArc_startDegrees" "', argument " "1"" of type '" "Magick::DrawableArc *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableArc * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableArc_startDegrees" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->startDegrees(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableArc_startDegrees__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableArc *arg1 = (Magick::DrawableArc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableArc_startDegrees" "', argument " "1"" of type '" "Magick::DrawableArc const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableArc * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableArc const *)arg1)->startDegrees();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableArc__wrap_DrawableArc_startDegrees(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableArc_startDegrees__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableArc_startDegrees__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function startDegrees.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableArc_endDegrees__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableArc *arg1 = (Magick::DrawableArc *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableArc_endDegrees" "', argument " "1"" of type '" "Magick::DrawableArc *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableArc * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableArc_endDegrees" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->endDegrees(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableArc_endDegrees__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableArc *arg1 = (Magick::DrawableArc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableArc_endDegrees" "', argument " "1"" of type '" "Magick::DrawableArc const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableArc * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableArc const *)arg1)->endDegrees();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableArc__wrap_DrawableArc_endDegrees(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableArc_endDegrees__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableArc_endDegrees__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function endDegrees.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableBezier__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::CoordinateList *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBezier *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableBezier__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableBezier__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_std__listT_Magick__Coordinate_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawableBezier" "', argument " "1"" of type '" "Magick::CoordinateList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableBezier" "', argument " "1"" of type '" "Magick::CoordinateList const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::CoordinateList * >(argp1);
  {
    try {
      result = (Magick::DrawableBezier *)new Magick::DrawableBezier((Magick::CoordinateList const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableBezier, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableBezier__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::DrawableBezier *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBezier *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableBezier__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableBezier__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__DrawableBezier,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawableBezier" "', argument " "1"" of type '" "Magick::DrawableBezier const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableBezier" "', argument " "1"" of type '" "Magick::DrawableBezier const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableBezier * >(argp1);
  {
    try {
      result = (Magick::DrawableBezier *)new Magick::DrawableBezier((Magick::DrawableBezier const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableBezier, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableBezier(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawableBezier__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawableBezier__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_DrawableBezier");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableBezier(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableBezier * arg1 = (Magick::DrawableBezier *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableBezier_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableBezier *arg1 = (Magick::DrawableBezier *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableBezier_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableBezier, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableBezier_call" "', argument " "1"" of type '" "Magick::DrawableBezier const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableBezier * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableBezier_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableBezier const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableBezier_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableBezier *arg1 = (Magick::DrawableBezier *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableBezier_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableBezier, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableBezier_copy" "', argument " "1"" of type '" "Magick::DrawableBezier const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableBezier * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableBezier const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawablePopClipPath(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::DrawablePopClipPath *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawablePopClipPath.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawablePopClipPath.");
  {
    try {
      result = (Magick::DrawablePopClipPath *)new Magick::DrawablePopClipPath();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawablePopClipPath, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawablePopClipPath(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawablePopClipPath * arg1 = (Magick::DrawablePopClipPath *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawablePopClipPath_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePopClipPath *arg1 = (Magick::DrawablePopClipPath *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawablePopClipPath_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePopClipPath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePopClipPath_call" "', argument " "1"" of type '" "Magick::DrawablePopClipPath const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePopClipPath * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawablePopClipPath_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawablePopClipPath const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawablePopClipPath_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePopClipPath *arg1 = (Magick::DrawablePopClipPath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawablePopClipPath_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePopClipPath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePopClipPath_copy" "', argument " "1"" of type '" "Magick::DrawablePopClipPath const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePopClipPath * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawablePopClipPath const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawablePushClipPath__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::DrawablePushClipPath *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawablePushClipPath__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawablePushClipPath__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawablePushClipPath" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawablePushClipPath" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::DrawablePushClipPath *)new Magick::DrawablePushClipPath((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawablePushClipPath, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawablePushClipPath__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::DrawablePushClipPath *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawablePushClipPath *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawablePushClipPath__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawablePushClipPath__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__DrawablePushClipPath,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawablePushClipPath" "', argument " "1"" of type '" "Magick::DrawablePushClipPath const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawablePushClipPath" "', argument " "1"" of type '" "Magick::DrawablePushClipPath const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePushClipPath * >(argp1);
  {
    try {
      result = (Magick::DrawablePushClipPath *)new Magick::DrawablePushClipPath((Magick::DrawablePushClipPath const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawablePushClipPath, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawablePushClipPath(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawablePushClipPath__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawablePushClipPath__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_DrawablePushClipPath");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawablePushClipPath(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawablePushClipPath * arg1 = (Magick::DrawablePushClipPath *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawablePushClipPath_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePushClipPath *arg1 = (Magick::DrawablePushClipPath *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawablePushClipPath_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePushClipPath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePushClipPath_call" "', argument " "1"" of type '" "Magick::DrawablePushClipPath const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePushClipPath * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawablePushClipPath_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawablePushClipPath const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawablePushClipPath_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePushClipPath *arg1 = (Magick::DrawablePushClipPath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawablePushClipPath_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePushClipPath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePushClipPath_copy" "', argument " "1"" of type '" "Magick::DrawablePushClipPath const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePushClipPath * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawablePushClipPath const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableClipPath__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::DrawableClipPath *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableClipPath__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableClipPath__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawableClipPath" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableClipPath" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::DrawableClipPath *)new Magick::DrawableClipPath((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableClipPath, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableClipPath__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::DrawableClipPath *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableClipPath *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableClipPath__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableClipPath__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__DrawableClipPath,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawableClipPath" "', argument " "1"" of type '" "Magick::DrawableClipPath const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableClipPath" "', argument " "1"" of type '" "Magick::DrawableClipPath const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableClipPath * >(argp1);
  {
    try {
      result = (Magick::DrawableClipPath *)new Magick::DrawableClipPath((Magick::DrawableClipPath const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableClipPath, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableClipPath(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawableClipPath__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawableClipPath__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_DrawableClipPath");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableClipPath(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableClipPath * arg1 = (Magick::DrawableClipPath *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableClipPath_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableClipPath *arg1 = (Magick::DrawableClipPath *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableClipPath_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableClipPath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableClipPath_call" "', argument " "1"" of type '" "Magick::DrawableClipPath const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableClipPath * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableClipPath_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableClipPath const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableClipPath_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableClipPath *arg1 = (Magick::DrawableClipPath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableClipPath_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableClipPath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableClipPath_copy" "', argument " "1"" of type '" "Magick::DrawableClipPath const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableClipPath * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableClipPath const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableClipPath_clip_path__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableClipPath *arg1 = (Magick::DrawableClipPath *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableClipPath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableClipPath_clip_path" "', argument " "1"" of type '" "Magick::DrawableClipPath *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableClipPath * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableClipPath_clip_path" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DrawableClipPath_clip_path" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->clip_path((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableClipPath_clip_path__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableClipPath *arg1 = (Magick::DrawableClipPath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableClipPath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableClipPath_clip_path" "', argument " "1"" of type '" "Magick::DrawableClipPath const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableClipPath * >(argp1);
  {
    try {
      result = ((Magick::DrawableClipPath const *)arg1)->clip_path();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableClipPath__wrap_DrawableClipPath_clip_path(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableClipPath_clip_path__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableClipPath_clip_path__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function clip_path.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableCircle(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  Magick::DrawableCircle *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableCircle.");
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableCircle.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableCircle" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_DrawableCircle" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_DrawableCircle" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_DrawableCircle" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    try {
      result = (Magick::DrawableCircle *)new Magick::DrawableCircle(arg1,arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableCircle, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableCircle(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableCircle * arg1 = (Magick::DrawableCircle *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableCircle_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCircle *arg1 = (Magick::DrawableCircle *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableCircle_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCircle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCircle_call" "', argument " "1"" of type '" "Magick::DrawableCircle const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCircle * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableCircle_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableCircle const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCircle_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCircle *arg1 = (Magick::DrawableCircle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableCircle_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCircle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCircle_copy" "', argument " "1"" of type '" "Magick::DrawableCircle const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCircle * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableCircle const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCircle_originX__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCircle *arg1 = (Magick::DrawableCircle *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCircle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCircle_originX" "', argument " "1"" of type '" "Magick::DrawableCircle *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCircle * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableCircle_originX" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->originX(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCircle_originX__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCircle *arg1 = (Magick::DrawableCircle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCircle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCircle_originX" "', argument " "1"" of type '" "Magick::DrawableCircle const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCircle * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableCircle const *)arg1)->originX();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCircle__wrap_DrawableCircle_originX(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableCircle_originX__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableCircle_originX__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function originX.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCircle_originY__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCircle *arg1 = (Magick::DrawableCircle *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCircle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCircle_originY" "', argument " "1"" of type '" "Magick::DrawableCircle *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCircle * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableCircle_originY" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->originY(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCircle_originY__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCircle *arg1 = (Magick::DrawableCircle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCircle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCircle_originY" "', argument " "1"" of type '" "Magick::DrawableCircle const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCircle * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableCircle const *)arg1)->originY();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCircle__wrap_DrawableCircle_originY(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableCircle_originY__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableCircle_originY__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function originY.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCircle_perimX__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCircle *arg1 = (Magick::DrawableCircle *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCircle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCircle_perimX" "', argument " "1"" of type '" "Magick::DrawableCircle *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCircle * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableCircle_perimX" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->perimX(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCircle_perimX__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCircle *arg1 = (Magick::DrawableCircle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCircle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCircle_perimX" "', argument " "1"" of type '" "Magick::DrawableCircle const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCircle * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableCircle const *)arg1)->perimX();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCircle__wrap_DrawableCircle_perimX(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableCircle_perimX__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableCircle_perimX__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function perimX.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCircle_perimY__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCircle *arg1 = (Magick::DrawableCircle *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCircle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCircle_perimY" "', argument " "1"" of type '" "Magick::DrawableCircle *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCircle * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableCircle_perimY" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->perimY(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCircle_perimY__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCircle *arg1 = (Magick::DrawableCircle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCircle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCircle_perimY" "', argument " "1"" of type '" "Magick::DrawableCircle const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCircle * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableCircle const *)arg1)->perimY();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCircle__wrap_DrawableCircle_perimY(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableCircle_perimY__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableCircle_perimY__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function perimY.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableColor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  Magick::PaintMethod arg3 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  Magick::DrawableColor *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableColor.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableColor.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableColor" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_DrawableColor" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_int(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_DrawableColor" "', argument " "3"" of type '" "Magick::PaintMethod""'");
  } 
  arg3 = static_cast< Magick::PaintMethod >(val3);
  {
    try {
      result = (Magick::DrawableColor *)new Magick::DrawableColor(arg1,arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableColor, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableColor(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableColor * arg1 = (Magick::DrawableColor *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableColor_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableColor *arg1 = (Magick::DrawableColor *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableColor_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableColor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableColor_call" "', argument " "1"" of type '" "Magick::DrawableColor const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableColor * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableColor_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableColor const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableColor_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableColor *arg1 = (Magick::DrawableColor *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableColor_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableColor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableColor_copy" "', argument " "1"" of type '" "Magick::DrawableColor const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableColor * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableColor const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableColor_x__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableColor *arg1 = (Magick::DrawableColor *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableColor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableColor_x" "', argument " "1"" of type '" "Magick::DrawableColor *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableColor * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableColor_x" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->x(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableColor_x__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableColor *arg1 = (Magick::DrawableColor *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableColor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableColor_x" "', argument " "1"" of type '" "Magick::DrawableColor const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableColor * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableColor const *)arg1)->x();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableColor__wrap_DrawableColor_x(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableColor_x__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableColor_x__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function x.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableColor_y__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableColor *arg1 = (Magick::DrawableColor *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableColor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableColor_y" "', argument " "1"" of type '" "Magick::DrawableColor *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableColor * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableColor_y" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->y(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableColor_y__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableColor *arg1 = (Magick::DrawableColor *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableColor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableColor_y" "', argument " "1"" of type '" "Magick::DrawableColor const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableColor * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableColor const *)arg1)->y();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableColor__wrap_DrawableColor_y(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableColor_y__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableColor_y__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function y.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableColor_paintMethod__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableColor *arg1 = (Magick::DrawableColor *) 0 ;
  Magick::PaintMethod arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableColor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableColor_paintMethod" "', argument " "1"" of type '" "Magick::DrawableColor *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableColor * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableColor_paintMethod" "', argument " "2"" of type '" "Magick::PaintMethod""'");
  } 
  arg2 = static_cast< Magick::PaintMethod >(val2);
  {
    try {
      (arg1)->paintMethod(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableColor_paintMethod__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableColor *arg1 = (Magick::DrawableColor *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PaintMethod result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableColor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableColor_paintMethod" "', argument " "1"" of type '" "Magick::DrawableColor const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableColor * >(argp1);
  {
    try {
      result = (Magick::PaintMethod)((Magick::DrawableColor const *)arg1)->paintMethod();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableColor__wrap_DrawableColor_paintMethod(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableColor_paintMethod__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableColor_paintMethod__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function paintMethod.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableCompositeImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  std::string *arg3 = 0 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  Magick::DrawableCompositeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableCompositeImage__SWIG_0.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableCompositeImage__SWIG_0.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableCompositeImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_DrawableCompositeImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(args[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_DrawableCompositeImage" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableCompositeImage" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    try {
      result = (Magick::DrawableCompositeImage *)new Magick::DrawableCompositeImage(arg1,arg2,(std::string const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  if (SWIG_IsNewObj(res3)) delete arg3;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableCompositeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableCompositeImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  Magick::Image *arg3 = 0 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  Magick::DrawableCompositeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableCompositeImage__SWIG_1.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableCompositeImage__SWIG_1.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableCompositeImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_DrawableCompositeImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_DrawableCompositeImage" "', argument " "3"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableCompositeImage" "', argument " "3"" of type '" "Magick::Image const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Image * >(argp3);
  {
    try {
      result = (Magick::DrawableCompositeImage *)new Magick::DrawableCompositeImage(arg1,arg2,(Magick::Image const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableCompositeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableCompositeImage__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  std::string *arg5 = 0 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  int res5 = SWIG_OLDOBJ ;
  Magick::DrawableCompositeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableCompositeImage__SWIG_2.");
  if(args.Length() != 5) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableCompositeImage__SWIG_2.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableCompositeImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_DrawableCompositeImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_DrawableCompositeImage" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_DrawableCompositeImage" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    std::string *ptr = (std::string *)0;
    res5 = SWIG_AsPtr_std_string(args[4], &ptr);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_DrawableCompositeImage" "', argument " "5"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableCompositeImage" "', argument " "5"" of type '" "std::string const &""'"); 
    }
    arg5 = ptr;
  }
  {
    try {
      result = (Magick::DrawableCompositeImage *)new Magick::DrawableCompositeImage(arg1,arg2,arg3,arg4,(std::string const &)*arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  if (SWIG_IsNewObj(res5)) delete arg5;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableCompositeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableCompositeImage__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  Magick::Image *arg5 = 0 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  Magick::DrawableCompositeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableCompositeImage__SWIG_3.");
  if(args.Length() != 5) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableCompositeImage__SWIG_3.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableCompositeImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_DrawableCompositeImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_DrawableCompositeImage" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_DrawableCompositeImage" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  res5 = SWIG_ConvertPtr(args[4], &argp5, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_DrawableCompositeImage" "', argument " "5"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableCompositeImage" "', argument " "5"" of type '" "Magick::Image const &""'"); 
  }
  arg5 = reinterpret_cast< Magick::Image * >(argp5);
  {
    try {
      result = (Magick::DrawableCompositeImage *)new Magick::DrawableCompositeImage(arg1,arg2,arg3,arg4,(Magick::Image const &)*arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableCompositeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableCompositeImage__SWIG_4(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  std::string *arg5 = 0 ;
  Magick::CompositeOperator arg6 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  int res5 = SWIG_OLDOBJ ;
  int val6 ;
  int ecode6 = 0 ;
  Magick::DrawableCompositeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableCompositeImage__SWIG_4.");
  if(args.Length() != 6) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableCompositeImage__SWIG_4.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableCompositeImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_DrawableCompositeImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_DrawableCompositeImage" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_DrawableCompositeImage" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    std::string *ptr = (std::string *)0;
    res5 = SWIG_AsPtr_std_string(args[4], &ptr);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_DrawableCompositeImage" "', argument " "5"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableCompositeImage" "', argument " "5"" of type '" "std::string const &""'"); 
    }
    arg5 = ptr;
  }
  ecode6 = SWIG_AsVal_int(args[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_DrawableCompositeImage" "', argument " "6"" of type '" "Magick::CompositeOperator""'");
  } 
  arg6 = static_cast< Magick::CompositeOperator >(val6);
  {
    try {
      result = (Magick::DrawableCompositeImage *)new Magick::DrawableCompositeImage(arg1,arg2,arg3,arg4,(std::string const &)*arg5,arg6);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  if (SWIG_IsNewObj(res5)) delete arg5;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableCompositeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableCompositeImage__SWIG_5(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  Magick::Image *arg5 = 0 ;
  Magick::CompositeOperator arg6 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  Magick::DrawableCompositeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableCompositeImage__SWIG_5.");
  if(args.Length() != 6) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableCompositeImage__SWIG_5.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableCompositeImage" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_DrawableCompositeImage" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_DrawableCompositeImage" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_DrawableCompositeImage" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  res5 = SWIG_ConvertPtr(args[4], &argp5, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_DrawableCompositeImage" "', argument " "5"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableCompositeImage" "', argument " "5"" of type '" "Magick::Image const &""'"); 
  }
  arg5 = reinterpret_cast< Magick::Image * >(argp5);
  ecode6 = SWIG_AsVal_int(args[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_DrawableCompositeImage" "', argument " "6"" of type '" "Magick::CompositeOperator""'");
  } 
  arg6 = static_cast< Magick::CompositeOperator >(val6);
  {
    try {
      result = (Magick::DrawableCompositeImage *)new Magick::DrawableCompositeImage(arg1,arg2,arg3,arg4,(Magick::Image const &)*arg5,arg6);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableCompositeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableCompositeImage__SWIG_6(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::DrawableCompositeImage *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableCompositeImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableCompositeImage__SWIG_6.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableCompositeImage__SWIG_6.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__DrawableCompositeImage,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawableCompositeImage" "', argument " "1"" of type '" "Magick::DrawableCompositeImage const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableCompositeImage" "', argument " "1"" of type '" "Magick::DrawableCompositeImage const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCompositeImage * >(argp1);
  {
    try {
      result = (Magick::DrawableCompositeImage *)new Magick::DrawableCompositeImage((Magick::DrawableCompositeImage const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableCompositeImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableCompositeImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_DrawableCompositeImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_DrawableCompositeImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 5) {
    errorHandler.err.Clear();
    _wrap_new_DrawableCompositeImage__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 5) {
    errorHandler.err.Clear();
    _wrap_new_DrawableCompositeImage__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 6) {
    errorHandler.err.Clear();
    _wrap_new_DrawableCompositeImage__SWIG_4(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 6) {
    errorHandler.err.Clear();
    _wrap_new_DrawableCompositeImage__SWIG_5(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawableCompositeImage__SWIG_6(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_DrawableCompositeImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableCompositeImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableCompositeImage * arg1 = (Magick::DrawableCompositeImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage_clone(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCompositeImage *arg1 = (Magick::DrawableCompositeImage *) 0 ;
  Magick::DrawableCompositeImage *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::DrawableCompositeImage *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableCompositeImage_clone.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCompositeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCompositeImage_clone" "', argument " "1"" of type '" "Magick::DrawableCompositeImage *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCompositeImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__DrawableCompositeImage,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableCompositeImage_clone" "', argument " "2"" of type '" "Magick::DrawableCompositeImage const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DrawableCompositeImage_clone" "', argument " "2"" of type '" "Magick::DrawableCompositeImage const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::DrawableCompositeImage * >(argp2);
  {
    try {
      result = (Magick::DrawableCompositeImage *) &(arg1)->operator =((Magick::DrawableCompositeImage const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableCompositeImage, 0 |  0 );
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCompositeImage *arg1 = (Magick::DrawableCompositeImage *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableCompositeImage_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCompositeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCompositeImage_call" "', argument " "1"" of type '" "Magick::DrawableCompositeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCompositeImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableCompositeImage_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableCompositeImage const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCompositeImage *arg1 = (Magick::DrawableCompositeImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableCompositeImage_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCompositeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCompositeImage_copy" "', argument " "1"" of type '" "Magick::DrawableCompositeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCompositeImage * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableCompositeImage const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage_composition__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCompositeImage *arg1 = (Magick::DrawableCompositeImage *) 0 ;
  Magick::CompositeOperator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCompositeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCompositeImage_composition" "', argument " "1"" of type '" "Magick::DrawableCompositeImage *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCompositeImage * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableCompositeImage_composition" "', argument " "2"" of type '" "Magick::CompositeOperator""'");
  } 
  arg2 = static_cast< Magick::CompositeOperator >(val2);
  {
    try {
      (arg1)->composition(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage_composition__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCompositeImage *arg1 = (Magick::DrawableCompositeImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::CompositeOperator result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCompositeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCompositeImage_composition" "', argument " "1"" of type '" "Magick::DrawableCompositeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCompositeImage * >(argp1);
  {
    try {
      result = (Magick::CompositeOperator)((Magick::DrawableCompositeImage const *)arg1)->composition();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage__wrap_DrawableCompositeImage_composition(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableCompositeImage_composition__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableCompositeImage_composition__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function composition.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage_filename__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCompositeImage *arg1 = (Magick::DrawableCompositeImage *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCompositeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCompositeImage_filename" "', argument " "1"" of type '" "Magick::DrawableCompositeImage *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCompositeImage * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableCompositeImage_filename" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DrawableCompositeImage_filename" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->filename((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage_filename__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCompositeImage *arg1 = (Magick::DrawableCompositeImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCompositeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCompositeImage_filename" "', argument " "1"" of type '" "Magick::DrawableCompositeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCompositeImage * >(argp1);
  {
    try {
      result = ((Magick::DrawableCompositeImage const *)arg1)->filename();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage__wrap_DrawableCompositeImage_filename(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableCompositeImage_filename__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableCompositeImage_filename__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function filename.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage_x__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCompositeImage *arg1 = (Magick::DrawableCompositeImage *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCompositeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCompositeImage_x" "', argument " "1"" of type '" "Magick::DrawableCompositeImage *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCompositeImage * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableCompositeImage_x" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->x(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage_x__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCompositeImage *arg1 = (Magick::DrawableCompositeImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCompositeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCompositeImage_x" "', argument " "1"" of type '" "Magick::DrawableCompositeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCompositeImage * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableCompositeImage const *)arg1)->x();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage__wrap_DrawableCompositeImage_x(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableCompositeImage_x__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableCompositeImage_x__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function x.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage_y__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCompositeImage *arg1 = (Magick::DrawableCompositeImage *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCompositeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCompositeImage_y" "', argument " "1"" of type '" "Magick::DrawableCompositeImage *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCompositeImage * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableCompositeImage_y" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->y(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage_y__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCompositeImage *arg1 = (Magick::DrawableCompositeImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCompositeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCompositeImage_y" "', argument " "1"" of type '" "Magick::DrawableCompositeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCompositeImage * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableCompositeImage const *)arg1)->y();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage__wrap_DrawableCompositeImage_y(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableCompositeImage_y__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableCompositeImage_y__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function y.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage_width__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCompositeImage *arg1 = (Magick::DrawableCompositeImage *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCompositeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCompositeImage_width" "', argument " "1"" of type '" "Magick::DrawableCompositeImage *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCompositeImage * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableCompositeImage_width" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->width(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage_width__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCompositeImage *arg1 = (Magick::DrawableCompositeImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCompositeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCompositeImage_width" "', argument " "1"" of type '" "Magick::DrawableCompositeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCompositeImage * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableCompositeImage const *)arg1)->width();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage__wrap_DrawableCompositeImage_width(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableCompositeImage_width__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableCompositeImage_width__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function width.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage_height__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCompositeImage *arg1 = (Magick::DrawableCompositeImage *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCompositeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCompositeImage_height" "', argument " "1"" of type '" "Magick::DrawableCompositeImage *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCompositeImage * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableCompositeImage_height" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->height(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage_height__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCompositeImage *arg1 = (Magick::DrawableCompositeImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCompositeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCompositeImage_height" "', argument " "1"" of type '" "Magick::DrawableCompositeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCompositeImage * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableCompositeImage const *)arg1)->height();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage__wrap_DrawableCompositeImage_height(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableCompositeImage_height__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableCompositeImage_height__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function height.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage_image__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCompositeImage *arg1 = (Magick::DrawableCompositeImage *) 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCompositeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCompositeImage_image" "', argument " "1"" of type '" "Magick::DrawableCompositeImage *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCompositeImage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableCompositeImage_image" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DrawableCompositeImage_image" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  {
    try {
      (arg1)->image((Magick::Image const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage_image__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCompositeImage *arg1 = (Magick::DrawableCompositeImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Image result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCompositeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCompositeImage_image" "', argument " "1"" of type '" "Magick::DrawableCompositeImage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCompositeImage * >(argp1);
  {
    try {
      result = ((Magick::DrawableCompositeImage const *)arg1)->image();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Image(result)), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage__wrap_DrawableCompositeImage_image(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableCompositeImage_image__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableCompositeImage_image__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function image.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage_magick__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCompositeImage *arg1 = (Magick::DrawableCompositeImage *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCompositeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCompositeImage_magick" "', argument " "1"" of type '" "Magick::DrawableCompositeImage *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCompositeImage * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "DrawableCompositeImage_magick" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      (arg1)->magick(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage_magick__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableCompositeImage *arg1 = (Magick::DrawableCompositeImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableCompositeImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableCompositeImage_magick" "', argument " "1"" of type '" "Magick::DrawableCompositeImage *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableCompositeImage * >(argp1);
  {
    try {
      result = (arg1)->magick();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableCompositeImage__wrap_DrawableCompositeImage_magick(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableCompositeImage_magick__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableCompositeImage_magick__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function magick.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableDensity(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::DrawableDensity *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableDensity.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableDensity.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawableDensity" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableDensity" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::DrawableDensity *)new Magick::DrawableDensity((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableDensity, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableDensity(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableDensity * arg1 = (Magick::DrawableDensity *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableDensity_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableDensity *arg1 = (Magick::DrawableDensity *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableDensity_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableDensity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableDensity_call" "', argument " "1"" of type '" "Magick::DrawableDensity const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableDensity * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableDensity_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableDensity const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableDensity_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableDensity *arg1 = (Magick::DrawableDensity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableDensity_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableDensity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableDensity_copy" "', argument " "1"" of type '" "Magick::DrawableDensity const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableDensity * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableDensity const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableEllipse(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  Magick::DrawableEllipse *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableEllipse.");
  if(args.Length() != 6) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableEllipse.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableEllipse" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_DrawableEllipse" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_DrawableEllipse" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_DrawableEllipse" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  ecode5 = SWIG_AsVal_double(args[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_DrawableEllipse" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = static_cast< double >(val5);
  ecode6 = SWIG_AsVal_double(args[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_DrawableEllipse" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = static_cast< double >(val6);
  {
    try {
      result = (Magick::DrawableEllipse *)new Magick::DrawableEllipse(arg1,arg2,arg3,arg4,arg5,arg6);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableEllipse, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableEllipse(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableEllipse * arg1 = (Magick::DrawableEllipse *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableEllipse_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableEllipse *arg1 = (Magick::DrawableEllipse *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableEllipse_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableEllipse, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableEllipse_call" "', argument " "1"" of type '" "Magick::DrawableEllipse const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableEllipse * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableEllipse_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableEllipse const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableEllipse_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableEllipse *arg1 = (Magick::DrawableEllipse *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableEllipse_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableEllipse, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableEllipse_copy" "', argument " "1"" of type '" "Magick::DrawableEllipse const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableEllipse * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableEllipse const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableEllipse_originX__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableEllipse *arg1 = (Magick::DrawableEllipse *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableEllipse, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableEllipse_originX" "', argument " "1"" of type '" "Magick::DrawableEllipse *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableEllipse * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableEllipse_originX" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->originX(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableEllipse_originX__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableEllipse *arg1 = (Magick::DrawableEllipse *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableEllipse, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableEllipse_originX" "', argument " "1"" of type '" "Magick::DrawableEllipse const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableEllipse * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableEllipse const *)arg1)->originX();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableEllipse__wrap_DrawableEllipse_originX(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableEllipse_originX__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableEllipse_originX__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function originX.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableEllipse_originY__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableEllipse *arg1 = (Magick::DrawableEllipse *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableEllipse, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableEllipse_originY" "', argument " "1"" of type '" "Magick::DrawableEllipse *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableEllipse * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableEllipse_originY" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->originY(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableEllipse_originY__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableEllipse *arg1 = (Magick::DrawableEllipse *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableEllipse, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableEllipse_originY" "', argument " "1"" of type '" "Magick::DrawableEllipse const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableEllipse * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableEllipse const *)arg1)->originY();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableEllipse__wrap_DrawableEllipse_originY(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableEllipse_originY__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableEllipse_originY__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function originY.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableEllipse_radiusX__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableEllipse *arg1 = (Magick::DrawableEllipse *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableEllipse, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableEllipse_radiusX" "', argument " "1"" of type '" "Magick::DrawableEllipse *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableEllipse * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableEllipse_radiusX" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->radiusX(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableEllipse_radiusX__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableEllipse *arg1 = (Magick::DrawableEllipse *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableEllipse, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableEllipse_radiusX" "', argument " "1"" of type '" "Magick::DrawableEllipse const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableEllipse * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableEllipse const *)arg1)->radiusX();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableEllipse__wrap_DrawableEllipse_radiusX(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableEllipse_radiusX__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableEllipse_radiusX__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function radiusX.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableEllipse_radiusY__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableEllipse *arg1 = (Magick::DrawableEllipse *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableEllipse, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableEllipse_radiusY" "', argument " "1"" of type '" "Magick::DrawableEllipse *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableEllipse * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableEllipse_radiusY" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->radiusY(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableEllipse_radiusY__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableEllipse *arg1 = (Magick::DrawableEllipse *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableEllipse, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableEllipse_radiusY" "', argument " "1"" of type '" "Magick::DrawableEllipse const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableEllipse * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableEllipse const *)arg1)->radiusY();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableEllipse__wrap_DrawableEllipse_radiusY(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableEllipse_radiusY__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableEllipse_radiusY__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function radiusY.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableEllipse_arcStart__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableEllipse *arg1 = (Magick::DrawableEllipse *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableEllipse, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableEllipse_arcStart" "', argument " "1"" of type '" "Magick::DrawableEllipse *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableEllipse * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableEllipse_arcStart" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->arcStart(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableEllipse_arcStart__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableEllipse *arg1 = (Magick::DrawableEllipse *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableEllipse, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableEllipse_arcStart" "', argument " "1"" of type '" "Magick::DrawableEllipse const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableEllipse * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableEllipse const *)arg1)->arcStart();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableEllipse__wrap_DrawableEllipse_arcStart(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableEllipse_arcStart__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableEllipse_arcStart__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function arcStart.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableEllipse_arcEnd__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableEllipse *arg1 = (Magick::DrawableEllipse *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableEllipse, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableEllipse_arcEnd" "', argument " "1"" of type '" "Magick::DrawableEllipse *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableEllipse * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableEllipse_arcEnd" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->arcEnd(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableEllipse_arcEnd__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableEllipse *arg1 = (Magick::DrawableEllipse *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableEllipse, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableEllipse_arcEnd" "', argument " "1"" of type '" "Magick::DrawableEllipse const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableEllipse * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableEllipse const *)arg1)->arcEnd();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableEllipse__wrap_DrawableEllipse_arcEnd(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableEllipse_arcEnd__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableEllipse_arcEnd__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function arcEnd.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableFillColor__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Color *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableFillColor *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableFillColor__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableFillColor__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawableFillColor" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableFillColor" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  {
    try {
      result = (Magick::DrawableFillColor *)new Magick::DrawableFillColor((Magick::Color const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableFillColor, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableFillColor__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::DrawableFillColor *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableFillColor *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableFillColor__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableFillColor__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__DrawableFillColor,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawableFillColor" "', argument " "1"" of type '" "Magick::DrawableFillColor const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableFillColor" "', argument " "1"" of type '" "Magick::DrawableFillColor const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableFillColor * >(argp1);
  {
    try {
      result = (Magick::DrawableFillColor *)new Magick::DrawableFillColor((Magick::DrawableFillColor const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableFillColor, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableFillColor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawableFillColor__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawableFillColor__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_DrawableFillColor");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableFillColor(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableFillColor * arg1 = (Magick::DrawableFillColor *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableFillColor_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableFillColor *arg1 = (Magick::DrawableFillColor *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableFillColor_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableFillColor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableFillColor_call" "', argument " "1"" of type '" "Magick::DrawableFillColor const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableFillColor * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableFillColor_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableFillColor const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableFillColor_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableFillColor *arg1 = (Magick::DrawableFillColor *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableFillColor_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableFillColor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableFillColor_copy" "', argument " "1"" of type '" "Magick::DrawableFillColor const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableFillColor * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableFillColor const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableFillColor_color__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableFillColor *arg1 = (Magick::DrawableFillColor *) 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableFillColor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableFillColor_color" "', argument " "1"" of type '" "Magick::DrawableFillColor *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableFillColor * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableFillColor_color" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DrawableFillColor_color" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      (arg1)->color((Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableFillColor_color__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableFillColor *arg1 = (Magick::DrawableFillColor *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Color result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableFillColor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableFillColor_color" "', argument " "1"" of type '" "Magick::DrawableFillColor const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableFillColor * >(argp1);
  {
    try {
      result = ((Magick::DrawableFillColor const *)arg1)->color();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Color(result)), SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableFillColor__wrap_DrawableFillColor_color(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableFillColor_color__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableFillColor_color__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function color.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableFillRule(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::FillRule arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  Magick::DrawableFillRule *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableFillRule.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableFillRule.");
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableFillRule" "', argument " "1"" of type '" "Magick::FillRule""'");
  } 
  arg1 = static_cast< Magick::FillRule >(val1);
  {
    try {
      result = (Magick::DrawableFillRule *)new Magick::DrawableFillRule(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableFillRule, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableFillRule(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableFillRule * arg1 = (Magick::DrawableFillRule *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableFillRule_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableFillRule *arg1 = (Magick::DrawableFillRule *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableFillRule_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableFillRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableFillRule_call" "', argument " "1"" of type '" "Magick::DrawableFillRule const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableFillRule * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableFillRule_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableFillRule const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableFillRule_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableFillRule *arg1 = (Magick::DrawableFillRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableFillRule_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableFillRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableFillRule_copy" "', argument " "1"" of type '" "Magick::DrawableFillRule const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableFillRule * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableFillRule const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableFillRule_fillRule__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableFillRule *arg1 = (Magick::DrawableFillRule *) 0 ;
  Magick::FillRule arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableFillRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableFillRule_fillRule" "', argument " "1"" of type '" "Magick::DrawableFillRule *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableFillRule * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableFillRule_fillRule" "', argument " "2"" of type '" "Magick::FillRule""'");
  } 
  arg2 = static_cast< Magick::FillRule >(val2);
  {
    try {
      (arg1)->fillRule(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableFillRule_fillRule__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableFillRule *arg1 = (Magick::DrawableFillRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::FillRule result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableFillRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableFillRule_fillRule" "', argument " "1"" of type '" "Magick::DrawableFillRule const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableFillRule * >(argp1);
  {
    try {
      result = (Magick::FillRule)((Magick::DrawableFillRule const *)arg1)->fillRule();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableFillRule__wrap_DrawableFillRule_fillRule(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableFillRule_fillRule__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableFillRule_fillRule__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function fillRule.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableFillOpacity(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::DrawableFillOpacity *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableFillOpacity.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableFillOpacity.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableFillOpacity" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::DrawableFillOpacity *)new Magick::DrawableFillOpacity(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableFillOpacity, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableFillOpacity(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableFillOpacity * arg1 = (Magick::DrawableFillOpacity *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableFillOpacity_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableFillOpacity *arg1 = (Magick::DrawableFillOpacity *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableFillOpacity_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableFillOpacity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableFillOpacity_call" "', argument " "1"" of type '" "Magick::DrawableFillOpacity const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableFillOpacity * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableFillOpacity_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableFillOpacity const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableFillOpacity_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableFillOpacity *arg1 = (Magick::DrawableFillOpacity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableFillOpacity_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableFillOpacity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableFillOpacity_copy" "', argument " "1"" of type '" "Magick::DrawableFillOpacity const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableFillOpacity * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableFillOpacity const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableFillOpacity_opacity__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableFillOpacity *arg1 = (Magick::DrawableFillOpacity *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableFillOpacity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableFillOpacity_opacity" "', argument " "1"" of type '" "Magick::DrawableFillOpacity *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableFillOpacity * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableFillOpacity_opacity" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->opacity(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableFillOpacity_opacity__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableFillOpacity *arg1 = (Magick::DrawableFillOpacity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableFillOpacity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableFillOpacity_opacity" "', argument " "1"" of type '" "Magick::DrawableFillOpacity const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableFillOpacity * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableFillOpacity const *)arg1)->opacity();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableFillOpacity__wrap_DrawableFillOpacity_opacity(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableFillOpacity_opacity__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableFillOpacity_opacity__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function opacity.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableFont__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::DrawableFont *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableFont__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableFont__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawableFont" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableFont" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::DrawableFont *)new Magick::DrawableFont((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableFont, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableFont__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::StyleType arg2 ;
  unsigned int arg3 ;
  Magick::StretchType arg4 ;
  int res1 = SWIG_OLDOBJ ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  Magick::DrawableFont *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableFont__SWIG_1.");
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableFont__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawableFont" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableFont" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_int(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_DrawableFont" "', argument " "2"" of type '" "Magick::StyleType""'");
  } 
  arg2 = static_cast< Magick::StyleType >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_DrawableFont" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_int(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_DrawableFont" "', argument " "4"" of type '" "Magick::StretchType""'");
  } 
  arg4 = static_cast< Magick::StretchType >(val4);
  {
    try {
      result = (Magick::DrawableFont *)new Magick::DrawableFont((std::string const &)*arg1,arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableFont, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableFont__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::DrawableFont *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableFont *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableFont__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableFont__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__DrawableFont,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawableFont" "', argument " "1"" of type '" "Magick::DrawableFont const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableFont" "', argument " "1"" of type '" "Magick::DrawableFont const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableFont * >(argp1);
  {
    try {
      result = (Magick::DrawableFont *)new Magick::DrawableFont((Magick::DrawableFont const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableFont, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableFont(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawableFont__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_new_DrawableFont__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawableFont__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_DrawableFont");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableFont(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableFont * arg1 = (Magick::DrawableFont *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableFont_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableFont *arg1 = (Magick::DrawableFont *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableFont_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableFont, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableFont_call" "', argument " "1"" of type '" "Magick::DrawableFont const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableFont * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableFont_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableFont const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableFont_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableFont *arg1 = (Magick::DrawableFont *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableFont_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableFont, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableFont_copy" "', argument " "1"" of type '" "Magick::DrawableFont const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableFont * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableFont const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableFont_font__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableFont *arg1 = (Magick::DrawableFont *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableFont, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableFont_font" "', argument " "1"" of type '" "Magick::DrawableFont *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableFont * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableFont_font" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DrawableFont_font" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->font((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableFont_font__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableFont *arg1 = (Magick::DrawableFont *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableFont, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableFont_font" "', argument " "1"" of type '" "Magick::DrawableFont const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableFont * >(argp1);
  {
    try {
      result = ((Magick::DrawableFont const *)arg1)->font();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableFont__wrap_DrawableFont_font(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableFont_font__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableFont_font__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function font.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableGravity(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::GravityType arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  Magick::DrawableGravity *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableGravity.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableGravity.");
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableGravity" "', argument " "1"" of type '" "Magick::GravityType""'");
  } 
  arg1 = static_cast< Magick::GravityType >(val1);
  {
    try {
      result = (Magick::DrawableGravity *)new Magick::DrawableGravity(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableGravity, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableGravity(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableGravity * arg1 = (Magick::DrawableGravity *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableGravity_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableGravity *arg1 = (Magick::DrawableGravity *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableGravity_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableGravity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableGravity_call" "', argument " "1"" of type '" "Magick::DrawableGravity const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableGravity * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableGravity_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableGravity const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableGravity_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableGravity *arg1 = (Magick::DrawableGravity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableGravity_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableGravity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableGravity_copy" "', argument " "1"" of type '" "Magick::DrawableGravity const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableGravity * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableGravity const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableGravity_gravity__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableGravity *arg1 = (Magick::DrawableGravity *) 0 ;
  Magick::GravityType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableGravity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableGravity_gravity" "', argument " "1"" of type '" "Magick::DrawableGravity *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableGravity * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableGravity_gravity" "', argument " "2"" of type '" "Magick::GravityType""'");
  } 
  arg2 = static_cast< Magick::GravityType >(val2);
  {
    try {
      (arg1)->gravity(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableGravity_gravity__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableGravity *arg1 = (Magick::DrawableGravity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::GravityType result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableGravity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableGravity_gravity" "', argument " "1"" of type '" "Magick::DrawableGravity const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableGravity * >(argp1);
  {
    try {
      result = (Magick::GravityType)((Magick::DrawableGravity const *)arg1)->gravity();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableGravity__wrap_DrawableGravity_gravity(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableGravity_gravity__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableGravity_gravity__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function gravity.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableLine(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  Magick::DrawableLine *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableLine.");
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableLine.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableLine" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_DrawableLine" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_DrawableLine" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_DrawableLine" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    try {
      result = (Magick::DrawableLine *)new Magick::DrawableLine(arg1,arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableLine, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableLine(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableLine * arg1 = (Magick::DrawableLine *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableLine_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableLine *arg1 = (Magick::DrawableLine *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableLine_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableLine, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableLine_call" "', argument " "1"" of type '" "Magick::DrawableLine const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableLine * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableLine_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableLine const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableLine_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableLine *arg1 = (Magick::DrawableLine *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableLine_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableLine, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableLine_copy" "', argument " "1"" of type '" "Magick::DrawableLine const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableLine * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableLine const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableLine_startX__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableLine *arg1 = (Magick::DrawableLine *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableLine, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableLine_startX" "', argument " "1"" of type '" "Magick::DrawableLine *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableLine * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableLine_startX" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->startX(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableLine_startX__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableLine *arg1 = (Magick::DrawableLine *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableLine, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableLine_startX" "', argument " "1"" of type '" "Magick::DrawableLine const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableLine * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableLine const *)arg1)->startX();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableLine__wrap_DrawableLine_startX(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableLine_startX__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableLine_startX__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function startX.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableLine_startY__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableLine *arg1 = (Magick::DrawableLine *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableLine, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableLine_startY" "', argument " "1"" of type '" "Magick::DrawableLine *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableLine * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableLine_startY" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->startY(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableLine_startY__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableLine *arg1 = (Magick::DrawableLine *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableLine, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableLine_startY" "', argument " "1"" of type '" "Magick::DrawableLine const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableLine * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableLine const *)arg1)->startY();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableLine__wrap_DrawableLine_startY(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableLine_startY__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableLine_startY__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function startY.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableLine_endX__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableLine *arg1 = (Magick::DrawableLine *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableLine, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableLine_endX" "', argument " "1"" of type '" "Magick::DrawableLine *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableLine * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableLine_endX" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->endX(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableLine_endX__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableLine *arg1 = (Magick::DrawableLine *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableLine, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableLine_endX" "', argument " "1"" of type '" "Magick::DrawableLine const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableLine * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableLine const *)arg1)->endX();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableLine__wrap_DrawableLine_endX(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableLine_endX__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableLine_endX__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function endX.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableLine_endY__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableLine *arg1 = (Magick::DrawableLine *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableLine, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableLine_endY" "', argument " "1"" of type '" "Magick::DrawableLine *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableLine * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableLine_endY" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->endY(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableLine_endY__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableLine *arg1 = (Magick::DrawableLine *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableLine, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableLine_endY" "', argument " "1"" of type '" "Magick::DrawableLine const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableLine * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableLine const *)arg1)->endY();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableLine__wrap_DrawableLine_endY(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableLine_endY__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableLine_endY__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function endY.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableMatte(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  Magick::PaintMethod arg3 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  Magick::DrawableMatte *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableMatte.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableMatte.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableMatte" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_DrawableMatte" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_int(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_DrawableMatte" "', argument " "3"" of type '" "Magick::PaintMethod""'");
  } 
  arg3 = static_cast< Magick::PaintMethod >(val3);
  {
    try {
      result = (Magick::DrawableMatte *)new Magick::DrawableMatte(arg1,arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableMatte, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableMatte(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableMatte * arg1 = (Magick::DrawableMatte *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableMatte_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableMatte *arg1 = (Magick::DrawableMatte *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableMatte_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableMatte, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableMatte_call" "', argument " "1"" of type '" "Magick::DrawableMatte const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableMatte * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableMatte_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableMatte const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableMatte_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableMatte *arg1 = (Magick::DrawableMatte *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableMatte_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableMatte, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableMatte_copy" "', argument " "1"" of type '" "Magick::DrawableMatte const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableMatte * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableMatte const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableMatte_x__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableMatte *arg1 = (Magick::DrawableMatte *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableMatte, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableMatte_x" "', argument " "1"" of type '" "Magick::DrawableMatte *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableMatte * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableMatte_x" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->x(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableMatte_x__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableMatte *arg1 = (Magick::DrawableMatte *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableMatte, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableMatte_x" "', argument " "1"" of type '" "Magick::DrawableMatte const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableMatte * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableMatte const *)arg1)->x();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableMatte__wrap_DrawableMatte_x(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableMatte_x__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableMatte_x__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function x.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableMatte_y__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableMatte *arg1 = (Magick::DrawableMatte *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableMatte, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableMatte_y" "', argument " "1"" of type '" "Magick::DrawableMatte *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableMatte * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableMatte_y" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->y(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableMatte_y__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableMatte *arg1 = (Magick::DrawableMatte *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableMatte, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableMatte_y" "', argument " "1"" of type '" "Magick::DrawableMatte const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableMatte * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableMatte const *)arg1)->y();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableMatte__wrap_DrawableMatte_y(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableMatte_y__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableMatte_y__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function y.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableMatte_paintMethod__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableMatte *arg1 = (Magick::DrawableMatte *) 0 ;
  Magick::PaintMethod arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableMatte, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableMatte_paintMethod" "', argument " "1"" of type '" "Magick::DrawableMatte *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableMatte * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableMatte_paintMethod" "', argument " "2"" of type '" "Magick::PaintMethod""'");
  } 
  arg2 = static_cast< Magick::PaintMethod >(val2);
  {
    try {
      (arg1)->paintMethod(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableMatte_paintMethod__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableMatte *arg1 = (Magick::DrawableMatte *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PaintMethod result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableMatte, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableMatte_paintMethod" "', argument " "1"" of type '" "Magick::DrawableMatte const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableMatte * >(argp1);
  {
    try {
      result = (Magick::PaintMethod)((Magick::DrawableMatte const *)arg1)->paintMethod();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableMatte__wrap_DrawableMatte_paintMethod(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableMatte_paintMethod__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableMatte_paintMethod__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function paintMethod.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawablePath__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::VPathList *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawablePath *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawablePath__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawablePath__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_std__listT_Magick__VPath_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawablePath" "', argument " "1"" of type '" "Magick::VPathList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawablePath" "', argument " "1"" of type '" "Magick::VPathList const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::VPathList * >(argp1);
  {
    try {
      result = (Magick::DrawablePath *)new Magick::DrawablePath((Magick::VPathList const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawablePath, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawablePath__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::DrawablePath *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawablePath *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawablePath__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawablePath__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__DrawablePath,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawablePath" "', argument " "1"" of type '" "Magick::DrawablePath const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawablePath" "', argument " "1"" of type '" "Magick::DrawablePath const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePath * >(argp1);
  {
    try {
      result = (Magick::DrawablePath *)new Magick::DrawablePath((Magick::DrawablePath const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawablePath, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawablePath(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawablePath__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawablePath__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_DrawablePath");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawablePath(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawablePath * arg1 = (Magick::DrawablePath *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawablePath_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePath *arg1 = (Magick::DrawablePath *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawablePath_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePath_call" "', argument " "1"" of type '" "Magick::DrawablePath const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePath * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawablePath_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawablePath const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawablePath_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePath *arg1 = (Magick::DrawablePath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawablePath_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePath_copy" "', argument " "1"" of type '" "Magick::DrawablePath const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePath * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawablePath const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawablePoint(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  Magick::DrawablePoint *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawablePoint.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawablePoint.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawablePoint" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_DrawablePoint" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      result = (Magick::DrawablePoint *)new Magick::DrawablePoint(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawablePoint, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawablePoint(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawablePoint * arg1 = (Magick::DrawablePoint *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawablePoint_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePoint *arg1 = (Magick::DrawablePoint *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawablePoint_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePoint_call" "', argument " "1"" of type '" "Magick::DrawablePoint const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePoint * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawablePoint_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawablePoint const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawablePoint_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePoint *arg1 = (Magick::DrawablePoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawablePoint_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePoint_copy" "', argument " "1"" of type '" "Magick::DrawablePoint const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePoint * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawablePoint const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawablePoint_x__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePoint *arg1 = (Magick::DrawablePoint *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePoint_x" "', argument " "1"" of type '" "Magick::DrawablePoint *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePoint * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawablePoint_x" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->x(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawablePoint_x__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePoint *arg1 = (Magick::DrawablePoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePoint_x" "', argument " "1"" of type '" "Magick::DrawablePoint const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePoint * >(argp1);
  {
    try {
      result = (double)((Magick::DrawablePoint const *)arg1)->x();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawablePoint__wrap_DrawablePoint_x(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawablePoint_x__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawablePoint_x__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function x.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawablePoint_y__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePoint *arg1 = (Magick::DrawablePoint *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePoint_y" "', argument " "1"" of type '" "Magick::DrawablePoint *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePoint * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawablePoint_y" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->y(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawablePoint_y__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePoint *arg1 = (Magick::DrawablePoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePoint_y" "', argument " "1"" of type '" "Magick::DrawablePoint const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePoint * >(argp1);
  {
    try {
      result = (double)((Magick::DrawablePoint const *)arg1)->y();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawablePoint__wrap_DrawablePoint_y(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawablePoint_y__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawablePoint_y__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function y.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawablePointSize(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::DrawablePointSize *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawablePointSize.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawablePointSize.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawablePointSize" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::DrawablePointSize *)new Magick::DrawablePointSize(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawablePointSize, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawablePointSize(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawablePointSize * arg1 = (Magick::DrawablePointSize *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawablePointSize_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePointSize *arg1 = (Magick::DrawablePointSize *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawablePointSize_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePointSize, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePointSize_call" "', argument " "1"" of type '" "Magick::DrawablePointSize const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePointSize * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawablePointSize_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawablePointSize const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawablePointSize_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePointSize *arg1 = (Magick::DrawablePointSize *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawablePointSize_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePointSize, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePointSize_copy" "', argument " "1"" of type '" "Magick::DrawablePointSize const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePointSize * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawablePointSize const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawablePointSize_pointSize__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePointSize *arg1 = (Magick::DrawablePointSize *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePointSize, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePointSize_pointSize" "', argument " "1"" of type '" "Magick::DrawablePointSize *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePointSize * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawablePointSize_pointSize" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->pointSize(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawablePointSize_pointSize__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePointSize *arg1 = (Magick::DrawablePointSize *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePointSize, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePointSize_pointSize" "', argument " "1"" of type '" "Magick::DrawablePointSize const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePointSize * >(argp1);
  {
    try {
      result = (double)((Magick::DrawablePointSize const *)arg1)->pointSize();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawablePointSize__wrap_DrawablePointSize_pointSize(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawablePointSize_pointSize__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawablePointSize_pointSize__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function pointSize.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawablePolygon__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::CoordinateList *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawablePolygon *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawablePolygon__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawablePolygon__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_std__listT_Magick__Coordinate_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawablePolygon" "', argument " "1"" of type '" "Magick::CoordinateList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawablePolygon" "', argument " "1"" of type '" "Magick::CoordinateList const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::CoordinateList * >(argp1);
  {
    try {
      result = (Magick::DrawablePolygon *)new Magick::DrawablePolygon((Magick::CoordinateList const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawablePolygon, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawablePolygon__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::DrawablePolygon *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawablePolygon *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawablePolygon__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawablePolygon__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__DrawablePolygon,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawablePolygon" "', argument " "1"" of type '" "Magick::DrawablePolygon const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawablePolygon" "', argument " "1"" of type '" "Magick::DrawablePolygon const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePolygon * >(argp1);
  {
    try {
      result = (Magick::DrawablePolygon *)new Magick::DrawablePolygon((Magick::DrawablePolygon const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawablePolygon, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawablePolygon(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawablePolygon__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawablePolygon__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_DrawablePolygon");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawablePolygon(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawablePolygon * arg1 = (Magick::DrawablePolygon *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawablePolygon_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePolygon *arg1 = (Magick::DrawablePolygon *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawablePolygon_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePolygon, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePolygon_call" "', argument " "1"" of type '" "Magick::DrawablePolygon const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePolygon * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawablePolygon_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawablePolygon const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawablePolygon_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePolygon *arg1 = (Magick::DrawablePolygon *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawablePolygon_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePolygon, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePolygon_copy" "', argument " "1"" of type '" "Magick::DrawablePolygon const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePolygon * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawablePolygon const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawablePolyline__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::CoordinateList *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawablePolyline *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawablePolyline__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawablePolyline__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_std__listT_Magick__Coordinate_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawablePolyline" "', argument " "1"" of type '" "Magick::CoordinateList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawablePolyline" "', argument " "1"" of type '" "Magick::CoordinateList const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::CoordinateList * >(argp1);
  {
    try {
      result = (Magick::DrawablePolyline *)new Magick::DrawablePolyline((Magick::CoordinateList const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawablePolyline, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawablePolyline__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::DrawablePolyline *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawablePolyline *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawablePolyline__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawablePolyline__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__DrawablePolyline,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawablePolyline" "', argument " "1"" of type '" "Magick::DrawablePolyline const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawablePolyline" "', argument " "1"" of type '" "Magick::DrawablePolyline const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePolyline * >(argp1);
  {
    try {
      result = (Magick::DrawablePolyline *)new Magick::DrawablePolyline((Magick::DrawablePolyline const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawablePolyline, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawablePolyline(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawablePolyline__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawablePolyline__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_DrawablePolyline");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawablePolyline(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawablePolyline * arg1 = (Magick::DrawablePolyline *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawablePolyline_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePolyline *arg1 = (Magick::DrawablePolyline *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawablePolyline_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePolyline, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePolyline_call" "', argument " "1"" of type '" "Magick::DrawablePolyline const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePolyline * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawablePolyline_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawablePolyline const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawablePolyline_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePolyline *arg1 = (Magick::DrawablePolyline *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawablePolyline_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePolyline, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePolyline_copy" "', argument " "1"" of type '" "Magick::DrawablePolyline const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePolyline * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawablePolyline const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawablePopGraphicContext(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::DrawablePopGraphicContext *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawablePopGraphicContext.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawablePopGraphicContext.");
  {
    try {
      result = (Magick::DrawablePopGraphicContext *)new Magick::DrawablePopGraphicContext();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawablePopGraphicContext, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawablePopGraphicContext(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawablePopGraphicContext * arg1 = (Magick::DrawablePopGraphicContext *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawablePopGraphicContext_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePopGraphicContext *arg1 = (Magick::DrawablePopGraphicContext *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawablePopGraphicContext_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePopGraphicContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePopGraphicContext_call" "', argument " "1"" of type '" "Magick::DrawablePopGraphicContext const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePopGraphicContext * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawablePopGraphicContext_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawablePopGraphicContext const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawablePopGraphicContext_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePopGraphicContext *arg1 = (Magick::DrawablePopGraphicContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawablePopGraphicContext_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePopGraphicContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePopGraphicContext_copy" "', argument " "1"" of type '" "Magick::DrawablePopGraphicContext const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePopGraphicContext * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawablePopGraphicContext const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawablePushGraphicContext(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::DrawablePushGraphicContext *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawablePushGraphicContext.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawablePushGraphicContext.");
  {
    try {
      result = (Magick::DrawablePushGraphicContext *)new Magick::DrawablePushGraphicContext();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawablePushGraphicContext, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawablePushGraphicContext(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawablePushGraphicContext * arg1 = (Magick::DrawablePushGraphicContext *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawablePushGraphicContext_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePushGraphicContext *arg1 = (Magick::DrawablePushGraphicContext *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawablePushGraphicContext_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePushGraphicContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePushGraphicContext_call" "', argument " "1"" of type '" "Magick::DrawablePushGraphicContext const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePushGraphicContext * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawablePushGraphicContext_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawablePushGraphicContext const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawablePushGraphicContext_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePushGraphicContext *arg1 = (Magick::DrawablePushGraphicContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawablePushGraphicContext_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePushGraphicContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePushGraphicContext_copy" "', argument " "1"" of type '" "Magick::DrawablePushGraphicContext const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePushGraphicContext * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawablePushGraphicContext const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawablePopPattern(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::DrawablePopPattern *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawablePopPattern.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawablePopPattern.");
  {
    try {
      result = (Magick::DrawablePopPattern *)new Magick::DrawablePopPattern();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawablePopPattern, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawablePopPattern(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawablePopPattern * arg1 = (Magick::DrawablePopPattern *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawablePopPattern_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePopPattern *arg1 = (Magick::DrawablePopPattern *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawablePopPattern_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePopPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePopPattern_call" "', argument " "1"" of type '" "Magick::DrawablePopPattern const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePopPattern * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawablePopPattern_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawablePopPattern const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawablePopPattern_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePopPattern *arg1 = (Magick::DrawablePopPattern *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawablePopPattern_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePopPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePopPattern_copy" "', argument " "1"" of type '" "Magick::DrawablePopPattern const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePopPattern * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawablePopPattern const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawablePushPattern__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  size_t arg4 ;
  size_t arg5 ;
  int res1 = SWIG_OLDOBJ ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  Magick::DrawablePushPattern *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawablePushPattern__SWIG_0.");
  if(args.Length() != 5) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawablePushPattern__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawablePushPattern" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawablePushPattern" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_DrawablePushPattern" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_DrawablePushPattern" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  ecode4 = SWIG_AsVal_size_t(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_DrawablePushPattern" "', argument " "4"" of type '" "size_t""'");
  } 
  arg4 = static_cast< size_t >(val4);
  ecode5 = SWIG_AsVal_size_t(args[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_DrawablePushPattern" "', argument " "5"" of type '" "size_t""'");
  } 
  arg5 = static_cast< size_t >(val5);
  {
    try {
      result = (Magick::DrawablePushPattern *)new Magick::DrawablePushPattern((std::string const &)*arg1,arg2,arg3,arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawablePushPattern, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawablePushPattern__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::DrawablePushPattern *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawablePushPattern *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawablePushPattern__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawablePushPattern__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__DrawablePushPattern,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawablePushPattern" "', argument " "1"" of type '" "Magick::DrawablePushPattern const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawablePushPattern" "', argument " "1"" of type '" "Magick::DrawablePushPattern const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePushPattern * >(argp1);
  {
    try {
      result = (Magick::DrawablePushPattern *)new Magick::DrawablePushPattern((Magick::DrawablePushPattern const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawablePushPattern, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawablePushPattern(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 5) {
    errorHandler.err.Clear();
    _wrap_new_DrawablePushPattern__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawablePushPattern__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_DrawablePushPattern");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawablePushPattern(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawablePushPattern * arg1 = (Magick::DrawablePushPattern *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawablePushPattern_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePushPattern *arg1 = (Magick::DrawablePushPattern *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawablePushPattern_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePushPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePushPattern_call" "', argument " "1"" of type '" "Magick::DrawablePushPattern const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePushPattern * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawablePushPattern_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawablePushPattern const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawablePushPattern_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawablePushPattern *arg1 = (Magick::DrawablePushPattern *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawablePushPattern_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawablePushPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawablePushPattern_copy" "', argument " "1"" of type '" "Magick::DrawablePushPattern const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawablePushPattern * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawablePushPattern const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableRectangle(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  Magick::DrawableRectangle *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableRectangle.");
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableRectangle.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableRectangle" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_DrawableRectangle" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_DrawableRectangle" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_DrawableRectangle" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    try {
      result = (Magick::DrawableRectangle *)new Magick::DrawableRectangle(arg1,arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableRectangle, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableRectangle(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableRectangle * arg1 = (Magick::DrawableRectangle *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableRectangle_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRectangle *arg1 = (Magick::DrawableRectangle *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableRectangle_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRectangle_call" "', argument " "1"" of type '" "Magick::DrawableRectangle const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRectangle * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableRectangle_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableRectangle const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRectangle_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRectangle *arg1 = (Magick::DrawableRectangle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableRectangle_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRectangle_copy" "', argument " "1"" of type '" "Magick::DrawableRectangle const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRectangle * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableRectangle const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRectangle_upperLeftX__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRectangle *arg1 = (Magick::DrawableRectangle *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRectangle_upperLeftX" "', argument " "1"" of type '" "Magick::DrawableRectangle *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRectangle * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableRectangle_upperLeftX" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->upperLeftX(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRectangle_upperLeftX__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRectangle *arg1 = (Magick::DrawableRectangle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRectangle_upperLeftX" "', argument " "1"" of type '" "Magick::DrawableRectangle const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRectangle * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableRectangle const *)arg1)->upperLeftX();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRectangle__wrap_DrawableRectangle_upperLeftX(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableRectangle_upperLeftX__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableRectangle_upperLeftX__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function upperLeftX.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRectangle_upperLeftY__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRectangle *arg1 = (Magick::DrawableRectangle *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRectangle_upperLeftY" "', argument " "1"" of type '" "Magick::DrawableRectangle *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRectangle * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableRectangle_upperLeftY" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->upperLeftY(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRectangle_upperLeftY__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRectangle *arg1 = (Magick::DrawableRectangle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRectangle_upperLeftY" "', argument " "1"" of type '" "Magick::DrawableRectangle const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRectangle * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableRectangle const *)arg1)->upperLeftY();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRectangle__wrap_DrawableRectangle_upperLeftY(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableRectangle_upperLeftY__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableRectangle_upperLeftY__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function upperLeftY.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRectangle_lowerRightX__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRectangle *arg1 = (Magick::DrawableRectangle *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRectangle_lowerRightX" "', argument " "1"" of type '" "Magick::DrawableRectangle *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRectangle * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableRectangle_lowerRightX" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->lowerRightX(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRectangle_lowerRightX__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRectangle *arg1 = (Magick::DrawableRectangle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRectangle_lowerRightX" "', argument " "1"" of type '" "Magick::DrawableRectangle const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRectangle * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableRectangle const *)arg1)->lowerRightX();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRectangle__wrap_DrawableRectangle_lowerRightX(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableRectangle_lowerRightX__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableRectangle_lowerRightX__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function lowerRightX.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRectangle_lowerRightY__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRectangle *arg1 = (Magick::DrawableRectangle *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRectangle_lowerRightY" "', argument " "1"" of type '" "Magick::DrawableRectangle *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRectangle * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableRectangle_lowerRightY" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->lowerRightY(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRectangle_lowerRightY__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRectangle *arg1 = (Magick::DrawableRectangle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRectangle_lowerRightY" "', argument " "1"" of type '" "Magick::DrawableRectangle const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRectangle * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableRectangle const *)arg1)->lowerRightY();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRectangle__wrap_DrawableRectangle_lowerRightY(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableRectangle_lowerRightY__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableRectangle_lowerRightY__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function lowerRightY.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableRotation(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::DrawableRotation *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableRotation.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableRotation.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableRotation" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::DrawableRotation *)new Magick::DrawableRotation(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableRotation, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableRotation(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableRotation * arg1 = (Magick::DrawableRotation *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableRotation_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRotation *arg1 = (Magick::DrawableRotation *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableRotation_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRotation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRotation_call" "', argument " "1"" of type '" "Magick::DrawableRotation const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRotation * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableRotation_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableRotation const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRotation_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRotation *arg1 = (Magick::DrawableRotation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableRotation_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRotation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRotation_copy" "', argument " "1"" of type '" "Magick::DrawableRotation const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRotation * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableRotation const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRotation_angle__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRotation *arg1 = (Magick::DrawableRotation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRotation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRotation_angle" "', argument " "1"" of type '" "Magick::DrawableRotation *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRotation * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableRotation_angle" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->angle(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRotation_angle__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRotation *arg1 = (Magick::DrawableRotation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRotation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRotation_angle" "', argument " "1"" of type '" "Magick::DrawableRotation const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRotation * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableRotation const *)arg1)->angle();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRotation__wrap_DrawableRotation_angle(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableRotation_angle__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableRotation_angle__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function angle.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableRoundRectangle(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  Magick::DrawableRoundRectangle *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableRoundRectangle.");
  if(args.Length() != 6) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableRoundRectangle.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableRoundRectangle" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_DrawableRoundRectangle" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_DrawableRoundRectangle" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_DrawableRoundRectangle" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  ecode5 = SWIG_AsVal_double(args[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_DrawableRoundRectangle" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = static_cast< double >(val5);
  ecode6 = SWIG_AsVal_double(args[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_DrawableRoundRectangle" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = static_cast< double >(val6);
  {
    try {
      result = (Magick::DrawableRoundRectangle *)new Magick::DrawableRoundRectangle(arg1,arg2,arg3,arg4,arg5,arg6);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableRoundRectangle, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableRoundRectangle(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableRoundRectangle * arg1 = (Magick::DrawableRoundRectangle *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRoundRectangle *arg1 = (Magick::DrawableRoundRectangle *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableRoundRectangle_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRoundRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRoundRectangle_call" "', argument " "1"" of type '" "Magick::DrawableRoundRectangle const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRoundRectangle * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableRoundRectangle_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableRoundRectangle const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRoundRectangle *arg1 = (Magick::DrawableRoundRectangle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableRoundRectangle_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRoundRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRoundRectangle_copy" "', argument " "1"" of type '" "Magick::DrawableRoundRectangle const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRoundRectangle * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableRoundRectangle const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle_centerX__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRoundRectangle *arg1 = (Magick::DrawableRoundRectangle *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRoundRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRoundRectangle_centerX" "', argument " "1"" of type '" "Magick::DrawableRoundRectangle *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRoundRectangle * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableRoundRectangle_centerX" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->centerX(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle_centerX__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRoundRectangle *arg1 = (Magick::DrawableRoundRectangle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRoundRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRoundRectangle_centerX" "', argument " "1"" of type '" "Magick::DrawableRoundRectangle const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRoundRectangle * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableRoundRectangle const *)arg1)->centerX();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle__wrap_DrawableRoundRectangle_centerX(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableRoundRectangle_centerX__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableRoundRectangle_centerX__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function centerX.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle_centerY__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRoundRectangle *arg1 = (Magick::DrawableRoundRectangle *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRoundRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRoundRectangle_centerY" "', argument " "1"" of type '" "Magick::DrawableRoundRectangle *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRoundRectangle * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableRoundRectangle_centerY" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->centerY(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle_centerY__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRoundRectangle *arg1 = (Magick::DrawableRoundRectangle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRoundRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRoundRectangle_centerY" "', argument " "1"" of type '" "Magick::DrawableRoundRectangle const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRoundRectangle * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableRoundRectangle const *)arg1)->centerY();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle__wrap_DrawableRoundRectangle_centerY(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableRoundRectangle_centerY__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableRoundRectangle_centerY__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function centerY.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle_width__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRoundRectangle *arg1 = (Magick::DrawableRoundRectangle *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRoundRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRoundRectangle_width" "', argument " "1"" of type '" "Magick::DrawableRoundRectangle *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRoundRectangle * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableRoundRectangle_width" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->width(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle_width__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRoundRectangle *arg1 = (Magick::DrawableRoundRectangle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRoundRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRoundRectangle_width" "', argument " "1"" of type '" "Magick::DrawableRoundRectangle const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRoundRectangle * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableRoundRectangle const *)arg1)->width();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle__wrap_DrawableRoundRectangle_width(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableRoundRectangle_width__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableRoundRectangle_width__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function width.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle_hight__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRoundRectangle *arg1 = (Magick::DrawableRoundRectangle *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRoundRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRoundRectangle_hight" "', argument " "1"" of type '" "Magick::DrawableRoundRectangle *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRoundRectangle * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableRoundRectangle_hight" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->hight(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle_hight__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRoundRectangle *arg1 = (Magick::DrawableRoundRectangle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRoundRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRoundRectangle_hight" "', argument " "1"" of type '" "Magick::DrawableRoundRectangle const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRoundRectangle * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableRoundRectangle const *)arg1)->hight();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle__wrap_DrawableRoundRectangle_hight(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableRoundRectangle_hight__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableRoundRectangle_hight__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function hight.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle_upperLeftX__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRoundRectangle *arg1 = (Magick::DrawableRoundRectangle *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRoundRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRoundRectangle_upperLeftX" "', argument " "1"" of type '" "Magick::DrawableRoundRectangle *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRoundRectangle * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableRoundRectangle_upperLeftX" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->upperLeftX(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle_upperLeftX__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRoundRectangle *arg1 = (Magick::DrawableRoundRectangle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRoundRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRoundRectangle_upperLeftX" "', argument " "1"" of type '" "Magick::DrawableRoundRectangle const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRoundRectangle * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableRoundRectangle const *)arg1)->upperLeftX();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle__wrap_DrawableRoundRectangle_upperLeftX(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableRoundRectangle_upperLeftX__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableRoundRectangle_upperLeftX__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function upperLeftX.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle_upperLeftY__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRoundRectangle *arg1 = (Magick::DrawableRoundRectangle *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRoundRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRoundRectangle_upperLeftY" "', argument " "1"" of type '" "Magick::DrawableRoundRectangle *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRoundRectangle * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableRoundRectangle_upperLeftY" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->upperLeftY(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle_upperLeftY__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRoundRectangle *arg1 = (Magick::DrawableRoundRectangle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRoundRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRoundRectangle_upperLeftY" "', argument " "1"" of type '" "Magick::DrawableRoundRectangle const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRoundRectangle * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableRoundRectangle const *)arg1)->upperLeftY();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle__wrap_DrawableRoundRectangle_upperLeftY(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableRoundRectangle_upperLeftY__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableRoundRectangle_upperLeftY__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function upperLeftY.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle_lowerRightX__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRoundRectangle *arg1 = (Magick::DrawableRoundRectangle *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRoundRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRoundRectangle_lowerRightX" "', argument " "1"" of type '" "Magick::DrawableRoundRectangle *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRoundRectangle * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableRoundRectangle_lowerRightX" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->lowerRightX(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle_lowerRightX__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRoundRectangle *arg1 = (Magick::DrawableRoundRectangle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRoundRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRoundRectangle_lowerRightX" "', argument " "1"" of type '" "Magick::DrawableRoundRectangle const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRoundRectangle * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableRoundRectangle const *)arg1)->lowerRightX();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle__wrap_DrawableRoundRectangle_lowerRightX(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableRoundRectangle_lowerRightX__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableRoundRectangle_lowerRightX__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function lowerRightX.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle_lowerRightY__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRoundRectangle *arg1 = (Magick::DrawableRoundRectangle *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRoundRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRoundRectangle_lowerRightY" "', argument " "1"" of type '" "Magick::DrawableRoundRectangle *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRoundRectangle * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableRoundRectangle_lowerRightY" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->lowerRightY(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle_lowerRightY__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRoundRectangle *arg1 = (Magick::DrawableRoundRectangle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRoundRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRoundRectangle_lowerRightY" "', argument " "1"" of type '" "Magick::DrawableRoundRectangle const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRoundRectangle * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableRoundRectangle const *)arg1)->lowerRightY();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle__wrap_DrawableRoundRectangle_lowerRightY(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableRoundRectangle_lowerRightY__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableRoundRectangle_lowerRightY__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function lowerRightY.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle_cornerWidth__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRoundRectangle *arg1 = (Magick::DrawableRoundRectangle *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRoundRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRoundRectangle_cornerWidth" "', argument " "1"" of type '" "Magick::DrawableRoundRectangle *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRoundRectangle * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableRoundRectangle_cornerWidth" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->cornerWidth(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle_cornerWidth__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRoundRectangle *arg1 = (Magick::DrawableRoundRectangle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRoundRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRoundRectangle_cornerWidth" "', argument " "1"" of type '" "Magick::DrawableRoundRectangle const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRoundRectangle * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableRoundRectangle const *)arg1)->cornerWidth();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle__wrap_DrawableRoundRectangle_cornerWidth(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableRoundRectangle_cornerWidth__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableRoundRectangle_cornerWidth__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function cornerWidth.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle_cornerHeight__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRoundRectangle *arg1 = (Magick::DrawableRoundRectangle *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRoundRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRoundRectangle_cornerHeight" "', argument " "1"" of type '" "Magick::DrawableRoundRectangle *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRoundRectangle * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableRoundRectangle_cornerHeight" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->cornerHeight(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle_cornerHeight__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableRoundRectangle *arg1 = (Magick::DrawableRoundRectangle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableRoundRectangle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableRoundRectangle_cornerHeight" "', argument " "1"" of type '" "Magick::DrawableRoundRectangle const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableRoundRectangle * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableRoundRectangle const *)arg1)->cornerHeight();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableRoundRectangle__wrap_DrawableRoundRectangle_cornerHeight(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableRoundRectangle_cornerHeight__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableRoundRectangle_cornerHeight__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function cornerHeight.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableScaling(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  Magick::DrawableScaling *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableScaling.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableScaling.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableScaling" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_DrawableScaling" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      result = (Magick::DrawableScaling *)new Magick::DrawableScaling(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableScaling, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableScaling(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableScaling * arg1 = (Magick::DrawableScaling *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableScaling_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableScaling *arg1 = (Magick::DrawableScaling *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableScaling_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableScaling, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableScaling_call" "', argument " "1"" of type '" "Magick::DrawableScaling const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableScaling * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableScaling_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableScaling const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableScaling_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableScaling *arg1 = (Magick::DrawableScaling *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableScaling_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableScaling, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableScaling_copy" "', argument " "1"" of type '" "Magick::DrawableScaling const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableScaling * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableScaling const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableScaling_x__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableScaling *arg1 = (Magick::DrawableScaling *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableScaling, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableScaling_x" "', argument " "1"" of type '" "Magick::DrawableScaling *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableScaling * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableScaling_x" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->x(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableScaling_x__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableScaling *arg1 = (Magick::DrawableScaling *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableScaling, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableScaling_x" "', argument " "1"" of type '" "Magick::DrawableScaling const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableScaling * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableScaling const *)arg1)->x();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableScaling__wrap_DrawableScaling_x(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableScaling_x__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableScaling_x__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function x.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableScaling_y__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableScaling *arg1 = (Magick::DrawableScaling *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableScaling, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableScaling_y" "', argument " "1"" of type '" "Magick::DrawableScaling *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableScaling * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableScaling_y" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->y(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableScaling_y__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableScaling *arg1 = (Magick::DrawableScaling *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableScaling, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableScaling_y" "', argument " "1"" of type '" "Magick::DrawableScaling const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableScaling * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableScaling const *)arg1)->y();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableScaling__wrap_DrawableScaling_y(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableScaling_y__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableScaling_y__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function y.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableSkewX(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::DrawableSkewX *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableSkewX.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableSkewX.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableSkewX" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::DrawableSkewX *)new Magick::DrawableSkewX(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableSkewX, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableSkewX(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableSkewX * arg1 = (Magick::DrawableSkewX *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableSkewX_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableSkewX *arg1 = (Magick::DrawableSkewX *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableSkewX_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableSkewX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableSkewX_call" "', argument " "1"" of type '" "Magick::DrawableSkewX const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableSkewX * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableSkewX_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableSkewX const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableSkewX_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableSkewX *arg1 = (Magick::DrawableSkewX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableSkewX_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableSkewX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableSkewX_copy" "', argument " "1"" of type '" "Magick::DrawableSkewX const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableSkewX * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableSkewX const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableSkewX_angle__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableSkewX *arg1 = (Magick::DrawableSkewX *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableSkewX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableSkewX_angle" "', argument " "1"" of type '" "Magick::DrawableSkewX *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableSkewX * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableSkewX_angle" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->angle(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableSkewX_angle__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableSkewX *arg1 = (Magick::DrawableSkewX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableSkewX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableSkewX_angle" "', argument " "1"" of type '" "Magick::DrawableSkewX const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableSkewX * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableSkewX const *)arg1)->angle();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableSkewX__wrap_DrawableSkewX_angle(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableSkewX_angle__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableSkewX_angle__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function angle.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableSkewY(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::DrawableSkewY *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableSkewY.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableSkewY.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableSkewY" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::DrawableSkewY *)new Magick::DrawableSkewY(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableSkewY, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableSkewY(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableSkewY * arg1 = (Magick::DrawableSkewY *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableSkewY_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableSkewY *arg1 = (Magick::DrawableSkewY *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableSkewY_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableSkewY, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableSkewY_call" "', argument " "1"" of type '" "Magick::DrawableSkewY const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableSkewY * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableSkewY_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableSkewY const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableSkewY_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableSkewY *arg1 = (Magick::DrawableSkewY *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableSkewY_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableSkewY, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableSkewY_copy" "', argument " "1"" of type '" "Magick::DrawableSkewY const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableSkewY * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableSkewY const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableSkewY_angle__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableSkewY *arg1 = (Magick::DrawableSkewY *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableSkewY, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableSkewY_angle" "', argument " "1"" of type '" "Magick::DrawableSkewY *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableSkewY * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableSkewY_angle" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->angle(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableSkewY_angle__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableSkewY *arg1 = (Magick::DrawableSkewY *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableSkewY, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableSkewY_angle" "', argument " "1"" of type '" "Magick::DrawableSkewY const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableSkewY * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableSkewY const *)arg1)->angle();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableSkewY__wrap_DrawableSkewY_angle(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableSkewY_angle__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableSkewY_angle__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function angle.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableDashArray__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double *arg1 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableDashArray *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableDashArray__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableDashArray__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawableDashArray" "', argument " "1"" of type '" "double const *""'"); 
  }
  arg1 = reinterpret_cast< double * >(argp1);
  {
    try {
      result = (Magick::DrawableDashArray *)new Magick::DrawableDashArray((double const *)arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableDashArray, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableDashArray__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t *arg1 = (size_t *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableDashArray *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableDashArray__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableDashArray__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_size_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawableDashArray" "', argument " "1"" of type '" "size_t const *""'"); 
  }
  arg1 = reinterpret_cast< size_t * >(argp1);
  {
    try {
      result = (Magick::DrawableDashArray *)new Magick::DrawableDashArray((size_t const *)arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableDashArray, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableDashArray__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::DrawableDashArray *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableDashArray *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableDashArray__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableDashArray__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__DrawableDashArray,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawableDashArray" "', argument " "1"" of type '" "Magick::DrawableDashArray const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableDashArray" "', argument " "1"" of type '" "Magick::DrawableDashArray const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableDashArray * >(argp1);
  {
    try {
      result = (Magick::DrawableDashArray *)new Magick::DrawableDashArray((Magick::DrawableDashArray const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableDashArray, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableDashArray(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawableDashArray__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawableDashArray__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawableDashArray__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_DrawableDashArray");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableDashArray(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableDashArray * arg1 = (Magick::DrawableDashArray *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableDashArray_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableDashArray *arg1 = (Magick::DrawableDashArray *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableDashArray_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableDashArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableDashArray_call" "', argument " "1"" of type '" "Magick::DrawableDashArray const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableDashArray * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableDashArray_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableDashArray const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableDashArray_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableDashArray *arg1 = (Magick::DrawableDashArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableDashArray_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableDashArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableDashArray_copy" "', argument " "1"" of type '" "Magick::DrawableDashArray const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableDashArray * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableDashArray const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableDashArray_dasharray__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableDashArray *arg1 = (Magick::DrawableDashArray *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableDashArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableDashArray_dasharray" "', argument " "1"" of type '" "Magick::DrawableDashArray *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableDashArray * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableDashArray_dasharray" "', argument " "2"" of type '" "double const *""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  {
    try {
      (arg1)->dasharray((double const *)arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableDashArray_dasharray__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableDashArray *arg1 = (Magick::DrawableDashArray *) 0 ;
  size_t *arg2 = (size_t *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableDashArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableDashArray_dasharray" "', argument " "1"" of type '" "Magick::DrawableDashArray *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableDashArray * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p_size_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableDashArray_dasharray" "', argument " "2"" of type '" "size_t const *""'"); 
  }
  arg2 = reinterpret_cast< size_t * >(argp2);
  {
    try {
      (arg1)->dasharray((size_t const *)arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableDashArray_dasharray__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableDashArray *arg1 = (Magick::DrawableDashArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double *result = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableDashArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableDashArray_dasharray" "', argument " "1"" of type '" "Magick::DrawableDashArray const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableDashArray * >(argp1);
  {
    try {
      result = (double *)((Magick::DrawableDashArray const *)arg1)->dasharray();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableDashArray__wrap_DrawableDashArray_dasharray(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableDashArray_dasharray__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableDashArray_dasharray__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableDashArray_dasharray__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function dasharray.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableDashArray_clone(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableDashArray *arg1 = (Magick::DrawableDashArray *) 0 ;
  Magick::DrawableDashArray *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::DrawableDashArray *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableDashArray_clone.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableDashArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableDashArray_clone" "', argument " "1"" of type '" "Magick::DrawableDashArray *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableDashArray * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__DrawableDashArray,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableDashArray_clone" "', argument " "2"" of type '" "Magick::DrawableDashArray const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DrawableDashArray_clone" "', argument " "2"" of type '" "Magick::DrawableDashArray const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::DrawableDashArray * >(argp2);
  {
    try {
      result = (Magick::DrawableDashArray *) &(arg1)->operator =((Magick::DrawableDashArray const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableDashArray, 0 |  0 );
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableDashOffset(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::DrawableDashOffset *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableDashOffset.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableDashOffset.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableDashOffset" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::DrawableDashOffset *)new Magick::DrawableDashOffset(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableDashOffset, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableDashOffset(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableDashOffset * arg1 = (Magick::DrawableDashOffset *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableDashOffset_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableDashOffset *arg1 = (Magick::DrawableDashOffset *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableDashOffset_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableDashOffset, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableDashOffset_call" "', argument " "1"" of type '" "Magick::DrawableDashOffset const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableDashOffset * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableDashOffset_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableDashOffset const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableDashOffset_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableDashOffset *arg1 = (Magick::DrawableDashOffset *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableDashOffset_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableDashOffset, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableDashOffset_copy" "', argument " "1"" of type '" "Magick::DrawableDashOffset const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableDashOffset * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableDashOffset const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableDashOffset_offset__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableDashOffset *arg1 = (Magick::DrawableDashOffset *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableDashOffset, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableDashOffset_offset" "', argument " "1"" of type '" "Magick::DrawableDashOffset *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableDashOffset * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableDashOffset_offset" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->offset(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableDashOffset_offset__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableDashOffset *arg1 = (Magick::DrawableDashOffset *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableDashOffset, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableDashOffset_offset" "', argument " "1"" of type '" "Magick::DrawableDashOffset const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableDashOffset * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableDashOffset const *)arg1)->offset();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableDashOffset__wrap_DrawableDashOffset_offset(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableDashOffset_offset__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableDashOffset_offset__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function offset.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableStrokeLineCap(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::LineCap arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  Magick::DrawableStrokeLineCap *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableStrokeLineCap.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableStrokeLineCap.");
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableStrokeLineCap" "', argument " "1"" of type '" "Magick::LineCap""'");
  } 
  arg1 = static_cast< Magick::LineCap >(val1);
  {
    try {
      result = (Magick::DrawableStrokeLineCap *)new Magick::DrawableStrokeLineCap(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableStrokeLineCap, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableStrokeLineCap(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableStrokeLineCap * arg1 = (Magick::DrawableStrokeLineCap *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableStrokeLineCap_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableStrokeLineCap *arg1 = (Magick::DrawableStrokeLineCap *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableStrokeLineCap_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableStrokeLineCap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableStrokeLineCap_call" "', argument " "1"" of type '" "Magick::DrawableStrokeLineCap const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableStrokeLineCap * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableStrokeLineCap_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableStrokeLineCap const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableStrokeLineCap_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableStrokeLineCap *arg1 = (Magick::DrawableStrokeLineCap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableStrokeLineCap_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableStrokeLineCap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableStrokeLineCap_copy" "', argument " "1"" of type '" "Magick::DrawableStrokeLineCap const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableStrokeLineCap * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableStrokeLineCap const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableStrokeLineCap_linecap__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableStrokeLineCap *arg1 = (Magick::DrawableStrokeLineCap *) 0 ;
  Magick::LineCap arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableStrokeLineCap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableStrokeLineCap_linecap" "', argument " "1"" of type '" "Magick::DrawableStrokeLineCap *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableStrokeLineCap * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableStrokeLineCap_linecap" "', argument " "2"" of type '" "Magick::LineCap""'");
  } 
  arg2 = static_cast< Magick::LineCap >(val2);
  {
    try {
      (arg1)->linecap(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableStrokeLineCap_linecap__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableStrokeLineCap *arg1 = (Magick::DrawableStrokeLineCap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::LineCap result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableStrokeLineCap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableStrokeLineCap_linecap" "', argument " "1"" of type '" "Magick::DrawableStrokeLineCap const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableStrokeLineCap * >(argp1);
  {
    try {
      result = (Magick::LineCap)((Magick::DrawableStrokeLineCap const *)arg1)->linecap();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableStrokeLineCap__wrap_DrawableStrokeLineCap_linecap(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableStrokeLineCap_linecap__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableStrokeLineCap_linecap__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function linecap.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableStrokeLineJoin(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::LineJoin arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  Magick::DrawableStrokeLineJoin *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableStrokeLineJoin.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableStrokeLineJoin.");
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableStrokeLineJoin" "', argument " "1"" of type '" "Magick::LineJoin""'");
  } 
  arg1 = static_cast< Magick::LineJoin >(val1);
  {
    try {
      result = (Magick::DrawableStrokeLineJoin *)new Magick::DrawableStrokeLineJoin(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableStrokeLineJoin, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableStrokeLineJoin(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableStrokeLineJoin * arg1 = (Magick::DrawableStrokeLineJoin *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableStrokeLineJoin_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableStrokeLineJoin *arg1 = (Magick::DrawableStrokeLineJoin *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableStrokeLineJoin_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableStrokeLineJoin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableStrokeLineJoin_call" "', argument " "1"" of type '" "Magick::DrawableStrokeLineJoin const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableStrokeLineJoin * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableStrokeLineJoin_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableStrokeLineJoin const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableStrokeLineJoin_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableStrokeLineJoin *arg1 = (Magick::DrawableStrokeLineJoin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableStrokeLineJoin_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableStrokeLineJoin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableStrokeLineJoin_copy" "', argument " "1"" of type '" "Magick::DrawableStrokeLineJoin const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableStrokeLineJoin * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableStrokeLineJoin const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableStrokeLineJoin_linejoin__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableStrokeLineJoin *arg1 = (Magick::DrawableStrokeLineJoin *) 0 ;
  Magick::LineJoin arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableStrokeLineJoin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableStrokeLineJoin_linejoin" "', argument " "1"" of type '" "Magick::DrawableStrokeLineJoin *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableStrokeLineJoin * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableStrokeLineJoin_linejoin" "', argument " "2"" of type '" "Magick::LineJoin""'");
  } 
  arg2 = static_cast< Magick::LineJoin >(val2);
  {
    try {
      (arg1)->linejoin(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableStrokeLineJoin_linejoin__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableStrokeLineJoin *arg1 = (Magick::DrawableStrokeLineJoin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::LineJoin result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableStrokeLineJoin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableStrokeLineJoin_linejoin" "', argument " "1"" of type '" "Magick::DrawableStrokeLineJoin const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableStrokeLineJoin * >(argp1);
  {
    try {
      result = (Magick::LineJoin)((Magick::DrawableStrokeLineJoin const *)arg1)->linejoin();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableStrokeLineJoin__wrap_DrawableStrokeLineJoin_linejoin(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableStrokeLineJoin_linejoin__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableStrokeLineJoin_linejoin__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function linejoin.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableMiterLimit(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  Magick::DrawableMiterLimit *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableMiterLimit.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableMiterLimit.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableMiterLimit" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  {
    try {
      result = (Magick::DrawableMiterLimit *)new Magick::DrawableMiterLimit(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableMiterLimit, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableMiterLimit(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableMiterLimit * arg1 = (Magick::DrawableMiterLimit *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableMiterLimit_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableMiterLimit *arg1 = (Magick::DrawableMiterLimit *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableMiterLimit_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableMiterLimit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableMiterLimit_call" "', argument " "1"" of type '" "Magick::DrawableMiterLimit const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableMiterLimit * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableMiterLimit_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableMiterLimit const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableMiterLimit_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableMiterLimit *arg1 = (Magick::DrawableMiterLimit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableMiterLimit_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableMiterLimit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableMiterLimit_copy" "', argument " "1"" of type '" "Magick::DrawableMiterLimit const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableMiterLimit * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableMiterLimit const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableMiterLimit_miterlimit__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableMiterLimit *arg1 = (Magick::DrawableMiterLimit *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableMiterLimit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableMiterLimit_miterlimit" "', argument " "1"" of type '" "Magick::DrawableMiterLimit *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableMiterLimit * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableMiterLimit_miterlimit" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      (arg1)->miterlimit(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableMiterLimit_miterlimit__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableMiterLimit *arg1 = (Magick::DrawableMiterLimit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableMiterLimit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableMiterLimit_miterlimit" "', argument " "1"" of type '" "Magick::DrawableMiterLimit const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableMiterLimit * >(argp1);
  {
    try {
      result = ((Magick::DrawableMiterLimit const *)arg1)->miterlimit();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableMiterLimit__wrap_DrawableMiterLimit_miterlimit(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableMiterLimit_miterlimit__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableMiterLimit_miterlimit__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function miterlimit.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableStrokeAntialias(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  Magick::DrawableStrokeAntialias *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableStrokeAntialias.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableStrokeAntialias.");
  ecode1 = SWIG_AsVal_bool(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableStrokeAntialias" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      result = (Magick::DrawableStrokeAntialias *)new Magick::DrawableStrokeAntialias(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableStrokeAntialias, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableStrokeAntialias(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableStrokeAntialias * arg1 = (Magick::DrawableStrokeAntialias *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableStrokeAntialias_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableStrokeAntialias *arg1 = (Magick::DrawableStrokeAntialias *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableStrokeAntialias_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableStrokeAntialias, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableStrokeAntialias_call" "', argument " "1"" of type '" "Magick::DrawableStrokeAntialias const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableStrokeAntialias * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableStrokeAntialias_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableStrokeAntialias const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableStrokeAntialias_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableStrokeAntialias *arg1 = (Magick::DrawableStrokeAntialias *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableStrokeAntialias_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableStrokeAntialias, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableStrokeAntialias_copy" "', argument " "1"" of type '" "Magick::DrawableStrokeAntialias const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableStrokeAntialias * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableStrokeAntialias const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableStrokeAntialias_flag__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableStrokeAntialias *arg1 = (Magick::DrawableStrokeAntialias *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableStrokeAntialias, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableStrokeAntialias_flag" "', argument " "1"" of type '" "Magick::DrawableStrokeAntialias *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableStrokeAntialias * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableStrokeAntialias_flag" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->flag(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableStrokeAntialias_flag__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableStrokeAntialias *arg1 = (Magick::DrawableStrokeAntialias *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableStrokeAntialias, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableStrokeAntialias_flag" "', argument " "1"" of type '" "Magick::DrawableStrokeAntialias const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableStrokeAntialias * >(argp1);
  {
    try {
      result = (bool)((Magick::DrawableStrokeAntialias const *)arg1)->flag();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableStrokeAntialias__wrap_DrawableStrokeAntialias_flag(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableStrokeAntialias_flag__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableStrokeAntialias_flag__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function flag.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableStrokeColor__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Color *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableStrokeColor *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableStrokeColor__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableStrokeColor__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawableStrokeColor" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableStrokeColor" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  {
    try {
      result = (Magick::DrawableStrokeColor *)new Magick::DrawableStrokeColor((Magick::Color const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableStrokeColor, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableStrokeColor__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::DrawableStrokeColor *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableStrokeColor *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableStrokeColor__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableStrokeColor__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__DrawableStrokeColor,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawableStrokeColor" "', argument " "1"" of type '" "Magick::DrawableStrokeColor const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableStrokeColor" "', argument " "1"" of type '" "Magick::DrawableStrokeColor const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableStrokeColor * >(argp1);
  {
    try {
      result = (Magick::DrawableStrokeColor *)new Magick::DrawableStrokeColor((Magick::DrawableStrokeColor const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableStrokeColor, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableStrokeColor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawableStrokeColor__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawableStrokeColor__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_DrawableStrokeColor");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableStrokeColor(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableStrokeColor * arg1 = (Magick::DrawableStrokeColor *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableStrokeColor_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableStrokeColor *arg1 = (Magick::DrawableStrokeColor *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableStrokeColor_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableStrokeColor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableStrokeColor_call" "', argument " "1"" of type '" "Magick::DrawableStrokeColor const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableStrokeColor * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableStrokeColor_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableStrokeColor const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableStrokeColor_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableStrokeColor *arg1 = (Magick::DrawableStrokeColor *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableStrokeColor_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableStrokeColor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableStrokeColor_copy" "', argument " "1"" of type '" "Magick::DrawableStrokeColor const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableStrokeColor * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableStrokeColor const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableStrokeColor_color__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableStrokeColor *arg1 = (Magick::DrawableStrokeColor *) 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableStrokeColor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableStrokeColor_color" "', argument " "1"" of type '" "Magick::DrawableStrokeColor *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableStrokeColor * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableStrokeColor_color" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DrawableStrokeColor_color" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      (arg1)->color((Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableStrokeColor_color__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableStrokeColor *arg1 = (Magick::DrawableStrokeColor *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Color result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableStrokeColor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableStrokeColor_color" "', argument " "1"" of type '" "Magick::DrawableStrokeColor const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableStrokeColor * >(argp1);
  {
    try {
      result = ((Magick::DrawableStrokeColor const *)arg1)->color();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Color(result)), SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableStrokeColor__wrap_DrawableStrokeColor_color(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableStrokeColor_color__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableStrokeColor_color__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function color.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableStrokeOpacity(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::DrawableStrokeOpacity *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableStrokeOpacity.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableStrokeOpacity.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableStrokeOpacity" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::DrawableStrokeOpacity *)new Magick::DrawableStrokeOpacity(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableStrokeOpacity, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableStrokeOpacity(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableStrokeOpacity * arg1 = (Magick::DrawableStrokeOpacity *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableStrokeOpacity_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableStrokeOpacity *arg1 = (Magick::DrawableStrokeOpacity *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableStrokeOpacity_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableStrokeOpacity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableStrokeOpacity_call" "', argument " "1"" of type '" "Magick::DrawableStrokeOpacity const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableStrokeOpacity * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableStrokeOpacity_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableStrokeOpacity const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableStrokeOpacity_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableStrokeOpacity *arg1 = (Magick::DrawableStrokeOpacity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableStrokeOpacity_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableStrokeOpacity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableStrokeOpacity_copy" "', argument " "1"" of type '" "Magick::DrawableStrokeOpacity const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableStrokeOpacity * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableStrokeOpacity const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableStrokeOpacity_opacity__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableStrokeOpacity *arg1 = (Magick::DrawableStrokeOpacity *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableStrokeOpacity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableStrokeOpacity_opacity" "', argument " "1"" of type '" "Magick::DrawableStrokeOpacity *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableStrokeOpacity * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableStrokeOpacity_opacity" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->opacity(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableStrokeOpacity_opacity__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableStrokeOpacity *arg1 = (Magick::DrawableStrokeOpacity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableStrokeOpacity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableStrokeOpacity_opacity" "', argument " "1"" of type '" "Magick::DrawableStrokeOpacity const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableStrokeOpacity * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableStrokeOpacity const *)arg1)->opacity();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableStrokeOpacity__wrap_DrawableStrokeOpacity_opacity(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableStrokeOpacity_opacity__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableStrokeOpacity_opacity__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function opacity.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableStrokeWidth(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::DrawableStrokeWidth *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableStrokeWidth.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableStrokeWidth.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableStrokeWidth" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::DrawableStrokeWidth *)new Magick::DrawableStrokeWidth(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableStrokeWidth, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableStrokeWidth(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableStrokeWidth * arg1 = (Magick::DrawableStrokeWidth *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableStrokeWidth_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableStrokeWidth *arg1 = (Magick::DrawableStrokeWidth *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableStrokeWidth_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableStrokeWidth, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableStrokeWidth_call" "', argument " "1"" of type '" "Magick::DrawableStrokeWidth const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableStrokeWidth * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableStrokeWidth_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableStrokeWidth const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableStrokeWidth_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableStrokeWidth *arg1 = (Magick::DrawableStrokeWidth *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableStrokeWidth_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableStrokeWidth, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableStrokeWidth_copy" "', argument " "1"" of type '" "Magick::DrawableStrokeWidth const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableStrokeWidth * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableStrokeWidth const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableStrokeWidth_width__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableStrokeWidth *arg1 = (Magick::DrawableStrokeWidth *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableStrokeWidth, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableStrokeWidth_width" "', argument " "1"" of type '" "Magick::DrawableStrokeWidth *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableStrokeWidth * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableStrokeWidth_width" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->width(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableStrokeWidth_width__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableStrokeWidth *arg1 = (Magick::DrawableStrokeWidth *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableStrokeWidth, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableStrokeWidth_width" "', argument " "1"" of type '" "Magick::DrawableStrokeWidth const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableStrokeWidth * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableStrokeWidth const *)arg1)->width();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableStrokeWidth__wrap_DrawableStrokeWidth_width(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableStrokeWidth_width__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableStrokeWidth_width__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function width.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableText__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  std::string *arg3 = 0 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  Magick::DrawableText *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableText__SWIG_0.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableText__SWIG_0.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableText" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_DrawableText" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(args[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_DrawableText" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableText" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    try {
      result = (Magick::DrawableText *)new Magick::DrawableText(arg1,arg2,(std::string const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  if (SWIG_IsNewObj(res3)) delete arg3;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableText, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableText__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  Magick::DrawableText *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableText__SWIG_1.");
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableText__SWIG_1.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableText" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_DrawableText" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(args[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_DrawableText" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableText" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(args[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_DrawableText" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableText" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  {
    try {
      result = (Magick::DrawableText *)new Magick::DrawableText(arg1,arg2,(std::string const &)*arg3,(std::string const &)*arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableText, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableText__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::DrawableText *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableText *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableText__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableText__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__DrawableText,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawableText" "', argument " "1"" of type '" "Magick::DrawableText const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableText" "', argument " "1"" of type '" "Magick::DrawableText const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableText * >(argp1);
  {
    try {
      result = (Magick::DrawableText *)new Magick::DrawableText((Magick::DrawableText const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableText, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableText(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_DrawableText__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_new_DrawableText__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawableText__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_DrawableText");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableText(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableText * arg1 = (Magick::DrawableText *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableText_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableText *arg1 = (Magick::DrawableText *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableText_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableText_call" "', argument " "1"" of type '" "Magick::DrawableText const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableText * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableText_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableText const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableText_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableText *arg1 = (Magick::DrawableText *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableText_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableText_copy" "', argument " "1"" of type '" "Magick::DrawableText const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableText * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableText const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableText_encoding(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableText *arg1 = (Magick::DrawableText *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableText_encoding.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableText_encoding" "', argument " "1"" of type '" "Magick::DrawableText *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableText * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableText_encoding" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DrawableText_encoding" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->encoding((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableText_x__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableText *arg1 = (Magick::DrawableText *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableText_x" "', argument " "1"" of type '" "Magick::DrawableText *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableText * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableText_x" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->x(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableText_x__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableText *arg1 = (Magick::DrawableText *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableText_x" "', argument " "1"" of type '" "Magick::DrawableText const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableText * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableText const *)arg1)->x();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableText__wrap_DrawableText_x(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableText_x__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableText_x__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function x.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableText_y__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableText *arg1 = (Magick::DrawableText *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableText_y" "', argument " "1"" of type '" "Magick::DrawableText *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableText * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableText_y" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->y(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableText_y__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableText *arg1 = (Magick::DrawableText *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableText_y" "', argument " "1"" of type '" "Magick::DrawableText const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableText * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableText const *)arg1)->y();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableText__wrap_DrawableText_y(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableText_y__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableText_y__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function y.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableText_text__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableText *arg1 = (Magick::DrawableText *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableText_text" "', argument " "1"" of type '" "Magick::DrawableText *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableText * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableText_text" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DrawableText_text" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->text((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableText_text__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableText *arg1 = (Magick::DrawableText *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableText_text" "', argument " "1"" of type '" "Magick::DrawableText const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableText * >(argp1);
  {
    try {
      result = ((Magick::DrawableText const *)arg1)->text();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableText__wrap_DrawableText_text(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableText_text__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableText_text__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function text.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableTextAntialias__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  Magick::DrawableTextAntialias *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableTextAntialias__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableTextAntialias__SWIG_0.");
  ecode1 = SWIG_AsVal_bool(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableTextAntialias" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      result = (Magick::DrawableTextAntialias *)new Magick::DrawableTextAntialias(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableTextAntialias, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableTextAntialias__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::DrawableTextAntialias *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableTextAntialias *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableTextAntialias__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableTextAntialias__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__DrawableTextAntialias,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawableTextAntialias" "', argument " "1"" of type '" "Magick::DrawableTextAntialias const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableTextAntialias" "', argument " "1"" of type '" "Magick::DrawableTextAntialias const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextAntialias * >(argp1);
  {
    try {
      result = (Magick::DrawableTextAntialias *)new Magick::DrawableTextAntialias((Magick::DrawableTextAntialias const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableTextAntialias, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableTextAntialias(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawableTextAntialias__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawableTextAntialias__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_DrawableTextAntialias");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableTextAntialias(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableTextAntialias * arg1 = (Magick::DrawableTextAntialias *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableTextAntialias_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextAntialias *arg1 = (Magick::DrawableTextAntialias *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableTextAntialias_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextAntialias, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextAntialias_call" "', argument " "1"" of type '" "Magick::DrawableTextAntialias const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextAntialias * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableTextAntialias_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableTextAntialias const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextAntialias_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextAntialias *arg1 = (Magick::DrawableTextAntialias *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableTextAntialias_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextAntialias, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextAntialias_copy" "', argument " "1"" of type '" "Magick::DrawableTextAntialias const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextAntialias * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableTextAntialias const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextAntialias_flag__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextAntialias *arg1 = (Magick::DrawableTextAntialias *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextAntialias, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextAntialias_flag" "', argument " "1"" of type '" "Magick::DrawableTextAntialias *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextAntialias * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableTextAntialias_flag" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->flag(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextAntialias_flag__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextAntialias *arg1 = (Magick::DrawableTextAntialias *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextAntialias, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextAntialias_flag" "', argument " "1"" of type '" "Magick::DrawableTextAntialias const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextAntialias * >(argp1);
  {
    try {
      result = (bool)((Magick::DrawableTextAntialias const *)arg1)->flag();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextAntialias__wrap_DrawableTextAntialias_flag(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableTextAntialias_flag__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableTextAntialias_flag__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function flag.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableTextDecoration__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::DecorationType arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  Magick::DrawableTextDecoration *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableTextDecoration__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableTextDecoration__SWIG_0.");
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableTextDecoration" "', argument " "1"" of type '" "Magick::DecorationType""'");
  } 
  arg1 = static_cast< Magick::DecorationType >(val1);
  {
    try {
      result = (Magick::DrawableTextDecoration *)new Magick::DrawableTextDecoration(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableTextDecoration, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableTextDecoration__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::DrawableTextDecoration *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableTextDecoration *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableTextDecoration__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableTextDecoration__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__DrawableTextDecoration,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawableTextDecoration" "', argument " "1"" of type '" "Magick::DrawableTextDecoration const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableTextDecoration" "', argument " "1"" of type '" "Magick::DrawableTextDecoration const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextDecoration * >(argp1);
  {
    try {
      result = (Magick::DrawableTextDecoration *)new Magick::DrawableTextDecoration((Magick::DrawableTextDecoration const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableTextDecoration, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableTextDecoration(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawableTextDecoration__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawableTextDecoration__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_DrawableTextDecoration");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableTextDecoration(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableTextDecoration * arg1 = (Magick::DrawableTextDecoration *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableTextDecoration_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextDecoration *arg1 = (Magick::DrawableTextDecoration *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableTextDecoration_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextDecoration, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextDecoration_call" "', argument " "1"" of type '" "Magick::DrawableTextDecoration const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextDecoration * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableTextDecoration_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableTextDecoration const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextDecoration_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextDecoration *arg1 = (Magick::DrawableTextDecoration *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableTextDecoration_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextDecoration, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextDecoration_copy" "', argument " "1"" of type '" "Magick::DrawableTextDecoration const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextDecoration * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableTextDecoration const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextDecoration_decoration__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextDecoration *arg1 = (Magick::DrawableTextDecoration *) 0 ;
  Magick::DecorationType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextDecoration, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextDecoration_decoration" "', argument " "1"" of type '" "Magick::DrawableTextDecoration *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextDecoration * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableTextDecoration_decoration" "', argument " "2"" of type '" "Magick::DecorationType""'");
  } 
  arg2 = static_cast< Magick::DecorationType >(val2);
  {
    try {
      (arg1)->decoration(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextDecoration_decoration__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextDecoration *arg1 = (Magick::DrawableTextDecoration *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DecorationType result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextDecoration, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextDecoration_decoration" "', argument " "1"" of type '" "Magick::DrawableTextDecoration const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextDecoration * >(argp1);
  {
    try {
      result = (Magick::DecorationType)((Magick::DrawableTextDecoration const *)arg1)->decoration();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextDecoration__wrap_DrawableTextDecoration_decoration(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableTextDecoration_decoration__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableTextDecoration_decoration__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function decoration.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableTextDirection(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::DirectionType arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  Magick::DrawableTextDirection *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableTextDirection.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableTextDirection.");
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableTextDirection" "', argument " "1"" of type '" "Magick::DirectionType""'");
  } 
  arg1 = static_cast< Magick::DirectionType >(val1);
  {
    try {
      result = (Magick::DrawableTextDirection *)new Magick::DrawableTextDirection(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableTextDirection, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableTextDirection(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableTextDirection * arg1 = (Magick::DrawableTextDirection *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableTextDirection_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextDirection *arg1 = (Magick::DrawableTextDirection *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableTextDirection_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextDirection, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextDirection_call" "', argument " "1"" of type '" "Magick::DrawableTextDirection const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextDirection * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableTextDirection_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableTextDirection const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextDirection_direction__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextDirection *arg1 = (Magick::DrawableTextDirection *) 0 ;
  Magick::DirectionType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextDirection, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextDirection_direction" "', argument " "1"" of type '" "Magick::DrawableTextDirection *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextDirection * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableTextDirection_direction" "', argument " "2"" of type '" "Magick::DirectionType""'");
  } 
  arg2 = static_cast< Magick::DirectionType >(val2);
  {
    try {
      (arg1)->direction(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextDirection_direction__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextDirection *arg1 = (Magick::DrawableTextDirection *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DirectionType result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextDirection, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextDirection_direction" "', argument " "1"" of type '" "Magick::DrawableTextDirection const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextDirection * >(argp1);
  {
    try {
      result = (Magick::DirectionType)((Magick::DrawableTextDirection const *)arg1)->direction();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextDirection__wrap_DrawableTextDirection_direction(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableTextDirection_direction__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableTextDirection_direction__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function direction.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextDirection_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextDirection *arg1 = (Magick::DrawableTextDirection *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableTextDirection_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextDirection, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextDirection_copy" "', argument " "1"" of type '" "Magick::DrawableTextDirection const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextDirection * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableTextDirection const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableTextInterlineSpacing(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::DrawableTextInterlineSpacing *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableTextInterlineSpacing.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableTextInterlineSpacing.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableTextInterlineSpacing" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::DrawableTextInterlineSpacing *)new Magick::DrawableTextInterlineSpacing(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableTextInterlineSpacing, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableTextInterlineSpacing(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableTextInterlineSpacing * arg1 = (Magick::DrawableTextInterlineSpacing *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableTextInterlineSpacing_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextInterlineSpacing *arg1 = (Magick::DrawableTextInterlineSpacing *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableTextInterlineSpacing_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextInterlineSpacing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextInterlineSpacing_call" "', argument " "1"" of type '" "Magick::DrawableTextInterlineSpacing const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextInterlineSpacing * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableTextInterlineSpacing_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableTextInterlineSpacing const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextInterlineSpacing_spacing__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextInterlineSpacing *arg1 = (Magick::DrawableTextInterlineSpacing *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextInterlineSpacing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextInterlineSpacing_spacing" "', argument " "1"" of type '" "Magick::DrawableTextInterlineSpacing *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextInterlineSpacing * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableTextInterlineSpacing_spacing" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->spacing(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextInterlineSpacing_spacing__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextInterlineSpacing *arg1 = (Magick::DrawableTextInterlineSpacing *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextInterlineSpacing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextInterlineSpacing_spacing" "', argument " "1"" of type '" "Magick::DrawableTextInterlineSpacing const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextInterlineSpacing * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableTextInterlineSpacing const *)arg1)->spacing();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextInterlineSpacing__wrap_DrawableTextInterlineSpacing_spacing(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableTextInterlineSpacing_spacing__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableTextInterlineSpacing_spacing__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function spacing.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextInterlineSpacing_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextInterlineSpacing *arg1 = (Magick::DrawableTextInterlineSpacing *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableTextInterlineSpacing_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextInterlineSpacing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextInterlineSpacing_copy" "', argument " "1"" of type '" "Magick::DrawableTextInterlineSpacing const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextInterlineSpacing * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableTextInterlineSpacing const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableTextInterwordSpacing(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::DrawableTextInterwordSpacing *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableTextInterwordSpacing.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableTextInterwordSpacing.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableTextInterwordSpacing" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::DrawableTextInterwordSpacing *)new Magick::DrawableTextInterwordSpacing(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableTextInterwordSpacing, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableTextInterwordSpacing(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableTextInterwordSpacing * arg1 = (Magick::DrawableTextInterwordSpacing *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableTextInterwordSpacing_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextInterwordSpacing *arg1 = (Magick::DrawableTextInterwordSpacing *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableTextInterwordSpacing_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextInterwordSpacing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextInterwordSpacing_call" "', argument " "1"" of type '" "Magick::DrawableTextInterwordSpacing const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextInterwordSpacing * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableTextInterwordSpacing_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableTextInterwordSpacing const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextInterwordSpacing_spacing__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextInterwordSpacing *arg1 = (Magick::DrawableTextInterwordSpacing *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextInterwordSpacing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextInterwordSpacing_spacing" "', argument " "1"" of type '" "Magick::DrawableTextInterwordSpacing *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextInterwordSpacing * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableTextInterwordSpacing_spacing" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->spacing(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextInterwordSpacing_spacing__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextInterwordSpacing *arg1 = (Magick::DrawableTextInterwordSpacing *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextInterwordSpacing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextInterwordSpacing_spacing" "', argument " "1"" of type '" "Magick::DrawableTextInterwordSpacing const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextInterwordSpacing * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableTextInterwordSpacing const *)arg1)->spacing();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextInterwordSpacing__wrap_DrawableTextInterwordSpacing_spacing(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableTextInterwordSpacing_spacing__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableTextInterwordSpacing_spacing__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function spacing.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextInterwordSpacing_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextInterwordSpacing *arg1 = (Magick::DrawableTextInterwordSpacing *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableTextInterwordSpacing_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextInterwordSpacing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextInterwordSpacing_copy" "', argument " "1"" of type '" "Magick::DrawableTextInterwordSpacing const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextInterwordSpacing * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableTextInterwordSpacing const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableTextKerning(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::DrawableTextKerning *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableTextKerning.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableTextKerning.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableTextKerning" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::DrawableTextKerning *)new Magick::DrawableTextKerning(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableTextKerning, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableTextKerning(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableTextKerning * arg1 = (Magick::DrawableTextKerning *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableTextKerning_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextKerning *arg1 = (Magick::DrawableTextKerning *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableTextKerning_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextKerning, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextKerning_call" "', argument " "1"" of type '" "Magick::DrawableTextKerning const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextKerning * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableTextKerning_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableTextKerning const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextKerning_kerning__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextKerning *arg1 = (Magick::DrawableTextKerning *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextKerning, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextKerning_kerning" "', argument " "1"" of type '" "Magick::DrawableTextKerning *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextKerning * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableTextKerning_kerning" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->kerning(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextKerning_kerning__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextKerning *arg1 = (Magick::DrawableTextKerning *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextKerning, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextKerning_kerning" "', argument " "1"" of type '" "Magick::DrawableTextKerning const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextKerning * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableTextKerning const *)arg1)->kerning();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextKerning__wrap_DrawableTextKerning_kerning(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableTextKerning_kerning__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableTextKerning_kerning__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function kerning.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextKerning_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextKerning *arg1 = (Magick::DrawableTextKerning *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableTextKerning_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextKerning, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextKerning_copy" "', argument " "1"" of type '" "Magick::DrawableTextKerning const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextKerning * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableTextKerning const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableTextUnderColor__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Color *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableTextUnderColor *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableTextUnderColor__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableTextUnderColor__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawableTextUnderColor" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableTextUnderColor" "', argument " "1"" of type '" "Magick::Color const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Color * >(argp1);
  {
    try {
      result = (Magick::DrawableTextUnderColor *)new Magick::DrawableTextUnderColor((Magick::Color const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableTextUnderColor, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableTextUnderColor__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::DrawableTextUnderColor *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableTextUnderColor *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableTextUnderColor__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableTextUnderColor__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__DrawableTextUnderColor,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DrawableTextUnderColor" "', argument " "1"" of type '" "Magick::DrawableTextUnderColor const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DrawableTextUnderColor" "', argument " "1"" of type '" "Magick::DrawableTextUnderColor const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextUnderColor * >(argp1);
  {
    try {
      result = (Magick::DrawableTextUnderColor *)new Magick::DrawableTextUnderColor((Magick::DrawableTextUnderColor const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableTextUnderColor, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableTextUnderColor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawableTextUnderColor__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_DrawableTextUnderColor__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_DrawableTextUnderColor");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableTextUnderColor(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableTextUnderColor * arg1 = (Magick::DrawableTextUnderColor *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableTextUnderColor_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextUnderColor *arg1 = (Magick::DrawableTextUnderColor *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableTextUnderColor_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextUnderColor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextUnderColor_call" "', argument " "1"" of type '" "Magick::DrawableTextUnderColor const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextUnderColor * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableTextUnderColor_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableTextUnderColor const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextUnderColor_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextUnderColor *arg1 = (Magick::DrawableTextUnderColor *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableTextUnderColor_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextUnderColor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextUnderColor_copy" "', argument " "1"" of type '" "Magick::DrawableTextUnderColor const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextUnderColor * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableTextUnderColor const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextUnderColor_color__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextUnderColor *arg1 = (Magick::DrawableTextUnderColor *) 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextUnderColor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextUnderColor_color" "', argument " "1"" of type '" "Magick::DrawableTextUnderColor *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextUnderColor * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableTextUnderColor_color" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DrawableTextUnderColor_color" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      (arg1)->color((Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextUnderColor_color__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTextUnderColor *arg1 = (Magick::DrawableTextUnderColor *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Color result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTextUnderColor, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTextUnderColor_color" "', argument " "1"" of type '" "Magick::DrawableTextUnderColor const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTextUnderColor * >(argp1);
  {
    try {
      result = ((Magick::DrawableTextUnderColor const *)arg1)->color();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Color(result)), SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTextUnderColor__wrap_DrawableTextUnderColor_color(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableTextUnderColor_color__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableTextUnderColor_color__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function color.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableTranslation(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  Magick::DrawableTranslation *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableTranslation.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableTranslation.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableTranslation" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_DrawableTranslation" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      result = (Magick::DrawableTranslation *)new Magick::DrawableTranslation(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableTranslation, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableTranslation(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableTranslation * arg1 = (Magick::DrawableTranslation *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableTranslation_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTranslation *arg1 = (Magick::DrawableTranslation *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableTranslation_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTranslation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTranslation_call" "', argument " "1"" of type '" "Magick::DrawableTranslation const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTranslation * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableTranslation_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableTranslation const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTranslation_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTranslation *arg1 = (Magick::DrawableTranslation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableTranslation_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTranslation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTranslation_copy" "', argument " "1"" of type '" "Magick::DrawableTranslation const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTranslation * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableTranslation const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTranslation_x__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTranslation *arg1 = (Magick::DrawableTranslation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTranslation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTranslation_x" "', argument " "1"" of type '" "Magick::DrawableTranslation *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTranslation * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableTranslation_x" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->x(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTranslation_x__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTranslation *arg1 = (Magick::DrawableTranslation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTranslation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTranslation_x" "', argument " "1"" of type '" "Magick::DrawableTranslation const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTranslation * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableTranslation const *)arg1)->x();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTranslation__wrap_DrawableTranslation_x(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableTranslation_x__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableTranslation_x__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function x.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTranslation_y__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTranslation *arg1 = (Magick::DrawableTranslation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTranslation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTranslation_y" "', argument " "1"" of type '" "Magick::DrawableTranslation *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTranslation * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableTranslation_y" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->y(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTranslation_y__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableTranslation *arg1 = (Magick::DrawableTranslation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableTranslation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableTranslation_y" "', argument " "1"" of type '" "Magick::DrawableTranslation const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableTranslation * >(argp1);
  {
    try {
      result = (double)((Magick::DrawableTranslation const *)arg1)->y();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableTranslation__wrap_DrawableTranslation_y(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableTranslation_y__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableTranslation_y__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function y.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_DrawableViewbox(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  ::ssize_t arg1 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  ::ssize_t arg4 ;
  long val1 ;
  int ecode1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  Magick::DrawableViewbox *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_DrawableViewbox.");
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_DrawableViewbox.");
  ecode1 = SWIG_AsVal_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DrawableViewbox" "', argument " "1"" of type '" "::ssize_t""'");
  } 
  arg1 = static_cast< ::ssize_t >(val1);
  ecode2 = SWIG_AsVal_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_DrawableViewbox" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_DrawableViewbox" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  ecode4 = SWIG_AsVal_long(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_DrawableViewbox" "', argument " "4"" of type '" "::ssize_t""'");
  } 
  arg4 = static_cast< ::ssize_t >(val4);
  {
    try {
      result = (Magick::DrawableViewbox *)new Magick::DrawableViewbox(arg1,arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__DrawableViewbox, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_DrawableViewbox(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::DrawableViewbox * arg1 = (Magick::DrawableViewbox *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_DrawableViewbox_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableViewbox *arg1 = (Magick::DrawableViewbox *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableViewbox_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableViewbox, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableViewbox_call" "', argument " "1"" of type '" "Magick::DrawableViewbox const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableViewbox * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DrawableViewbox_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::DrawableViewbox const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableViewbox_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableViewbox *arg1 = (Magick::DrawableViewbox *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DrawableBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_DrawableViewbox_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableViewbox, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableViewbox_copy" "', argument " "1"" of type '" "Magick::DrawableViewbox const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableViewbox * >(argp1);
  {
    try {
      result = (Magick::DrawableBase *)((Magick::DrawableViewbox const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__DrawableBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableViewbox_x1__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableViewbox *arg1 = (Magick::DrawableViewbox *) 0 ;
  ::ssize_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableViewbox, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableViewbox_x1" "', argument " "1"" of type '" "Magick::DrawableViewbox *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableViewbox * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableViewbox_x1" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  {
    try {
      (arg1)->x1(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableViewbox_x1__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableViewbox *arg1 = (Magick::DrawableViewbox *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ::ssize_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableViewbox, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableViewbox_x1" "', argument " "1"" of type '" "Magick::DrawableViewbox const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableViewbox * >(argp1);
  {
    try {
      result = ((Magick::DrawableViewbox const *)arg1)->x1();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_long(static_cast< long >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableViewbox__wrap_DrawableViewbox_x1(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableViewbox_x1__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableViewbox_x1__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function x1.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableViewbox_y1__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableViewbox *arg1 = (Magick::DrawableViewbox *) 0 ;
  ::ssize_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableViewbox, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableViewbox_y1" "', argument " "1"" of type '" "Magick::DrawableViewbox *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableViewbox * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableViewbox_y1" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  {
    try {
      (arg1)->y1(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableViewbox_y1__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableViewbox *arg1 = (Magick::DrawableViewbox *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ::ssize_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableViewbox, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableViewbox_y1" "', argument " "1"" of type '" "Magick::DrawableViewbox const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableViewbox * >(argp1);
  {
    try {
      result = ((Magick::DrawableViewbox const *)arg1)->y1();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_long(static_cast< long >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableViewbox__wrap_DrawableViewbox_y1(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableViewbox_y1__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableViewbox_y1__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function y1.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableViewbox_x2__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableViewbox *arg1 = (Magick::DrawableViewbox *) 0 ;
  ::ssize_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableViewbox, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableViewbox_x2" "', argument " "1"" of type '" "Magick::DrawableViewbox *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableViewbox * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableViewbox_x2" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  {
    try {
      (arg1)->x2(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableViewbox_x2__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableViewbox *arg1 = (Magick::DrawableViewbox *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ::ssize_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableViewbox, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableViewbox_x2" "', argument " "1"" of type '" "Magick::DrawableViewbox const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableViewbox * >(argp1);
  {
    try {
      result = ((Magick::DrawableViewbox const *)arg1)->x2();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_long(static_cast< long >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableViewbox__wrap_DrawableViewbox_x2(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableViewbox_x2__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableViewbox_x2__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function x2.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableViewbox_y2__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableViewbox *arg1 = (Magick::DrawableViewbox *) 0 ;
  ::ssize_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableViewbox, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableViewbox_y2" "', argument " "1"" of type '" "Magick::DrawableViewbox *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableViewbox * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DrawableViewbox_y2" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  {
    try {
      (arg1)->y2(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableViewbox_y2__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::DrawableViewbox *arg1 = (Magick::DrawableViewbox *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ::ssize_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__DrawableViewbox, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DrawableViewbox_y2" "', argument " "1"" of type '" "Magick::DrawableViewbox const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::DrawableViewbox * >(argp1);
  {
    try {
      result = ((Magick::DrawableViewbox const *)arg1)->y2();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_long(static_cast< long >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_DrawableViewbox__wrap_DrawableViewbox_y2(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_DrawableViewbox_y2__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_DrawableViewbox_y2__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function y2.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathArcArgs__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathArcArgs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathArcArgs__SWIG_0.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathArcArgs__SWIG_0.");
  {
    try {
      result = (Magick::PathArcArgs *)new Magick::PathArcArgs();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathArcArgs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathArcArgs__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double arg3 ;
  bool arg4 ;
  bool arg5 ;
  double arg6 ;
  double arg7 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  double val7 ;
  int ecode7 = 0 ;
  Magick::PathArcArgs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathArcArgs__SWIG_1.");
  if(args.Length() != 7) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathArcArgs__SWIG_1.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_PathArcArgs" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_PathArcArgs" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_PathArcArgs" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_bool(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_PathArcArgs" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  ecode5 = SWIG_AsVal_bool(args[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_PathArcArgs" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  ecode6 = SWIG_AsVal_double(args[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_PathArcArgs" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = static_cast< double >(val6);
  ecode7 = SWIG_AsVal_double(args[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_PathArcArgs" "', argument " "7"" of type '" "double""'");
  } 
  arg7 = static_cast< double >(val7);
  {
    try {
      result = (Magick::PathArcArgs *)new Magick::PathArcArgs(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathArcArgs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathArcArgs__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathArcArgs *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathArcArgs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathArcArgs__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathArcArgs__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathArcArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathArcArgs" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathArcArgs" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);
  {
    try {
      result = (Magick::PathArcArgs *)new Magick::PathArcArgs((Magick::PathArcArgs const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathArcArgs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathArcArgs(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_PathArcArgs__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 7) {
    errorHandler.err.Clear();
    _wrap_new_PathArcArgs__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathArcArgs__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_PathArcArgs");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_PathArcArgs(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::PathArcArgs * arg1 = (Magick::PathArcArgs *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_PathArcArgs_radiusX__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathArcArgs *arg1 = (Magick::PathArcArgs *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathArcArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathArcArgs_radiusX" "', argument " "1"" of type '" "Magick::PathArcArgs *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PathArcArgs_radiusX" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->radiusX(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathArcArgs_radiusX__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathArcArgs *arg1 = (Magick::PathArcArgs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathArcArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathArcArgs_radiusX" "', argument " "1"" of type '" "Magick::PathArcArgs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);
  {
    try {
      result = (double)((Magick::PathArcArgs const *)arg1)->radiusX();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathArcArgs__wrap_PathArcArgs_radiusX(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_PathArcArgs_radiusX__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_PathArcArgs_radiusX__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function radiusX.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathArcArgs_radiusY__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathArcArgs *arg1 = (Magick::PathArcArgs *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathArcArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathArcArgs_radiusY" "', argument " "1"" of type '" "Magick::PathArcArgs *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PathArcArgs_radiusY" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->radiusY(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathArcArgs_radiusY__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathArcArgs *arg1 = (Magick::PathArcArgs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathArcArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathArcArgs_radiusY" "', argument " "1"" of type '" "Magick::PathArcArgs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);
  {
    try {
      result = (double)((Magick::PathArcArgs const *)arg1)->radiusY();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathArcArgs__wrap_PathArcArgs_radiusY(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_PathArcArgs_radiusY__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_PathArcArgs_radiusY__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function radiusY.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathArcArgs_xAxisRotation__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathArcArgs *arg1 = (Magick::PathArcArgs *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathArcArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathArcArgs_xAxisRotation" "', argument " "1"" of type '" "Magick::PathArcArgs *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PathArcArgs_xAxisRotation" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->xAxisRotation(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathArcArgs_xAxisRotation__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathArcArgs *arg1 = (Magick::PathArcArgs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathArcArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathArcArgs_xAxisRotation" "', argument " "1"" of type '" "Magick::PathArcArgs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);
  {
    try {
      result = (double)((Magick::PathArcArgs const *)arg1)->xAxisRotation();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathArcArgs__wrap_PathArcArgs_xAxisRotation(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_PathArcArgs_xAxisRotation__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_PathArcArgs_xAxisRotation__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function xAxisRotation.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathArcArgs_largeArcFlag__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathArcArgs *arg1 = (Magick::PathArcArgs *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathArcArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathArcArgs_largeArcFlag" "', argument " "1"" of type '" "Magick::PathArcArgs *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PathArcArgs_largeArcFlag" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->largeArcFlag(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathArcArgs_largeArcFlag__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathArcArgs *arg1 = (Magick::PathArcArgs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathArcArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathArcArgs_largeArcFlag" "', argument " "1"" of type '" "Magick::PathArcArgs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);
  {
    try {
      result = (bool)((Magick::PathArcArgs const *)arg1)->largeArcFlag();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathArcArgs__wrap_PathArcArgs_largeArcFlag(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_PathArcArgs_largeArcFlag__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_PathArcArgs_largeArcFlag__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function largeArcFlag.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathArcArgs_sweepFlag__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathArcArgs *arg1 = (Magick::PathArcArgs *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathArcArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathArcArgs_sweepFlag" "', argument " "1"" of type '" "Magick::PathArcArgs *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PathArcArgs_sweepFlag" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->sweepFlag(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathArcArgs_sweepFlag__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathArcArgs *arg1 = (Magick::PathArcArgs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathArcArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathArcArgs_sweepFlag" "', argument " "1"" of type '" "Magick::PathArcArgs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);
  {
    try {
      result = (bool)((Magick::PathArcArgs const *)arg1)->sweepFlag();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathArcArgs__wrap_PathArcArgs_sweepFlag(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_PathArcArgs_sweepFlag__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_PathArcArgs_sweepFlag__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function sweepFlag.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathArcArgs_x__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathArcArgs *arg1 = (Magick::PathArcArgs *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathArcArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathArcArgs_x" "', argument " "1"" of type '" "Magick::PathArcArgs *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PathArcArgs_x" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->x(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathArcArgs_x__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathArcArgs *arg1 = (Magick::PathArcArgs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathArcArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathArcArgs_x" "', argument " "1"" of type '" "Magick::PathArcArgs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);
  {
    try {
      result = (double)((Magick::PathArcArgs const *)arg1)->x();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathArcArgs__wrap_PathArcArgs_x(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_PathArcArgs_x__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_PathArcArgs_x__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function x.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathArcArgs_y__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathArcArgs *arg1 = (Magick::PathArcArgs *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathArcArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathArcArgs_y" "', argument " "1"" of type '" "Magick::PathArcArgs *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PathArcArgs_y" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->y(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathArcArgs_y__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathArcArgs *arg1 = (Magick::PathArcArgs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathArcArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathArcArgs_y" "', argument " "1"" of type '" "Magick::PathArcArgs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);
  {
    try {
      result = (double)((Magick::PathArcArgs const *)arg1)->y();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathArcArgs__wrap_PathArcArgs_y(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_PathArcArgs_y__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_PathArcArgs_y__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function y.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_equal__SWIG_6(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathArcArgs *arg1 = 0 ;
  Magick::PathArcArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathArcArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equal" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__PathArcArgs,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equal" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::PathArcArgs * >(argp2);
  {
    try {
      result = (int)Magick::operator ==((Magick::PathArcArgs const &)*arg1,(Magick::PathArcArgs const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_notEqual__SWIG_6(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathArcArgs *arg1 = 0 ;
  Magick::PathArcArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathArcArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "notEqual" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__PathArcArgs,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "notEqual" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::PathArcArgs * >(argp2);
  {
    try {
      result = (int)Magick::operator !=((Magick::PathArcArgs const &)*arg1,(Magick::PathArcArgs const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_gt__SWIG_5(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathArcArgs *arg1 = 0 ;
  Magick::PathArcArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathArcArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gt" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__PathArcArgs,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gt" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::PathArcArgs * >(argp2);
  {
    try {
      result = (int)Magick::operator >((Magick::PathArcArgs const &)*arg1,(Magick::PathArcArgs const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_lt__SWIG_5(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathArcArgs *arg1 = 0 ;
  Magick::PathArcArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathArcArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lt" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__PathArcArgs,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lt" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::PathArcArgs * >(argp2);
  {
    try {
      result = (int)Magick::operator <((Magick::PathArcArgs const &)*arg1,(Magick::PathArcArgs const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_gte__SWIG_5(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathArcArgs *arg1 = 0 ;
  Magick::PathArcArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathArcArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gte" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__PathArcArgs,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gte" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::PathArcArgs * >(argp2);
  {
    try {
      result = (int)Magick::operator >=((Magick::PathArcArgs const &)*arg1,(Magick::PathArcArgs const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_lte__SWIG_5(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathArcArgs *arg1 = 0 ;
  Magick::PathArcArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathArcArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lte" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__PathArcArgs,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lte" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::PathArcArgs * >(argp2);
  {
    try {
      result = (int)Magick::operator <=((Magick::PathArcArgs const &)*arg1,(Magick::PathArcArgs const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathArcAbs__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathArcArgs *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathArcAbs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathArcAbs__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathArcAbs__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathArcArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathArcAbs" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathArcAbs" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);
  {
    try {
      result = (Magick::PathArcAbs *)new Magick::PathArcAbs((Magick::PathArcArgs const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathArcAbs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathArcAbs__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathArcArgsList *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathArcAbs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathArcAbs__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathArcAbs__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_std__listT_Magick__PathArcArgs_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathArcAbs" "', argument " "1"" of type '" "Magick::PathArcArgsList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathArcAbs" "', argument " "1"" of type '" "Magick::PathArcArgsList const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcArgsList * >(argp1);
  {
    try {
      result = (Magick::PathArcAbs *)new Magick::PathArcAbs((Magick::PathArcArgsList const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathArcAbs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathArcAbs__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathArcAbs *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathArcAbs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathArcAbs__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathArcAbs__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathArcAbs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathArcAbs" "', argument " "1"" of type '" "Magick::PathArcAbs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathArcAbs" "', argument " "1"" of type '" "Magick::PathArcAbs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcAbs * >(argp1);
  {
    try {
      result = (Magick::PathArcAbs *)new Magick::PathArcAbs((Magick::PathArcAbs const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathArcAbs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathArcAbs(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathArcAbs__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathArcAbs__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathArcAbs__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_PathArcAbs");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_PathArcAbs(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::PathArcAbs * arg1 = (Magick::PathArcAbs *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_PathArcAbs_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathArcAbs *arg1 = (Magick::PathArcAbs *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathArcAbs_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathArcAbs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathArcAbs_call" "', argument " "1"" of type '" "Magick::PathArcAbs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcAbs * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PathArcAbs_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::PathArcAbs const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathArcAbs_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathArcAbs *arg1 = (Magick::PathArcAbs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::VPathBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathArcAbs_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathArcAbs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathArcAbs_copy" "', argument " "1"" of type '" "Magick::PathArcAbs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcAbs * >(argp1);
  {
    try {
      result = (Magick::VPathBase *)((Magick::PathArcAbs const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__VPathBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathArcRel__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathArcArgs *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathArcRel *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathArcRel__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathArcRel__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathArcArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathArcRel" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathArcRel" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);
  {
    try {
      result = (Magick::PathArcRel *)new Magick::PathArcRel((Magick::PathArcArgs const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathArcRel, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathArcRel__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathArcArgsList *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathArcRel *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathArcRel__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathArcRel__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_std__listT_Magick__PathArcArgs_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathArcRel" "', argument " "1"" of type '" "Magick::PathArcArgsList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathArcRel" "', argument " "1"" of type '" "Magick::PathArcArgsList const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcArgsList * >(argp1);
  {
    try {
      result = (Magick::PathArcRel *)new Magick::PathArcRel((Magick::PathArcArgsList const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathArcRel, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathArcRel__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathArcRel *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathArcRel *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathArcRel__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathArcRel__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathArcRel,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathArcRel" "', argument " "1"" of type '" "Magick::PathArcRel const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathArcRel" "', argument " "1"" of type '" "Magick::PathArcRel const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcRel * >(argp1);
  {
    try {
      result = (Magick::PathArcRel *)new Magick::PathArcRel((Magick::PathArcRel const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathArcRel, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathArcRel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathArcRel__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathArcRel__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathArcRel__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_PathArcRel");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_PathArcRel(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::PathArcRel * arg1 = (Magick::PathArcRel *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_PathArcRel_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathArcRel *arg1 = (Magick::PathArcRel *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathArcRel_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathArcRel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathArcRel_call" "', argument " "1"" of type '" "Magick::PathArcRel const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcRel * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PathArcRel_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::PathArcRel const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathArcRel_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathArcRel *arg1 = (Magick::PathArcRel *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::VPathBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathArcRel_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathArcRel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathArcRel_copy" "', argument " "1"" of type '" "Magick::PathArcRel const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathArcRel * >(argp1);
  {
    try {
      result = (Magick::VPathBase *)((Magick::PathArcRel const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__VPathBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathClosePath(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathClosePath *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathClosePath.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathClosePath.");
  {
    try {
      result = (Magick::PathClosePath *)new Magick::PathClosePath();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathClosePath, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_PathClosePath(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::PathClosePath * arg1 = (Magick::PathClosePath *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_PathClosePath_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathClosePath *arg1 = (Magick::PathClosePath *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathClosePath_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathClosePath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathClosePath_call" "', argument " "1"" of type '" "Magick::PathClosePath const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathClosePath * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PathClosePath_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::PathClosePath const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathClosePath_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathClosePath *arg1 = (Magick::PathClosePath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::VPathBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathClosePath_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathClosePath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathClosePath_copy" "', argument " "1"" of type '" "Magick::PathClosePath const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathClosePath * >(argp1);
  {
    try {
      result = (Magick::VPathBase *)((Magick::PathClosePath const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__VPathBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathCurvetoArgs__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathCurvetoArgs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathCurvetoArgs__SWIG_0.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathCurvetoArgs__SWIG_0.");
  {
    try {
      result = (Magick::PathCurvetoArgs *)new Magick::PathCurvetoArgs();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathCurvetoArgs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathCurvetoArgs__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  Magick::PathCurvetoArgs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathCurvetoArgs__SWIG_1.");
  if(args.Length() != 6) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathCurvetoArgs__SWIG_1.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_PathCurvetoArgs" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_PathCurvetoArgs" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_PathCurvetoArgs" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_PathCurvetoArgs" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  ecode5 = SWIG_AsVal_double(args[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_PathCurvetoArgs" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = static_cast< double >(val5);
  ecode6 = SWIG_AsVal_double(args[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_PathCurvetoArgs" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = static_cast< double >(val6);
  {
    try {
      result = (Magick::PathCurvetoArgs *)new Magick::PathCurvetoArgs(arg1,arg2,arg3,arg4,arg5,arg6);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathCurvetoArgs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathCurvetoArgs__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathCurvetoArgs *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathCurvetoArgs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathCurvetoArgs__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathCurvetoArgs__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathCurvetoArgs" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathCurvetoArgs" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);
  {
    try {
      result = (Magick::PathCurvetoArgs *)new Magick::PathCurvetoArgs((Magick::PathCurvetoArgs const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathCurvetoArgs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathCurvetoArgs(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_PathCurvetoArgs__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 6) {
    errorHandler.err.Clear();
    _wrap_new_PathCurvetoArgs__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathCurvetoArgs__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_PathCurvetoArgs");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_PathCurvetoArgs(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::PathCurvetoArgs * arg1 = (Magick::PathCurvetoArgs *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_PathCurvetoArgs_x1__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathCurvetoArgs *arg1 = (Magick::PathCurvetoArgs *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathCurvetoArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathCurvetoArgs_x1" "', argument " "1"" of type '" "Magick::PathCurvetoArgs *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PathCurvetoArgs_x1" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->x1(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathCurvetoArgs_x1__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathCurvetoArgs *arg1 = (Magick::PathCurvetoArgs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathCurvetoArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathCurvetoArgs_x1" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);
  {
    try {
      result = (double)((Magick::PathCurvetoArgs const *)arg1)->x1();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathCurvetoArgs__wrap_PathCurvetoArgs_x1(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_PathCurvetoArgs_x1__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_PathCurvetoArgs_x1__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function x1.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathCurvetoArgs_y1__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathCurvetoArgs *arg1 = (Magick::PathCurvetoArgs *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathCurvetoArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathCurvetoArgs_y1" "', argument " "1"" of type '" "Magick::PathCurvetoArgs *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PathCurvetoArgs_y1" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->y1(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathCurvetoArgs_y1__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathCurvetoArgs *arg1 = (Magick::PathCurvetoArgs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathCurvetoArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathCurvetoArgs_y1" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);
  {
    try {
      result = (double)((Magick::PathCurvetoArgs const *)arg1)->y1();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathCurvetoArgs__wrap_PathCurvetoArgs_y1(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_PathCurvetoArgs_y1__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_PathCurvetoArgs_y1__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function y1.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathCurvetoArgs_x2__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathCurvetoArgs *arg1 = (Magick::PathCurvetoArgs *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathCurvetoArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathCurvetoArgs_x2" "', argument " "1"" of type '" "Magick::PathCurvetoArgs *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PathCurvetoArgs_x2" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->x2(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathCurvetoArgs_x2__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathCurvetoArgs *arg1 = (Magick::PathCurvetoArgs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathCurvetoArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathCurvetoArgs_x2" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);
  {
    try {
      result = (double)((Magick::PathCurvetoArgs const *)arg1)->x2();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathCurvetoArgs__wrap_PathCurvetoArgs_x2(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_PathCurvetoArgs_x2__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_PathCurvetoArgs_x2__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function x2.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathCurvetoArgs_y2__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathCurvetoArgs *arg1 = (Magick::PathCurvetoArgs *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathCurvetoArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathCurvetoArgs_y2" "', argument " "1"" of type '" "Magick::PathCurvetoArgs *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PathCurvetoArgs_y2" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->y2(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathCurvetoArgs_y2__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathCurvetoArgs *arg1 = (Magick::PathCurvetoArgs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathCurvetoArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathCurvetoArgs_y2" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);
  {
    try {
      result = (double)((Magick::PathCurvetoArgs const *)arg1)->y2();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathCurvetoArgs__wrap_PathCurvetoArgs_y2(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_PathCurvetoArgs_y2__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_PathCurvetoArgs_y2__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function y2.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathCurvetoArgs_x__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathCurvetoArgs *arg1 = (Magick::PathCurvetoArgs *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathCurvetoArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathCurvetoArgs_x" "', argument " "1"" of type '" "Magick::PathCurvetoArgs *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PathCurvetoArgs_x" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->x(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathCurvetoArgs_x__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathCurvetoArgs *arg1 = (Magick::PathCurvetoArgs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathCurvetoArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathCurvetoArgs_x" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);
  {
    try {
      result = (double)((Magick::PathCurvetoArgs const *)arg1)->x();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathCurvetoArgs__wrap_PathCurvetoArgs_x(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_PathCurvetoArgs_x__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_PathCurvetoArgs_x__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function x.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathCurvetoArgs_y__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathCurvetoArgs *arg1 = (Magick::PathCurvetoArgs *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathCurvetoArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathCurvetoArgs_y" "', argument " "1"" of type '" "Magick::PathCurvetoArgs *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PathCurvetoArgs_y" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->y(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathCurvetoArgs_y__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathCurvetoArgs *arg1 = (Magick::PathCurvetoArgs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathCurvetoArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathCurvetoArgs_y" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);
  {
    try {
      result = (double)((Magick::PathCurvetoArgs const *)arg1)->y();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathCurvetoArgs__wrap_PathCurvetoArgs_y(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_PathCurvetoArgs_y__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_PathCurvetoArgs_y__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function y.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_equal__SWIG_7(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathCurvetoArgs *arg1 = 0 ;
  Magick::PathCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equal" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equal" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp2);
  {
    try {
      result = (int)Magick::operator ==((Magick::PathCurvetoArgs const &)*arg1,(Magick::PathCurvetoArgs const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_notEqual__SWIG_7(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathCurvetoArgs *arg1 = 0 ;
  Magick::PathCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "notEqual" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "notEqual" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp2);
  {
    try {
      result = (int)Magick::operator !=((Magick::PathCurvetoArgs const &)*arg1,(Magick::PathCurvetoArgs const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_gt__SWIG_6(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathCurvetoArgs *arg1 = 0 ;
  Magick::PathCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gt" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gt" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp2);
  {
    try {
      result = (int)Magick::operator >((Magick::PathCurvetoArgs const &)*arg1,(Magick::PathCurvetoArgs const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_lt__SWIG_6(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathCurvetoArgs *arg1 = 0 ;
  Magick::PathCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lt" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lt" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp2);
  {
    try {
      result = (int)Magick::operator <((Magick::PathCurvetoArgs const &)*arg1,(Magick::PathCurvetoArgs const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_gte__SWIG_6(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathCurvetoArgs *arg1 = 0 ;
  Magick::PathCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gte" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gte" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp2);
  {
    try {
      result = (int)Magick::operator >=((Magick::PathCurvetoArgs const &)*arg1,(Magick::PathCurvetoArgs const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_lte__SWIG_6(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathCurvetoArgs *arg1 = 0 ;
  Magick::PathCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lte" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lte" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp2);
  {
    try {
      result = (int)Magick::operator <=((Magick::PathCurvetoArgs const &)*arg1,(Magick::PathCurvetoArgs const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathCurvetoAbs__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathCurvetoArgs *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathCurvetoAbs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathCurvetoAbs__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathCurvetoAbs__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathCurvetoAbs" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathCurvetoAbs" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);
  {
    try {
      result = (Magick::PathCurvetoAbs *)new Magick::PathCurvetoAbs((Magick::PathCurvetoArgs const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathCurvetoAbs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathCurvetoAbs__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathCurveToArgsList *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathCurvetoAbs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathCurvetoAbs__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathCurvetoAbs__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_std__listT_Magick__PathCurvetoArgs_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathCurvetoAbs" "', argument " "1"" of type '" "Magick::PathCurveToArgsList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathCurvetoAbs" "', argument " "1"" of type '" "Magick::PathCurveToArgsList const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurveToArgsList * >(argp1);
  {
    try {
      result = (Magick::PathCurvetoAbs *)new Magick::PathCurvetoAbs((Magick::PathCurveToArgsList const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathCurvetoAbs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathCurvetoAbs__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathCurvetoAbs *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathCurvetoAbs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathCurvetoAbs__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathCurvetoAbs__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathCurvetoAbs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathCurvetoAbs" "', argument " "1"" of type '" "Magick::PathCurvetoAbs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathCurvetoAbs" "', argument " "1"" of type '" "Magick::PathCurvetoAbs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoAbs * >(argp1);
  {
    try {
      result = (Magick::PathCurvetoAbs *)new Magick::PathCurvetoAbs((Magick::PathCurvetoAbs const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathCurvetoAbs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathCurvetoAbs(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathCurvetoAbs__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathCurvetoAbs__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathCurvetoAbs__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_PathCurvetoAbs");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_PathCurvetoAbs(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::PathCurvetoAbs * arg1 = (Magick::PathCurvetoAbs *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_PathCurvetoAbs_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathCurvetoAbs *arg1 = (Magick::PathCurvetoAbs *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathCurvetoAbs_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathCurvetoAbs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathCurvetoAbs_call" "', argument " "1"" of type '" "Magick::PathCurvetoAbs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoAbs * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PathCurvetoAbs_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::PathCurvetoAbs const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathCurvetoAbs_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathCurvetoAbs *arg1 = (Magick::PathCurvetoAbs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::VPathBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathCurvetoAbs_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathCurvetoAbs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathCurvetoAbs_copy" "', argument " "1"" of type '" "Magick::PathCurvetoAbs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoAbs * >(argp1);
  {
    try {
      result = (Magick::VPathBase *)((Magick::PathCurvetoAbs const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__VPathBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathCurvetoRel__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathCurvetoArgs *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathCurvetoRel *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathCurvetoRel__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathCurvetoRel__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathCurvetoRel" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathCurvetoRel" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);
  {
    try {
      result = (Magick::PathCurvetoRel *)new Magick::PathCurvetoRel((Magick::PathCurvetoArgs const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathCurvetoRel, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathCurvetoRel__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathCurveToArgsList *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathCurvetoRel *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathCurvetoRel__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathCurvetoRel__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_std__listT_Magick__PathCurvetoArgs_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathCurvetoRel" "', argument " "1"" of type '" "Magick::PathCurveToArgsList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathCurvetoRel" "', argument " "1"" of type '" "Magick::PathCurveToArgsList const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurveToArgsList * >(argp1);
  {
    try {
      result = (Magick::PathCurvetoRel *)new Magick::PathCurvetoRel((Magick::PathCurveToArgsList const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathCurvetoRel, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathCurvetoRel__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathCurvetoRel *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathCurvetoRel *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathCurvetoRel__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathCurvetoRel__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathCurvetoRel,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathCurvetoRel" "', argument " "1"" of type '" "Magick::PathCurvetoRel const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathCurvetoRel" "', argument " "1"" of type '" "Magick::PathCurvetoRel const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoRel * >(argp1);
  {
    try {
      result = (Magick::PathCurvetoRel *)new Magick::PathCurvetoRel((Magick::PathCurvetoRel const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathCurvetoRel, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathCurvetoRel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathCurvetoRel__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathCurvetoRel__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathCurvetoRel__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_PathCurvetoRel");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_PathCurvetoRel(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::PathCurvetoRel * arg1 = (Magick::PathCurvetoRel *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_PathCurvetoRel_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathCurvetoRel *arg1 = (Magick::PathCurvetoRel *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathCurvetoRel_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathCurvetoRel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathCurvetoRel_call" "', argument " "1"" of type '" "Magick::PathCurvetoRel const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoRel * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PathCurvetoRel_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::PathCurvetoRel const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathCurvetoRel_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathCurvetoRel *arg1 = (Magick::PathCurvetoRel *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::VPathBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathCurvetoRel_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathCurvetoRel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathCurvetoRel_copy" "', argument " "1"" of type '" "Magick::PathCurvetoRel const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathCurvetoRel * >(argp1);
  {
    try {
      result = (Magick::VPathBase *)((Magick::PathCurvetoRel const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__VPathBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathSmoothCurvetoAbs__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Coordinate *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathSmoothCurvetoAbs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathSmoothCurvetoAbs__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathSmoothCurvetoAbs__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Coordinate,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathSmoothCurvetoAbs" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathSmoothCurvetoAbs" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Coordinate * >(argp1);
  {
    try {
      result = (Magick::PathSmoothCurvetoAbs *)new Magick::PathSmoothCurvetoAbs((Magick::Coordinate const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathSmoothCurvetoAbs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathSmoothCurvetoAbs__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::CoordinateList *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathSmoothCurvetoAbs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathSmoothCurvetoAbs__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathSmoothCurvetoAbs__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_std__listT_Magick__Coordinate_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathSmoothCurvetoAbs" "', argument " "1"" of type '" "Magick::CoordinateList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathSmoothCurvetoAbs" "', argument " "1"" of type '" "Magick::CoordinateList const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::CoordinateList * >(argp1);
  {
    try {
      result = (Magick::PathSmoothCurvetoAbs *)new Magick::PathSmoothCurvetoAbs((Magick::CoordinateList const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathSmoothCurvetoAbs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathSmoothCurvetoAbs__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathSmoothCurvetoAbs *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathSmoothCurvetoAbs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathSmoothCurvetoAbs__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathSmoothCurvetoAbs__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathSmoothCurvetoAbs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathSmoothCurvetoAbs" "', argument " "1"" of type '" "Magick::PathSmoothCurvetoAbs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathSmoothCurvetoAbs" "', argument " "1"" of type '" "Magick::PathSmoothCurvetoAbs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathSmoothCurvetoAbs * >(argp1);
  {
    try {
      result = (Magick::PathSmoothCurvetoAbs *)new Magick::PathSmoothCurvetoAbs((Magick::PathSmoothCurvetoAbs const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathSmoothCurvetoAbs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathSmoothCurvetoAbs(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathSmoothCurvetoAbs__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathSmoothCurvetoAbs__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathSmoothCurvetoAbs__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_PathSmoothCurvetoAbs");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_PathSmoothCurvetoAbs(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::PathSmoothCurvetoAbs * arg1 = (Magick::PathSmoothCurvetoAbs *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_PathSmoothCurvetoAbs_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathSmoothCurvetoAbs *arg1 = (Magick::PathSmoothCurvetoAbs *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathSmoothCurvetoAbs_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathSmoothCurvetoAbs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathSmoothCurvetoAbs_call" "', argument " "1"" of type '" "Magick::PathSmoothCurvetoAbs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathSmoothCurvetoAbs * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PathSmoothCurvetoAbs_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::PathSmoothCurvetoAbs const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathSmoothCurvetoAbs_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathSmoothCurvetoAbs *arg1 = (Magick::PathSmoothCurvetoAbs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::VPathBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathSmoothCurvetoAbs_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathSmoothCurvetoAbs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathSmoothCurvetoAbs_copy" "', argument " "1"" of type '" "Magick::PathSmoothCurvetoAbs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathSmoothCurvetoAbs * >(argp1);
  {
    try {
      result = (Magick::VPathBase *)((Magick::PathSmoothCurvetoAbs const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__VPathBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathSmoothCurvetoRel__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Coordinate *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathSmoothCurvetoRel *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathSmoothCurvetoRel__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathSmoothCurvetoRel__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Coordinate,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathSmoothCurvetoRel" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathSmoothCurvetoRel" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Coordinate * >(argp1);
  {
    try {
      result = (Magick::PathSmoothCurvetoRel *)new Magick::PathSmoothCurvetoRel((Magick::Coordinate const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathSmoothCurvetoRel, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathSmoothCurvetoRel__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::CoordinateList *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathSmoothCurvetoRel *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathSmoothCurvetoRel__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathSmoothCurvetoRel__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_std__listT_Magick__Coordinate_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathSmoothCurvetoRel" "', argument " "1"" of type '" "Magick::CoordinateList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathSmoothCurvetoRel" "', argument " "1"" of type '" "Magick::CoordinateList const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::CoordinateList * >(argp1);
  {
    try {
      result = (Magick::PathSmoothCurvetoRel *)new Magick::PathSmoothCurvetoRel((Magick::CoordinateList const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathSmoothCurvetoRel, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathSmoothCurvetoRel__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathSmoothCurvetoRel *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathSmoothCurvetoRel *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathSmoothCurvetoRel__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathSmoothCurvetoRel__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathSmoothCurvetoRel,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathSmoothCurvetoRel" "', argument " "1"" of type '" "Magick::PathSmoothCurvetoRel const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathSmoothCurvetoRel" "', argument " "1"" of type '" "Magick::PathSmoothCurvetoRel const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathSmoothCurvetoRel * >(argp1);
  {
    try {
      result = (Magick::PathSmoothCurvetoRel *)new Magick::PathSmoothCurvetoRel((Magick::PathSmoothCurvetoRel const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathSmoothCurvetoRel, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathSmoothCurvetoRel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathSmoothCurvetoRel__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathSmoothCurvetoRel__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathSmoothCurvetoRel__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_PathSmoothCurvetoRel");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_PathSmoothCurvetoRel(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::PathSmoothCurvetoRel * arg1 = (Magick::PathSmoothCurvetoRel *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_PathSmoothCurvetoRel_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathSmoothCurvetoRel *arg1 = (Magick::PathSmoothCurvetoRel *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathSmoothCurvetoRel_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathSmoothCurvetoRel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathSmoothCurvetoRel_call" "', argument " "1"" of type '" "Magick::PathSmoothCurvetoRel const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathSmoothCurvetoRel * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PathSmoothCurvetoRel_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::PathSmoothCurvetoRel const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathSmoothCurvetoRel_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathSmoothCurvetoRel *arg1 = (Magick::PathSmoothCurvetoRel *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::VPathBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathSmoothCurvetoRel_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathSmoothCurvetoRel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathSmoothCurvetoRel_copy" "', argument " "1"" of type '" "Magick::PathSmoothCurvetoRel const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathSmoothCurvetoRel * >(argp1);
  {
    try {
      result = (Magick::VPathBase *)((Magick::PathSmoothCurvetoRel const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__VPathBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathQuadraticCurvetoArgs__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathQuadraticCurvetoArgs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathQuadraticCurvetoArgs__SWIG_0.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathQuadraticCurvetoArgs__SWIG_0.");
  {
    try {
      result = (Magick::PathQuadraticCurvetoArgs *)new Magick::PathQuadraticCurvetoArgs();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathQuadraticCurvetoArgs__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  Magick::PathQuadraticCurvetoArgs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathQuadraticCurvetoArgs__SWIG_1.");
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathQuadraticCurvetoArgs__SWIG_1.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_PathQuadraticCurvetoArgs" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_PathQuadraticCurvetoArgs" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_PathQuadraticCurvetoArgs" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_PathQuadraticCurvetoArgs" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    try {
      result = (Magick::PathQuadraticCurvetoArgs *)new Magick::PathQuadraticCurvetoArgs(arg1,arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathQuadraticCurvetoArgs__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathQuadraticCurvetoArgs *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathQuadraticCurvetoArgs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathQuadraticCurvetoArgs__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathQuadraticCurvetoArgs__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathQuadraticCurvetoArgs" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathQuadraticCurvetoArgs" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp1);
  {
    try {
      result = (Magick::PathQuadraticCurvetoArgs *)new Magick::PathQuadraticCurvetoArgs((Magick::PathQuadraticCurvetoArgs const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathQuadraticCurvetoArgs(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_PathQuadraticCurvetoArgs__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_new_PathQuadraticCurvetoArgs__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathQuadraticCurvetoArgs__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_PathQuadraticCurvetoArgs");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_PathQuadraticCurvetoArgs(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::PathQuadraticCurvetoArgs * arg1 = (Magick::PathQuadraticCurvetoArgs *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_PathQuadraticCurvetoArgs_x1__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathQuadraticCurvetoArgs *arg1 = (Magick::PathQuadraticCurvetoArgs *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathQuadraticCurvetoArgs_x1" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PathQuadraticCurvetoArgs_x1" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->x1(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathQuadraticCurvetoArgs_x1__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathQuadraticCurvetoArgs *arg1 = (Magick::PathQuadraticCurvetoArgs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathQuadraticCurvetoArgs_x1" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp1);
  {
    try {
      result = (double)((Magick::PathQuadraticCurvetoArgs const *)arg1)->x1();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathQuadraticCurvetoArgs__wrap_PathQuadraticCurvetoArgs_x1(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_PathQuadraticCurvetoArgs_x1__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_PathQuadraticCurvetoArgs_x1__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function x1.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathQuadraticCurvetoArgs_y1__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathQuadraticCurvetoArgs *arg1 = (Magick::PathQuadraticCurvetoArgs *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathQuadraticCurvetoArgs_y1" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PathQuadraticCurvetoArgs_y1" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->y1(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathQuadraticCurvetoArgs_y1__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathQuadraticCurvetoArgs *arg1 = (Magick::PathQuadraticCurvetoArgs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathQuadraticCurvetoArgs_y1" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp1);
  {
    try {
      result = (double)((Magick::PathQuadraticCurvetoArgs const *)arg1)->y1();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathQuadraticCurvetoArgs__wrap_PathQuadraticCurvetoArgs_y1(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_PathQuadraticCurvetoArgs_y1__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_PathQuadraticCurvetoArgs_y1__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function y1.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathQuadraticCurvetoArgs_x__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathQuadraticCurvetoArgs *arg1 = (Magick::PathQuadraticCurvetoArgs *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathQuadraticCurvetoArgs_x" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PathQuadraticCurvetoArgs_x" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->x(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathQuadraticCurvetoArgs_x__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathQuadraticCurvetoArgs *arg1 = (Magick::PathQuadraticCurvetoArgs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathQuadraticCurvetoArgs_x" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp1);
  {
    try {
      result = (double)((Magick::PathQuadraticCurvetoArgs const *)arg1)->x();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathQuadraticCurvetoArgs__wrap_PathQuadraticCurvetoArgs_x(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_PathQuadraticCurvetoArgs_x__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_PathQuadraticCurvetoArgs_x__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function x.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathQuadraticCurvetoArgs_y__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathQuadraticCurvetoArgs *arg1 = (Magick::PathQuadraticCurvetoArgs *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathQuadraticCurvetoArgs_y" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PathQuadraticCurvetoArgs_y" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->y(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathQuadraticCurvetoArgs_y__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathQuadraticCurvetoArgs *arg1 = (Magick::PathQuadraticCurvetoArgs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathQuadraticCurvetoArgs_y" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp1);
  {
    try {
      result = (double)((Magick::PathQuadraticCurvetoArgs const *)arg1)->y();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathQuadraticCurvetoArgs__wrap_PathQuadraticCurvetoArgs_y(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_PathQuadraticCurvetoArgs_y__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_PathQuadraticCurvetoArgs_y__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function y.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_equal__SWIG_8(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathQuadraticCurvetoArgs *arg1 = 0 ;
  Magick::PathQuadraticCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equal" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equal" "', argument " "2"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "2"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp2);
  {
    try {
      result = (int)Magick::operator ==((Magick::PathQuadraticCurvetoArgs const &)*arg1,(Magick::PathQuadraticCurvetoArgs const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_notEqual__SWIG_8(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathQuadraticCurvetoArgs *arg1 = 0 ;
  Magick::PathQuadraticCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "notEqual" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "notEqual" "', argument " "2"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "2"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp2);
  {
    try {
      result = (int)Magick::operator !=((Magick::PathQuadraticCurvetoArgs const &)*arg1,(Magick::PathQuadraticCurvetoArgs const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_gt__SWIG_7(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathQuadraticCurvetoArgs *arg1 = 0 ;
  Magick::PathQuadraticCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gt" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gt" "', argument " "2"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "2"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp2);
  {
    try {
      result = (int)Magick::operator >((Magick::PathQuadraticCurvetoArgs const &)*arg1,(Magick::PathQuadraticCurvetoArgs const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_lt__SWIG_7(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathQuadraticCurvetoArgs *arg1 = 0 ;
  Magick::PathQuadraticCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lt" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lt" "', argument " "2"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "2"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp2);
  {
    try {
      result = (int)Magick::operator <((Magick::PathQuadraticCurvetoArgs const &)*arg1,(Magick::PathQuadraticCurvetoArgs const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_gte__SWIG_7(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathQuadraticCurvetoArgs *arg1 = 0 ;
  Magick::PathQuadraticCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gte" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gte" "', argument " "2"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "2"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp2);
  {
    try {
      result = (int)Magick::operator >=((Magick::PathQuadraticCurvetoArgs const &)*arg1,(Magick::PathQuadraticCurvetoArgs const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_lte__SWIG_7(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathQuadraticCurvetoArgs *arg1 = 0 ;
  Magick::PathQuadraticCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lte" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lte" "', argument " "2"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "2"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp2);
  {
    try {
      result = (int)Magick::operator <=((Magick::PathQuadraticCurvetoArgs const &)*arg1,(Magick::PathQuadraticCurvetoArgs const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathQuadraticCurvetoAbs__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathQuadraticCurvetoArgs *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathQuadraticCurvetoAbs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathQuadraticCurvetoAbs__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathQuadraticCurvetoAbs__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathQuadraticCurvetoAbs" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathQuadraticCurvetoAbs" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp1);
  {
    try {
      result = (Magick::PathQuadraticCurvetoAbs *)new Magick::PathQuadraticCurvetoAbs((Magick::PathQuadraticCurvetoArgs const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathQuadraticCurvetoAbs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathQuadraticCurvetoAbs__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathQuadraticCurvetoArgsList *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathQuadraticCurvetoAbs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathQuadraticCurvetoAbs__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathQuadraticCurvetoAbs__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_std__listT_Magick__PathQuadraticCurvetoArgs_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathQuadraticCurvetoAbs" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgsList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathQuadraticCurvetoAbs" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgsList const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoArgsList * >(argp1);
  {
    try {
      result = (Magick::PathQuadraticCurvetoAbs *)new Magick::PathQuadraticCurvetoAbs((Magick::PathQuadraticCurvetoArgsList const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathQuadraticCurvetoAbs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathQuadraticCurvetoAbs__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathQuadraticCurvetoAbs *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathQuadraticCurvetoAbs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathQuadraticCurvetoAbs__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathQuadraticCurvetoAbs__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathQuadraticCurvetoAbs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathQuadraticCurvetoAbs" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoAbs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathQuadraticCurvetoAbs" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoAbs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoAbs * >(argp1);
  {
    try {
      result = (Magick::PathQuadraticCurvetoAbs *)new Magick::PathQuadraticCurvetoAbs((Magick::PathQuadraticCurvetoAbs const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathQuadraticCurvetoAbs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathQuadraticCurvetoAbs(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathQuadraticCurvetoAbs__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathQuadraticCurvetoAbs__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathQuadraticCurvetoAbs__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_PathQuadraticCurvetoAbs");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_PathQuadraticCurvetoAbs(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::PathQuadraticCurvetoAbs * arg1 = (Magick::PathQuadraticCurvetoAbs *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_PathQuadraticCurvetoAbs_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathQuadraticCurvetoAbs *arg1 = (Magick::PathQuadraticCurvetoAbs *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathQuadraticCurvetoAbs_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathQuadraticCurvetoAbs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathQuadraticCurvetoAbs_call" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoAbs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoAbs * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PathQuadraticCurvetoAbs_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::PathQuadraticCurvetoAbs const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathQuadraticCurvetoAbs_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathQuadraticCurvetoAbs *arg1 = (Magick::PathQuadraticCurvetoAbs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::VPathBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathQuadraticCurvetoAbs_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathQuadraticCurvetoAbs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathQuadraticCurvetoAbs_copy" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoAbs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoAbs * >(argp1);
  {
    try {
      result = (Magick::VPathBase *)((Magick::PathQuadraticCurvetoAbs const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__VPathBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathQuadraticCurvetoRel__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathQuadraticCurvetoArgs *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathQuadraticCurvetoRel *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathQuadraticCurvetoRel__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathQuadraticCurvetoRel__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathQuadraticCurvetoRel" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathQuadraticCurvetoRel" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp1);
  {
    try {
      result = (Magick::PathQuadraticCurvetoRel *)new Magick::PathQuadraticCurvetoRel((Magick::PathQuadraticCurvetoArgs const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathQuadraticCurvetoRel, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathQuadraticCurvetoRel__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathQuadraticCurvetoArgsList *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathQuadraticCurvetoRel *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathQuadraticCurvetoRel__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathQuadraticCurvetoRel__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_std__listT_Magick__PathQuadraticCurvetoArgs_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathQuadraticCurvetoRel" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgsList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathQuadraticCurvetoRel" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgsList const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoArgsList * >(argp1);
  {
    try {
      result = (Magick::PathQuadraticCurvetoRel *)new Magick::PathQuadraticCurvetoRel((Magick::PathQuadraticCurvetoArgsList const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathQuadraticCurvetoRel, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathQuadraticCurvetoRel__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathQuadraticCurvetoRel *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathQuadraticCurvetoRel *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathQuadraticCurvetoRel__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathQuadraticCurvetoRel__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathQuadraticCurvetoRel,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathQuadraticCurvetoRel" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoRel const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathQuadraticCurvetoRel" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoRel const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoRel * >(argp1);
  {
    try {
      result = (Magick::PathQuadraticCurvetoRel *)new Magick::PathQuadraticCurvetoRel((Magick::PathQuadraticCurvetoRel const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathQuadraticCurvetoRel, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathQuadraticCurvetoRel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathQuadraticCurvetoRel__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathQuadraticCurvetoRel__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathQuadraticCurvetoRel__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_PathQuadraticCurvetoRel");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_PathQuadraticCurvetoRel(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::PathQuadraticCurvetoRel * arg1 = (Magick::PathQuadraticCurvetoRel *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_PathQuadraticCurvetoRel_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathQuadraticCurvetoRel *arg1 = (Magick::PathQuadraticCurvetoRel *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathQuadraticCurvetoRel_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathQuadraticCurvetoRel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathQuadraticCurvetoRel_call" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoRel const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoRel * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PathQuadraticCurvetoRel_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::PathQuadraticCurvetoRel const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathQuadraticCurvetoRel_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathQuadraticCurvetoRel *arg1 = (Magick::PathQuadraticCurvetoRel *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::VPathBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathQuadraticCurvetoRel_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathQuadraticCurvetoRel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathQuadraticCurvetoRel_copy" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoRel const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoRel * >(argp1);
  {
    try {
      result = (Magick::VPathBase *)((Magick::PathQuadraticCurvetoRel const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__VPathBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathSmoothQuadraticCurvetoAbs__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Coordinate *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathSmoothQuadraticCurvetoAbs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathSmoothQuadraticCurvetoAbs__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathSmoothQuadraticCurvetoAbs__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Coordinate,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathSmoothQuadraticCurvetoAbs" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathSmoothQuadraticCurvetoAbs" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Coordinate * >(argp1);
  {
    try {
      result = (Magick::PathSmoothQuadraticCurvetoAbs *)new Magick::PathSmoothQuadraticCurvetoAbs((Magick::Coordinate const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathSmoothQuadraticCurvetoAbs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathSmoothQuadraticCurvetoAbs__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::CoordinateList *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathSmoothQuadraticCurvetoAbs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathSmoothQuadraticCurvetoAbs__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathSmoothQuadraticCurvetoAbs__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_std__listT_Magick__Coordinate_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathSmoothQuadraticCurvetoAbs" "', argument " "1"" of type '" "Magick::CoordinateList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathSmoothQuadraticCurvetoAbs" "', argument " "1"" of type '" "Magick::CoordinateList const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::CoordinateList * >(argp1);
  {
    try {
      result = (Magick::PathSmoothQuadraticCurvetoAbs *)new Magick::PathSmoothQuadraticCurvetoAbs((Magick::CoordinateList const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathSmoothQuadraticCurvetoAbs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathSmoothQuadraticCurvetoAbs__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathSmoothQuadraticCurvetoAbs *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathSmoothQuadraticCurvetoAbs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathSmoothQuadraticCurvetoAbs__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathSmoothQuadraticCurvetoAbs__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathSmoothQuadraticCurvetoAbs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathSmoothQuadraticCurvetoAbs" "', argument " "1"" of type '" "Magick::PathSmoothQuadraticCurvetoAbs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathSmoothQuadraticCurvetoAbs" "', argument " "1"" of type '" "Magick::PathSmoothQuadraticCurvetoAbs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathSmoothQuadraticCurvetoAbs * >(argp1);
  {
    try {
      result = (Magick::PathSmoothQuadraticCurvetoAbs *)new Magick::PathSmoothQuadraticCurvetoAbs((Magick::PathSmoothQuadraticCurvetoAbs const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathSmoothQuadraticCurvetoAbs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathSmoothQuadraticCurvetoAbs(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathSmoothQuadraticCurvetoAbs__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathSmoothQuadraticCurvetoAbs__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathSmoothQuadraticCurvetoAbs__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_PathSmoothQuadraticCurvetoAbs");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_PathSmoothQuadraticCurvetoAbs(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::PathSmoothQuadraticCurvetoAbs * arg1 = (Magick::PathSmoothQuadraticCurvetoAbs *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_PathSmoothQuadraticCurvetoAbs_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathSmoothQuadraticCurvetoAbs *arg1 = (Magick::PathSmoothQuadraticCurvetoAbs *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathSmoothQuadraticCurvetoAbs_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathSmoothQuadraticCurvetoAbs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathSmoothQuadraticCurvetoAbs_call" "', argument " "1"" of type '" "Magick::PathSmoothQuadraticCurvetoAbs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathSmoothQuadraticCurvetoAbs * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PathSmoothQuadraticCurvetoAbs_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::PathSmoothQuadraticCurvetoAbs const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathSmoothQuadraticCurvetoAbs_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathSmoothQuadraticCurvetoAbs *arg1 = (Magick::PathSmoothQuadraticCurvetoAbs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::VPathBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathSmoothQuadraticCurvetoAbs_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathSmoothQuadraticCurvetoAbs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathSmoothQuadraticCurvetoAbs_copy" "', argument " "1"" of type '" "Magick::PathSmoothQuadraticCurvetoAbs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathSmoothQuadraticCurvetoAbs * >(argp1);
  {
    try {
      result = (Magick::VPathBase *)((Magick::PathSmoothQuadraticCurvetoAbs const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__VPathBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathSmoothQuadraticCurvetoRel__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Coordinate *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathSmoothQuadraticCurvetoRel *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathSmoothQuadraticCurvetoRel__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathSmoothQuadraticCurvetoRel__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Coordinate,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathSmoothQuadraticCurvetoRel" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathSmoothQuadraticCurvetoRel" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Coordinate * >(argp1);
  {
    try {
      result = (Magick::PathSmoothQuadraticCurvetoRel *)new Magick::PathSmoothQuadraticCurvetoRel((Magick::Coordinate const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathSmoothQuadraticCurvetoRel, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathSmoothQuadraticCurvetoRel__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::CoordinateList *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathSmoothQuadraticCurvetoRel *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathSmoothQuadraticCurvetoRel__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathSmoothQuadraticCurvetoRel__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_std__listT_Magick__Coordinate_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathSmoothQuadraticCurvetoRel" "', argument " "1"" of type '" "Magick::CoordinateList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathSmoothQuadraticCurvetoRel" "', argument " "1"" of type '" "Magick::CoordinateList const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::CoordinateList * >(argp1);
  {
    try {
      result = (Magick::PathSmoothQuadraticCurvetoRel *)new Magick::PathSmoothQuadraticCurvetoRel((Magick::CoordinateList const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathSmoothQuadraticCurvetoRel, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathSmoothQuadraticCurvetoRel__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathSmoothQuadraticCurvetoRel *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathSmoothQuadraticCurvetoRel *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathSmoothQuadraticCurvetoRel__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathSmoothQuadraticCurvetoRel__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathSmoothQuadraticCurvetoRel,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathSmoothQuadraticCurvetoRel" "', argument " "1"" of type '" "Magick::PathSmoothQuadraticCurvetoRel const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathSmoothQuadraticCurvetoRel" "', argument " "1"" of type '" "Magick::PathSmoothQuadraticCurvetoRel const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathSmoothQuadraticCurvetoRel * >(argp1);
  {
    try {
      result = (Magick::PathSmoothQuadraticCurvetoRel *)new Magick::PathSmoothQuadraticCurvetoRel((Magick::PathSmoothQuadraticCurvetoRel const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathSmoothQuadraticCurvetoRel, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathSmoothQuadraticCurvetoRel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathSmoothQuadraticCurvetoRel__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathSmoothQuadraticCurvetoRel__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathSmoothQuadraticCurvetoRel__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_PathSmoothQuadraticCurvetoRel");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_PathSmoothQuadraticCurvetoRel(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::PathSmoothQuadraticCurvetoRel * arg1 = (Magick::PathSmoothQuadraticCurvetoRel *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_PathSmoothQuadraticCurvetoRel_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathSmoothQuadraticCurvetoRel *arg1 = (Magick::PathSmoothQuadraticCurvetoRel *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathSmoothQuadraticCurvetoRel_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathSmoothQuadraticCurvetoRel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathSmoothQuadraticCurvetoRel_call" "', argument " "1"" of type '" "Magick::PathSmoothQuadraticCurvetoRel const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathSmoothQuadraticCurvetoRel * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PathSmoothQuadraticCurvetoRel_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::PathSmoothQuadraticCurvetoRel const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathSmoothQuadraticCurvetoRel_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathSmoothQuadraticCurvetoRel *arg1 = (Magick::PathSmoothQuadraticCurvetoRel *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::VPathBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathSmoothQuadraticCurvetoRel_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathSmoothQuadraticCurvetoRel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathSmoothQuadraticCurvetoRel_copy" "', argument " "1"" of type '" "Magick::PathSmoothQuadraticCurvetoRel const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathSmoothQuadraticCurvetoRel * >(argp1);
  {
    try {
      result = (Magick::VPathBase *)((Magick::PathSmoothQuadraticCurvetoRel const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__VPathBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathLinetoAbs__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Coordinate *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathLinetoAbs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathLinetoAbs__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathLinetoAbs__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Coordinate,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathLinetoAbs" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathLinetoAbs" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Coordinate * >(argp1);
  {
    try {
      result = (Magick::PathLinetoAbs *)new Magick::PathLinetoAbs((Magick::Coordinate const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathLinetoAbs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathLinetoAbs__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::CoordinateList *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathLinetoAbs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathLinetoAbs__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathLinetoAbs__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_std__listT_Magick__Coordinate_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathLinetoAbs" "', argument " "1"" of type '" "Magick::CoordinateList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathLinetoAbs" "', argument " "1"" of type '" "Magick::CoordinateList const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::CoordinateList * >(argp1);
  {
    try {
      result = (Magick::PathLinetoAbs *)new Magick::PathLinetoAbs((Magick::CoordinateList const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathLinetoAbs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathLinetoAbs__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathLinetoAbs *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathLinetoAbs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathLinetoAbs__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathLinetoAbs__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathLinetoAbs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathLinetoAbs" "', argument " "1"" of type '" "Magick::PathLinetoAbs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathLinetoAbs" "', argument " "1"" of type '" "Magick::PathLinetoAbs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathLinetoAbs * >(argp1);
  {
    try {
      result = (Magick::PathLinetoAbs *)new Magick::PathLinetoAbs((Magick::PathLinetoAbs const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathLinetoAbs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathLinetoAbs(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathLinetoAbs__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathLinetoAbs__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathLinetoAbs__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_PathLinetoAbs");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_PathLinetoAbs(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::PathLinetoAbs * arg1 = (Magick::PathLinetoAbs *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_PathLinetoAbs_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathLinetoAbs *arg1 = (Magick::PathLinetoAbs *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathLinetoAbs_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathLinetoAbs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathLinetoAbs_call" "', argument " "1"" of type '" "Magick::PathLinetoAbs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathLinetoAbs * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PathLinetoAbs_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::PathLinetoAbs const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathLinetoAbs_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathLinetoAbs *arg1 = (Magick::PathLinetoAbs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::VPathBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathLinetoAbs_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathLinetoAbs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathLinetoAbs_copy" "', argument " "1"" of type '" "Magick::PathLinetoAbs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathLinetoAbs * >(argp1);
  {
    try {
      result = (Magick::VPathBase *)((Magick::PathLinetoAbs const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__VPathBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathLinetoRel__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Coordinate *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathLinetoRel *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathLinetoRel__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathLinetoRel__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Coordinate,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathLinetoRel" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathLinetoRel" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Coordinate * >(argp1);
  {
    try {
      result = (Magick::PathLinetoRel *)new Magick::PathLinetoRel((Magick::Coordinate const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathLinetoRel, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathLinetoRel__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::CoordinateList *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathLinetoRel *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathLinetoRel__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathLinetoRel__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_std__listT_Magick__Coordinate_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathLinetoRel" "', argument " "1"" of type '" "Magick::CoordinateList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathLinetoRel" "', argument " "1"" of type '" "Magick::CoordinateList const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::CoordinateList * >(argp1);
  {
    try {
      result = (Magick::PathLinetoRel *)new Magick::PathLinetoRel((Magick::CoordinateList const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathLinetoRel, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathLinetoRel__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathLinetoRel *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathLinetoRel *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathLinetoRel__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathLinetoRel__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathLinetoRel,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathLinetoRel" "', argument " "1"" of type '" "Magick::PathLinetoRel const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathLinetoRel" "', argument " "1"" of type '" "Magick::PathLinetoRel const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathLinetoRel * >(argp1);
  {
    try {
      result = (Magick::PathLinetoRel *)new Magick::PathLinetoRel((Magick::PathLinetoRel const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathLinetoRel, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathLinetoRel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathLinetoRel__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathLinetoRel__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathLinetoRel__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_PathLinetoRel");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_PathLinetoRel(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::PathLinetoRel * arg1 = (Magick::PathLinetoRel *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_PathLinetoRel_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathLinetoRel *arg1 = (Magick::PathLinetoRel *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathLinetoRel_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathLinetoRel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathLinetoRel_call" "', argument " "1"" of type '" "Magick::PathLinetoRel const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathLinetoRel * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PathLinetoRel_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::PathLinetoRel const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathLinetoRel_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathLinetoRel *arg1 = (Magick::PathLinetoRel *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::VPathBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathLinetoRel_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathLinetoRel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathLinetoRel_copy" "', argument " "1"" of type '" "Magick::PathLinetoRel const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathLinetoRel * >(argp1);
  {
    try {
      result = (Magick::VPathBase *)((Magick::PathLinetoRel const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__VPathBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathLinetoHorizontalAbs(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::PathLinetoHorizontalAbs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathLinetoHorizontalAbs.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathLinetoHorizontalAbs.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_PathLinetoHorizontalAbs" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::PathLinetoHorizontalAbs *)new Magick::PathLinetoHorizontalAbs(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathLinetoHorizontalAbs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_PathLinetoHorizontalAbs(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::PathLinetoHorizontalAbs * arg1 = (Magick::PathLinetoHorizontalAbs *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_PathLinetoHorizontalAbs_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathLinetoHorizontalAbs *arg1 = (Magick::PathLinetoHorizontalAbs *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathLinetoHorizontalAbs_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathLinetoHorizontalAbs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathLinetoHorizontalAbs_call" "', argument " "1"" of type '" "Magick::PathLinetoHorizontalAbs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathLinetoHorizontalAbs * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PathLinetoHorizontalAbs_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::PathLinetoHorizontalAbs const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathLinetoHorizontalAbs_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathLinetoHorizontalAbs *arg1 = (Magick::PathLinetoHorizontalAbs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::VPathBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathLinetoHorizontalAbs_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathLinetoHorizontalAbs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathLinetoHorizontalAbs_copy" "', argument " "1"" of type '" "Magick::PathLinetoHorizontalAbs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathLinetoHorizontalAbs * >(argp1);
  {
    try {
      result = (Magick::VPathBase *)((Magick::PathLinetoHorizontalAbs const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__VPathBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathLinetoHorizontalAbs_x__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathLinetoHorizontalAbs *arg1 = (Magick::PathLinetoHorizontalAbs *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathLinetoHorizontalAbs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathLinetoHorizontalAbs_x" "', argument " "1"" of type '" "Magick::PathLinetoHorizontalAbs *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathLinetoHorizontalAbs * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PathLinetoHorizontalAbs_x" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->x(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathLinetoHorizontalAbs_x__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathLinetoHorizontalAbs *arg1 = (Magick::PathLinetoHorizontalAbs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathLinetoHorizontalAbs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathLinetoHorizontalAbs_x" "', argument " "1"" of type '" "Magick::PathLinetoHorizontalAbs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathLinetoHorizontalAbs * >(argp1);
  {
    try {
      result = (double)((Magick::PathLinetoHorizontalAbs const *)arg1)->x();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathLinetoHorizontalAbs__wrap_PathLinetoHorizontalAbs_x(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_PathLinetoHorizontalAbs_x__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_PathLinetoHorizontalAbs_x__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function x.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathLinetoHorizontalRel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::PathLinetoHorizontalRel *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathLinetoHorizontalRel.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathLinetoHorizontalRel.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_PathLinetoHorizontalRel" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::PathLinetoHorizontalRel *)new Magick::PathLinetoHorizontalRel(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathLinetoHorizontalRel, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_PathLinetoHorizontalRel(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::PathLinetoHorizontalRel * arg1 = (Magick::PathLinetoHorizontalRel *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_PathLinetoHorizontalRel_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathLinetoHorizontalRel *arg1 = (Magick::PathLinetoHorizontalRel *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathLinetoHorizontalRel_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathLinetoHorizontalRel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathLinetoHorizontalRel_call" "', argument " "1"" of type '" "Magick::PathLinetoHorizontalRel const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathLinetoHorizontalRel * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PathLinetoHorizontalRel_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::PathLinetoHorizontalRel const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathLinetoHorizontalRel_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathLinetoHorizontalRel *arg1 = (Magick::PathLinetoHorizontalRel *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::VPathBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathLinetoHorizontalRel_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathLinetoHorizontalRel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathLinetoHorizontalRel_copy" "', argument " "1"" of type '" "Magick::PathLinetoHorizontalRel const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathLinetoHorizontalRel * >(argp1);
  {
    try {
      result = (Magick::VPathBase *)((Magick::PathLinetoHorizontalRel const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__VPathBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathLinetoHorizontalRel_x__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathLinetoHorizontalRel *arg1 = (Magick::PathLinetoHorizontalRel *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathLinetoHorizontalRel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathLinetoHorizontalRel_x" "', argument " "1"" of type '" "Magick::PathLinetoHorizontalRel *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathLinetoHorizontalRel * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PathLinetoHorizontalRel_x" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->x(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathLinetoHorizontalRel_x__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathLinetoHorizontalRel *arg1 = (Magick::PathLinetoHorizontalRel *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathLinetoHorizontalRel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathLinetoHorizontalRel_x" "', argument " "1"" of type '" "Magick::PathLinetoHorizontalRel const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathLinetoHorizontalRel * >(argp1);
  {
    try {
      result = (double)((Magick::PathLinetoHorizontalRel const *)arg1)->x();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathLinetoHorizontalRel__wrap_PathLinetoHorizontalRel_x(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_PathLinetoHorizontalRel_x__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_PathLinetoHorizontalRel_x__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function x.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathLinetoVerticalAbs(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::PathLinetoVerticalAbs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathLinetoVerticalAbs.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathLinetoVerticalAbs.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_PathLinetoVerticalAbs" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::PathLinetoVerticalAbs *)new Magick::PathLinetoVerticalAbs(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathLinetoVerticalAbs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_PathLinetoVerticalAbs(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::PathLinetoVerticalAbs * arg1 = (Magick::PathLinetoVerticalAbs *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_PathLinetoVerticalAbs_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathLinetoVerticalAbs *arg1 = (Magick::PathLinetoVerticalAbs *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathLinetoVerticalAbs_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathLinetoVerticalAbs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathLinetoVerticalAbs_call" "', argument " "1"" of type '" "Magick::PathLinetoVerticalAbs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathLinetoVerticalAbs * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PathLinetoVerticalAbs_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::PathLinetoVerticalAbs const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathLinetoVerticalAbs_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathLinetoVerticalAbs *arg1 = (Magick::PathLinetoVerticalAbs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::VPathBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathLinetoVerticalAbs_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathLinetoVerticalAbs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathLinetoVerticalAbs_copy" "', argument " "1"" of type '" "Magick::PathLinetoVerticalAbs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathLinetoVerticalAbs * >(argp1);
  {
    try {
      result = (Magick::VPathBase *)((Magick::PathLinetoVerticalAbs const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__VPathBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathLinetoVerticalAbs_y__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathLinetoVerticalAbs *arg1 = (Magick::PathLinetoVerticalAbs *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathLinetoVerticalAbs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathLinetoVerticalAbs_y" "', argument " "1"" of type '" "Magick::PathLinetoVerticalAbs *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathLinetoVerticalAbs * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PathLinetoVerticalAbs_y" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->y(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathLinetoVerticalAbs_y__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathLinetoVerticalAbs *arg1 = (Magick::PathLinetoVerticalAbs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathLinetoVerticalAbs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathLinetoVerticalAbs_y" "', argument " "1"" of type '" "Magick::PathLinetoVerticalAbs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathLinetoVerticalAbs * >(argp1);
  {
    try {
      result = (double)((Magick::PathLinetoVerticalAbs const *)arg1)->y();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathLinetoVerticalAbs__wrap_PathLinetoVerticalAbs_y(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_PathLinetoVerticalAbs_y__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_PathLinetoVerticalAbs_y__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function y.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathLinetoVerticalRel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  Magick::PathLinetoVerticalRel *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathLinetoVerticalRel.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathLinetoVerticalRel.");
  ecode1 = SWIG_AsVal_double(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_PathLinetoVerticalRel" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (Magick::PathLinetoVerticalRel *)new Magick::PathLinetoVerticalRel(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathLinetoVerticalRel, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_PathLinetoVerticalRel(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::PathLinetoVerticalRel * arg1 = (Magick::PathLinetoVerticalRel *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_PathLinetoVerticalRel_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathLinetoVerticalRel *arg1 = (Magick::PathLinetoVerticalRel *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathLinetoVerticalRel_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathLinetoVerticalRel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathLinetoVerticalRel_call" "', argument " "1"" of type '" "Magick::PathLinetoVerticalRel const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathLinetoVerticalRel * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PathLinetoVerticalRel_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::PathLinetoVerticalRel const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathLinetoVerticalRel_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathLinetoVerticalRel *arg1 = (Magick::PathLinetoVerticalRel *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::VPathBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathLinetoVerticalRel_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathLinetoVerticalRel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathLinetoVerticalRel_copy" "', argument " "1"" of type '" "Magick::PathLinetoVerticalRel const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathLinetoVerticalRel * >(argp1);
  {
    try {
      result = (Magick::VPathBase *)((Magick::PathLinetoVerticalRel const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__VPathBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathLinetoVerticalRel_y__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathLinetoVerticalRel *arg1 = (Magick::PathLinetoVerticalRel *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathLinetoVerticalRel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathLinetoVerticalRel_y" "', argument " "1"" of type '" "Magick::PathLinetoVerticalRel *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathLinetoVerticalRel * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PathLinetoVerticalRel_y" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->y(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathLinetoVerticalRel_y__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathLinetoVerticalRel *arg1 = (Magick::PathLinetoVerticalRel *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathLinetoVerticalRel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathLinetoVerticalRel_y" "', argument " "1"" of type '" "Magick::PathLinetoVerticalRel const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathLinetoVerticalRel * >(argp1);
  {
    try {
      result = (double)((Magick::PathLinetoVerticalRel const *)arg1)->y();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathLinetoVerticalRel__wrap_PathLinetoVerticalRel_y(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_PathLinetoVerticalRel_y__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_PathLinetoVerticalRel_y__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function y.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathMovetoAbs__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Coordinate *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathMovetoAbs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathMovetoAbs__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathMovetoAbs__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Coordinate,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathMovetoAbs" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathMovetoAbs" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Coordinate * >(argp1);
  {
    try {
      result = (Magick::PathMovetoAbs *)new Magick::PathMovetoAbs((Magick::Coordinate const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathMovetoAbs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathMovetoAbs__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::CoordinateList *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathMovetoAbs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathMovetoAbs__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathMovetoAbs__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_std__listT_Magick__Coordinate_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathMovetoAbs" "', argument " "1"" of type '" "Magick::CoordinateList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathMovetoAbs" "', argument " "1"" of type '" "Magick::CoordinateList const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::CoordinateList * >(argp1);
  {
    try {
      result = (Magick::PathMovetoAbs *)new Magick::PathMovetoAbs((Magick::CoordinateList const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathMovetoAbs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathMovetoAbs__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathMovetoAbs *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathMovetoAbs *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathMovetoAbs__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathMovetoAbs__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathMovetoAbs,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathMovetoAbs" "', argument " "1"" of type '" "Magick::PathMovetoAbs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathMovetoAbs" "', argument " "1"" of type '" "Magick::PathMovetoAbs const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathMovetoAbs * >(argp1);
  {
    try {
      result = (Magick::PathMovetoAbs *)new Magick::PathMovetoAbs((Magick::PathMovetoAbs const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathMovetoAbs, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathMovetoAbs(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathMovetoAbs__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathMovetoAbs__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathMovetoAbs__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_PathMovetoAbs");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_PathMovetoAbs(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::PathMovetoAbs * arg1 = (Magick::PathMovetoAbs *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_PathMovetoAbs_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathMovetoAbs *arg1 = (Magick::PathMovetoAbs *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathMovetoAbs_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathMovetoAbs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathMovetoAbs_call" "', argument " "1"" of type '" "Magick::PathMovetoAbs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathMovetoAbs * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PathMovetoAbs_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::PathMovetoAbs const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathMovetoAbs_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathMovetoAbs *arg1 = (Magick::PathMovetoAbs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::VPathBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathMovetoAbs_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathMovetoAbs, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathMovetoAbs_copy" "', argument " "1"" of type '" "Magick::PathMovetoAbs const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathMovetoAbs * >(argp1);
  {
    try {
      result = (Magick::VPathBase *)((Magick::PathMovetoAbs const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__VPathBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathMovetoRel__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Coordinate *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathMovetoRel *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathMovetoRel__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathMovetoRel__SWIG_0.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Coordinate,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathMovetoRel" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathMovetoRel" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Coordinate * >(argp1);
  {
    try {
      result = (Magick::PathMovetoRel *)new Magick::PathMovetoRel((Magick::Coordinate const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathMovetoRel, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathMovetoRel__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::CoordinateList *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathMovetoRel *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathMovetoRel__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathMovetoRel__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_std__listT_Magick__Coordinate_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathMovetoRel" "', argument " "1"" of type '" "Magick::CoordinateList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathMovetoRel" "', argument " "1"" of type '" "Magick::CoordinateList const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::CoordinateList * >(argp1);
  {
    try {
      result = (Magick::PathMovetoRel *)new Magick::PathMovetoRel((Magick::CoordinateList const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathMovetoRel, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathMovetoRel__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::PathMovetoRel *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::PathMovetoRel *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_PathMovetoRel__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_PathMovetoRel__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__PathMovetoRel,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PathMovetoRel" "', argument " "1"" of type '" "Magick::PathMovetoRel const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PathMovetoRel" "', argument " "1"" of type '" "Magick::PathMovetoRel const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathMovetoRel * >(argp1);
  {
    try {
      result = (Magick::PathMovetoRel *)new Magick::PathMovetoRel((Magick::PathMovetoRel const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__PathMovetoRel, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_PathMovetoRel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathMovetoRel__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathMovetoRel__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_PathMovetoRel__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_PathMovetoRel");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_PathMovetoRel(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::PathMovetoRel * arg1 = (Magick::PathMovetoRel *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_PathMovetoRel_call(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathMovetoRel *arg1 = (Magick::PathMovetoRel *) 0 ;
  MagickCore::DrawingWand *arg2 = (MagickCore::DrawingWand *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathMovetoRel_call.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathMovetoRel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathMovetoRel_call" "', argument " "1"" of type '" "Magick::PathMovetoRel const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathMovetoRel * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__DrawingWand, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PathMovetoRel_call" "', argument " "2"" of type '" "MagickCore::DrawingWand *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::DrawingWand * >(argp2);
  {
    try {
      ((Magick::PathMovetoRel const *)arg1)->operator ()(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_PathMovetoRel_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::PathMovetoRel *arg1 = (Magick::PathMovetoRel *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::VPathBase *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_PathMovetoRel_copy.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__PathMovetoRel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathMovetoRel_copy" "', argument " "1"" of type '" "Magick::PathMovetoRel const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::PathMovetoRel * >(argp1);
  {
    try {
      result = (Magick::VPathBase *)((Magick::PathMovetoRel const *)arg1)->copy();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__VPathBase, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Exception__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::Exception *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Exception__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Exception__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Exception" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Exception" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::Exception *)new Magick::Exception((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Exception, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Exception__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::Exception *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Exception__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Exception__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Exception" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Exception" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_Exception" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::Exception *)new Magick::Exception((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Exception, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Exception__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Exception *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Exception *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Exception__SWIG_2.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Exception__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Exception,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Exception" "', argument " "1"" of type '" "Magick::Exception const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Exception" "', argument " "1"" of type '" "Magick::Exception const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Exception * >(argp1);
  {
    try {
      result = (Magick::Exception *)new Magick::Exception((Magick::Exception const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Exception, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Exception(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_Exception__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_Exception__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_Exception__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_Exception");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_Exception(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::Exception * arg1 = (Magick::Exception *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_Exception_clone(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Exception *arg1 = (Magick::Exception *) 0 ;
  Magick::Exception *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::Exception *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Exception_clone.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Exception_clone" "', argument " "1"" of type '" "Magick::Exception *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Exception * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Exception,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Exception_clone" "', argument " "2"" of type '" "Magick::Exception const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Exception_clone" "', argument " "2"" of type '" "Magick::Exception const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::Exception *) &(arg1)->operator =((Magick::Exception const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__Exception, 0 |  0 );
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Exception_what(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Exception *arg1 = (Magick::Exception *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Exception_what.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Exception_what" "', argument " "1"" of type '" "Magick::Exception const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Exception * >(argp1);
  {
    try {
      result = (char *)((Magick::Exception const *)arg1)->what();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_FromCharPtr((const char *)result);
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Exception_nested__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Exception *arg1 = (Magick::Exception *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Exception *result = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Exception_nested" "', argument " "1"" of type '" "Magick::Exception const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Exception * >(argp1);
  {
    try {
      result = (Magick::Exception *)((Magick::Exception const *)arg1)->nested();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__Exception, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Exception_nested__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Exception *arg1 = (Magick::Exception *) 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Exception_nested" "', argument " "1"" of type '" "Magick::Exception *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Exception * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Exception_nested" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      (arg1)->nested(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Exception__wrap_Exception_nested(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Exception_nested__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Exception_nested__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function nested.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Error__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::Error *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Error__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Error__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Error" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Error" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::Error *)new Magick::Error((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Error, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Error__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::Error *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Error__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Error__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Error" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Error" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_Error" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::Error *)new Magick::Error((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Error, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Error(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_Error__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_Error__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_Error");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_Error(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::Error * arg1 = (Magick::Error *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_ErrorBlob__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::ErrorBlob *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorBlob__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorBlob__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorBlob" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorBlob" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::ErrorBlob *)new Magick::ErrorBlob((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorBlob, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorBlob__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::ErrorBlob *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorBlob__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorBlob__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorBlob" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorBlob" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ErrorBlob" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::ErrorBlob *)new Magick::ErrorBlob((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorBlob, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorBlob(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ErrorBlob__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_ErrorBlob__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ErrorBlob");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ErrorBlob(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ErrorBlob * arg1 = (Magick::ErrorBlob *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_ErrorCache__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::ErrorCache *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorCache__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorCache__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorCache" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorCache" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::ErrorCache *)new Magick::ErrorCache((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorCache, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorCache__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::ErrorCache *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorCache__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorCache__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorCache" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorCache" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ErrorCache" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::ErrorCache *)new Magick::ErrorCache((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorCache, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorCache(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ErrorCache__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_ErrorCache__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ErrorCache");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ErrorCache(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ErrorCache * arg1 = (Magick::ErrorCache *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_ErrorCoder__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::ErrorCoder *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorCoder__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorCoder__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorCoder" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorCoder" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::ErrorCoder *)new Magick::ErrorCoder((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorCoder, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorCoder__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::ErrorCoder *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorCoder__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorCoder__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorCoder" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorCoder" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ErrorCoder" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::ErrorCoder *)new Magick::ErrorCoder((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorCoder, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorCoder(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ErrorCoder__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_ErrorCoder__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ErrorCoder");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ErrorCoder(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ErrorCoder * arg1 = (Magick::ErrorCoder *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_ErrorConfigure__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::ErrorConfigure *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorConfigure__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorConfigure__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorConfigure" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorConfigure" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::ErrorConfigure *)new Magick::ErrorConfigure((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorConfigure, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorConfigure__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::ErrorConfigure *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorConfigure__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorConfigure__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorConfigure" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorConfigure" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ErrorConfigure" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::ErrorConfigure *)new Magick::ErrorConfigure((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorConfigure, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorConfigure(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ErrorConfigure__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_ErrorConfigure__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ErrorConfigure");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ErrorConfigure(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ErrorConfigure * arg1 = (Magick::ErrorConfigure *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_ErrorCorruptImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::ErrorCorruptImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorCorruptImage__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorCorruptImage__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorCorruptImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorCorruptImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::ErrorCorruptImage *)new Magick::ErrorCorruptImage((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorCorruptImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorCorruptImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::ErrorCorruptImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorCorruptImage__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorCorruptImage__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorCorruptImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorCorruptImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ErrorCorruptImage" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::ErrorCorruptImage *)new Magick::ErrorCorruptImage((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorCorruptImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorCorruptImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ErrorCorruptImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_ErrorCorruptImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ErrorCorruptImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ErrorCorruptImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ErrorCorruptImage * arg1 = (Magick::ErrorCorruptImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_ErrorDelegate__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::ErrorDelegate *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorDelegate__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorDelegate__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorDelegate" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorDelegate" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::ErrorDelegate *)new Magick::ErrorDelegate((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorDelegate, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorDelegate__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::ErrorDelegate *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorDelegate__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorDelegate__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorDelegate" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorDelegate" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ErrorDelegate" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::ErrorDelegate *)new Magick::ErrorDelegate((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorDelegate, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorDelegate(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ErrorDelegate__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_ErrorDelegate__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ErrorDelegate");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ErrorDelegate(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ErrorDelegate * arg1 = (Magick::ErrorDelegate *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_ErrorDraw__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::ErrorDraw *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorDraw__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorDraw__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorDraw" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorDraw" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::ErrorDraw *)new Magick::ErrorDraw((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorDraw, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorDraw__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::ErrorDraw *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorDraw__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorDraw__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorDraw" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorDraw" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ErrorDraw" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::ErrorDraw *)new Magick::ErrorDraw((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorDraw, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorDraw(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ErrorDraw__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_ErrorDraw__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ErrorDraw");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ErrorDraw(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ErrorDraw * arg1 = (Magick::ErrorDraw *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_ErrorFileOpen__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::ErrorFileOpen *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorFileOpen__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorFileOpen__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorFileOpen" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorFileOpen" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::ErrorFileOpen *)new Magick::ErrorFileOpen((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorFileOpen, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorFileOpen__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::ErrorFileOpen *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorFileOpen__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorFileOpen__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorFileOpen" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorFileOpen" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ErrorFileOpen" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::ErrorFileOpen *)new Magick::ErrorFileOpen((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorFileOpen, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorFileOpen(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ErrorFileOpen__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_ErrorFileOpen__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ErrorFileOpen");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ErrorFileOpen(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ErrorFileOpen * arg1 = (Magick::ErrorFileOpen *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_ErrorImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::ErrorImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorImage__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorImage__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::ErrorImage *)new Magick::ErrorImage((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::ErrorImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorImage__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorImage__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ErrorImage" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::ErrorImage *)new Magick::ErrorImage((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ErrorImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_ErrorImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ErrorImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ErrorImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ErrorImage * arg1 = (Magick::ErrorImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_ErrorMissingDelegate__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::ErrorMissingDelegate *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorMissingDelegate__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorMissingDelegate__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorMissingDelegate" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorMissingDelegate" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::ErrorMissingDelegate *)new Magick::ErrorMissingDelegate((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorMissingDelegate, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorMissingDelegate__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::ErrorMissingDelegate *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorMissingDelegate__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorMissingDelegate__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorMissingDelegate" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorMissingDelegate" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ErrorMissingDelegate" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::ErrorMissingDelegate *)new Magick::ErrorMissingDelegate((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorMissingDelegate, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorMissingDelegate(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ErrorMissingDelegate__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_ErrorMissingDelegate__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ErrorMissingDelegate");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ErrorMissingDelegate(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ErrorMissingDelegate * arg1 = (Magick::ErrorMissingDelegate *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_ErrorModule__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::ErrorModule *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorModule__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorModule__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorModule" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorModule" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::ErrorModule *)new Magick::ErrorModule((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorModule, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorModule__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::ErrorModule *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorModule__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorModule__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorModule" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorModule" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ErrorModule" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::ErrorModule *)new Magick::ErrorModule((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorModule, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorModule(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ErrorModule__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_ErrorModule__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ErrorModule");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ErrorModule(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ErrorModule * arg1 = (Magick::ErrorModule *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_ErrorMonitor__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::ErrorMonitor *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorMonitor__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorMonitor__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorMonitor" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorMonitor" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::ErrorMonitor *)new Magick::ErrorMonitor((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorMonitor, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorMonitor__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::ErrorMonitor *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorMonitor__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorMonitor__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorMonitor" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorMonitor" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ErrorMonitor" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::ErrorMonitor *)new Magick::ErrorMonitor((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorMonitor, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorMonitor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ErrorMonitor__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_ErrorMonitor__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ErrorMonitor");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ErrorMonitor(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ErrorMonitor * arg1 = (Magick::ErrorMonitor *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_ErrorOption__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::ErrorOption *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorOption__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorOption__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorOption" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorOption" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::ErrorOption *)new Magick::ErrorOption((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorOption, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorOption__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::ErrorOption *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorOption__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorOption__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorOption" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorOption" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ErrorOption" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::ErrorOption *)new Magick::ErrorOption((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorOption, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorOption(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ErrorOption__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_ErrorOption__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ErrorOption");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ErrorOption(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ErrorOption * arg1 = (Magick::ErrorOption *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_ErrorPolicy__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::ErrorPolicy *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorPolicy__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorPolicy__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorPolicy" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorPolicy" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::ErrorPolicy *)new Magick::ErrorPolicy((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorPolicy, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorPolicy__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::ErrorPolicy *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorPolicy__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorPolicy__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorPolicy" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorPolicy" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ErrorPolicy" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::ErrorPolicy *)new Magick::ErrorPolicy((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorPolicy, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorPolicy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ErrorPolicy__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_ErrorPolicy__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ErrorPolicy");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ErrorPolicy(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ErrorPolicy * arg1 = (Magick::ErrorPolicy *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_ErrorRegistry__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::ErrorRegistry *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorRegistry__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorRegistry__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorRegistry" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorRegistry" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::ErrorRegistry *)new Magick::ErrorRegistry((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorRegistry, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorRegistry__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::ErrorRegistry *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorRegistry__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorRegistry__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorRegistry" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorRegistry" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ErrorRegistry" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::ErrorRegistry *)new Magick::ErrorRegistry((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorRegistry, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorRegistry(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ErrorRegistry__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_ErrorRegistry__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ErrorRegistry");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ErrorRegistry(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ErrorRegistry * arg1 = (Magick::ErrorRegistry *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_ErrorResourceLimit__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::ErrorResourceLimit *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorResourceLimit__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorResourceLimit__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorResourceLimit" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorResourceLimit" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::ErrorResourceLimit *)new Magick::ErrorResourceLimit((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorResourceLimit, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorResourceLimit__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::ErrorResourceLimit *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorResourceLimit__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorResourceLimit__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorResourceLimit" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorResourceLimit" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ErrorResourceLimit" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::ErrorResourceLimit *)new Magick::ErrorResourceLimit((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorResourceLimit, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorResourceLimit(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ErrorResourceLimit__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_ErrorResourceLimit__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ErrorResourceLimit");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ErrorResourceLimit(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ErrorResourceLimit * arg1 = (Magick::ErrorResourceLimit *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_ErrorStream__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::ErrorStream *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorStream__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorStream__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorStream" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorStream" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::ErrorStream *)new Magick::ErrorStream((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorStream, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorStream__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::ErrorStream *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorStream__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorStream__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorStream" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorStream" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ErrorStream" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::ErrorStream *)new Magick::ErrorStream((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorStream, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorStream(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ErrorStream__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_ErrorStream__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ErrorStream");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ErrorStream(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ErrorStream * arg1 = (Magick::ErrorStream *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_ErrorType__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::ErrorType *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorType__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorType__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorType" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorType" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::ErrorType *)new Magick::ErrorType((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorType, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorType__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::ErrorType *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorType__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorType__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorType" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorType" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ErrorType" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::ErrorType *)new Magick::ErrorType((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorType, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorType(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ErrorType__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_ErrorType__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ErrorType");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ErrorType(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ErrorType * arg1 = (Magick::ErrorType *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_ErrorUndefined__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::ErrorUndefined *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorUndefined__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorUndefined__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorUndefined" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorUndefined" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::ErrorUndefined *)new Magick::ErrorUndefined((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorUndefined, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorUndefined__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::ErrorUndefined *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorUndefined__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorUndefined__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorUndefined" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorUndefined" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ErrorUndefined" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::ErrorUndefined *)new Magick::ErrorUndefined((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorUndefined, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorUndefined(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ErrorUndefined__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_ErrorUndefined__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ErrorUndefined");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ErrorUndefined(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ErrorUndefined * arg1 = (Magick::ErrorUndefined *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_ErrorXServer__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::ErrorXServer *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorXServer__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorXServer__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorXServer" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorXServer" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::ErrorXServer *)new Magick::ErrorXServer((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorXServer, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorXServer__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::ErrorXServer *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_ErrorXServer__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_ErrorXServer__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ErrorXServer" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ErrorXServer" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ErrorXServer" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::ErrorXServer *)new Magick::ErrorXServer((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__ErrorXServer, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_ErrorXServer(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_ErrorXServer__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_ErrorXServer__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_ErrorXServer");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_ErrorXServer(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::ErrorXServer * arg1 = (Magick::ErrorXServer *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_Warning__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::Warning *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Warning__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Warning__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Warning" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Warning" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::Warning *)new Magick::Warning((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Warning, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Warning__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::Warning *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Warning__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Warning__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Warning" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Warning" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_Warning" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::Warning *)new Magick::Warning((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Warning, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Warning(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_Warning__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_Warning__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_Warning");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_Warning(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::Warning * arg1 = (Magick::Warning *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_WarningBlob__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::WarningBlob *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningBlob__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningBlob__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningBlob" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningBlob" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::WarningBlob *)new Magick::WarningBlob((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningBlob, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningBlob__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::WarningBlob *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningBlob__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningBlob__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningBlob" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningBlob" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_WarningBlob" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::WarningBlob *)new Magick::WarningBlob((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningBlob, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningBlob(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_WarningBlob__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_WarningBlob__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_WarningBlob");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_WarningBlob(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::WarningBlob * arg1 = (Magick::WarningBlob *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_WarningCache__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::WarningCache *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningCache__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningCache__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningCache" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningCache" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::WarningCache *)new Magick::WarningCache((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningCache, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningCache__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::WarningCache *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningCache__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningCache__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningCache" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningCache" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_WarningCache" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::WarningCache *)new Magick::WarningCache((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningCache, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningCache(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_WarningCache__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_WarningCache__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_WarningCache");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_WarningCache(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::WarningCache * arg1 = (Magick::WarningCache *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_WarningCoder__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::WarningCoder *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningCoder__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningCoder__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningCoder" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningCoder" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::WarningCoder *)new Magick::WarningCoder((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningCoder, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningCoder__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::WarningCoder *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningCoder__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningCoder__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningCoder" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningCoder" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_WarningCoder" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::WarningCoder *)new Magick::WarningCoder((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningCoder, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningCoder(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_WarningCoder__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_WarningCoder__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_WarningCoder");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_WarningCoder(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::WarningCoder * arg1 = (Magick::WarningCoder *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_WarningConfigure__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::WarningConfigure *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningConfigure__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningConfigure__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningConfigure" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningConfigure" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::WarningConfigure *)new Magick::WarningConfigure((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningConfigure, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningConfigure__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::WarningConfigure *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningConfigure__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningConfigure__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningConfigure" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningConfigure" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_WarningConfigure" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::WarningConfigure *)new Magick::WarningConfigure((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningConfigure, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningConfigure(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_WarningConfigure__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_WarningConfigure__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_WarningConfigure");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_WarningConfigure(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::WarningConfigure * arg1 = (Magick::WarningConfigure *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_WarningCorruptImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::WarningCorruptImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningCorruptImage__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningCorruptImage__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningCorruptImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningCorruptImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::WarningCorruptImage *)new Magick::WarningCorruptImage((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningCorruptImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningCorruptImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::WarningCorruptImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningCorruptImage__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningCorruptImage__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningCorruptImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningCorruptImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_WarningCorruptImage" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::WarningCorruptImage *)new Magick::WarningCorruptImage((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningCorruptImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningCorruptImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_WarningCorruptImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_WarningCorruptImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_WarningCorruptImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_WarningCorruptImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::WarningCorruptImage * arg1 = (Magick::WarningCorruptImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_WarningDelegate__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::WarningDelegate *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningDelegate__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningDelegate__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningDelegate" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningDelegate" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::WarningDelegate *)new Magick::WarningDelegate((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningDelegate, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningDelegate__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::WarningDelegate *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningDelegate__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningDelegate__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningDelegate" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningDelegate" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_WarningDelegate" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::WarningDelegate *)new Magick::WarningDelegate((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningDelegate, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningDelegate(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_WarningDelegate__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_WarningDelegate__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_WarningDelegate");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_WarningDelegate(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::WarningDelegate * arg1 = (Magick::WarningDelegate *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_WarningDraw__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::WarningDraw *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningDraw__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningDraw__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningDraw" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningDraw" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::WarningDraw *)new Magick::WarningDraw((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningDraw, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningDraw__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::WarningDraw *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningDraw__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningDraw__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningDraw" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningDraw" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_WarningDraw" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::WarningDraw *)new Magick::WarningDraw((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningDraw, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningDraw(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_WarningDraw__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_WarningDraw__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_WarningDraw");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_WarningDraw(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::WarningDraw * arg1 = (Magick::WarningDraw *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_WarningFileOpen__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::WarningFileOpen *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningFileOpen__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningFileOpen__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningFileOpen" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningFileOpen" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::WarningFileOpen *)new Magick::WarningFileOpen((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningFileOpen, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningFileOpen__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::WarningFileOpen *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningFileOpen__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningFileOpen__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningFileOpen" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningFileOpen" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_WarningFileOpen" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::WarningFileOpen *)new Magick::WarningFileOpen((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningFileOpen, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningFileOpen(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_WarningFileOpen__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_WarningFileOpen__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_WarningFileOpen");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_WarningFileOpen(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::WarningFileOpen * arg1 = (Magick::WarningFileOpen *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_WarningImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::WarningImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningImage__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningImage__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::WarningImage *)new Magick::WarningImage((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::WarningImage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningImage__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningImage__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningImage" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_WarningImage" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::WarningImage *)new Magick::WarningImage((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningImage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_WarningImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_WarningImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_WarningImage");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_WarningImage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::WarningImage * arg1 = (Magick::WarningImage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_WarningMissingDelegate__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::WarningMissingDelegate *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningMissingDelegate__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningMissingDelegate__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningMissingDelegate" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningMissingDelegate" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::WarningMissingDelegate *)new Magick::WarningMissingDelegate((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningMissingDelegate, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningMissingDelegate__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::WarningMissingDelegate *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningMissingDelegate__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningMissingDelegate__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningMissingDelegate" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningMissingDelegate" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_WarningMissingDelegate" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::WarningMissingDelegate *)new Magick::WarningMissingDelegate((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningMissingDelegate, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningMissingDelegate(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_WarningMissingDelegate__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_WarningMissingDelegate__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_WarningMissingDelegate");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_WarningMissingDelegate(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::WarningMissingDelegate * arg1 = (Magick::WarningMissingDelegate *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_WarningModule__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::WarningModule *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningModule__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningModule__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningModule" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningModule" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::WarningModule *)new Magick::WarningModule((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningModule, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningModule__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::WarningModule *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningModule__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningModule__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningModule" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningModule" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_WarningModule" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::WarningModule *)new Magick::WarningModule((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningModule, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningModule(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_WarningModule__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_WarningModule__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_WarningModule");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_WarningModule(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::WarningModule * arg1 = (Magick::WarningModule *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_WarningMonitor__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::WarningMonitor *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningMonitor__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningMonitor__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningMonitor" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningMonitor" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::WarningMonitor *)new Magick::WarningMonitor((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningMonitor, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningMonitor__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::WarningMonitor *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningMonitor__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningMonitor__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningMonitor" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningMonitor" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_WarningMonitor" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::WarningMonitor *)new Magick::WarningMonitor((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningMonitor, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningMonitor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_WarningMonitor__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_WarningMonitor__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_WarningMonitor");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_WarningMonitor(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::WarningMonitor * arg1 = (Magick::WarningMonitor *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_WarningOption__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::WarningOption *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningOption__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningOption__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningOption" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningOption" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::WarningOption *)new Magick::WarningOption((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningOption, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningOption__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::WarningOption *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningOption__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningOption__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningOption" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningOption" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_WarningOption" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::WarningOption *)new Magick::WarningOption((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningOption, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningOption(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_WarningOption__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_WarningOption__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_WarningOption");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_WarningOption(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::WarningOption * arg1 = (Magick::WarningOption *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_WarningPolicy__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::WarningPolicy *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningPolicy__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningPolicy__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningPolicy" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningPolicy" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::WarningPolicy *)new Magick::WarningPolicy((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningPolicy, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningPolicy__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::WarningPolicy *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningPolicy__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningPolicy__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningPolicy" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningPolicy" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_WarningPolicy" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::WarningPolicy *)new Magick::WarningPolicy((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningPolicy, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningPolicy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_WarningPolicy__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_WarningPolicy__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_WarningPolicy");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_WarningPolicy(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::WarningPolicy * arg1 = (Magick::WarningPolicy *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_WarningRegistry__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::WarningRegistry *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningRegistry__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningRegistry__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningRegistry" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningRegistry" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::WarningRegistry *)new Magick::WarningRegistry((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningRegistry, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningRegistry__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::WarningRegistry *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningRegistry__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningRegistry__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningRegistry" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningRegistry" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_WarningRegistry" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::WarningRegistry *)new Magick::WarningRegistry((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningRegistry, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningRegistry(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_WarningRegistry__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_WarningRegistry__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_WarningRegistry");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_WarningRegistry(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::WarningRegistry * arg1 = (Magick::WarningRegistry *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_WarningResourceLimit__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::WarningResourceLimit *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningResourceLimit__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningResourceLimit__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningResourceLimit" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningResourceLimit" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::WarningResourceLimit *)new Magick::WarningResourceLimit((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningResourceLimit, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningResourceLimit__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::WarningResourceLimit *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningResourceLimit__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningResourceLimit__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningResourceLimit" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningResourceLimit" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_WarningResourceLimit" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::WarningResourceLimit *)new Magick::WarningResourceLimit((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningResourceLimit, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningResourceLimit(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_WarningResourceLimit__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_WarningResourceLimit__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_WarningResourceLimit");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_WarningResourceLimit(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::WarningResourceLimit * arg1 = (Magick::WarningResourceLimit *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_WarningStream__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::WarningStream *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningStream__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningStream__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningStream" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningStream" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::WarningStream *)new Magick::WarningStream((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningStream, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningStream__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::WarningStream *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningStream__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningStream__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningStream" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningStream" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_WarningStream" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::WarningStream *)new Magick::WarningStream((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningStream, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningStream(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_WarningStream__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_WarningStream__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_WarningStream");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_WarningStream(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::WarningStream * arg1 = (Magick::WarningStream *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_WarningType__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::WarningType *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningType__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningType__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningType" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningType" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::WarningType *)new Magick::WarningType((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningType, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningType__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::WarningType *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningType__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningType__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningType" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningType" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_WarningType" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::WarningType *)new Magick::WarningType((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningType, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningType(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_WarningType__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_WarningType__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_WarningType");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_WarningType(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::WarningType * arg1 = (Magick::WarningType *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_WarningUndefined__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::WarningUndefined *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningUndefined__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningUndefined__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningUndefined" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningUndefined" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::WarningUndefined *)new Magick::WarningUndefined((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningUndefined, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningUndefined__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::WarningUndefined *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningUndefined__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningUndefined__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningUndefined" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningUndefined" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_WarningUndefined" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::WarningUndefined *)new Magick::WarningUndefined((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningUndefined, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningUndefined(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_WarningUndefined__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_WarningUndefined__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_WarningUndefined");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_WarningUndefined(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::WarningUndefined * arg1 = (Magick::WarningUndefined *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_new_WarningXServer__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::WarningXServer *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningXServer__SWIG_0.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningXServer__SWIG_0.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningXServer" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningXServer" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::WarningXServer *)new Magick::WarningXServer((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningXServer, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningXServer__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  Magick::Exception *arg2 = (Magick::Exception *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::WarningXServer *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_WarningXServer__SWIG_1.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_WarningXServer__SWIG_1.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WarningXServer" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WarningXServer" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_Magick__Exception, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_WarningXServer" "', argument " "2"" of type '" "Magick::Exception *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Exception * >(argp2);
  {
    try {
      result = (Magick::WarningXServer *)new Magick::WarningXServer((std::string const &)*arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__WarningXServer, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_WarningXServer(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_WarningXServer__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_WarningXServer__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_WarningXServer");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_WarningXServer(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::WarningXServer * arg1 = (Magick::WarningXServer *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_formatExceptionMessage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  MagickCore::ExceptionInfo *arg1 = (MagickCore::ExceptionInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_formatExceptionMessage.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_MagickCore___ExceptionInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "formatExceptionMessage" "', argument " "1"" of type '" "MagickCore::ExceptionInfo const *""'"); 
  }
  arg1 = reinterpret_cast< MagickCore::ExceptionInfo * >(argp1);
  {
    try {
      result = Magick::formatExceptionMessage((MagickCore::_ExceptionInfo const *)arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_createException(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  MagickCore::ExceptionInfo *arg1 = (MagickCore::ExceptionInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Exception *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_createException.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_MagickCore___ExceptionInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "createException" "', argument " "1"" of type '" "MagickCore::ExceptionInfo const *""'"); 
  }
  arg1 = reinterpret_cast< MagickCore::ExceptionInfo * >(argp1);
  {
    try {
      result = (Magick::Exception *)Magick::createException((MagickCore::_ExceptionInfo const *)arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__Exception, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_throwExceptionExplicit__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  MagickCore::ExceptionType arg1 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "throwExceptionExplicit" "', argument " "1"" of type '" "MagickCore::ExceptionType""'");
  } 
  arg1 = static_cast< MagickCore::ExceptionType >(val1);
  res2 = SWIG_AsCharPtrAndSize(args[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "throwExceptionExplicit" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(args[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "throwExceptionExplicit" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  {
    try {
      Magick::throwExceptionExplicit(arg1,(char const *)arg2,(char const *)arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_throwExceptionExplicit__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  MagickCore::ExceptionType arg1 ;
  char *arg2 = (char *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "throwExceptionExplicit" "', argument " "1"" of type '" "MagickCore::ExceptionType""'");
  } 
  arg1 = static_cast< MagickCore::ExceptionType >(val1);
  res2 = SWIG_AsCharPtrAndSize(args[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "throwExceptionExplicit" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      Magick::throwExceptionExplicit(arg1,(char const *)arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Magick__wrap_throwExceptionExplicit(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_throwExceptionExplicit__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_throwExceptionExplicit__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function throwExceptionExplicit.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_throwException__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  MagickCore::ExceptionInfo *arg1 = (MagickCore::ExceptionInfo *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_MagickCore___ExceptionInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "throwException" "', argument " "1"" of type '" "MagickCore::ExceptionInfo *""'"); 
  }
  arg1 = reinterpret_cast< MagickCore::ExceptionInfo * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "throwException" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      Magick::throwException(arg1,arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_throwException__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  MagickCore::ExceptionInfo *arg1 = (MagickCore::ExceptionInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_MagickCore___ExceptionInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "throwException" "', argument " "1"" of type '" "MagickCore::ExceptionInfo *""'"); 
  }
  arg1 = reinterpret_cast< MagickCore::ExceptionInfo * >(argp1);
  {
    try {
      Magick::throwException(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Magick__wrap_throwException(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_throwException__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_throwException__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function throwException.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Montage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Montage *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Montage.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Montage.");
  {
    try {
      result = (Magick::Montage *)new Magick::Montage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Montage, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_Montage(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::Montage * arg1 = (Magick::Montage *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_Montage_backgroundColor__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_backgroundColor" "', argument " "1"" of type '" "Magick::Montage *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Montage_backgroundColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Montage_backgroundColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      (arg1)->backgroundColor((Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_backgroundColor__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Color result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_backgroundColor" "', argument " "1"" of type '" "Magick::Montage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  {
    try {
      result = ((Magick::Montage const *)arg1)->backgroundColor();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Color(result)), SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage__wrap_Montage_backgroundColor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Montage_backgroundColor__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Montage_backgroundColor__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function backgroundColor.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_compose__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  Magick::CompositeOperator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_compose" "', argument " "1"" of type '" "Magick::Montage *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Montage_compose" "', argument " "2"" of type '" "Magick::CompositeOperator""'");
  } 
  arg2 = static_cast< Magick::CompositeOperator >(val2);
  {
    try {
      (arg1)->compose(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_compose__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::CompositeOperator result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_compose" "', argument " "1"" of type '" "Magick::Montage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  {
    try {
      result = (Magick::CompositeOperator)((Magick::Montage const *)arg1)->compose();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage__wrap_Montage_compose(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Montage_compose__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Montage_compose__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function compose.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_fileName__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_fileName" "', argument " "1"" of type '" "Magick::Montage *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Montage_fileName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Montage_fileName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->fileName((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_fileName__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_fileName" "', argument " "1"" of type '" "Magick::Montage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  {
    try {
      result = ((Magick::Montage const *)arg1)->fileName();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage__wrap_Montage_fileName(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Montage_fileName__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Montage_fileName__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function fileName.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_fillColor__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_fillColor" "', argument " "1"" of type '" "Magick::Montage *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Montage_fillColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Montage_fillColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      (arg1)->fillColor((Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_fillColor__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Color result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_fillColor" "', argument " "1"" of type '" "Magick::Montage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  {
    try {
      result = ((Magick::Montage const *)arg1)->fillColor();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Color(result)), SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage__wrap_Montage_fillColor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Montage_fillColor__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Montage_fillColor__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function fillColor.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_font__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_font" "', argument " "1"" of type '" "Magick::Montage *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Montage_font" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Montage_font" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->font((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_font__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_font" "', argument " "1"" of type '" "Magick::Montage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  {
    try {
      result = ((Magick::Montage const *)arg1)->font();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage__wrap_Montage_font(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Montage_font__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Montage_font__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function font.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_geometry__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_geometry" "', argument " "1"" of type '" "Magick::Montage *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Montage_geometry" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Montage_geometry" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->geometry((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_geometry__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Geometry result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_geometry" "', argument " "1"" of type '" "Magick::Montage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  {
    try {
      result = ((Magick::Montage const *)arg1)->geometry();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Geometry(result)), SWIGTYPE_p_Magick__Geometry, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage__wrap_Montage_geometry(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Montage_geometry__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Montage_geometry__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function geometry.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_gravity__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  Magick::GravityType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_gravity" "', argument " "1"" of type '" "Magick::Montage *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Montage_gravity" "', argument " "2"" of type '" "Magick::GravityType""'");
  } 
  arg2 = static_cast< Magick::GravityType >(val2);
  {
    try {
      (arg1)->gravity(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_gravity__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::GravityType result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_gravity" "', argument " "1"" of type '" "Magick::Montage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  {
    try {
      result = (Magick::GravityType)((Magick::Montage const *)arg1)->gravity();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage__wrap_Montage_gravity(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Montage_gravity__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Montage_gravity__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function gravity.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_label__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_label" "', argument " "1"" of type '" "Magick::Montage *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Montage_label" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Montage_label" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->label((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_label__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_label" "', argument " "1"" of type '" "Magick::Montage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  {
    try {
      result = ((Magick::Montage const *)arg1)->label();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage__wrap_Montage_label(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Montage_label__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Montage_label__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function label.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_penColor__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_penColor" "', argument " "1"" of type '" "Magick::Montage *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Montage_penColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Montage_penColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      (arg1)->penColor((Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_penColor__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Color result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_penColor" "', argument " "1"" of type '" "Magick::Montage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  {
    try {
      result = ((Magick::Montage const *)arg1)->penColor();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Color(result)), SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage__wrap_Montage_penColor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Montage_penColor__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Montage_penColor__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function penColor.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_pointSize__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_pointSize" "', argument " "1"" of type '" "Magick::Montage *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Montage_pointSize" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      (arg1)->pointSize(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_pointSize__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_pointSize" "', argument " "1"" of type '" "Magick::Montage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  {
    try {
      result = ((Magick::Montage const *)arg1)->pointSize();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage__wrap_Montage_pointSize(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Montage_pointSize__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Montage_pointSize__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function pointSize.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_shadow__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_shadow" "', argument " "1"" of type '" "Magick::Montage *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Montage_shadow" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->shadow(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_shadow__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_shadow" "', argument " "1"" of type '" "Magick::Montage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  {
    try {
      result = (bool)((Magick::Montage const *)arg1)->shadow();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage__wrap_Montage_shadow(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Montage_shadow__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Montage_shadow__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function shadow.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_strokeColor__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_strokeColor" "', argument " "1"" of type '" "Magick::Montage *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Montage_strokeColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Montage_strokeColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      (arg1)->strokeColor((Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_strokeColor__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Color result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_strokeColor" "', argument " "1"" of type '" "Magick::Montage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  {
    try {
      result = ((Magick::Montage const *)arg1)->strokeColor();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Color(result)), SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage__wrap_Montage_strokeColor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Montage_strokeColor__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Montage_strokeColor__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function strokeColor.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_texture__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_texture" "', argument " "1"" of type '" "Magick::Montage *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Montage_texture" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Montage_texture" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->texture((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_texture__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_texture" "', argument " "1"" of type '" "Magick::Montage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  {
    try {
      result = ((Magick::Montage const *)arg1)->texture();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage__wrap_Montage_texture(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Montage_texture__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Montage_texture__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function texture.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_tile__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_tile" "', argument " "1"" of type '" "Magick::Montage *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Montage_tile" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Montage_tile" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->tile((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_tile__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Geometry result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_tile" "', argument " "1"" of type '" "Magick::Montage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  {
    try {
      result = ((Magick::Montage const *)arg1)->tile();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Geometry(result)), SWIGTYPE_p_Magick__Geometry, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage__wrap_Montage_tile(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Montage_tile__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Montage_tile__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function tile.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_title__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_title" "', argument " "1"" of type '" "Magick::Montage *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Montage_title" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Montage_title" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->title((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_title__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_title" "', argument " "1"" of type '" "Magick::Montage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  {
    try {
      result = ((Magick::Montage const *)arg1)->title();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage__wrap_Montage_title(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Montage_title__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Montage_title__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function title.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_transparentColor__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_transparentColor" "', argument " "1"" of type '" "Magick::Montage *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Montage_transparentColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Montage_transparentColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      (arg1)->transparentColor((Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_transparentColor__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Color result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_transparentColor" "', argument " "1"" of type '" "Magick::Montage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  {
    try {
      result = ((Magick::Montage const *)arg1)->transparentColor();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Color(result)), SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage__wrap_Montage_transparentColor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Montage_transparentColor__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Montage_transparentColor__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function transparentColor.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Montage_updateMontageInfo(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Montage *arg1 = (Magick::Montage *) 0 ;
  MagickCore::MontageInfo *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Montage_updateMontageInfo.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Montage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Montage_updateMontageInfo" "', argument " "1"" of type '" "Magick::Montage const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Montage * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_MagickCore___MontageInfo,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Montage_updateMontageInfo" "', argument " "2"" of type '" "MagickCore::MontageInfo &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Montage_updateMontageInfo" "', argument " "2"" of type '" "MagickCore::MontageInfo &""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::MontageInfo * >(argp2);
  {
    try {
      ((Magick::Montage const *)arg1)->updateMontageInfo(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_MontageFramed(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::MontageFramed *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_MontageFramed.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_MontageFramed.");
  {
    try {
      result = (Magick::MontageFramed *)new Magick::MontageFramed();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__MontageFramed, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_MontageFramed(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::MontageFramed * arg1 = (Magick::MontageFramed *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_MontageFramed_borderColor__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MontageFramed *arg1 = (Magick::MontageFramed *) 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__MontageFramed, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MontageFramed_borderColor" "', argument " "1"" of type '" "Magick::MontageFramed *""'"); 
  }
  arg1 = reinterpret_cast< Magick::MontageFramed * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MontageFramed_borderColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MontageFramed_borderColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      (arg1)->borderColor((Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_MontageFramed_borderColor__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MontageFramed *arg1 = (Magick::MontageFramed *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Color result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__MontageFramed, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MontageFramed_borderColor" "', argument " "1"" of type '" "Magick::MontageFramed const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::MontageFramed * >(argp1);
  {
    try {
      result = ((Magick::MontageFramed const *)arg1)->borderColor();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Color(result)), SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_MontageFramed__wrap_MontageFramed_borderColor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_MontageFramed_borderColor__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_MontageFramed_borderColor__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function borderColor.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_MontageFramed_borderWidth__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MontageFramed *arg1 = (Magick::MontageFramed *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__MontageFramed, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MontageFramed_borderWidth" "', argument " "1"" of type '" "Magick::MontageFramed *""'"); 
  }
  arg1 = reinterpret_cast< Magick::MontageFramed * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MontageFramed_borderWidth" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      (arg1)->borderWidth(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_MontageFramed_borderWidth__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MontageFramed *arg1 = (Magick::MontageFramed *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__MontageFramed, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MontageFramed_borderWidth" "', argument " "1"" of type '" "Magick::MontageFramed const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::MontageFramed * >(argp1);
  {
    try {
      result = ((Magick::MontageFramed const *)arg1)->borderWidth();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_MontageFramed__wrap_MontageFramed_borderWidth(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_MontageFramed_borderWidth__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_MontageFramed_borderWidth__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function borderWidth.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_MontageFramed_frameGeometry__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MontageFramed *arg1 = (Magick::MontageFramed *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__MontageFramed, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MontageFramed_frameGeometry" "', argument " "1"" of type '" "Magick::MontageFramed *""'"); 
  }
  arg1 = reinterpret_cast< Magick::MontageFramed * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MontageFramed_frameGeometry" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MontageFramed_frameGeometry" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->frameGeometry((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_MontageFramed_frameGeometry__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MontageFramed *arg1 = (Magick::MontageFramed *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Geometry result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__MontageFramed, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MontageFramed_frameGeometry" "', argument " "1"" of type '" "Magick::MontageFramed const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::MontageFramed * >(argp1);
  {
    try {
      result = ((Magick::MontageFramed const *)arg1)->frameGeometry();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Geometry(result)), SWIGTYPE_p_Magick__Geometry, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_MontageFramed__wrap_MontageFramed_frameGeometry(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_MontageFramed_frameGeometry__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_MontageFramed_frameGeometry__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function frameGeometry.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_MontageFramed_matteColor__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MontageFramed *arg1 = (Magick::MontageFramed *) 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__MontageFramed, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MontageFramed_matteColor" "', argument " "1"" of type '" "Magick::MontageFramed *""'"); 
  }
  arg1 = reinterpret_cast< Magick::MontageFramed * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MontageFramed_matteColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MontageFramed_matteColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      (arg1)->matteColor((Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_MontageFramed_matteColor__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MontageFramed *arg1 = (Magick::MontageFramed *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Color result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__MontageFramed, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MontageFramed_matteColor" "', argument " "1"" of type '" "Magick::MontageFramed const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::MontageFramed * >(argp1);
  {
    try {
      result = ((Magick::MontageFramed const *)arg1)->matteColor();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Color(result)), SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_MontageFramed__wrap_MontageFramed_matteColor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_MontageFramed_matteColor__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_MontageFramed_matteColor__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function matteColor.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_MontageFramed_updateMontageInfo(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::MontageFramed *arg1 = (Magick::MontageFramed *) 0 ;
  MagickCore::MontageInfo *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_MontageFramed_updateMontageInfo.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__MontageFramed, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MontageFramed_updateMontageInfo" "', argument " "1"" of type '" "Magick::MontageFramed const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::MontageFramed * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_MagickCore___MontageInfo,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MontageFramed_updateMontageInfo" "', argument " "2"" of type '" "MagickCore::MontageInfo &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MontageFramed_updateMontageInfo" "', argument " "2"" of type '" "MagickCore::MontageInfo &""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::MontageInfo * >(argp2);
  {
    try {
      ((Magick::MontageFramed const *)arg1)->updateMontageInfo(*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_borderGeometryDefault_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
  SWIGV8_HANDLESCOPE();
  
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  res1 = SWIG_AsCharPtrAndSize(value, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "borderGeometryDefault_set" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  if (arg1) {
    size_t size = strlen(arg1) + 1;
    Magick::borderGeometryDefault = (char const *)reinterpret_cast< char* >(memcpy(new char[size], arg1, sizeof(char)*(size)));
  } else {
    Magick::borderGeometryDefault = 0;
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  
  goto fail;
fail:
  return;
}


static SwigV8ReturnValue _wrap_borderGeometryDefault_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  char *result = 0 ;
  
  result = (char *)Magick::borderGeometryDefault;
  jsresult = SWIG_FromCharPtr((const char *)result);
  
  SWIGV8_RETURN_INFO(jsresult, info);
  
  goto fail;
fail:
  SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
}


static void _wrap_frameGeometryDefault_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
  SWIGV8_HANDLESCOPE();
  
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  res1 = SWIG_AsCharPtrAndSize(value, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "frameGeometryDefault_set" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  if (arg1) {
    size_t size = strlen(arg1) + 1;
    Magick::frameGeometryDefault = (char const *)reinterpret_cast< char* >(memcpy(new char[size], arg1, sizeof(char)*(size)));
  } else {
    Magick::frameGeometryDefault = 0;
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  
  goto fail;
fail:
  return;
}


static SwigV8ReturnValue _wrap_frameGeometryDefault_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  char *result = 0 ;
  
  result = (char *)Magick::frameGeometryDefault;
  jsresult = SWIG_FromCharPtr((const char *)result);
  
  SWIGV8_RETURN_INFO(jsresult, info);
  
  goto fail;
fail:
  SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
}


static void _wrap_raiseGeometryDefault_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
  SWIGV8_HANDLESCOPE();
  
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  res1 = SWIG_AsCharPtrAndSize(value, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "raiseGeometryDefault_set" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  if (arg1) {
    size_t size = strlen(arg1) + 1;
    Magick::raiseGeometryDefault = (char const *)reinterpret_cast< char* >(memcpy(new char[size], arg1, sizeof(char)*(size)));
  } else {
    Magick::raiseGeometryDefault = 0;
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  
  goto fail;
fail:
  return;
}


static SwigV8ReturnValue _wrap_raiseGeometryDefault_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  char *result = 0 ;
  
  result = (char *)Magick::raiseGeometryDefault;
  jsresult = SWIG_FromCharPtr((const char *)result);
  
  SWIGV8_RETURN_INFO(jsresult, info);
  
  goto fail;
fail:
  SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
}


static SwigV8ReturnValue _wrap_equal__SWIG_9(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equal" "', argument " "1"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "1"" of type '" "Magick::Image const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equal" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  {
    try {
      result = (int)Magick::operator ==((Magick::Image const &)*arg1,(Magick::Image const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Magick__wrap_equal(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_equal__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_equal__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_equal__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_equal__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_equal__SWIG_4(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_equal__SWIG_5(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_equal__SWIG_6(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_equal__SWIG_7(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_equal__SWIG_8(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_equal__SWIG_9(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function equal.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_notEqual__SWIG_9(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Image const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  {
    try {
      result = (int)Magick::operator !=((Magick::Image const &)*arg1,(Magick::Image const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Magick__wrap_notEqual(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_notEqual__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_notEqual__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_notEqual__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_notEqual__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_notEqual__SWIG_4(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_notEqual__SWIG_5(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_notEqual__SWIG_6(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_notEqual__SWIG_7(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_notEqual__SWIG_8(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_notEqual__SWIG_9(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function notEqual.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_gt__SWIG_8(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gt" "', argument " "1"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "1"" of type '" "Magick::Image const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gt" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  {
    try {
      result = (int)Magick::operator >((Magick::Image const &)*arg1,(Magick::Image const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Magick__wrap_gt(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_gt__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_gt__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_gt__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_gt__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_gt__SWIG_4(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_gt__SWIG_5(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_gt__SWIG_6(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_gt__SWIG_7(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_gt__SWIG_8(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function gt.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_lt__SWIG_8(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lt" "', argument " "1"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "1"" of type '" "Magick::Image const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lt" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  {
    try {
      result = (int)Magick::operator <((Magick::Image const &)*arg1,(Magick::Image const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Magick__wrap_lt(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_lt__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_lt__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_lt__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_lt__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_lt__SWIG_4(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_lt__SWIG_5(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_lt__SWIG_6(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_lt__SWIG_7(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_lt__SWIG_8(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function lt.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_gte__SWIG_8(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gte" "', argument " "1"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "1"" of type '" "Magick::Image const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gte" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  {
    try {
      result = (int)Magick::operator >=((Magick::Image const &)*arg1,(Magick::Image const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Magick__wrap_gte(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_gte__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_gte__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_gte__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_gte__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_gte__SWIG_4(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_gte__SWIG_5(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_gte__SWIG_6(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_gte__SWIG_7(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_gte__SWIG_8(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function gte.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_lte__SWIG_8(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lte" "', argument " "1"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "1"" of type '" "Magick::Image const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lte" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  {
    try {
      result = (int)Magick::operator <=((Magick::Image const &)*arg1,(Magick::Image const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Magick__wrap_lte(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_lte__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_lte__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_lte__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_lte__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_lte__SWIG_4(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_lte__SWIG_5(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_lte__SWIG_6(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_lte__SWIG_7(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_lte__SWIG_8(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function lte.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Image__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Image *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Image__SWIG_0.");
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Image__SWIG_0.");
  {
    try {
      result = (Magick::Image *)new Magick::Image();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Image__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Blob *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Image *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Image__SWIG_1.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Image__SWIG_1.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Blob,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Image" "', argument " "1"" of type '" "Magick::Blob const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Image" "', argument " "1"" of type '" "Magick::Blob const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Blob * >(argp1);
  {
    try {
      result = (Magick::Image *)new Magick::Image((Magick::Blob const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Image__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Blob *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::Image *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Image__SWIG_2.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Image__SWIG_2.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Blob,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Image" "', argument " "1"" of type '" "Magick::Blob const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Image" "', argument " "1"" of type '" "Magick::Blob const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Blob * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_Image" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Image" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      result = (Magick::Image *)new Magick::Image((Magick::Blob const &)*arg1,(Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Image__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Blob *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  Magick::Image *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Image__SWIG_3.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Image__SWIG_3.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Blob,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Image" "', argument " "1"" of type '" "Magick::Blob const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Image" "', argument " "1"" of type '" "Magick::Blob const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Blob * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_Image" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Image" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  ecode3 = SWIG_AsVal_size_t(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Image" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  {
    try {
      result = (Magick::Image *)new Magick::Image((Magick::Blob const &)*arg1,(Magick::Geometry const &)*arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Image__SWIG_4(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Blob *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  size_t arg3 ;
  std::string *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  Magick::Image *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Image__SWIG_4.");
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Image__SWIG_4.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Blob,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Image" "', argument " "1"" of type '" "Magick::Blob const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Image" "', argument " "1"" of type '" "Magick::Blob const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Blob * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_Image" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Image" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  ecode3 = SWIG_AsVal_size_t(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Image" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(args[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_Image" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Image" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  {
    try {
      result = (Magick::Image *)new Magick::Image((Magick::Blob const &)*arg1,(Magick::Geometry const &)*arg2,arg3,(std::string const &)*arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  if (SWIG_IsNewObj(res4)) delete arg4;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Image__SWIG_5(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Blob *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  Magick::Image *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Image__SWIG_5.");
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Image__SWIG_5.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Blob,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Image" "', argument " "1"" of type '" "Magick::Blob const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Image" "', argument " "1"" of type '" "Magick::Blob const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Blob * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_Image" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Image" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(args[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_Image" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Image" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    try {
      result = (Magick::Image *)new Magick::Image((Magick::Blob const &)*arg1,(Magick::Geometry const &)*arg2,(std::string const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  if (SWIG_IsNewObj(res3)) delete arg3;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Image__SWIG_6(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Geometry *arg1 = 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::Image *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Image__SWIG_6.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Image__SWIG_6.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Image" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Image" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Geometry * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_Image" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Image" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      result = (Magick::Image *)new Magick::Image((Magick::Geometry const &)*arg1,(Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Image__SWIG_7(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Image *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Image *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Image__SWIG_7.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Image__SWIG_7.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Image" "', argument " "1"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Image" "', argument " "1"" of type '" "Magick::Image const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::Image *)new Magick::Image((Magick::Image const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Image__SWIG_8(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  Magick::Image *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::Image *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Image__SWIG_8.");
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Image__SWIG_8.");
  res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Image" "', argument " "1"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Image" "', argument " "1"" of type '" "Magick::Image const &""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_Image" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Image" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      result = (Magick::Image *)new Magick::Image((Magick::Image const &)*arg1,(Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Image__SWIG_9(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  size_t arg1 ;
  size_t arg2 ;
  std::string *arg3 = 0 ;
  Magick::StorageType arg4 ;
  void *arg5 = (void *) 0 ;
  size_t val1 ;
  int ecode1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  Magick::Image *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Image__SWIG_9.");
  if(args.Length() != 5) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Image__SWIG_9.");
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Image" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  ecode2 = SWIG_AsVal_size_t(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Image" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(args[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_Image" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Image" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  ecode4 = SWIG_AsVal_int(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_Image" "', argument " "4"" of type '" "Magick::StorageType""'");
  } 
  arg4 = static_cast< Magick::StorageType >(val4);
  res5 = SWIG_ConvertPtr(args[4],SWIG_as_voidptrptr(&arg5), 0, 0);
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_Image" "', argument " "5"" of type '" "void const *""'"); 
  }
  {
    try {
      result = (Magick::Image *)new Magick::Image(arg1,arg2,(std::string const &)*arg3,arg4,(void const *)arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  if (SWIG_IsNewObj(res3)) delete arg3;
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Image__SWIG_10(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Magick::Image *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Image__SWIG_10.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Image__SWIG_10.");
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Image" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Image" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (Magick::Image *)new Magick::Image((std::string const &)*arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static void _wrap_delete_Image(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
  
  if(proxy->swigCMemOwn && proxy->swigCObject) {
    Magick::Image * arg1 = (Magick::Image *)proxy->swigCObject;
    delete arg1;
  }
  delete proxy;
}


static SwigV8ReturnValue _wrap_Image_clone(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Magick::Image *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_clone.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_clone" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_clone" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_clone" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  {
    try {
      result = (Magick::Image *) &(arg1)->operator =((Magick::Image const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__Image, 0 |  0 );
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_adjoin__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_adjoin" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_adjoin" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->adjoin(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_adjoin__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_adjoin" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (bool)((Magick::Image const *)arg1)->adjoin();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_adjoin(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_adjoin__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_adjoin__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function adjoin.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_antiAlias__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_antiAlias" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_antiAlias" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->antiAlias(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_antiAlias__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_antiAlias" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (bool)((Magick::Image const *)arg1)->antiAlias();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_antiAlias(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_antiAlias__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_antiAlias__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function antiAlias.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_animationDelay__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_animationDelay" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_animationDelay" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      (arg1)->animationDelay(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_animationDelay__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_animationDelay" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->animationDelay();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_animationDelay(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_animationDelay__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_animationDelay__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function animationDelay.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_animationIterations__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_animationIterations" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_animationIterations" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      (arg1)->animationIterations(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_animationIterations__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_animationIterations" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->animationIterations();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_animationIterations(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_animationIterations__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_animationIterations__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function animationIterations.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_attenuate(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_attenuate.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_attenuate" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_attenuate" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->attenuate(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_backgroundColor__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_backgroundColor" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_backgroundColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_backgroundColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      (arg1)->backgroundColor((Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_backgroundColor__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Color result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_backgroundColor" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->backgroundColor();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Color(result)), SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_backgroundColor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_backgroundColor__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_backgroundColor__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function backgroundColor.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_backgroundTexture__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_backgroundTexture" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_backgroundTexture" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_backgroundTexture" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->backgroundTexture((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_backgroundTexture__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_backgroundTexture" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->backgroundTexture();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_backgroundTexture(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_backgroundTexture__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_backgroundTexture__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function backgroundTexture.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_baseColumns(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_baseColumns.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_baseColumns" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->baseColumns();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_baseFilename(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_baseFilename.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_baseFilename" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->baseFilename();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_baseRows(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_baseRows.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_baseRows" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->baseRows();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_blackPointCompensation__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_blackPointCompensation" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_blackPointCompensation" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->blackPointCompensation(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_blackPointCompensation__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_blackPointCompensation" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (bool)((Magick::Image const *)arg1)->blackPointCompensation();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_blackPointCompensation(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_blackPointCompensation__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_blackPointCompensation__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function blackPointCompensation.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_borderColor__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_borderColor" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_borderColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_borderColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      (arg1)->borderColor((Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_borderColor__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Color result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_borderColor" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->borderColor();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Color(result)), SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_borderColor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_borderColor__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_borderColor__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function borderColor.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_boundingBox(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Geometry result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_boundingBox.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_boundingBox" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->boundingBox();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Geometry(result)), SWIGTYPE_p_Magick__Geometry, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_boxColor__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_boxColor" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_boxColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_boxColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      (arg1)->boxColor((Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_boxColor__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Color result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_boxColor" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->boxColor();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Color(result)), SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_boxColor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_boxColor__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_boxColor__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function boxColor.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_cacheThreshold(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_cacheThreshold.");
  
  ecode1 = SWIG_AsVal_size_t(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "Image_cacheThreshold" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  {
    try {
      Magick::Image::cacheThreshold(SWIG_STD_MOVE(arg1));
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_classType__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ClassType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_classType" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_classType" "', argument " "2"" of type '" "Magick::ClassType""'");
  } 
  arg2 = static_cast< Magick::ClassType >(val2);
  {
    try {
      (arg1)->classType(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_classType__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::ClassType result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_classType" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::ClassType)((Magick::Image const *)arg1)->classType();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_classType(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_classType__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_classType__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function classType.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_clipMask__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_clipMask" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_clipMask" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_clipMask" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  {
    try {
      (arg1)->clipMask((Magick::Image const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_clipMask__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Image result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_clipMask" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->clipMask();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Image(result)), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_clipMask(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_clipMask__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_clipMask__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function clipMask.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_colorFuzz__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_colorFuzz" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_colorFuzz" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->colorFuzz(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_colorFuzz__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_colorFuzz" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (double)((Magick::Image const *)arg1)->colorFuzz();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_colorFuzz(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_colorFuzz__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_colorFuzz__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function colorFuzz.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_colorMapSize__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_colorMapSize" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_colorMapSize" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      (arg1)->colorMapSize(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_colorMapSize__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_colorMapSize" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->colorMapSize();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_colorMapSize(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_colorMapSize__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_colorMapSize__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function colorMapSize.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_colorSpace__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ColorspaceType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_colorSpace" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_colorSpace" "', argument " "2"" of type '" "Magick::ColorspaceType""'");
  } 
  arg2 = static_cast< Magick::ColorspaceType >(val2);
  {
    try {
      (arg1)->colorSpace(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_colorSpace__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::ColorspaceType result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_colorSpace" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::ColorspaceType)((Magick::Image const *)arg1)->colorSpace();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_colorSpace(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_colorSpace__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_colorSpace__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function colorSpace.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_colorspaceType__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ColorspaceType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_colorspaceType" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_colorspaceType" "', argument " "2"" of type '" "Magick::ColorspaceType""'");
  } 
  arg2 = static_cast< Magick::ColorspaceType >(val2);
  {
    try {
      (arg1)->colorspaceType(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_colorspaceType__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::ColorspaceType result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_colorspaceType" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::ColorspaceType)((Magick::Image const *)arg1)->colorspaceType();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_colorspaceType(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_colorspaceType__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_colorspaceType__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function colorspaceType.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_columns(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_columns.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_columns" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->columns();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_comment__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_comment" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_comment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_comment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->comment((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_comment__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_comment" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->comment();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_comment(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_comment__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_comment__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function comment.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_compose__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::CompositeOperator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_compose" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_compose" "', argument " "2"" of type '" "Magick::CompositeOperator""'");
  } 
  arg2 = static_cast< Magick::CompositeOperator >(val2);
  {
    try {
      (arg1)->compose(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_compose__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::CompositeOperator result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_compose" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::CompositeOperator)((Magick::Image const *)arg1)->compose();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_compose(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_compose__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_compose__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function compose.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_compressType__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::CompressionType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_compressType" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_compressType" "', argument " "2"" of type '" "Magick::CompressionType""'");
  } 
  arg2 = static_cast< Magick::CompressionType >(val2);
  {
    try {
      (arg1)->compressType(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_compressType__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::CompressionType result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_compressType" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::CompressionType)((Magick::Image const *)arg1)->compressType();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_compressType(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_compressType__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_compressType__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function compressType.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_debug__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_debug" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_debug" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->debug(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_debug__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_debug" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (bool)((Magick::Image const *)arg1)->debug();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_debug(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_debug__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_debug__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function debug.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_density__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_density" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_density" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_density" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->density((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_density__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Geometry result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_density" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->density();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Geometry(result)), SWIGTYPE_p_Magick__Geometry, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_density(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_density__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_density__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function density.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_depth__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_depth" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_depth" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      (arg1)->depth(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_depth__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_depth" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->depth();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_depth(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_depth__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_depth__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function depth.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_directory(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_directory.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_directory" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->directory();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_endian__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::EndianType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_endian" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_endian" "', argument " "2"" of type '" "Magick::EndianType""'");
  } 
  arg2 = static_cast< Magick::EndianType >(val2);
  {
    try {
      (arg1)->endian(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_endian__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::EndianType result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_endian" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::EndianType)((Magick::Image const *)arg1)->endian();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_endian(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_endian__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_endian__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function endian.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_exifProfile__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Blob *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_exifProfile" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Blob,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_exifProfile" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_exifProfile" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Blob * >(argp2);
  {
    try {
      (arg1)->exifProfile((Magick::Blob const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_exifProfile__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Blob result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_exifProfile" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->exifProfile();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Blob(result)), SWIGTYPE_p_Magick__Blob, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_exifProfile(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_exifProfile__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_exifProfile__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function exifProfile.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_fileName__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_fileName" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_fileName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_fileName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->fileName((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_fileName__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_fileName" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->fileName();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_fileName(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_fileName__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_fileName__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function fileName.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_fileSize(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  off_t result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_fileSize.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_fileSize" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->fileSize();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new off_t(result)), SWIGTYPE_p_off_t, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_fillColor__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_fillColor" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_fillColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_fillColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      (arg1)->fillColor((Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_fillColor__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Color result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_fillColor" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->fillColor();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Color(result)), SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_fillColor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_fillColor__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_fillColor__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function fillColor.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_fillRule__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::FillRule *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 ;
  Magick::FillRule temp2 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_fillRule" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int (args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_fillRule" "', argument " "2"" of type '" "Magick::FillRule const &""'");
  } else {
    temp2 = static_cast< Magick::FillRule >(val2);
    arg2 = &temp2;
  }
  {
    try {
      (arg1)->fillRule((Magick::FillRule const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_fillRule__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::FillRule result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_fillRule" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::FillRule)((Magick::Image const *)arg1)->fillRule();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_fillRule(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_fillRule__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_fillRule__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function fillRule.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_fillPattern__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_fillPattern" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_fillPattern" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_fillPattern" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  {
    try {
      (arg1)->fillPattern((Magick::Image const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_fillPattern__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Image result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_fillPattern" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->fillPattern();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Image(result)), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_fillPattern(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_fillPattern__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_fillPattern__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function fillPattern.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_filterType__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::FilterTypes arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_filterType" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_filterType" "', argument " "2"" of type '" "Magick::FilterTypes""'");
  } 
  arg2 = static_cast< Magick::FilterTypes >(val2);
  {
    try {
      (arg1)->filterType(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_filterType__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::FilterTypes result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_filterType" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::FilterTypes)((Magick::Image const *)arg1)->filterType();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_filterType(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_filterType__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_filterType__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function filterType.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_font__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_font" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_font" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_font" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->font((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_font__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_font" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->font();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_font(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_font__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_font__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function font.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_fontFamily__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_fontFamily" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_fontFamily" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_fontFamily" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->fontFamily((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_fontFamily__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_fontFamily" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->fontFamily();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_fontFamily(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_fontFamily__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_fontFamily__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function fontFamily.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_fontPointsize__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_fontPointsize" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_fontPointsize" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->fontPointsize(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_fontPointsize__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_fontPointsize" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (double)((Magick::Image const *)arg1)->fontPointsize();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_fontPointsize(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_fontPointsize__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_fontPointsize__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function fontPointsize.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_fontStyle__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::StyleType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_fontStyle" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_fontStyle" "', argument " "2"" of type '" "Magick::StyleType""'");
  } 
  arg2 = static_cast< Magick::StyleType >(val2);
  {
    try {
      (arg1)->fontStyle(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_fontStyle__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::StyleType result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_fontStyle" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::StyleType)((Magick::Image const *)arg1)->fontStyle();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_fontStyle(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_fontStyle__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_fontStyle__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function fontStyle.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_fontWeight__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_fontWeight" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_fontWeight" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      (arg1)->fontWeight(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_fontWeight__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_fontWeight" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->fontWeight();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_fontWeight(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_fontWeight__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_fontWeight__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function fontWeight.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_format(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_format.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_format" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->format();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_formatExpression(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_formatExpression.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_formatExpression" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Image_formatExpression" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      result = (arg1)->formatExpression(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_gamma__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_gamma" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (double)((Magick::Image const *)arg1)->gamma();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_geometry(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Geometry result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_geometry.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_geometry" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->geometry();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Geometry(result)), SWIGTYPE_p_Magick__Geometry, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_gifDisposeMethod__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_gifDisposeMethod" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_gifDisposeMethod" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      (arg1)->gifDisposeMethod(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_gifDisposeMethod__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_gifDisposeMethod" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->gifDisposeMethod();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_gifDisposeMethod(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_gifDisposeMethod__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_gifDisposeMethod__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function gifDisposeMethod.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_highlightColor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Color arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_highlightColor.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_highlightColor" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_highlightColor" "', argument " "2"" of type '" "Magick::Color const""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_highlightColor" "', argument " "2"" of type '" "Magick::Color const""'");
    } else {
      arg2 = *(reinterpret_cast< Magick::Color * >(argp2));
    }
  }
  {
    try {
      (arg1)->highlightColor(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_iccColorProfile__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Blob *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_iccColorProfile" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Blob,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_iccColorProfile" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_iccColorProfile" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Blob * >(argp2);
  {
    try {
      (arg1)->iccColorProfile((Magick::Blob const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_iccColorProfile__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Blob result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_iccColorProfile" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->iccColorProfile();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Blob(result)), SWIGTYPE_p_Magick__Blob, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_iccColorProfile(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_iccColorProfile__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_iccColorProfile__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function iccColorProfile.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_interlaceType__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::InterlaceType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_interlaceType" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_interlaceType" "', argument " "2"" of type '" "Magick::InterlaceType""'");
  } 
  arg2 = static_cast< Magick::InterlaceType >(val2);
  {
    try {
      (arg1)->interlaceType(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_interlaceType__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::InterlaceType result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_interlaceType" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::InterlaceType)((Magick::Image const *)arg1)->interlaceType();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_interlaceType(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_interlaceType__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_interlaceType__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function interlaceType.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_interpolate__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::InterpolatePixelMethod arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_interpolate" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_interpolate" "', argument " "2"" of type '" "Magick::InterpolatePixelMethod""'");
  } 
  arg2 = static_cast< Magick::InterpolatePixelMethod >(val2);
  {
    try {
      (arg1)->interpolate(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_interpolate__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::InterpolatePixelMethod result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_interpolate" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::InterpolatePixelMethod)((Magick::Image const *)arg1)->interpolate();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_interpolate(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_interpolate__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_interpolate__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function interpolate.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_iptcProfile__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Blob *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_iptcProfile" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Blob,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_iptcProfile" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_iptcProfile" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Blob * >(argp2);
  {
    try {
      (arg1)->iptcProfile((Magick::Blob const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_iptcProfile__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Blob result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_iptcProfile" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->iptcProfile();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Blob(result)), SWIGTYPE_p_Magick__Blob, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_iptcProfile(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_iptcProfile__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_iptcProfile__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function iptcProfile.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_isOpaque(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_isOpaque.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_isOpaque" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (bool)((Magick::Image const *)arg1)->isOpaque();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_isValid__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_isValid" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_isValid" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->isValid(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_isValid__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_isValid" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (bool)((Magick::Image const *)arg1)->isValid();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_isValid(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_isValid__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_isValid__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function isValid.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_label__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_label" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_label" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_label" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->label((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_label__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_label" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->label();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_label(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_label__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_label__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function label.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_lineWidth__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_lineWidth" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_lineWidth" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->lineWidth(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_lineWidth__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_lineWidth" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (double)((Magick::Image const *)arg1)->lineWidth();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_lineWidth(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_lineWidth__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_lineWidth__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function lineWidth.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_lowlightColor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Color arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_lowlightColor.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_lowlightColor" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_lowlightColor" "', argument " "2"" of type '" "Magick::Color const""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_lowlightColor" "', argument " "2"" of type '" "Magick::Color const""'");
    } else {
      arg2 = *(reinterpret_cast< Magick::Color * >(argp2));
    }
  }
  {
    try {
      (arg1)->lowlightColor(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_magick__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_magick" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_magick" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_magick" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->magick((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_magick__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_magick" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->magick();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_magick(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_magick__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_magick__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function magick.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_mask__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_mask" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_mask" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_mask" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  {
    try {
      (arg1)->mask((Magick::Image const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_mask__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Image result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_mask" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->mask();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Image(result)), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_mask(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_mask__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_mask__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function mask.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_matte__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_matte" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_matte" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->matte(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_matte__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_matte" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (bool)((Magick::Image const *)arg1)->matte();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_matte(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_matte__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_matte__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function matte.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_matteColor__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_matteColor" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_matteColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_matteColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      (arg1)->matteColor((Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_matteColor__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Color result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_matteColor" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->matteColor();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Color(result)), SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_matteColor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_matteColor__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_matteColor__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function matteColor.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_meanErrorPerPixel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_meanErrorPerPixel.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_meanErrorPerPixel" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (double)((Magick::Image const *)arg1)->meanErrorPerPixel();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_modulusDepth__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_modulusDepth" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_modulusDepth" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      (arg1)->modulusDepth(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_modulusDepth__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_modulusDepth" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->modulusDepth();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_modulusDepth(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_modulusDepth__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_modulusDepth__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function modulusDepth.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_monochrome__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_monochrome" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_monochrome" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->monochrome(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_monochrome__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_monochrome" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (bool)((Magick::Image const *)arg1)->monochrome();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_monochrome(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_monochrome__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_monochrome__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function monochrome.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_montageGeometry(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Geometry result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_montageGeometry.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_montageGeometry" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->montageGeometry();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Geometry(result)), SWIGTYPE_p_Magick__Geometry, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_normalizedMaxError(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_normalizedMaxError.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_normalizedMaxError" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (double)((Magick::Image const *)arg1)->normalizedMaxError();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_normalizedMeanError(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_normalizedMeanError.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_normalizedMeanError" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (double)((Magick::Image const *)arg1)->normalizedMeanError();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_orientation__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::OrientationType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_orientation" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_orientation" "', argument " "2"" of type '" "Magick::OrientationType""'");
  } 
  arg2 = static_cast< Magick::OrientationType >(val2);
  {
    try {
      (arg1)->orientation(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_orientation__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::OrientationType result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_orientation" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::OrientationType)((Magick::Image const *)arg1)->orientation();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_orientation(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_orientation__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_orientation__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function orientation.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_page__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_page" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_page" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_page" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->page((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_page__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Geometry result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_page" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->page();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Geometry(result)), SWIGTYPE_p_Magick__Geometry, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_page(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_page__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_page__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function page.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_penColor__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_penColor" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_penColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_penColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      (arg1)->penColor((Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_penColor__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Color result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_penColor" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->penColor();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Color(result)), SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_penColor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_penColor__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_penColor__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function penColor.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_penTexture__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_penTexture" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_penTexture" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_penTexture" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  {
    try {
      (arg1)->penTexture((Magick::Image const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_penTexture__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Image result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_penTexture" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->penTexture();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Image(result)), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_penTexture(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_penTexture__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_penTexture__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function penTexture.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_quality__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_quality" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_quality" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      (arg1)->quality(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_quality__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_quality" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->quality();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_quality(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_quality__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_quality__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function quality.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_quantizeColors__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_quantizeColors" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_quantizeColors" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      (arg1)->quantizeColors(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_quantizeColors__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_quantizeColors" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->quantizeColors();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_quantizeColors(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_quantizeColors__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_quantizeColors__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function quantizeColors.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_quantizeColorSpace__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ColorspaceType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_quantizeColorSpace" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_quantizeColorSpace" "', argument " "2"" of type '" "Magick::ColorspaceType""'");
  } 
  arg2 = static_cast< Magick::ColorspaceType >(val2);
  {
    try {
      (arg1)->quantizeColorSpace(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_quantizeColorSpace__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::ColorspaceType result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_quantizeColorSpace" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::ColorspaceType)((Magick::Image const *)arg1)->quantizeColorSpace();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_quantizeColorSpace(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_quantizeColorSpace__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_quantizeColorSpace__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function quantizeColorSpace.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_quantizeDither__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_quantizeDither" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_quantizeDither" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->quantizeDither(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_quantizeDither__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_quantizeDither" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (bool)((Magick::Image const *)arg1)->quantizeDither();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_quantizeDither(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_quantizeDither__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_quantizeDither__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function quantizeDither.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_quantizeDitherMethod__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::DitherMethod arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_quantizeDitherMethod" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_quantizeDitherMethod" "', argument " "2"" of type '" "Magick::DitherMethod""'");
  } 
  arg2 = static_cast< Magick::DitherMethod >(val2);
  {
    try {
      (arg1)->quantizeDitherMethod(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_quantizeDitherMethod__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DitherMethod result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_quantizeDitherMethod" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::DitherMethod)((Magick::Image const *)arg1)->quantizeDitherMethod();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_quantizeDitherMethod(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_quantizeDitherMethod__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_quantizeDitherMethod__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function quantizeDitherMethod.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_quantizeTreeDepth__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_quantizeTreeDepth" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_quantizeTreeDepth" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      (arg1)->quantizeTreeDepth(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_quantizeTreeDepth__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_quantizeTreeDepth" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->quantizeTreeDepth();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_quantizeTreeDepth(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_quantizeTreeDepth__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_quantizeTreeDepth__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function quantizeTreeDepth.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_quiet__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_quiet" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_quiet" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->quiet(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_quiet__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_quiet" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (bool)((Magick::Image const *)arg1)->quiet();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_quiet(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_quiet__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_quiet__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function quiet.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_renderingIntent__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::RenderingIntent arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_renderingIntent" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_renderingIntent" "', argument " "2"" of type '" "Magick::RenderingIntent""'");
  } 
  arg2 = static_cast< Magick::RenderingIntent >(val2);
  {
    try {
      (arg1)->renderingIntent(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_renderingIntent__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::RenderingIntent result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_renderingIntent" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::RenderingIntent)((Magick::Image const *)arg1)->renderingIntent();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_renderingIntent(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_renderingIntent__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_renderingIntent__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function renderingIntent.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_resolutionUnits__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ResolutionType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_resolutionUnits" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_resolutionUnits" "', argument " "2"" of type '" "Magick::ResolutionType""'");
  } 
  arg2 = static_cast< Magick::ResolutionType >(val2);
  {
    try {
      (arg1)->resolutionUnits(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_resolutionUnits__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::ResolutionType result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_resolutionUnits" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::ResolutionType)((Magick::Image const *)arg1)->resolutionUnits();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_resolutionUnits(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_resolutionUnits__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_resolutionUnits__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function resolutionUnits.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_rows(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_rows.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_rows" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->rows();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_scene__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_scene" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_scene" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      (arg1)->scene(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_scene__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_scene" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->scene();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_scene(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_scene__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_scene__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function scene.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_size__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_size" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_size" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_size" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->size((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_size__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Geometry result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_size" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->size();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Geometry(result)), SWIGTYPE_p_Magick__Geometry, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_size(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_size__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_size__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function size.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_strokeAntiAlias__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_strokeAntiAlias" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_strokeAntiAlias" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->strokeAntiAlias(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_strokeAntiAlias__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_strokeAntiAlias" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (bool)((Magick::Image const *)arg1)->strokeAntiAlias();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_strokeAntiAlias(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_strokeAntiAlias__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_strokeAntiAlias__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function strokeAntiAlias.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_strokeColor__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_strokeColor" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_strokeColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_strokeColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      (arg1)->strokeColor((Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_strokeColor__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Color result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_strokeColor" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->strokeColor();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Color(result)), SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_strokeColor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_strokeColor__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_strokeColor__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function strokeColor.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_strokeDashArray__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_strokeDashArray" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_strokeDashArray" "', argument " "2"" of type '" "double const *""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  {
    try {
      (arg1)->strokeDashArray((double const *)arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_strokeDashArray__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double *result = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_strokeDashArray" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (double *)((Magick::Image const *)arg1)->strokeDashArray();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_strokeDashArray(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_strokeDashArray__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_strokeDashArray__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function strokeDashArray.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_strokeDashOffset__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_strokeDashOffset" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_strokeDashOffset" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->strokeDashOffset(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_strokeDashOffset__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_strokeDashOffset" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (double)((Magick::Image const *)arg1)->strokeDashOffset();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_strokeDashOffset(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_strokeDashOffset__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_strokeDashOffset__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function strokeDashOffset.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_strokeLineCap__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::LineCap arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_strokeLineCap" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_strokeLineCap" "', argument " "2"" of type '" "Magick::LineCap""'");
  } 
  arg2 = static_cast< Magick::LineCap >(val2);
  {
    try {
      (arg1)->strokeLineCap(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_strokeLineCap__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::LineCap result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_strokeLineCap" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::LineCap)((Magick::Image const *)arg1)->strokeLineCap();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_strokeLineCap(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_strokeLineCap__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_strokeLineCap__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function strokeLineCap.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_strokeLineJoin__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::LineJoin arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_strokeLineJoin" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_strokeLineJoin" "', argument " "2"" of type '" "Magick::LineJoin""'");
  } 
  arg2 = static_cast< Magick::LineJoin >(val2);
  {
    try {
      (arg1)->strokeLineJoin(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_strokeLineJoin__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::LineJoin result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_strokeLineJoin" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::LineJoin)((Magick::Image const *)arg1)->strokeLineJoin();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_strokeLineJoin(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_strokeLineJoin__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_strokeLineJoin__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function strokeLineJoin.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_strokeMiterLimit__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_strokeMiterLimit" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_strokeMiterLimit" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      (arg1)->strokeMiterLimit(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_strokeMiterLimit__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_strokeMiterLimit" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->strokeMiterLimit();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_strokeMiterLimit(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_strokeMiterLimit__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_strokeMiterLimit__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function strokeMiterLimit.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_strokePattern__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_strokePattern" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_strokePattern" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_strokePattern" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  {
    try {
      (arg1)->strokePattern((Magick::Image const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_strokePattern__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Image result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_strokePattern" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->strokePattern();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Image(result)), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_strokePattern(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_strokePattern__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_strokePattern__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function strokePattern.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_strokeWidth__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_strokeWidth" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_strokeWidth" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->strokeWidth(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_strokeWidth__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_strokeWidth" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (double)((Magick::Image const *)arg1)->strokeWidth();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_strokeWidth(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_strokeWidth__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_strokeWidth__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function strokeWidth.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_subImage__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_subImage" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_subImage" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      (arg1)->subImage(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_subImage__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_subImage" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->subImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_subImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_subImage__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_subImage__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function subImage.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_subRange__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_subRange" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_subRange" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      (arg1)->subRange(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_subRange__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_subRange" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->subRange();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_subRange(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_subRange__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_subRange__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function subRange.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_textDirection__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::DirectionType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_textDirection" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_textDirection" "', argument " "2"" of type '" "Magick::DirectionType""'");
  } 
  arg2 = static_cast< Magick::DirectionType >(val2);
  {
    try {
      (arg1)->textDirection(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_textDirection__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::DirectionType result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_textDirection" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::DirectionType)((Magick::Image const *)arg1)->textDirection();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_textDirection(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_textDirection__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_textDirection__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function textDirection.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_textEncoding__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_textEncoding" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_textEncoding" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_textEncoding" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->textEncoding((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_textEncoding__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_textEncoding" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->textEncoding();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_textEncoding(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_textEncoding__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_textEncoding__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function textEncoding.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_textGravity__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::GravityType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_textGravity" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_textGravity" "', argument " "2"" of type '" "Magick::GravityType""'");
  } 
  arg2 = static_cast< Magick::GravityType >(val2);
  {
    try {
      (arg1)->textGravity(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_textGravity__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::GravityType result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_textGravity" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::GravityType)((Magick::Image const *)arg1)->textGravity();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_textGravity(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_textGravity__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_textGravity__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function textGravity.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_textInterlineSpacing__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_textInterlineSpacing" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_textInterlineSpacing" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->textInterlineSpacing(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_textInterlineSpacing__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_textInterlineSpacing" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (double)((Magick::Image const *)arg1)->textInterlineSpacing();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_textInterlineSpacing(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_textInterlineSpacing__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_textInterlineSpacing__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function textInterlineSpacing.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_textInterwordSpacing__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_textInterwordSpacing" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_textInterwordSpacing" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->textInterwordSpacing(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_textInterwordSpacing__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_textInterwordSpacing" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (double)((Magick::Image const *)arg1)->textInterwordSpacing();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_textInterwordSpacing(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_textInterwordSpacing__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_textInterwordSpacing__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function textInterwordSpacing.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_textKerning__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_textKerning" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_textKerning" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->textKerning(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_textKerning__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_textKerning" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (double)((Magick::Image const *)arg1)->textKerning();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_textKerning(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_textKerning__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_textKerning__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function textKerning.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_textUnderColor__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_textUnderColor" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_textUnderColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_textUnderColor" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      (arg1)->textUnderColor((Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_textUnderColor__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Color result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_textUnderColor" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->textUnderColor();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Color(result)), SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_textUnderColor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_textUnderColor__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_textUnderColor__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function textUnderColor.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_tileName__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_tileName" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_tileName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_tileName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->tileName((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_tileName__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_tileName" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->tileName();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_tileName(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_tileName__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_tileName__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function tileName.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_totalColors(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_totalColors.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_totalColors" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->totalColors();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_transformRotation(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_transformRotation.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_transformRotation" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_transformRotation" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->transformRotation(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_transformSkewX(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_transformSkewX.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_transformSkewX" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_transformSkewX" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->transformSkewX(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_transformSkewY(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_transformSkewY.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_transformSkewY" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_transformSkewY" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->transformSkewY(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_type__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ImageType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_type" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_type" "', argument " "2"" of type '" "Magick::ImageType""'");
  } 
  arg2 = static_cast< Magick::ImageType >(val2);
  {
    try {
      (arg1)->type(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_type__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::ImageType result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_type" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::ImageType)((Magick::Image const *)arg1)->type();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_type(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_type__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_type__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function type.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_verbose__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_verbose" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_verbose" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->verbose(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_verbose__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_verbose" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (bool)((Magick::Image const *)arg1)->verbose();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_verbose(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_verbose__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_verbose__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function verbose.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_view__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_view" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_view" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_view" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->view((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_view__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_view" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->view();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_view(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_view__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_view__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function view.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_virtualPixelMethod__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::VirtualPixelMethod arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_virtualPixelMethod" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_virtualPixelMethod" "', argument " "2"" of type '" "Magick::VirtualPixelMethod""'");
  } 
  arg2 = static_cast< Magick::VirtualPixelMethod >(val2);
  {
    try {
      (arg1)->virtualPixelMethod(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_virtualPixelMethod__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::VirtualPixelMethod result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_virtualPixelMethod" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::VirtualPixelMethod)((Magick::Image const *)arg1)->virtualPixelMethod();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_virtualPixelMethod(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_virtualPixelMethod__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_virtualPixelMethod__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function virtualPixelMethod.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_x11Display__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_x11Display" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_x11Display" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_x11Display" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->x11Display((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_x11Display__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_x11Display" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->x11Display();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_x11Display(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_x11Display__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_x11Display__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function x11Display.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_xResolution(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_xResolution.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_xResolution" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (double)((Magick::Image const *)arg1)->xResolution();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_yResolution(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_yResolution.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_yResolution" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (double)((Magick::Image const *)arg1)->yResolution();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_adaptiveBlur__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_adaptiveBlur" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_adaptiveBlur" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_adaptiveBlur" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->adaptiveBlur(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_adaptiveBlur__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_adaptiveBlur" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_adaptiveBlur" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->adaptiveBlur(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_adaptiveBlur__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_adaptiveBlur" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->adaptiveBlur();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_adaptiveBlur(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_adaptiveBlur__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_adaptiveBlur__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_adaptiveBlur__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function adaptiveBlur.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_adaptiveResize(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_adaptiveResize.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_adaptiveResize" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_adaptiveResize" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_adaptiveResize" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->adaptiveResize((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_adaptiveSharpen__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_adaptiveSharpen" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_adaptiveSharpen" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_adaptiveSharpen" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->adaptiveSharpen(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_adaptiveSharpen__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_adaptiveSharpen" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_adaptiveSharpen" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->adaptiveSharpen(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_adaptiveSharpen__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_adaptiveSharpen" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->adaptiveSharpen();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_adaptiveSharpen(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_adaptiveSharpen__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_adaptiveSharpen__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_adaptiveSharpen__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function adaptiveSharpen.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_adaptiveSharpenChannel__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_adaptiveSharpenChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_adaptiveSharpenChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_adaptiveSharpenChannel" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_adaptiveSharpenChannel" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    try {
      (arg1)->adaptiveSharpenChannel(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_adaptiveSharpenChannel__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_adaptiveSharpenChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_adaptiveSharpenChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_adaptiveSharpenChannel" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->adaptiveSharpenChannel(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_adaptiveSharpenChannel__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_adaptiveSharpenChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_adaptiveSharpenChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  {
    try {
      (arg1)->adaptiveSharpenChannel(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_adaptiveSharpenChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_adaptiveSharpenChannel__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_adaptiveSharpenChannel__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_adaptiveSharpenChannel__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function adaptiveSharpenChannel.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_adaptiveThreshold__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  ::ssize_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_adaptiveThreshold" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_adaptiveThreshold" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_size_t(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_adaptiveThreshold" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  ecode4 = SWIG_AsVal_long(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_adaptiveThreshold" "', argument " "4"" of type '" "::ssize_t""'");
  } 
  arg4 = static_cast< ::ssize_t >(val4);
  {
    try {
      (arg1)->adaptiveThreshold(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_adaptiveThreshold__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_adaptiveThreshold" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_adaptiveThreshold" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_size_t(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_adaptiveThreshold" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  {
    try {
      (arg1)->adaptiveThreshold(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_adaptiveThreshold(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_adaptiveThreshold__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_adaptiveThreshold__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function adaptiveThreshold.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_addNoise(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::NoiseType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_addNoise.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_addNoise" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_addNoise" "', argument " "2"" of type '" "Magick::NoiseType""'");
  } 
  arg2 = static_cast< Magick::NoiseType >(val2);
  {
    try {
      (arg1)->addNoise(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_addNoiseChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  Magick::NoiseType arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_addNoiseChannel.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_addNoiseChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_addNoiseChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_int(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_addNoiseChannel" "', argument " "3"" of type '" "Magick::NoiseType""'");
  } 
  arg3 = static_cast< Magick::NoiseType >(val3);
  {
    try {
      (arg1)->addNoiseChannel(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_affineTransform(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::DrawableAffine *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_affineTransform.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_affineTransform" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__DrawableAffine,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_affineTransform" "', argument " "2"" of type '" "Magick::DrawableAffine const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_affineTransform" "', argument " "2"" of type '" "Magick::DrawableAffine const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::DrawableAffine * >(argp2);
  {
    try {
      (arg1)->affineTransform((Magick::DrawableAffine const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_alphaChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::AlphaChannelType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_alphaChannel.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_alphaChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_alphaChannel" "', argument " "2"" of type '" "Magick::AlphaChannelType""'");
  } 
  arg2 = static_cast< Magick::AlphaChannelType >(val2);
  {
    try {
      (arg1)->alphaChannel(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_annotate__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  Magick::Geometry *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_annotate" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_annotate" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_annotate" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_annotate" "', argument " "3"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_annotate" "', argument " "3"" of type '" "Magick::Geometry const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Geometry * >(argp3);
  {
    try {
      (arg1)->annotate((std::string const &)*arg2,(Magick::Geometry const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_annotate__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  Magick::Geometry *arg3 = 0 ;
  Magick::GravityType arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_annotate" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_annotate" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_annotate" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_annotate" "', argument " "3"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_annotate" "', argument " "3"" of type '" "Magick::Geometry const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Geometry * >(argp3);
  ecode4 = SWIG_AsVal_int(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_annotate" "', argument " "4"" of type '" "Magick::GravityType""'");
  } 
  arg4 = static_cast< Magick::GravityType >(val4);
  {
    try {
      (arg1)->annotate((std::string const &)*arg2,(Magick::Geometry const &)*arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_annotate__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  Magick::Geometry *arg3 = 0 ;
  Magick::GravityType arg4 ;
  double arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_annotate" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_annotate" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_annotate" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_annotate" "', argument " "3"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_annotate" "', argument " "3"" of type '" "Magick::Geometry const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Geometry * >(argp3);
  ecode4 = SWIG_AsVal_int(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_annotate" "', argument " "4"" of type '" "Magick::GravityType""'");
  } 
  arg4 = static_cast< Magick::GravityType >(val4);
  ecode5 = SWIG_AsVal_double(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_annotate" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = static_cast< double >(val5);
  {
    try {
      (arg1)->annotate((std::string const &)*arg2,(Magick::Geometry const &)*arg3,arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_annotate__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  Magick::GravityType arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_annotate" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_annotate" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_annotate" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_int(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_annotate" "', argument " "3"" of type '" "Magick::GravityType""'");
  } 
  arg3 = static_cast< Magick::GravityType >(val3);
  {
    try {
      (arg1)->annotate((std::string const &)*arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_annotate(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_annotate__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_annotate__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_annotate__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_annotate__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function annotate.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_artifact__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_artifact" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_artifact" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_artifact" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(args[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_artifact" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_artifact" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    try {
      (arg1)->artifact((std::string const &)*arg2,(std::string const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_artifact__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_artifact" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_artifact" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_artifact" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      result = ((Magick::Image const *)arg1)->artifact((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_artifact(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_artifact__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_artifact__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function artifact.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_attribute__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string arg2 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_attribute" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Image_attribute" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  res3 = SWIG_AsCharPtrAndSize(args[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_attribute" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  {
    try {
      (arg1)->attribute(arg2,(char const *)arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_attribute__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string arg2 ;
  std::string arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_attribute" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Image_attribute" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(args[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Image_attribute" "', argument " "3"" of type '" "std::string const""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      (arg1)->attribute(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_attribute__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_attribute" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Image_attribute" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      result = ((Magick::Image const *)arg1)->attribute(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_attribute(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_attribute__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_attribute__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_attribute__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function attribute.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_autoGamma(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_autoGamma.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_autoGamma" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->autoGamma();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_autoGammaChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_autoGammaChannel.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_autoGammaChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_autoGammaChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  {
    try {
      (arg1)->autoGammaChannel(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_autoLevel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_autoLevel.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_autoLevel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->autoLevel();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_autoLevelChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_autoLevelChannel.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_autoLevelChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_autoLevelChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  {
    try {
      (arg1)->autoLevelChannel(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_autoOrient(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_autoOrient.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_autoOrient" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->autoOrient();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_blackThreshold(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_blackThreshold.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_blackThreshold" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_blackThreshold" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_blackThreshold" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->blackThreshold((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_blackThresholdChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_blackThresholdChannel.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_blackThresholdChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_blackThresholdChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(args[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_blackThresholdChannel" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_blackThresholdChannel" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    try {
      (arg1)->blackThresholdChannel(arg2,(std::string const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  if (SWIG_IsNewObj(res3)) delete arg3;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_blueShift__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_blueShift" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_blueShift" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->blueShift(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_blueShift__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_blueShift" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->blueShift();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_blueShift(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_blueShift__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_blueShift__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function blueShift.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_blur__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_blur" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_blur" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_blur" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->blur(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_blur__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_blur" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_blur" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->blur(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_blur__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_blur" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->blur();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_blur(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_blur__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_blur__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_blur__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function blur.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_blurChannel__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_blurChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_blurChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_blurChannel" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_blurChannel" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    try {
      (arg1)->blurChannel(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_blurChannel__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_blurChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_blurChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_blurChannel" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->blurChannel(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_blurChannel__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_blurChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_blurChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  {
    try {
      (arg1)->blurChannel(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_blurChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_blurChannel__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_blurChannel__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_blurChannel__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function blurChannel.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_border__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_border" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_border" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_border" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->border((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_border__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_border" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->border();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_border(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_border__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_border__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function border.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_brightnessContrast__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_brightnessContrast" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_brightnessContrast" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_brightnessContrast" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->brightnessContrast(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_brightnessContrast__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_brightnessContrast" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_brightnessContrast" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->brightnessContrast(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_brightnessContrast__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_brightnessContrast" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->brightnessContrast();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_brightnessContrast(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_brightnessContrast__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_brightnessContrast__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_brightnessContrast__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function brightnessContrast.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_brightnessContrastChannel__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_brightnessContrastChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_brightnessContrastChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_brightnessContrastChannel" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_brightnessContrastChannel" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    try {
      (arg1)->brightnessContrastChannel(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_brightnessContrastChannel__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_brightnessContrastChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_brightnessContrastChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_brightnessContrastChannel" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->brightnessContrastChannel(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_brightnessContrastChannel__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_brightnessContrastChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_brightnessContrastChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  {
    try {
      (arg1)->brightnessContrastChannel(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_brightnessContrastChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_brightnessContrastChannel__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_brightnessContrastChannel__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_brightnessContrastChannel__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function brightnessContrastChannel.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_cannyEdge__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_cannyEdge" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_cannyEdge" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_cannyEdge" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_cannyEdge" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  ecode5 = SWIG_AsVal_double(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_cannyEdge" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = static_cast< double >(val5);
  {
    try {
      (arg1)->cannyEdge(arg2,arg3,arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_cannyEdge__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_cannyEdge" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_cannyEdge" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_cannyEdge" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_cannyEdge" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    try {
      (arg1)->cannyEdge(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_cannyEdge__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_cannyEdge" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_cannyEdge" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_cannyEdge" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->cannyEdge(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_cannyEdge__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_cannyEdge" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_cannyEdge" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->cannyEdge(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_cannyEdge__SWIG_4(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_cannyEdge" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->cannyEdge();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_cannyEdge(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_cannyEdge__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_cannyEdge__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_cannyEdge__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_cannyEdge__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_cannyEdge__SWIG_4(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function cannyEdge.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_cdl(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_cdl.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_cdl" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_cdl" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_cdl" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->cdl((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_channel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_channel.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_channel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_channel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  {
    try {
      (arg1)->channel(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_channelDepth__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_channelDepth" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_channelDepth" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_size_t(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_channelDepth" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  {
    try {
      (arg1)->channelDepth(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_channelDepth__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  size_t result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_channelDepth" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_channelDepth" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  {
    try {
      result = (arg1)->channelDepth(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_size_t(static_cast< size_t >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_channelDepth(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_channelDepth__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_channelDepth__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function channelDepth.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_charcoal__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_charcoal" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_charcoal" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_charcoal" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->charcoal(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_charcoal__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_charcoal" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_charcoal" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->charcoal(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_charcoal__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_charcoal" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->charcoal();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_charcoal(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_charcoal__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_charcoal__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_charcoal__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function charcoal.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_chop(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_chop.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_chop" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_chop" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_chop" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->chop((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_chromaBluePrimary__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_chromaBluePrimary" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_chromaBluePrimary" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_chromaBluePrimary" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->chromaBluePrimary(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_chromaBluePrimary__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_chromaBluePrimary" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_chromaBluePrimary" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_chromaBluePrimary" "', argument " "3"" of type '" "double *""'"); 
  }
  arg3 = reinterpret_cast< double * >(argp3);
  {
    try {
      ((Magick::Image const *)arg1)->chromaBluePrimary(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_chromaBluePrimary(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_chromaBluePrimary__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_chromaBluePrimary__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function chromaBluePrimary.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_chromaGreenPrimary__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_chromaGreenPrimary" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_chromaGreenPrimary" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_chromaGreenPrimary" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->chromaGreenPrimary(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_chromaGreenPrimary__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_chromaGreenPrimary" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_chromaGreenPrimary" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_chromaGreenPrimary" "', argument " "3"" of type '" "double *""'"); 
  }
  arg3 = reinterpret_cast< double * >(argp3);
  {
    try {
      ((Magick::Image const *)arg1)->chromaGreenPrimary(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_chromaGreenPrimary(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_chromaGreenPrimary__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_chromaGreenPrimary__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function chromaGreenPrimary.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_chromaRedPrimary__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_chromaRedPrimary" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_chromaRedPrimary" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_chromaRedPrimary" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->chromaRedPrimary(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_chromaRedPrimary__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_chromaRedPrimary" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_chromaRedPrimary" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_chromaRedPrimary" "', argument " "3"" of type '" "double *""'"); 
  }
  arg3 = reinterpret_cast< double * >(argp3);
  {
    try {
      ((Magick::Image const *)arg1)->chromaRedPrimary(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_chromaRedPrimary(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_chromaRedPrimary__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_chromaRedPrimary__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function chromaRedPrimary.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_chromaWhitePoint__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_chromaWhitePoint" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_chromaWhitePoint" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_chromaWhitePoint" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->chromaWhitePoint(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_chromaWhitePoint__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_chromaWhitePoint" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_chromaWhitePoint" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_chromaWhitePoint" "', argument " "3"" of type '" "double *""'"); 
  }
  arg3 = reinterpret_cast< double * >(argp3);
  {
    try {
      ((Magick::Image const *)arg1)->chromaWhitePoint(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_chromaWhitePoint(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_chromaWhitePoint__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_chromaWhitePoint__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function chromaWhitePoint.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_clamp(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_clamp.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_clamp" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->clamp();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_clampChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_clampChannel.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_clampChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_clampChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  {
    try {
      (arg1)->clampChannel(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_clip(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_clip.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_clip" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->clip();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_clipPath(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_clipPath.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_clipPath" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Image_clipPath" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  ecode3 = SWIG_AsVal_bool(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_clipPath" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      (arg1)->clipPath(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_clut(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_clut.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_clut" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_clut" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_clut" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  {
    try {
      (arg1)->clut((Magick::Image const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_clutChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  Magick::Image *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_clutChannel.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_clutChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_clutChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_clutChannel" "', argument " "3"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_clutChannel" "', argument " "3"" of type '" "Magick::Image const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Image * >(argp3);
  {
    try {
      (arg1)->clutChannel(arg2,(Magick::Image const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_colorize__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  unsigned int arg2 ;
  Magick::Color *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_colorize" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_colorize" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_colorize" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_colorize" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Color * >(argp3);
  {
    try {
      (arg1)->colorize(arg2,(Magick::Color const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_colorize__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  Magick::Color *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_colorize" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_colorize" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_colorize" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_colorize" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  res5 = SWIG_ConvertPtr(args[3], &argp5, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Image_colorize" "', argument " "5"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_colorize" "', argument " "5"" of type '" "Magick::Color const &""'"); 
  }
  arg5 = reinterpret_cast< Magick::Color * >(argp5);
  {
    try {
      (arg1)->colorize(arg2,arg3,arg4,(Magick::Color const &)*arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_colorize(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_colorize__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_colorize__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function colorize.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_colorMap__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  Magick::Color *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_colorMap" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_colorMap" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_colorMap" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_colorMap" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Color * >(argp3);
  {
    try {
      (arg1)->colorMap(arg2,(Magick::Color const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_colorMap__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  Magick::Color result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_colorMap" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_colorMap" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      result = ((Magick::Image const *)arg1)->colorMap(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Color(result)), SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN |  0 );
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_colorMap(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_colorMap__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_colorMap__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function colorMap.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_colorMatrix(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  double *arg3 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_colorMatrix.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_colorMatrix" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_colorMatrix" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  res3 = SWIG_ConvertPtr(args[1], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_colorMatrix" "', argument " "3"" of type '" "double const *""'"); 
  }
  arg3 = reinterpret_cast< double * >(argp3);
  {
    try {
      (arg1)->colorMatrix(arg2,(double const *)arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_compare__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_compare" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_compare" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_compare" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  {
    try {
      result = (bool)(arg1)->compare((Magick::Image const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_compare__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  Magick::MetricType arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_compare" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_compare" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_compare" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  ecode3 = SWIG_AsVal_int(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_compare" "', argument " "3"" of type '" "Magick::MetricType""'");
  } 
  arg3 = static_cast< Magick::MetricType >(val3);
  {
    try {
      result = (double)(arg1)->compare((Magick::Image const &)*arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_compareChannel__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  Magick::Image *arg3 = 0 ;
  Magick::MetricType arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  double result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_compareChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_compareChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_compareChannel" "', argument " "3"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_compareChannel" "', argument " "3"" of type '" "Magick::Image const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Image * >(argp3);
  ecode4 = SWIG_AsVal_int(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_compareChannel" "', argument " "4"" of type '" "Magick::MetricType""'");
  } 
  arg4 = static_cast< Magick::MetricType >(val4);
  {
    try {
      result = (double)(arg1)->compareChannel(arg2,(Magick::Image const &)*arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_double(static_cast< double >(result));
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_compare__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  Magick::MetricType arg3 ;
  double *arg4 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  Magick::Image result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_compare" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_compare" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_compare" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  ecode3 = SWIG_AsVal_int(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_compare" "', argument " "3"" of type '" "Magick::MetricType""'");
  } 
  arg3 = static_cast< Magick::MetricType >(val3);
  res4 = SWIG_ConvertPtr(args[2], &argp4,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Image_compare" "', argument " "4"" of type '" "double *""'"); 
  }
  arg4 = reinterpret_cast< double * >(argp4);
  {
    try {
      result = (arg1)->compare((Magick::Image const &)*arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Image(result)), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN |  0 );
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_compare(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_compare__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_compare__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_compare__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function compare.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_compareChannel__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  Magick::Image *arg3 = 0 ;
  Magick::MetricType arg4 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  Magick::Image result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_compareChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_compareChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_compareChannel" "', argument " "3"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_compareChannel" "', argument " "3"" of type '" "Magick::Image const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Image * >(argp3);
  ecode4 = SWIG_AsVal_int(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_compareChannel" "', argument " "4"" of type '" "Magick::MetricType""'");
  } 
  arg4 = static_cast< Magick::MetricType >(val4);
  res5 = SWIG_ConvertPtr(args[3], &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Image_compareChannel" "', argument " "5"" of type '" "double *""'"); 
  }
  arg5 = reinterpret_cast< double * >(argp5);
  {
    try {
      result = (arg1)->compareChannel(arg2,(Magick::Image const &)*arg3,arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Image(result)), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN |  0 );
  
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_compareChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_compareChannel__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_compareChannel__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function compareChannel.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_composite__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  Magick::Geometry *arg3 = 0 ;
  Magick::CompositeOperator arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_composite" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_composite" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_composite" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_composite" "', argument " "3"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_composite" "', argument " "3"" of type '" "Magick::Geometry const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Geometry * >(argp3);
  ecode4 = SWIG_AsVal_int(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_composite" "', argument " "4"" of type '" "Magick::CompositeOperator""'");
  } 
  arg4 = static_cast< Magick::CompositeOperator >(val4);
  {
    try {
      (arg1)->composite((Magick::Image const &)*arg2,(Magick::Geometry const &)*arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_composite__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  Magick::Geometry *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_composite" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_composite" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_composite" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_composite" "', argument " "3"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_composite" "', argument " "3"" of type '" "Magick::Geometry const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Geometry * >(argp3);
  {
    try {
      (arg1)->composite((Magick::Image const &)*arg2,(Magick::Geometry const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_composite__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  Magick::GravityType arg3 ;
  Magick::CompositeOperator arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_composite" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_composite" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_composite" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  ecode3 = SWIG_AsVal_int(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_composite" "', argument " "3"" of type '" "Magick::GravityType""'");
  } 
  arg3 = static_cast< Magick::GravityType >(val3);
  ecode4 = SWIG_AsVal_int(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_composite" "', argument " "4"" of type '" "Magick::CompositeOperator""'");
  } 
  arg4 = static_cast< Magick::CompositeOperator >(val4);
  {
    try {
      (arg1)->composite((Magick::Image const &)*arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_composite__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  Magick::GravityType arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_composite" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_composite" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_composite" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  ecode3 = SWIG_AsVal_int(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_composite" "', argument " "3"" of type '" "Magick::GravityType""'");
  } 
  arg3 = static_cast< Magick::GravityType >(val3);
  {
    try {
      (arg1)->composite((Magick::Image const &)*arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_composite__SWIG_4(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  ::ssize_t arg3 ;
  ::ssize_t arg4 ;
  Magick::CompositeOperator arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_composite" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_composite" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_composite" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  ecode3 = SWIG_AsVal_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_composite" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  ecode4 = SWIG_AsVal_long(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_composite" "', argument " "4"" of type '" "::ssize_t""'");
  } 
  arg4 = static_cast< ::ssize_t >(val4);
  ecode5 = SWIG_AsVal_int(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_composite" "', argument " "5"" of type '" "Magick::CompositeOperator""'");
  } 
  arg5 = static_cast< Magick::CompositeOperator >(val5);
  {
    try {
      (arg1)->composite((Magick::Image const &)*arg2,arg3,arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_composite__SWIG_5(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  ::ssize_t arg3 ;
  ::ssize_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_composite" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_composite" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_composite" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  ecode3 = SWIG_AsVal_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_composite" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  ecode4 = SWIG_AsVal_long(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_composite" "', argument " "4"" of type '" "::ssize_t""'");
  } 
  arg4 = static_cast< ::ssize_t >(val4);
  {
    try {
      (arg1)->composite((Magick::Image const &)*arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_composite(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_composite__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_composite__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_composite__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_composite__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_composite__SWIG_4(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_composite__SWIG_5(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function composite.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_connectedComponents(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_connectedComponents.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_connectedComponents" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_connectedComponents" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      (arg1)->connectedComponents(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_contrast(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_contrast.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_contrast" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_contrast" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      (arg1)->contrast(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_contrastStretch(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_contrastStretch.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_contrastStretch" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_contrastStretch" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_contrastStretch" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->contrastStretch(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_contrastStretchChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_contrastStretchChannel.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_contrastStretchChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_contrastStretchChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_contrastStretchChannel" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_contrastStretchChannel" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    try {
      (arg1)->contrastStretchChannel(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_convolve(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  double *arg3 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_convolve.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_convolve" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_convolve" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  res3 = SWIG_ConvertPtr(args[1], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_convolve" "', argument " "3"" of type '" "double const *""'"); 
  }
  arg3 = reinterpret_cast< double * >(argp3);
  {
    try {
      (arg1)->convolve(arg2,(double const *)arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_copyPixels(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  Magick::Geometry *arg3 = 0 ;
  Magick::Offset *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_copyPixels.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_copyPixels" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_copyPixels" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_copyPixels" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_copyPixels" "', argument " "3"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_copyPixels" "', argument " "3"" of type '" "Magick::Geometry const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Geometry * >(argp3);
  res4 = SWIG_ConvertPtr(args[2], &argp4, SWIGTYPE_p_Magick__Offset,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Image_copyPixels" "', argument " "4"" of type '" "Magick::Offset const &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_copyPixels" "', argument " "4"" of type '" "Magick::Offset const &""'"); 
  }
  arg4 = reinterpret_cast< Magick::Offset * >(argp4);
  {
    try {
      (arg1)->copyPixels((Magick::Image const &)*arg2,(Magick::Geometry const &)*arg3,(Magick::Offset const &)*arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_crop(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_crop.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_crop" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_crop" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_crop" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->crop((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_cycleColormap(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ::ssize_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_cycleColormap.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_cycleColormap" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_cycleColormap" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  {
    try {
      (arg1)->cycleColormap(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_decipher(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_decipher.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_decipher" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_decipher" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_decipher" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->decipher((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_defineSet__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  bool val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_defineSet" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_defineSet" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_defineSet" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(args[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_defineSet" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_defineSet" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  ecode4 = SWIG_AsVal_bool(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_defineSet" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      (arg1)->defineSet((std::string const &)*arg2,(std::string const &)*arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_defineSet__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  bool result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_defineSet" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_defineSet" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_defineSet" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(args[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_defineSet" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_defineSet" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    try {
      result = (bool)((Magick::Image const *)arg1)->defineSet((std::string const &)*arg2,(std::string const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_bool(static_cast< bool >(result));
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_defineSet(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_defineSet__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_defineSet__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function defineSet.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_defineValue__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_defineValue" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_defineValue" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_defineValue" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(args[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_defineValue" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_defineValue" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(args[2], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Image_defineValue" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_defineValue" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  {
    try {
      (arg1)->defineValue((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_defineValue__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_defineValue" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_defineValue" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_defineValue" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(args[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_defineValue" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_defineValue" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    try {
      result = ((Magick::Image const *)arg1)->defineValue((std::string const &)*arg2,(std::string const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_defineValue(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_defineValue__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_defineValue__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function defineValue.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_deskew(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_deskew.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_deskew" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_deskew" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->deskew(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_despeckle(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_despeckle.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_despeckle" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->despeckle();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_determineType(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::ImageType result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_determineType.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_determineType" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::ImageType)((Magick::Image const *)arg1)->determineType();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_display(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_display.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_display" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->display();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_distort__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::DistortImageMethod arg2 ;
  size_t arg3 ;
  double *arg4 = (double *) 0 ;
  bool arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_distort" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_distort" "', argument " "2"" of type '" "Magick::DistortImageMethod""'");
  } 
  arg2 = static_cast< Magick::DistortImageMethod >(val2);
  ecode3 = SWIG_AsVal_size_t(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_distort" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  res4 = SWIG_ConvertPtr(args[2], &argp4,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Image_distort" "', argument " "4"" of type '" "double const *""'"); 
  }
  arg4 = reinterpret_cast< double * >(argp4);
  ecode5 = SWIG_AsVal_bool(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_distort" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  {
    try {
      (arg1)->distort(arg2,arg3,(double const *)arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_distort__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::DistortImageMethod arg2 ;
  size_t arg3 ;
  double *arg4 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_distort" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_distort" "', argument " "2"" of type '" "Magick::DistortImageMethod""'");
  } 
  arg2 = static_cast< Magick::DistortImageMethod >(val2);
  ecode3 = SWIG_AsVal_size_t(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_distort" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  res4 = SWIG_ConvertPtr(args[2], &argp4,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Image_distort" "', argument " "4"" of type '" "double const *""'"); 
  }
  arg4 = reinterpret_cast< double * >(argp4);
  {
    try {
      (arg1)->distort(arg2,arg3,(double const *)arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_distort(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_distort__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_distort__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function distort.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_draw__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Drawable *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_draw" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Drawable,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_draw" "', argument " "2"" of type '" "Magick::Drawable const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_draw" "', argument " "2"" of type '" "Magick::Drawable const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Drawable * >(argp2);
  {
    try {
      (arg1)->draw((Magick::Drawable const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_draw__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::list< Magick::Drawable > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_draw" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_std__listT_Magick__Drawable_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_draw" "', argument " "2"" of type '" "std::list< Magick::Drawable > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_draw" "', argument " "2"" of type '" "std::list< Magick::Drawable > const &""'"); 
  }
  arg2 = reinterpret_cast< std::list< Magick::Drawable > * >(argp2);
  {
    try {
      (arg1)->draw((std::list< Magick::Drawable > const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_draw(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_draw__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_draw__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function draw.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_edge__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_edge" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_edge" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->edge(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_edge__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_edge" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->edge();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_edge(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_edge__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_edge__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function edge.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_emboss__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_emboss" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_emboss" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_emboss" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->emboss(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_emboss__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_emboss" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_emboss" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->emboss(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_emboss__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_emboss" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->emboss();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_emboss(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_emboss__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_emboss__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_emboss__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function emboss.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_encipher(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_encipher.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_encipher" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_encipher" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_encipher" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->encipher((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_enhance(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_enhance.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_enhance" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->enhance();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_equalize(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_equalize.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_equalize" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->equalize();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_erase(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_erase.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_erase" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->erase();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_extent__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_extent" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_extent" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_extent" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->extent((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_extent__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  Magick::Color *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_extent" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_extent" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_extent" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_extent" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_extent" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Color * >(argp3);
  {
    try {
      (arg1)->extent((Magick::Geometry const &)*arg2,(Magick::Color const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_extent__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  Magick::Color *arg3 = 0 ;
  Magick::GravityType arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_extent" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_extent" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_extent" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_extent" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_extent" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Color * >(argp3);
  ecode4 = SWIG_AsVal_int(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_extent" "', argument " "4"" of type '" "Magick::GravityType""'");
  } 
  arg4 = static_cast< Magick::GravityType >(val4);
  {
    try {
      (arg1)->extent((Magick::Geometry const &)*arg2,(Magick::Color const &)*arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_extent__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  Magick::GravityType arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_extent" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_extent" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_extent" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  ecode3 = SWIG_AsVal_int(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_extent" "', argument " "3"" of type '" "Magick::GravityType""'");
  } 
  arg3 = static_cast< Magick::GravityType >(val3);
  {
    try {
      (arg1)->extent((Magick::Geometry const &)*arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_extent(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_extent__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_extent__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_extent__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_extent__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function extent.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_flip(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_flip.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_flip" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->flip();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_floodFillColor__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  Magick::Color *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_floodFillColor" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_floodFillColor" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillColor" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_floodFillColor" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillColor" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Color * >(argp3);
  {
    try {
      (arg1)->floodFillColor((Magick::Geometry const &)*arg2,(Magick::Color const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_floodFillColor__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  Magick::Color *arg3 = 0 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_floodFillColor" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_floodFillColor" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillColor" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_floodFillColor" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillColor" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Color * >(argp3);
  ecode4 = SWIG_AsVal_bool(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_floodFillColor" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      (arg1)->floodFillColor((Magick::Geometry const &)*arg2,(Magick::Color const &)*arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_floodFillColor__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  Magick::Color *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_floodFillColor" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_floodFillColor" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_floodFillColor" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  res4 = SWIG_ConvertPtr(args[2], &argp4, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Image_floodFillColor" "', argument " "4"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillColor" "', argument " "4"" of type '" "Magick::Color const &""'"); 
  }
  arg4 = reinterpret_cast< Magick::Color * >(argp4);
  {
    try {
      (arg1)->floodFillColor(arg2,arg3,(Magick::Color const &)*arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_floodFillColor__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  Magick::Color *arg4 = 0 ;
  bool arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_floodFillColor" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_floodFillColor" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_floodFillColor" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  res4 = SWIG_ConvertPtr(args[2], &argp4, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Image_floodFillColor" "', argument " "4"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillColor" "', argument " "4"" of type '" "Magick::Color const &""'"); 
  }
  arg4 = reinterpret_cast< Magick::Color * >(argp4);
  ecode5 = SWIG_AsVal_bool(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_floodFillColor" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  {
    try {
      (arg1)->floodFillColor(arg2,arg3,(Magick::Color const &)*arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_floodFillColor__SWIG_4(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  Magick::Color *arg3 = 0 ;
  Magick::Color *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_floodFillColor" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_floodFillColor" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillColor" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_floodFillColor" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillColor" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Color * >(argp3);
  res4 = SWIG_ConvertPtr(args[2], &argp4, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Image_floodFillColor" "', argument " "4"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillColor" "', argument " "4"" of type '" "Magick::Color const &""'"); 
  }
  arg4 = reinterpret_cast< Magick::Color * >(argp4);
  {
    try {
      (arg1)->floodFillColor((Magick::Geometry const &)*arg2,(Magick::Color const &)*arg3,(Magick::Color const &)*arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_floodFillColor__SWIG_5(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  Magick::Color *arg3 = 0 ;
  Magick::Color *arg4 = 0 ;
  bool arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_floodFillColor" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_floodFillColor" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillColor" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_floodFillColor" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillColor" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Color * >(argp3);
  res4 = SWIG_ConvertPtr(args[2], &argp4, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Image_floodFillColor" "', argument " "4"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillColor" "', argument " "4"" of type '" "Magick::Color const &""'"); 
  }
  arg4 = reinterpret_cast< Magick::Color * >(argp4);
  ecode5 = SWIG_AsVal_bool(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_floodFillColor" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  {
    try {
      (arg1)->floodFillColor((Magick::Geometry const &)*arg2,(Magick::Color const &)*arg3,(Magick::Color const &)*arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_floodFillColor__SWIG_6(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  Magick::Color *arg4 = 0 ;
  Magick::Color *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_floodFillColor" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_floodFillColor" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_floodFillColor" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  res4 = SWIG_ConvertPtr(args[2], &argp4, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Image_floodFillColor" "', argument " "4"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillColor" "', argument " "4"" of type '" "Magick::Color const &""'"); 
  }
  arg4 = reinterpret_cast< Magick::Color * >(argp4);
  res5 = SWIG_ConvertPtr(args[3], &argp5, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Image_floodFillColor" "', argument " "5"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillColor" "', argument " "5"" of type '" "Magick::Color const &""'"); 
  }
  arg5 = reinterpret_cast< Magick::Color * >(argp5);
  {
    try {
      (arg1)->floodFillColor(arg2,arg3,(Magick::Color const &)*arg4,(Magick::Color const &)*arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_floodFillColor__SWIG_7(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  Magick::Color *arg4 = 0 ;
  Magick::Color *arg5 = 0 ;
  bool arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_floodFillColor" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_floodFillColor" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_floodFillColor" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  res4 = SWIG_ConvertPtr(args[2], &argp4, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Image_floodFillColor" "', argument " "4"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillColor" "', argument " "4"" of type '" "Magick::Color const &""'"); 
  }
  arg4 = reinterpret_cast< Magick::Color * >(argp4);
  res5 = SWIG_ConvertPtr(args[3], &argp5, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Image_floodFillColor" "', argument " "5"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillColor" "', argument " "5"" of type '" "Magick::Color const &""'"); 
  }
  arg5 = reinterpret_cast< Magick::Color * >(argp5);
  ecode6 = SWIG_AsVal_bool(args[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Image_floodFillColor" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  {
    try {
      (arg1)->floodFillColor(arg2,arg3,(Magick::Color const &)*arg4,(Magick::Color const &)*arg5,arg6);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_floodFillColor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_floodFillColor__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_floodFillColor__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_floodFillColor__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_floodFillColor__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_floodFillColor__SWIG_4(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_floodFillColor__SWIG_5(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_floodFillColor__SWIG_6(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 5) {
    errorHandler.err.Clear();
    _wrap_Image_floodFillColor__SWIG_7(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function floodFillColor.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_floodFillOpacity__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  unsigned int arg4 ;
  bool arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_floodFillOpacity" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_floodFillOpacity" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_floodFillOpacity" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_floodFillOpacity" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_bool(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_floodFillOpacity" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  {
    try {
      (arg1)->floodFillOpacity(arg2,arg3,arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_floodFillOpacity__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  unsigned int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_floodFillOpacity" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_floodFillOpacity" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_floodFillOpacity" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_floodFillOpacity" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  {
    try {
      (arg1)->floodFillOpacity(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_floodFillOpacity__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  unsigned int arg4 ;
  Magick::PaintMethod arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_floodFillOpacity" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_floodFillOpacity" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_floodFillOpacity" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_floodFillOpacity" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_int(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_floodFillOpacity" "', argument " "5"" of type '" "Magick::PaintMethod""'");
  } 
  arg5 = static_cast< Magick::PaintMethod >(val5);
  {
    try {
      (arg1)->floodFillOpacity(arg2,arg3,arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_floodFillOpacity__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  unsigned int arg4 ;
  Magick::Color *arg5 = 0 ;
  bool arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_floodFillOpacity" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_floodFillOpacity" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_floodFillOpacity" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_floodFillOpacity" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  res5 = SWIG_ConvertPtr(args[3], &argp5, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Image_floodFillOpacity" "', argument " "5"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillOpacity" "', argument " "5"" of type '" "Magick::Color const &""'"); 
  }
  arg5 = reinterpret_cast< Magick::Color * >(argp5);
  ecode6 = SWIG_AsVal_bool(args[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Image_floodFillOpacity" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  {
    try {
      (arg1)->floodFillOpacity(arg2,arg3,arg4,(Magick::Color const &)*arg5,arg6);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_floodFillOpacity__SWIG_4(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  unsigned int arg4 ;
  Magick::Color *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_floodFillOpacity" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_floodFillOpacity" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_floodFillOpacity" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_floodFillOpacity" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  res5 = SWIG_ConvertPtr(args[3], &argp5, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Image_floodFillOpacity" "', argument " "5"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillOpacity" "', argument " "5"" of type '" "Magick::Color const &""'"); 
  }
  arg5 = reinterpret_cast< Magick::Color * >(argp5);
  {
    try {
      (arg1)->floodFillOpacity(arg2,arg3,arg4,(Magick::Color const &)*arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_floodFillOpacity(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_floodFillOpacity__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_floodFillOpacity__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_floodFillOpacity__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 5) {
    errorHandler.err.Clear();
    _wrap_Image_floodFillOpacity__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_floodFillOpacity__SWIG_4(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function floodFillOpacity.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_floodFillTexture__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  Magick::Image *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_floodFillTexture" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_floodFillTexture" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillTexture" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_floodFillTexture" "', argument " "3"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillTexture" "', argument " "3"" of type '" "Magick::Image const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Image * >(argp3);
  {
    try {
      (arg1)->floodFillTexture((Magick::Geometry const &)*arg2,(Magick::Image const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_floodFillTexture__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  Magick::Image *arg3 = 0 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_floodFillTexture" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_floodFillTexture" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillTexture" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_floodFillTexture" "', argument " "3"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillTexture" "', argument " "3"" of type '" "Magick::Image const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Image * >(argp3);
  ecode4 = SWIG_AsVal_bool(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_floodFillTexture" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      (arg1)->floodFillTexture((Magick::Geometry const &)*arg2,(Magick::Image const &)*arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_floodFillTexture__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  Magick::Image *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_floodFillTexture" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_floodFillTexture" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_floodFillTexture" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  res4 = SWIG_ConvertPtr(args[2], &argp4, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Image_floodFillTexture" "', argument " "4"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillTexture" "', argument " "4"" of type '" "Magick::Image const &""'"); 
  }
  arg4 = reinterpret_cast< Magick::Image * >(argp4);
  {
    try {
      (arg1)->floodFillTexture(arg2,arg3,(Magick::Image const &)*arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_floodFillTexture__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  Magick::Image *arg4 = 0 ;
  bool arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_floodFillTexture" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_floodFillTexture" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_floodFillTexture" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  res4 = SWIG_ConvertPtr(args[2], &argp4, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Image_floodFillTexture" "', argument " "4"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillTexture" "', argument " "4"" of type '" "Magick::Image const &""'"); 
  }
  arg4 = reinterpret_cast< Magick::Image * >(argp4);
  ecode5 = SWIG_AsVal_bool(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_floodFillTexture" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  {
    try {
      (arg1)->floodFillTexture(arg2,arg3,(Magick::Image const &)*arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_floodFillTexture__SWIG_4(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  Magick::Image *arg3 = 0 ;
  Magick::Color *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_floodFillTexture" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_floodFillTexture" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillTexture" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_floodFillTexture" "', argument " "3"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillTexture" "', argument " "3"" of type '" "Magick::Image const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Image * >(argp3);
  res4 = SWIG_ConvertPtr(args[2], &argp4, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Image_floodFillTexture" "', argument " "4"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillTexture" "', argument " "4"" of type '" "Magick::Color const &""'"); 
  }
  arg4 = reinterpret_cast< Magick::Color * >(argp4);
  {
    try {
      (arg1)->floodFillTexture((Magick::Geometry const &)*arg2,(Magick::Image const &)*arg3,(Magick::Color const &)*arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_floodFillTexture__SWIG_5(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  Magick::Image *arg3 = 0 ;
  Magick::Color *arg4 = 0 ;
  bool arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_floodFillTexture" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_floodFillTexture" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillTexture" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_floodFillTexture" "', argument " "3"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillTexture" "', argument " "3"" of type '" "Magick::Image const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Image * >(argp3);
  res4 = SWIG_ConvertPtr(args[2], &argp4, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Image_floodFillTexture" "', argument " "4"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillTexture" "', argument " "4"" of type '" "Magick::Color const &""'"); 
  }
  arg4 = reinterpret_cast< Magick::Color * >(argp4);
  ecode5 = SWIG_AsVal_bool(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_floodFillTexture" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  {
    try {
      (arg1)->floodFillTexture((Magick::Geometry const &)*arg2,(Magick::Image const &)*arg3,(Magick::Color const &)*arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_floodFillTexture__SWIG_6(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  Magick::Image *arg4 = 0 ;
  Magick::Color *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_floodFillTexture" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_floodFillTexture" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_floodFillTexture" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  res4 = SWIG_ConvertPtr(args[2], &argp4, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Image_floodFillTexture" "', argument " "4"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillTexture" "', argument " "4"" of type '" "Magick::Image const &""'"); 
  }
  arg4 = reinterpret_cast< Magick::Image * >(argp4);
  res5 = SWIG_ConvertPtr(args[3], &argp5, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Image_floodFillTexture" "', argument " "5"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillTexture" "', argument " "5"" of type '" "Magick::Color const &""'"); 
  }
  arg5 = reinterpret_cast< Magick::Color * >(argp5);
  {
    try {
      (arg1)->floodFillTexture(arg2,arg3,(Magick::Image const &)*arg4,(Magick::Color const &)*arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_floodFillTexture__SWIG_7(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  Magick::Image *arg4 = 0 ;
  Magick::Color *arg5 = 0 ;
  bool arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_floodFillTexture" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_floodFillTexture" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_floodFillTexture" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  res4 = SWIG_ConvertPtr(args[2], &argp4, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Image_floodFillTexture" "', argument " "4"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillTexture" "', argument " "4"" of type '" "Magick::Image const &""'"); 
  }
  arg4 = reinterpret_cast< Magick::Image * >(argp4);
  res5 = SWIG_ConvertPtr(args[3], &argp5, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Image_floodFillTexture" "', argument " "5"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_floodFillTexture" "', argument " "5"" of type '" "Magick::Color const &""'"); 
  }
  arg5 = reinterpret_cast< Magick::Color * >(argp5);
  ecode6 = SWIG_AsVal_bool(args[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Image_floodFillTexture" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  {
    try {
      (arg1)->floodFillTexture(arg2,arg3,(Magick::Image const &)*arg4,(Magick::Color const &)*arg5,arg6);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_floodFillTexture(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_floodFillTexture__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_floodFillTexture__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_floodFillTexture__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_floodFillTexture__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_floodFillTexture__SWIG_4(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_floodFillTexture__SWIG_5(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_floodFillTexture__SWIG_6(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 5) {
    errorHandler.err.Clear();
    _wrap_Image_floodFillTexture__SWIG_7(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function floodFillTexture.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_flop(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_flop.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_flop" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->flop();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_fontTypeMetrics(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  Magick::TypeMetric *arg3 = (Magick::TypeMetric *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_fontTypeMetrics.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_fontTypeMetrics" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_fontTypeMetrics" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_fontTypeMetrics" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  res3 = SWIG_ConvertPtr(args[1], &argp3,SWIGTYPE_p_Magick__TypeMetric, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_fontTypeMetrics" "', argument " "3"" of type '" "Magick::TypeMetric *""'"); 
  }
  arg3 = reinterpret_cast< Magick::TypeMetric * >(argp3);
  {
    try {
      (arg1)->fontTypeMetrics((std::string const &)*arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_fontTypeMetricsMultiline(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  Magick::TypeMetric *arg3 = (Magick::TypeMetric *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_fontTypeMetricsMultiline.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_fontTypeMetricsMultiline" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_fontTypeMetricsMultiline" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_fontTypeMetricsMultiline" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  res3 = SWIG_ConvertPtr(args[1], &argp3,SWIGTYPE_p_Magick__TypeMetric, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_fontTypeMetricsMultiline" "', argument " "3"" of type '" "Magick::TypeMetric *""'"); 
  }
  arg3 = reinterpret_cast< Magick::TypeMetric * >(argp3);
  {
    try {
      (arg1)->fontTypeMetricsMultiline((std::string const &)*arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_frame__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_frame" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_frame" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_frame" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->frame((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_frame__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_frame" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->frame();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_frame__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  ::ssize_t arg4 ;
  ::ssize_t arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  long val5 ;
  int ecode5 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_frame" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_frame" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_size_t(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_frame" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  ecode4 = SWIG_AsVal_long(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_frame" "', argument " "4"" of type '" "::ssize_t""'");
  } 
  arg4 = static_cast< ::ssize_t >(val4);
  ecode5 = SWIG_AsVal_long(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_frame" "', argument " "5"" of type '" "::ssize_t""'");
  } 
  arg5 = static_cast< ::ssize_t >(val5);
  {
    try {
      (arg1)->frame(arg2,arg3,arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_frame__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  ::ssize_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_frame" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_frame" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_size_t(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_frame" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  ecode4 = SWIG_AsVal_long(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_frame" "', argument " "4"" of type '" "::ssize_t""'");
  } 
  arg4 = static_cast< ::ssize_t >(val4);
  {
    try {
      (arg1)->frame(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_frame__SWIG_4(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_frame" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_frame" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_size_t(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_frame" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  {
    try {
      (arg1)->frame(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_frame(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_frame__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_frame__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_frame__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_frame__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_frame__SWIG_4(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function frame.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_fx__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_fx" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Image_fx" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      (arg1)->fx(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_fx__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string arg2 ;
  Magick::ChannelType arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_fx" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Image_fx" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  ecode3 = SWIG_AsVal_int(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_fx" "', argument " "3"" of type '" "Magick::ChannelType""'");
  } 
  arg3 = static_cast< Magick::ChannelType >(val3);
  {
    try {
      (arg1)->fx(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_fx(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_fx__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_fx__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function fx.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_gamma__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_gamma" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_gamma" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->gamma(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_gamma__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_gamma" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_gamma" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_gamma" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_gamma" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    try {
      (arg1)->gamma(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_gamma(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_gamma__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_gamma__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_gamma__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function gamma.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_gaussianBlur(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_gaussianBlur.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_gaussianBlur" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_gaussianBlur" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_gaussianBlur" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->gaussianBlur(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_gaussianBlurChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_gaussianBlurChannel.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_gaussianBlurChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_gaussianBlurChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_gaussianBlurChannel" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_gaussianBlurChannel" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    try {
      (arg1)->gaussianBlurChannel(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_getConstIndexes(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::IndexPacket *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_getConstIndexes.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_getConstIndexes" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::IndexPacket *)((Magick::Image const *)arg1)->getConstIndexes();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_short, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_getConstPixels(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  size_t arg4 ;
  size_t arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PixelPacket *result = 0 ;
  
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_getConstPixels.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_getConstPixels" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_getConstPixels" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_getConstPixels" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  ecode4 = SWIG_AsVal_size_t(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_getConstPixels" "', argument " "4"" of type '" "size_t""'");
  } 
  arg4 = static_cast< size_t >(val4);
  ecode5 = SWIG_AsVal_size_t(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_getConstPixels" "', argument " "5"" of type '" "size_t""'");
  } 
  arg5 = static_cast< size_t >(val5);
  {
    try {
      result = (PixelPacket *)((Magick::Image const *)arg1)->getConstPixels(arg2,arg3,arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_PixelPacket, 0 |  0 );
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_getIndexes(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::IndexPacket *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_getIndexes.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_getIndexes" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::IndexPacket *)(arg1)->getIndexes();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_short, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_getPixels(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  size_t arg4 ;
  size_t arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PixelPacket *result = 0 ;
  
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_getPixels.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_getPixels" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_getPixels" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_getPixels" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  ecode4 = SWIG_AsVal_size_t(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_getPixels" "', argument " "4"" of type '" "size_t""'");
  } 
  arg4 = static_cast< size_t >(val4);
  ecode5 = SWIG_AsVal_size_t(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_getPixels" "', argument " "5"" of type '" "size_t""'");
  } 
  arg5 = static_cast< size_t >(val5);
  {
    try {
      result = (PixelPacket *)(arg1)->getPixels(arg2,arg3,arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_PixelPacket, 0 |  0 );
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_grayscale(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::PixelIntensityMethod arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_grayscale.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_grayscale" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_grayscale" "', argument " "2"" of type '" "Magick::PixelIntensityMethod""'");
  } 
  arg2 = static_cast< Magick::PixelIntensityMethod >(val2);
  {
    try {
      (arg1)->grayscale(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_haldClut(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_haldClut.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_haldClut" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_haldClut" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_haldClut" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  {
    try {
      (arg1)->haldClut((Magick::Image const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_houghLine__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  size_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_houghLine" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_houghLine" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_size_t(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_houghLine" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  ecode4 = SWIG_AsVal_size_t(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_houghLine" "', argument " "4"" of type '" "size_t""'");
  } 
  arg4 = static_cast< size_t >(val4);
  {
    try {
      (arg1)->houghLine(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_houghLine__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_houghLine" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_houghLine" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_size_t(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_houghLine" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  {
    try {
      (arg1)->houghLine(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_houghLine(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_houghLine__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_houghLine__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function houghLine.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_implode(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_implode.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_implode" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_implode" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->implode(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_inverseFourierTransform__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_inverseFourierTransform" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_inverseFourierTransform" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_inverseFourierTransform" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  {
    try {
      (arg1)->inverseFourierTransform((Magick::Image const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_inverseFourierTransform__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_inverseFourierTransform" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_inverseFourierTransform" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_inverseFourierTransform" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  ecode3 = SWIG_AsVal_bool(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_inverseFourierTransform" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      (arg1)->inverseFourierTransform((Magick::Image const &)*arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_inverseFourierTransform(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_inverseFourierTransform__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_inverseFourierTransform__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function inverseFourierTransform.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_kuwahara__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_kuwahara" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_kuwahara" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_kuwahara" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->kuwahara(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_kuwahara__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_kuwahara" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_kuwahara" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->kuwahara(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_kuwahara__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_kuwahara" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->kuwahara();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_kuwahara(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_kuwahara__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_kuwahara__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_kuwahara__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function kuwahara.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_kuwaharaChannel__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_kuwaharaChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_kuwaharaChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_kuwaharaChannel" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_kuwaharaChannel" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    try {
      (arg1)->kuwaharaChannel(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_kuwaharaChannel__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_kuwaharaChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_kuwaharaChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_kuwaharaChannel" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->kuwaharaChannel(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_kuwaharaChannel__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_kuwaharaChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_kuwaharaChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  {
    try {
      (arg1)->kuwaharaChannel(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_kuwaharaChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_kuwaharaChannel__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_kuwaharaChannel__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_kuwaharaChannel__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function kuwaharaChannel.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_level__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_level" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_level" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_level" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_level" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    try {
      (arg1)->level(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_level__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_level" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_level" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_level" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->level(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_level(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_level__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_level__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function level.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_levelChannel__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_levelChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_levelChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_levelChannel" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_levelChannel" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  ecode5 = SWIG_AsVal_double(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_levelChannel" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = static_cast< double >(val5);
  {
    try {
      (arg1)->levelChannel(arg2,arg3,arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_levelChannel__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_levelChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_levelChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_levelChannel" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_levelChannel" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    try {
      (arg1)->levelChannel(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_levelChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_levelChannel__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_levelChannel__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function levelChannel.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_levelColors__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Color *arg2 = 0 ;
  Magick::Color *arg3 = 0 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_levelColors" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_levelColors" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_levelColors" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_levelColors" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_levelColors" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Color * >(argp3);
  ecode4 = SWIG_AsVal_bool(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_levelColors" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      (arg1)->levelColors((Magick::Color const &)*arg2,(Magick::Color const &)*arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_levelColors__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Color *arg2 = 0 ;
  Magick::Color *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_levelColors" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_levelColors" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_levelColors" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_levelColors" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_levelColors" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Color * >(argp3);
  {
    try {
      (arg1)->levelColors((Magick::Color const &)*arg2,(Magick::Color const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_levelColors(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_levelColors__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_levelColors__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function levelColors.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_levelColorsChannel__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  Magick::Color *arg3 = 0 ;
  Magick::Color *arg4 = 0 ;
  bool arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_levelColorsChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_levelColorsChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_levelColorsChannel" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_levelColorsChannel" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Color * >(argp3);
  res4 = SWIG_ConvertPtr(args[2], &argp4, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Image_levelColorsChannel" "', argument " "4"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_levelColorsChannel" "', argument " "4"" of type '" "Magick::Color const &""'"); 
  }
  arg4 = reinterpret_cast< Magick::Color * >(argp4);
  ecode5 = SWIG_AsVal_bool(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_levelColorsChannel" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  {
    try {
      (arg1)->levelColorsChannel(arg2,(Magick::Color const &)*arg3,(Magick::Color const &)*arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_levelColorsChannel__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  Magick::Color *arg3 = 0 ;
  Magick::Color *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_levelColorsChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_levelColorsChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_levelColorsChannel" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_levelColorsChannel" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Color * >(argp3);
  res4 = SWIG_ConvertPtr(args[2], &argp4, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Image_levelColorsChannel" "', argument " "4"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_levelColorsChannel" "', argument " "4"" of type '" "Magick::Color const &""'"); 
  }
  arg4 = reinterpret_cast< Magick::Color * >(argp4);
  {
    try {
      (arg1)->levelColorsChannel(arg2,(Magick::Color const &)*arg3,(Magick::Color const &)*arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_levelColorsChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_levelColorsChannel__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_levelColorsChannel__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function levelColorsChannel.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_levelize__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_levelize" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_levelize" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_levelize" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_levelize" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    try {
      (arg1)->levelize(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_levelize__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_levelize" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_levelize" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_levelize" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->levelize(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_levelize(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_levelize__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_levelize__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function levelize.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_levelizeChannel__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_levelizeChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_levelizeChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_levelizeChannel" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_levelizeChannel" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  ecode5 = SWIG_AsVal_double(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_levelizeChannel" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = static_cast< double >(val5);
  {
    try {
      (arg1)->levelizeChannel(arg2,arg3,arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_levelizeChannel__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_levelizeChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_levelizeChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_levelizeChannel" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_levelizeChannel" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    try {
      (arg1)->levelizeChannel(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_levelizeChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_levelizeChannel__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_levelizeChannel__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function levelizeChannel.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_linearStretch(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_linearStretch.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_linearStretch" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_linearStretch" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_linearStretch" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->linearStretch(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_liquidRescale(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_liquidRescale.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_liquidRescale" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_liquidRescale" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_liquidRescale" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->liquidRescale((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_localContrast(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_localContrast.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_localContrast" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_localContrast" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_localContrast" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->localContrast(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_magnify(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_magnify.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_magnify" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->magnify();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_map__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_map" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_map" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_map" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  ecode3 = SWIG_AsVal_bool(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_map" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      (arg1)->map((Magick::Image const &)*arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_map__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_map" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_map" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_map" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  {
    try {
      (arg1)->map((Magick::Image const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_map(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_map__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_map__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function map.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_matteFloodfill(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Color *arg2 = 0 ;
  unsigned int arg3 ;
  ::ssize_t arg4 ;
  ::ssize_t arg5 ;
  Magick::PaintMethod arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  long val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  
  if(args.Length() != 5) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_matteFloodfill.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_matteFloodfill" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_matteFloodfill" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_matteFloodfill" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_matteFloodfill" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_long(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_matteFloodfill" "', argument " "4"" of type '" "::ssize_t""'");
  } 
  arg4 = static_cast< ::ssize_t >(val4);
  ecode5 = SWIG_AsVal_long(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_matteFloodfill" "', argument " "5"" of type '" "::ssize_t""'");
  } 
  arg5 = static_cast< ::ssize_t >(val5);
  ecode6 = SWIG_AsVal_int(args[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Image_matteFloodfill" "', argument " "6"" of type '" "Magick::PaintMethod""'");
  } 
  arg6 = static_cast< Magick::PaintMethod >(val6);
  {
    try {
      (arg1)->matteFloodfill((Magick::Color const &)*arg2,arg3,arg4,arg5,arg6);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_medianFilter__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_medianFilter" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_medianFilter" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->medianFilter(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_medianFilter__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_medianFilter" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->medianFilter();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_medianFilter(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_medianFilter__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_medianFilter__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function medianFilter.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_mergeLayers(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ImageLayerMethod arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_mergeLayers.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_mergeLayers" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_mergeLayers" "', argument " "2"" of type '" "Magick::ImageLayerMethod""'");
  } 
  arg2 = static_cast< Magick::ImageLayerMethod >(val2);
  {
    try {
      (arg1)->mergeLayers(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_minify(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_minify.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_minify" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->minify();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_modulate(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_modulate.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_modulate" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_modulate" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_modulate" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_modulate" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    try {
      (arg1)->modulate(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_moments(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::ImageMoments result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_moments.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_moments" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->moments();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::ImageMoments(result)), SWIGTYPE_p_Magick__ImageMoments, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_morphology__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::MorphologyMethod arg2 ;
  std::string arg3 ;
  ssize_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_morphology" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_morphology" "', argument " "2"" of type '" "Magick::MorphologyMethod""'");
  } 
  arg2 = static_cast< Magick::MorphologyMethod >(val2);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(args[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Image_morphology" "', argument " "3"" of type '" "std::string const""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  ecode4 = SWIG_AsVal_long(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_morphology" "', argument " "4"" of type '" "ssize_t""'");
  } 
  arg4 = static_cast< ssize_t >(val4);
  {
    try {
      (arg1)->morphology(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_morphology__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::MorphologyMethod arg2 ;
  std::string arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_morphology" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_morphology" "', argument " "2"" of type '" "Magick::MorphologyMethod""'");
  } 
  arg2 = static_cast< Magick::MorphologyMethod >(val2);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(args[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Image_morphology" "', argument " "3"" of type '" "std::string const""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      (arg1)->morphology(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_morphology__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::MorphologyMethod arg2 ;
  Magick::KernelInfoType arg3 ;
  std::string arg4 ;
  ssize_t arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  long val5 ;
  int ecode5 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_morphology" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_morphology" "', argument " "2"" of type '" "Magick::MorphologyMethod""'");
  } 
  arg2 = static_cast< Magick::MorphologyMethod >(val2);
  ecode3 = SWIG_AsVal_int(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_morphology" "', argument " "3"" of type '" "Magick::KernelInfoType""'");
  } 
  arg3 = static_cast< Magick::KernelInfoType >(val3);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(args[2], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Image_morphology" "', argument " "4"" of type '" "std::string const""'"); 
    }
    arg4 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  ecode5 = SWIG_AsVal_long(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_morphology" "', argument " "5"" of type '" "ssize_t""'");
  } 
  arg5 = static_cast< ssize_t >(val5);
  {
    try {
      (arg1)->morphology(arg2,arg3,arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_morphology__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::MorphologyMethod arg2 ;
  Magick::KernelInfoType arg3 ;
  std::string arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_morphology" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_morphology" "', argument " "2"" of type '" "Magick::MorphologyMethod""'");
  } 
  arg2 = static_cast< Magick::MorphologyMethod >(val2);
  ecode3 = SWIG_AsVal_int(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_morphology" "', argument " "3"" of type '" "Magick::KernelInfoType""'");
  } 
  arg3 = static_cast< Magick::KernelInfoType >(val3);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(args[2], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Image_morphology" "', argument " "4"" of type '" "std::string const""'"); 
    }
    arg4 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      (arg1)->morphology(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_morphology(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_morphology__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_morphology__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_morphology__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_morphology__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function morphology.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_morphologyChannel__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  Magick::MorphologyMethod arg3 ;
  std::string arg4 ;
  ssize_t arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  long val5 ;
  int ecode5 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_morphologyChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_morphologyChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_int(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_morphologyChannel" "', argument " "3"" of type '" "Magick::MorphologyMethod""'");
  } 
  arg3 = static_cast< Magick::MorphologyMethod >(val3);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(args[2], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Image_morphologyChannel" "', argument " "4"" of type '" "std::string const""'"); 
    }
    arg4 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  ecode5 = SWIG_AsVal_long(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_morphologyChannel" "', argument " "5"" of type '" "ssize_t""'");
  } 
  arg5 = static_cast< ssize_t >(val5);
  {
    try {
      (arg1)->morphologyChannel(arg2,arg3,arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_morphologyChannel__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  Magick::MorphologyMethod arg3 ;
  std::string arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_morphologyChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_morphologyChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_int(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_morphologyChannel" "', argument " "3"" of type '" "Magick::MorphologyMethod""'");
  } 
  arg3 = static_cast< Magick::MorphologyMethod >(val3);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(args[2], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Image_morphologyChannel" "', argument " "4"" of type '" "std::string const""'"); 
    }
    arg4 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      (arg1)->morphologyChannel(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_morphologyChannel__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  Magick::MorphologyMethod arg3 ;
  Magick::KernelInfoType arg4 ;
  std::string arg5 ;
  ssize_t arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  long val6 ;
  int ecode6 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_morphologyChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_morphologyChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_int(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_morphologyChannel" "', argument " "3"" of type '" "Magick::MorphologyMethod""'");
  } 
  arg3 = static_cast< Magick::MorphologyMethod >(val3);
  ecode4 = SWIG_AsVal_int(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_morphologyChannel" "', argument " "4"" of type '" "Magick::KernelInfoType""'");
  } 
  arg4 = static_cast< Magick::KernelInfoType >(val4);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(args[3], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Image_morphologyChannel" "', argument " "5"" of type '" "std::string const""'"); 
    }
    arg5 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  ecode6 = SWIG_AsVal_long(args[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Image_morphologyChannel" "', argument " "6"" of type '" "ssize_t""'");
  } 
  arg6 = static_cast< ssize_t >(val6);
  {
    try {
      (arg1)->morphologyChannel(arg2,arg3,arg4,arg5,arg6);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_morphologyChannel__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  Magick::MorphologyMethod arg3 ;
  Magick::KernelInfoType arg4 ;
  std::string arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_morphologyChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_morphologyChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_int(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_morphologyChannel" "', argument " "3"" of type '" "Magick::MorphologyMethod""'");
  } 
  arg3 = static_cast< Magick::MorphologyMethod >(val3);
  ecode4 = SWIG_AsVal_int(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_morphologyChannel" "', argument " "4"" of type '" "Magick::KernelInfoType""'");
  } 
  arg4 = static_cast< Magick::KernelInfoType >(val4);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(args[3], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Image_morphologyChannel" "', argument " "5"" of type '" "std::string const""'"); 
    }
    arg5 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      (arg1)->morphologyChannel(arg2,arg3,arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_morphologyChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_morphologyChannel__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_morphologyChannel__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 5) {
    errorHandler.err.Clear();
    _wrap_Image_morphologyChannel__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_morphologyChannel__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function morphologyChannel.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_motionBlur(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_motionBlur.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_motionBlur" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_motionBlur" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_motionBlur" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_motionBlur" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    try {
      (arg1)->motionBlur(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_negate__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_negate" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_negate" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->negate(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_negate__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_negate" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->negate();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_negate(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_negate__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_negate__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function negate.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_negateChannel__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_negateChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_negateChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_bool(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_negateChannel" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      (arg1)->negateChannel(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_negateChannel__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_negateChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_negateChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  {
    try {
      (arg1)->negateChannel(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_negateChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_negateChannel__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_negateChannel__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function negateChannel.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_normalize(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_normalize.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_normalize" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->normalize();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_oilPaint__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_oilPaint" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_oilPaint" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->oilPaint(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_oilPaint__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_oilPaint" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->oilPaint();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_oilPaint(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_oilPaint__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_oilPaint__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function oilPaint.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_opacity(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_opacity.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_opacity" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_opacity" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      (arg1)->opacity(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_opaque__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Color *arg2 = 0 ;
  Magick::Color *arg3 = 0 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_opaque" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_opaque" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_opaque" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_opaque" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_opaque" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Color * >(argp3);
  ecode4 = SWIG_AsVal_bool(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_opaque" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      (arg1)->opaque((Magick::Color const &)*arg2,(Magick::Color const &)*arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_opaque__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Color *arg2 = 0 ;
  Magick::Color *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_opaque" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_opaque" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_opaque" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_opaque" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_opaque" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Color * >(argp3);
  {
    try {
      (arg1)->opaque((Magick::Color const &)*arg2,(Magick::Color const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_opaque(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_opaque__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_opaque__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function opaque.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_orderedDither(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_orderedDither.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_orderedDither" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Image_orderedDither" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      (arg1)->orderedDither(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_orderedDitherChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  std::string arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_orderedDitherChannel.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_orderedDitherChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_orderedDitherChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(args[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Image_orderedDitherChannel" "', argument " "3"" of type '" "std::string""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      (arg1)->orderedDitherChannel(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_perceptible(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_perceptible.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_perceptible" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_perceptible" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->perceptible(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_perceptibleChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_perceptibleChannel.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_perceptibleChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_perceptibleChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_perceptibleChannel" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->perceptibleChannel(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_ping__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Blob *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_ping" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Blob,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_ping" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_ping" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Blob * >(argp2);
  {
    try {
      (arg1)->ping((Magick::Blob const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_ping__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_ping" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_ping" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_ping" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->ping((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_ping(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_ping__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_ping__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function ping.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_pixelColor__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  Magick::Color *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_pixelColor" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_pixelColor" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_pixelColor" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  res4 = SWIG_ConvertPtr(args[2], &argp4, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Image_pixelColor" "', argument " "4"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_pixelColor" "', argument " "4"" of type '" "Magick::Color const &""'"); 
  }
  arg4 = reinterpret_cast< Magick::Color * >(argp4);
  {
    try {
      (arg1)->pixelColor(arg2,arg3,(Magick::Color const &)*arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_pixelColor__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  Magick::Color result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_pixelColor" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_pixelColor" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_pixelColor" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  {
    try {
      result = ((Magick::Image const *)arg1)->pixelColor(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Color(result)), SWIGTYPE_p_Magick__Color, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_pixelColor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_pixelColor__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_pixelColor__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function pixelColor.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_polaroid(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  double val3 ;
  int ecode3 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_polaroid.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_polaroid" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_polaroid" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_polaroid" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_polaroid" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->polaroid((std::string const &)*arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_posterize__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_posterize" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_posterize" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_bool(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_posterize" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      (arg1)->posterize(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_posterize__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_posterize" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_posterize" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      (arg1)->posterize(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_posterize(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_posterize__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_posterize__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function posterize.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_posterizeChannel__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  size_t arg3 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_posterizeChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_posterizeChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_size_t(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_posterizeChannel" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  ecode4 = SWIG_AsVal_bool(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_posterizeChannel" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      (arg1)->posterizeChannel(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_posterizeChannel__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_posterizeChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_posterizeChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_size_t(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_posterizeChannel" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  {
    try {
      (arg1)->posterizeChannel(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_posterizeChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_posterizeChannel__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_posterizeChannel__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function posterizeChannel.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_process(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string arg2 ;
  ::ssize_t arg3 ;
  char **arg4 = (char **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_process.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_process" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Image_process" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  ecode3 = SWIG_AsVal_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_process" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  res4 = SWIG_ConvertPtr(args[2], &argp4,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Image_process" "', argument " "4"" of type '" "char const **""'"); 
  }
  arg4 = reinterpret_cast< char ** >(argp4);
  {
    try {
      (arg1)->process(arg2,arg3,(char const **)arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_profile__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string arg2 ;
  Magick::Blob *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_profile" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Image_profile" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Blob,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_profile" "', argument " "3"" of type '" "Magick::Blob const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_profile" "', argument " "3"" of type '" "Magick::Blob const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Blob * >(argp3);
  {
    try {
      (arg1)->profile(arg2,(Magick::Blob const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_profile__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Blob result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_profile" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Image_profile" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      result = ((Magick::Image const *)arg1)->profile(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Blob(result)), SWIGTYPE_p_Magick__Blob, SWIG_POINTER_OWN |  0 );
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_profile(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_profile__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_profile__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function profile.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_quantize__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_quantize" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_quantize" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      (arg1)->quantize(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_quantize__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_quantize" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->quantize();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_quantize(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_quantize__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_quantize__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function quantize.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_quantumOperator__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  Magick::MagickEvaluateOperator arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_quantumOperator" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_quantumOperator" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_int(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_quantumOperator" "', argument " "3"" of type '" "Magick::MagickEvaluateOperator""'");
  } 
  arg3 = static_cast< Magick::MagickEvaluateOperator >(val3);
  ecode4 = SWIG_AsVal_double(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_quantumOperator" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    try {
      (arg1)->quantumOperator(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_quantumOperator__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  Magick::MagickFunction arg3 ;
  size_t arg4 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_quantumOperator" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_quantumOperator" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_int(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_quantumOperator" "', argument " "3"" of type '" "Magick::MagickFunction""'");
  } 
  arg3 = static_cast< Magick::MagickFunction >(val3);
  ecode4 = SWIG_AsVal_size_t(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_quantumOperator" "', argument " "4"" of type '" "size_t""'");
  } 
  arg4 = static_cast< size_t >(val4);
  res5 = SWIG_ConvertPtr(args[3], &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Image_quantumOperator" "', argument " "5"" of type '" "double const *""'"); 
  }
  arg5 = reinterpret_cast< double * >(argp5);
  {
    try {
      (arg1)->quantumOperator(arg2,arg3,arg4,(double const *)arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_quantumOperator__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  size_t arg4 ;
  size_t arg5 ;
  Magick::ChannelType arg6 ;
  Magick::MagickEvaluateOperator arg7 ;
  double arg8 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  double val8 ;
  int ecode8 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_quantumOperator" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_quantumOperator" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_quantumOperator" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  ecode4 = SWIG_AsVal_size_t(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_quantumOperator" "', argument " "4"" of type '" "size_t""'");
  } 
  arg4 = static_cast< size_t >(val4);
  ecode5 = SWIG_AsVal_size_t(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_quantumOperator" "', argument " "5"" of type '" "size_t""'");
  } 
  arg5 = static_cast< size_t >(val5);
  ecode6 = SWIG_AsVal_int(args[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Image_quantumOperator" "', argument " "6"" of type '" "Magick::ChannelType""'");
  } 
  arg6 = static_cast< Magick::ChannelType >(val6);
  ecode7 = SWIG_AsVal_int(args[5], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Image_quantumOperator" "', argument " "7"" of type '" "Magick::MagickEvaluateOperator""'");
  } 
  arg7 = static_cast< Magick::MagickEvaluateOperator >(val7);
  ecode8 = SWIG_AsVal_double(args[6], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "Image_quantumOperator" "', argument " "8"" of type '" "double""'");
  } 
  arg8 = static_cast< double >(val8);
  {
    try {
      (arg1)->quantumOperator(arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_quantumOperator(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_quantumOperator__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_quantumOperator__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 7) {
    errorHandler.err.Clear();
    _wrap_Image_quantumOperator__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function quantumOperator.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_raise__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_raise" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_raise" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_raise" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  ecode3 = SWIG_AsVal_bool(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_raise" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      (arg1)->raise((Magick::Geometry const &)*arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_raise__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_raise" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_raise" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_raise" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->raise((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_raise__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_raise" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->raise();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_raise(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_raise__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_raise__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_raise__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function raise.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_randomThreshold(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_randomThreshold.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_randomThreshold" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_randomThreshold" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_randomThreshold" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->randomThreshold((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_randomThresholdChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  Magick::ChannelType arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_randomThresholdChannel.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_randomThresholdChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_randomThresholdChannel" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_randomThresholdChannel" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  ecode3 = SWIG_AsVal_int(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_randomThresholdChannel" "', argument " "3"" of type '" "Magick::ChannelType""'");
  } 
  arg3 = static_cast< Magick::ChannelType >(val3);
  {
    try {
      (arg1)->randomThresholdChannel((Magick::Geometry const &)*arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_read__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Blob *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_read" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Blob,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_read" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_read" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Blob * >(argp2);
  {
    try {
      (arg1)->read((Magick::Blob const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_read__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Blob *arg2 = 0 ;
  Magick::Geometry *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_read" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Blob,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_read" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_read" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Blob * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_read" "', argument " "3"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_read" "', argument " "3"" of type '" "Magick::Geometry const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Geometry * >(argp3);
  {
    try {
      (arg1)->read((Magick::Blob const &)*arg2,(Magick::Geometry const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_read__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Blob *arg2 = 0 ;
  Magick::Geometry *arg3 = 0 ;
  size_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_read" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Blob,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_read" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_read" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Blob * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_read" "', argument " "3"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_read" "', argument " "3"" of type '" "Magick::Geometry const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Geometry * >(argp3);
  ecode4 = SWIG_AsVal_size_t(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_read" "', argument " "4"" of type '" "size_t""'");
  } 
  arg4 = static_cast< size_t >(val4);
  {
    try {
      (arg1)->read((Magick::Blob const &)*arg2,(Magick::Geometry const &)*arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_read__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Blob *arg2 = 0 ;
  Magick::Geometry *arg3 = 0 ;
  size_t arg4 ;
  std::string *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  int res5 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_read" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Blob,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_read" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_read" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Blob * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_read" "', argument " "3"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_read" "', argument " "3"" of type '" "Magick::Geometry const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Geometry * >(argp3);
  ecode4 = SWIG_AsVal_size_t(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_read" "', argument " "4"" of type '" "size_t""'");
  } 
  arg4 = static_cast< size_t >(val4);
  {
    std::string *ptr = (std::string *)0;
    res5 = SWIG_AsPtr_std_string(args[3], &ptr);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Image_read" "', argument " "5"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_read" "', argument " "5"" of type '" "std::string const &""'"); 
    }
    arg5 = ptr;
  }
  {
    try {
      (arg1)->read((Magick::Blob const &)*arg2,(Magick::Geometry const &)*arg3,arg4,(std::string const &)*arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  if (SWIG_IsNewObj(res5)) delete arg5;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_read__SWIG_4(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Blob *arg2 = 0 ;
  Magick::Geometry *arg3 = 0 ;
  std::string *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_read" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Blob,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_read" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_read" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Blob * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_read" "', argument " "3"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_read" "', argument " "3"" of type '" "Magick::Geometry const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Geometry * >(argp3);
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(args[2], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Image_read" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_read" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  {
    try {
      (arg1)->read((Magick::Blob const &)*arg2,(Magick::Geometry const &)*arg3,(std::string const &)*arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  if (SWIG_IsNewObj(res4)) delete arg4;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_read__SWIG_5(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_read" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_read" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_read" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(args[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_read" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_read" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    try {
      (arg1)->read((Magick::Geometry const &)*arg2,(std::string const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  if (SWIG_IsNewObj(res3)) delete arg3;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_read__SWIG_6(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  std::string *arg4 = 0 ;
  Magick::StorageType arg5 ;
  void *arg6 = (void *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  int val5 ;
  int ecode5 = 0 ;
  int res6 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_read" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_read" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_size_t(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_read" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(args[2], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Image_read" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_read" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  ecode5 = SWIG_AsVal_int(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_read" "', argument " "5"" of type '" "Magick::StorageType""'");
  } 
  arg5 = static_cast< Magick::StorageType >(val5);
  res6 = SWIG_ConvertPtr(args[4],SWIG_as_voidptrptr(&arg6), 0, 0);
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "Image_read" "', argument " "6"" of type '" "void const *""'"); 
  }
  {
    try {
      (arg1)->read(arg2,arg3,(std::string const &)*arg4,arg5,(void const *)arg6);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  if (SWIG_IsNewObj(res4)) delete arg4;
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_read__SWIG_7(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_read" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_read" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_read" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->read((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_read(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_read__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_read__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_read__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_read__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_read__SWIG_4(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_read__SWIG_5(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 5) {
    errorHandler.err.Clear();
    _wrap_Image_read__SWIG_6(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_read__SWIG_7(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function read.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_readPixels(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::QuantumType arg2 ;
  unsigned char *arg3 = (unsigned char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_readPixels.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_readPixels" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_readPixels" "', argument " "2"" of type '" "Magick::QuantumType""'");
  } 
  arg2 = static_cast< Magick::QuantumType >(val2);
  res3 = SWIG_ConvertPtr(args[1], &argp3,SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_readPixels" "', argument " "3"" of type '" "unsigned char const *""'"); 
  }
  arg3 = reinterpret_cast< unsigned char * >(argp3);
  {
    try {
      (arg1)->readPixels(arg2,(unsigned char const *)arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_reduceNoise__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_reduceNoise" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->reduceNoise();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_reduceNoise__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_reduceNoise" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_reduceNoise" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->reduceNoise(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_reduceNoise(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_reduceNoise__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_reduceNoise__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function reduceNoise.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_repage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_repage.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_repage" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->repage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_resample(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_resample.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_resample" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_resample" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_resample" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->resample((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_resize(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_resize.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_resize" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_resize" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_resize" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->resize((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_roll__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_roll" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_roll" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_roll" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->roll((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_roll__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_roll" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_roll" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_size_t(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_roll" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  {
    try {
      (arg1)->roll(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_roll(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_roll__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_roll__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function roll.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_rotate(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_rotate.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_rotate" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_rotate" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->rotate(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_rotationalBlur(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_rotationalBlur.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_rotationalBlur" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_rotationalBlur" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->rotationalBlur(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_rotationalBlurChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_rotationalBlurChannel.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_rotationalBlurChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_rotationalBlurChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_rotationalBlurChannel" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->rotationalBlurChannel(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_sample(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_sample.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_sample" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_sample" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_sample" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->sample((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_scale(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_scale.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_scale" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_scale" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_scale" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->scale((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_segment__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_segment" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_segment" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_segment" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->segment(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_segment__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_segment" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_segment" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->segment(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_segment__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_segment" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->segment();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_segment(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_segment__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_segment__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_segment__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function segment.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_selectiveBlur(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_selectiveBlur.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_selectiveBlur" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_selectiveBlur" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_selectiveBlur" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_selectiveBlur" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    try {
      (arg1)->selectiveBlur(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_selectiveBlurChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_selectiveBlurChannel.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_selectiveBlurChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_selectiveBlurChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_selectiveBlurChannel" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_selectiveBlurChannel" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  ecode5 = SWIG_AsVal_double(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_selectiveBlurChannel" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = static_cast< double >(val5);
  {
    try {
      (arg1)->selectiveBlurChannel(arg2,arg3,arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_separate(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  Magick::Image result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_separate.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_separate" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_separate" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  {
    try {
      result = ((Magick::Image const *)arg1)->separate(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Image(result)), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN |  0 );
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_sepiaTone(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_sepiaTone.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_sepiaTone" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_sepiaTone" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->sepiaTone(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_setPixels(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  size_t arg4 ;
  size_t arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PixelPacket *result = 0 ;
  
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_setPixels.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_setPixels" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_setPixels" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_setPixels" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  ecode4 = SWIG_AsVal_size_t(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_setPixels" "', argument " "4"" of type '" "size_t""'");
  } 
  arg4 = static_cast< size_t >(val4);
  ecode5 = SWIG_AsVal_size_t(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_setPixels" "', argument " "5"" of type '" "size_t""'");
  } 
  arg5 = static_cast< size_t >(val5);
  {
    try {
      result = (PixelPacket *)(arg1)->setPixels(arg2,arg3,arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_PixelPacket, 0 |  0 );
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_shade__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_shade" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_shade" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_shade" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_bool(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_shade" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      (arg1)->shade(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_shade__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_shade" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_shade" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_shade" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->shade(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_shade__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_shade" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_shade" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->shade(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_shade__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_shade" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->shade();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_shade(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_shade__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_shade__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_shade__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_shade__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function shade.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_shadow__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  ssize_t arg4 ;
  ssize_t arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  long val5 ;
  int ecode5 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_shadow" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_shadow" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_shadow" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_long(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_shadow" "', argument " "4"" of type '" "ssize_t""'");
  } 
  arg4 = static_cast< ssize_t >(val4);
  ecode5 = SWIG_AsVal_long(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_shadow" "', argument " "5"" of type '" "ssize_t""'");
  } 
  arg5 = static_cast< ssize_t >(val5);
  {
    try {
      (arg1)->shadow(arg2,arg3,arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_shadow__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  ssize_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_shadow" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_shadow" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_shadow" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_long(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_shadow" "', argument " "4"" of type '" "ssize_t""'");
  } 
  arg4 = static_cast< ssize_t >(val4);
  {
    try {
      (arg1)->shadow(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_shadow__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_shadow" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_shadow" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_shadow" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->shadow(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_shadow__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_shadow" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_shadow" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->shadow(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_shadow__SWIG_4(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_shadow" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->shadow();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_shadow(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_shadow__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_shadow__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_shadow__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_shadow__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_shadow__SWIG_4(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function shadow.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_sharpen__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_sharpen" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_sharpen" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_sharpen" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->sharpen(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_sharpen__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_sharpen" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_sharpen" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->sharpen(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_sharpen__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_sharpen" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->sharpen();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_sharpen(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_sharpen__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_sharpen__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_sharpen__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function sharpen.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_sharpenChannel__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_sharpenChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_sharpenChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_sharpenChannel" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_sharpenChannel" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    try {
      (arg1)->sharpenChannel(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_sharpenChannel__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_sharpenChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_sharpenChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_sharpenChannel" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->sharpenChannel(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_sharpenChannel__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_sharpenChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_sharpenChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  {
    try {
      (arg1)->sharpenChannel(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_sharpenChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_sharpenChannel__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_sharpenChannel__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_sharpenChannel__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function sharpenChannel.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_shave(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_shave.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_shave" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_shave" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_shave" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->shave((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_shear(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_shear.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_shear" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_shear" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_shear" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->shear(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_sigmoidalContrast__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_sigmoidalContrast" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_sigmoidalContrast" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_sigmoidalContrast" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_sigmoidalContrast" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    try {
      (arg1)->sigmoidalContrast(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_sigmoidalContrast__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_sigmoidalContrast" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_sigmoidalContrast" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_sigmoidalContrast" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->sigmoidalContrast(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_sigmoidalContrast(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_sigmoidalContrast__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_sigmoidalContrast__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function sigmoidalContrast.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_signature__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_signature" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_bool(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_signature" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      result = ((Magick::Image const *)arg1)->signature(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_signature__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_signature" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->signature();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_From_std_string(static_cast< std::string >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_signature(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_signature__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_signature__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function signature.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_sketch__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_sketch" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_sketch" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_sketch" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_sketch" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  {
    try {
      (arg1)->sketch(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_sketch__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_sketch" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_sketch" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_sketch" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->sketch(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_sketch__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_sketch" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_sketch" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->sketch(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_sketch__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_sketch" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->sketch();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_sketch(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_sketch__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_sketch__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_sketch__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_sketch__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function sketch.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_solarize__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_solarize" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_solarize" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->solarize(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_solarize__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_solarize" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->solarize();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_solarize(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_solarize__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_solarize__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function solarize.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_sparseColor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  Magick::SparseColorMethod arg3 ;
  size_t arg4 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_sparseColor.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_sparseColor" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_sparseColor" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_int(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_sparseColor" "', argument " "3"" of type '" "Magick::SparseColorMethod""'");
  } 
  arg3 = static_cast< Magick::SparseColorMethod >(val3);
  ecode4 = SWIG_AsVal_size_t(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_sparseColor" "', argument " "4"" of type '" "size_t""'");
  } 
  arg4 = static_cast< size_t >(val4);
  res5 = SWIG_ConvertPtr(args[3], &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Image_sparseColor" "', argument " "5"" of type '" "double const *""'"); 
  }
  arg5 = reinterpret_cast< double * >(argp5);
  {
    try {
      (arg1)->sparseColor(arg2,arg3,arg4,(double const *)arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_splice__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_splice" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_splice" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_splice" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->splice((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_splice__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  Magick::Color *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_splice" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_splice" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_splice" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_splice" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_splice" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Color * >(argp3);
  {
    try {
      (arg1)->splice((Magick::Geometry const &)*arg2,(Magick::Color const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_splice__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  Magick::Color *arg3 = 0 ;
  Magick::GravityType arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_splice" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_splice" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_splice" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_splice" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_splice" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Color * >(argp3);
  ecode4 = SWIG_AsVal_int(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_splice" "', argument " "4"" of type '" "Magick::GravityType""'");
  } 
  arg4 = static_cast< Magick::GravityType >(val4);
  {
    try {
      (arg1)->splice((Magick::Geometry const &)*arg2,(Magick::Color const &)*arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_splice(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_splice__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_splice__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_splice__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function splice.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_spread__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_spread" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_size_t(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_spread" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      (arg1)->spread(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_spread__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_spread" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->spread();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_spread(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_spread__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_spread__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function spread.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_statistics(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image::ImageStatistics *arg2 = (Magick::Image::ImageStatistics *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_statistics.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_statistics" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p_Magick__Image___ImageStatistics, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_statistics" "', argument " "2"" of type '" "Magick::Image::ImageStatistics *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image::ImageStatistics * >(argp2);
  {
    try {
      ((Magick::Image const *)arg1)->statistics(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_stegano(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_stegano.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_stegano" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_stegano" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_stegano" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  {
    try {
      (arg1)->stegano((Magick::Image const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_stereo(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_stereo.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_stereo" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_stereo" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_stereo" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  {
    try {
      (arg1)->stereo((Magick::Image const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_strip(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_strip.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_strip" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->strip();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_subImageSearch__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  Magick::MetricType arg3 ;
  Magick::Geometry *arg4 = (Magick::Geometry *) 0 ;
  double *arg5 = (double *) 0 ;
  double arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  Magick::Image result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_subImageSearch" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_subImageSearch" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_subImageSearch" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  ecode3 = SWIG_AsVal_int(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_subImageSearch" "', argument " "3"" of type '" "Magick::MetricType""'");
  } 
  arg3 = static_cast< Magick::MetricType >(val3);
  res4 = SWIG_ConvertPtr(args[2], &argp4,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Image_subImageSearch" "', argument " "4"" of type '" "Magick::Geometry *""'"); 
  }
  arg4 = reinterpret_cast< Magick::Geometry * >(argp4);
  res5 = SWIG_ConvertPtr(args[3], &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Image_subImageSearch" "', argument " "5"" of type '" "double *""'"); 
  }
  arg5 = reinterpret_cast< double * >(argp5);
  ecode6 = SWIG_AsVal_double(args[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Image_subImageSearch" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = static_cast< double >(val6);
  {
    try {
      result = (arg1)->subImageSearch((Magick::Image const &)*arg2,arg3,arg4,arg5,arg6);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Image(result)), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN |  0 );
  
  
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_subImageSearch__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  Magick::MetricType arg3 ;
  Magick::Geometry *arg4 = (Magick::Geometry *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  Magick::Image result;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_subImageSearch" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_subImageSearch" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_subImageSearch" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  ecode3 = SWIG_AsVal_int(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_subImageSearch" "', argument " "3"" of type '" "Magick::MetricType""'");
  } 
  arg3 = static_cast< Magick::MetricType >(val3);
  res4 = SWIG_ConvertPtr(args[2], &argp4,SWIGTYPE_p_Magick__Geometry, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Image_subImageSearch" "', argument " "4"" of type '" "Magick::Geometry *""'"); 
  }
  arg4 = reinterpret_cast< Magick::Geometry * >(argp4);
  res5 = SWIG_ConvertPtr(args[3], &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Image_subImageSearch" "', argument " "5"" of type '" "double *""'"); 
  }
  arg5 = reinterpret_cast< double * >(argp5);
  {
    try {
      result = (arg1)->subImageSearch((Magick::Image const &)*arg2,arg3,arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Image(result)), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN |  0 );
  
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_subImageSearch(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 5) {
    errorHandler.err.Clear();
    _wrap_Image_subImageSearch__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_subImageSearch__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function subImageSearch.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_swirl(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_swirl.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_swirl" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_swirl" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->swirl(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_syncPixels(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_syncPixels.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_syncPixels" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->syncPixels();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_texture(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_texture.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_texture" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_texture" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_texture" "', argument " "2"" of type '" "Magick::Image const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Image * >(argp2);
  {
    try {
      (arg1)->texture((Magick::Image const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_threshold(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_threshold.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_threshold" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_threshold" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->threshold(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_thumbnail(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_thumbnail.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_thumbnail" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_thumbnail" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_thumbnail" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->thumbnail((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_tint(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_tint.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_tint" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Image_tint" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      (arg1)->tint(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_transform__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_transform" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_transform" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_transform" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->transform((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_transform__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  Magick::Geometry *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_transform" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_transform" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_transform" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_transform" "', argument " "3"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_transform" "', argument " "3"" of type '" "Magick::Geometry const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Geometry * >(argp3);
  {
    try {
      (arg1)->transform((Magick::Geometry const &)*arg2,(Magick::Geometry const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_transform(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_transform__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_transform__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function transform.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_transformOrigin(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_transformOrigin.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_transformOrigin" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_transformOrigin" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_transformOrigin" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->transformOrigin(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_transformReset(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_transformReset.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_transformReset" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->transformReset();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_transformScale(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_transformScale.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_transformScale" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_transformScale" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_transformScale" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->transformScale(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_transparent(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_transparent.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_transparent" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_transparent" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_transparent" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  {
    try {
      (arg1)->transparent((Magick::Color const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_transparentChroma(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Color *arg2 = 0 ;
  Magick::Color *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_transparentChroma.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_transparentChroma" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_transparentChroma" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_transparentChroma" "', argument " "2"" of type '" "Magick::Color const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Color * >(argp2);
  res3 = SWIG_ConvertPtr(args[1], &argp3, SWIGTYPE_p_Magick__Color,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_transparentChroma" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_transparentChroma" "', argument " "3"" of type '" "Magick::Color const &""'"); 
  }
  arg3 = reinterpret_cast< Magick::Color * >(argp3);
  {
    try {
      (arg1)->transparentChroma((Magick::Color const &)*arg2,(Magick::Color const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_transpose(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_transpose.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_transpose" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->transpose();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_transverse(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_transverse.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_transverse" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->transverse();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_trim(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_trim.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_trim" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->trim();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_uniqueColors(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Image result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_uniqueColors.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_uniqueColors" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = ((Magick::Image const *)arg1)->uniqueColors();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj((new Magick::Image(result)), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_unsharpmask(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_unsharpmask.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_unsharpmask" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_unsharpmask" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_unsharpmask" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_unsharpmask" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  ecode5 = SWIG_AsVal_double(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_unsharpmask" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = static_cast< double >(val5);
  {
    try {
      (arg1)->unsharpmask(arg2,arg3,arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_unsharpmaskChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  
  if(args.Length() != 5) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_unsharpmaskChannel.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_unsharpmaskChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_unsharpmaskChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_unsharpmaskChannel" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_unsharpmaskChannel" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  ecode5 = SWIG_AsVal_double(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_unsharpmaskChannel" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = static_cast< double >(val5);
  ecode6 = SWIG_AsVal_double(args[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Image_unsharpmaskChannel" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = static_cast< double >(val6);
  {
    try {
      (arg1)->unsharpmaskChannel(arg2,arg3,arg4,arg5,arg6);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_vignette__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  ssize_t arg4 ;
  ssize_t arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  long val5 ;
  int ecode5 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_vignette" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_vignette" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_vignette" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_long(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_vignette" "', argument " "4"" of type '" "ssize_t""'");
  } 
  arg4 = static_cast< ssize_t >(val4);
  ecode5 = SWIG_AsVal_long(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_vignette" "', argument " "5"" of type '" "ssize_t""'");
  } 
  arg5 = static_cast< ssize_t >(val5);
  {
    try {
      (arg1)->vignette(arg2,arg3,arg4,arg5);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_vignette__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  ssize_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_vignette" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_vignette" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_vignette" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_long(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_vignette" "', argument " "4"" of type '" "ssize_t""'");
  } 
  arg4 = static_cast< ssize_t >(val4);
  {
    try {
      (arg1)->vignette(arg2,arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_vignette__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_vignette" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_vignette" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_vignette" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->vignette(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_vignette__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_vignette" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_vignette" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->vignette(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_vignette__SWIG_4(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_vignette" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->vignette();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_vignette(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_Image_vignette__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_vignette__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_vignette__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_vignette__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_vignette__SWIG_4(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function vignette.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_wave__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_wave" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_wave" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_wave" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->wave(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_wave__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_wave" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_wave" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->wave(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_wave__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_wave" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->wave();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_wave(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_wave__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_wave__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_Image_wave__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function wave.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_waveletDenoise(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_waveletDenoise.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_waveletDenoise" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_double(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_waveletDenoise" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_waveletDenoise" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->waveletDenoise(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_whiteThreshold(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_whiteThreshold.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_whiteThreshold" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_whiteThreshold" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_whiteThreshold" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->whiteThreshold((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_whiteThresholdChannel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::ChannelType arg2 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_whiteThresholdChannel.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_whiteThresholdChannel" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_whiteThresholdChannel" "', argument " "2"" of type '" "Magick::ChannelType""'");
  } 
  arg2 = static_cast< Magick::ChannelType >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(args[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_whiteThresholdChannel" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_whiteThresholdChannel" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    try {
      (arg1)->whiteThresholdChannel(arg2,(std::string const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  if (SWIG_IsNewObj(res3)) delete arg3;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_write__SWIG_0(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Blob *arg2 = (Magick::Blob *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_write" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p_Magick__Blob, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_write" "', argument " "2"" of type '" "Magick::Blob *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Blob * >(argp2);
  {
    try {
      (arg1)->write(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_write__SWIG_1(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Blob *arg2 = (Magick::Blob *) 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_write" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p_Magick__Blob, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_write" "', argument " "2"" of type '" "Magick::Blob *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Blob * >(argp2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(args[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_write" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_write" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    try {
      (arg1)->write(arg2,(std::string const &)*arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  if (SWIG_IsNewObj(res3)) delete arg3;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_write__SWIG_2(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Blob *arg2 = (Magick::Blob *) 0 ;
  std::string *arg3 = 0 ;
  size_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  size_t val4 ;
  int ecode4 = 0 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_write" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p_Magick__Blob, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_write" "', argument " "2"" of type '" "Magick::Blob *""'"); 
  }
  arg2 = reinterpret_cast< Magick::Blob * >(argp2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(args[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_write" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_write" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  ecode4 = SWIG_AsVal_size_t(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_write" "', argument " "4"" of type '" "size_t""'");
  } 
  arg4 = static_cast< size_t >(val4);
  {
    try {
      (arg1)->write(arg2,(std::string const &)*arg3,arg4);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  if (SWIG_IsNewObj(res3)) delete arg3;
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_write__SWIG_3(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ::ssize_t arg2 ;
  ::ssize_t arg3 ;
  size_t arg4 ;
  size_t arg5 ;
  std::string *arg6 = 0 ;
  Magick::StorageType arg7 ;
  void *arg8 = (void *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  int res6 = SWIG_OLDOBJ ;
  int val7 ;
  int ecode7 = 0 ;
  int res8 ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_write" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_long(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_write" "', argument " "2"" of type '" "::ssize_t""'");
  } 
  arg2 = static_cast< ::ssize_t >(val2);
  ecode3 = SWIG_AsVal_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Image_write" "', argument " "3"" of type '" "::ssize_t""'");
  } 
  arg3 = static_cast< ::ssize_t >(val3);
  ecode4 = SWIG_AsVal_size_t(args[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Image_write" "', argument " "4"" of type '" "size_t""'");
  } 
  arg4 = static_cast< size_t >(val4);
  ecode5 = SWIG_AsVal_size_t(args[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Image_write" "', argument " "5"" of type '" "size_t""'");
  } 
  arg5 = static_cast< size_t >(val5);
  {
    std::string *ptr = (std::string *)0;
    res6 = SWIG_AsPtr_std_string(args[4], &ptr);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "Image_write" "', argument " "6"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_write" "', argument " "6"" of type '" "std::string const &""'"); 
    }
    arg6 = ptr;
  }
  ecode7 = SWIG_AsVal_int(args[5], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Image_write" "', argument " "7"" of type '" "Magick::StorageType""'");
  } 
  arg7 = static_cast< Magick::StorageType >(val7);
  res8 = SWIG_ConvertPtr(args[6],SWIG_as_voidptrptr(&arg8), 0, 0);
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "Image_write" "', argument " "8"" of type '" "void *""'"); 
  }
  {
    try {
      (arg1)->write(arg2,arg3,arg4,arg5,(std::string const &)*arg6,arg7,arg8);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  if (SWIG_IsNewObj(res6)) delete arg6;
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_write__SWIG_4(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler)
{
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_write" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(args[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_write" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_write" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->write((std::string const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image__wrap_Image_write(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  OverloadErrorHandler errorHandler;
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_write__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_Image_write__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_Image_write__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 7) {
    errorHandler.err.Clear();
    _wrap_Image_write__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_Image_write__SWIG_4(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for function write.");
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_writePixels(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::QuantumType arg2 ;
  unsigned char *arg3 = (unsigned char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_writePixels.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_writePixels" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Image_writePixels" "', argument " "2"" of type '" "Magick::QuantumType""'");
  } 
  arg2 = static_cast< Magick::QuantumType >(val2);
  res3 = SWIG_ConvertPtr(args[1], &argp3,SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Image_writePixels" "', argument " "3"" of type '" "unsigned char *""'"); 
  }
  arg3 = reinterpret_cast< unsigned char * >(argp3);
  {
    try {
      (arg1)->writePixels(arg2,arg3);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_zoom(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_zoom.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_zoom" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_zoom" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Image_zoom" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
  }
  arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
  {
    try {
      (arg1)->zoom((Magick::Geometry const &)*arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Image__SWIG_11(const SwigV8Arguments &args, V8ErrorHandler &SWIGV8_ErrorHandler) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_OBJECT self = args.Holder();
  MagickCore::Image *arg1 = (MagickCore::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Image *result;
  if(self->InternalFieldCount() < 1) SWIG_exception_fail(SWIG_ERROR, "Illegal call of constructor _wrap_new_Image__SWIG_11.");
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Image__SWIG_11.");
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_MagickCore___Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Image" "', argument " "1"" of type '" "MagickCore::Image *""'"); 
  }
  arg1 = reinterpret_cast< MagickCore::Image * >(argp1);
  {
    try {
      result = (Magick::Image *)new Magick::Image(arg1);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Image(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  OverloadErrorHandler errorHandler;
  SWIGV8_VALUE self;
  
  // switch all cases by means of series of if-returns.
  
  if(args.Length() == 0) {
    errorHandler.err.Clear();
    _wrap_new_Image__SWIG_0(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_Image__SWIG_1(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_Image__SWIG_2(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_Image__SWIG_3(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 4) {
    errorHandler.err.Clear();
    _wrap_new_Image__SWIG_4(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 3) {
    errorHandler.err.Clear();
    _wrap_new_Image__SWIG_5(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_Image__SWIG_6(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_Image__SWIG_7(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 2) {
    errorHandler.err.Clear();
    _wrap_new_Image__SWIG_8(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 5) {
    errorHandler.err.Clear();
    _wrap_new_Image__SWIG_9(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_Image__SWIG_10(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  if(args.Length() == 1) {
    errorHandler.err.Clear();
    _wrap_new_Image__SWIG_11(args, errorHandler);
    if(errorHandler.err.IsEmpty()) {
      return;
    }
  }
  
  
  // default:
  SWIG_exception_fail(SWIG_ERROR, "Illegal arguments for construction of _exports_Image");
  
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_image(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  MagickCore::Image **result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_image.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_image" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (MagickCore::Image **) &(arg1)->image();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_MagickCore___Image, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_constImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  MagickCore::Image *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_constImage.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_constImage" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (MagickCore::Image *)((Magick::Image const *)arg1)->constImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_MagickCore___Image, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_imageInfo(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  MagickCore::ImageInfo *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_imageInfo.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_imageInfo" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (MagickCore::ImageInfo *)(arg1)->imageInfo();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_MagickCore___ImageInfo, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_constImageInfo(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  MagickCore::ImageInfo *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_constImageInfo.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_constImageInfo" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (MagickCore::ImageInfo *)((Magick::Image const *)arg1)->constImageInfo();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_MagickCore___ImageInfo, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_options(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Options *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_options.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_options" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::Options *)(arg1)->options();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__Options, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_constOptions(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Magick::Options *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_constOptions.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_constOptions" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (Magick::Options *)((Magick::Image const *)arg1)->constOptions();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Magick__Options, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_quantizeInfo(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  MagickCore::QuantizeInfo *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_quantizeInfo.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_quantizeInfo" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (MagickCore::QuantizeInfo *)(arg1)->quantizeInfo();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_MagickCore___QuantizeInfo, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_constQuantizeInfo(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  MagickCore::QuantizeInfo *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_constQuantizeInfo.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_constQuantizeInfo" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      result = (MagickCore::QuantizeInfo *)((Magick::Image const *)arg1)->constQuantizeInfo();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_MagickCore___QuantizeInfo, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_modifyImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_modifyImage.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_modifyImage" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      (arg1)->modifyImage();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_replaceImage(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  MagickCore::Image *arg2 = (MagickCore::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  MagickCore::Image *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_replaceImage.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_replaceImage" "', argument " "1"" of type '" "Magick::Image *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p_MagickCore___Image, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Image_replaceImage" "', argument " "2"" of type '" "MagickCore::Image *""'"); 
  }
  arg2 = reinterpret_cast< MagickCore::Image * >(argp2);
  {
    try {
      result = (MagickCore::Image *)(arg1)->replaceImage(arg2);
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_MagickCore___Image, 0 |  0 );
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Image_throwImageException(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  SWIGV8_VALUE jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Image_throwImageException.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Image_throwImageException" "', argument " "1"" of type '" "Magick::Image const *""'"); 
  }
  arg1 = reinterpret_cast< Magick::Image * >(argp1);
  {
    try {
      ((Magick::Image const *)arg1)->throwImageException();
    } catch (const Magick::ErrorBlob &e) {
      SWIG_exception_fail(SWIG_ValueError, e.what());
    }
  }
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_Magick__ColorGrayTo_p_Magick__Color(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Color *)  ((Magick::ColorGray *) x));
}
static void *_p_Magick__ColorHSLTo_p_Magick__Color(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Color *)  ((Magick::ColorHSL *) x));
}
static void *_p_Magick__ColorMonoTo_p_Magick__Color(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Color *)  ((Magick::ColorMono *) x));
}
static void *_p_Magick__ColorRGBTo_p_Magick__Color(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Color *)  ((Magick::ColorRGB *) x));
}
static void *_p_Magick__ColorYUVTo_p_Magick__Color(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Color *)  ((Magick::ColorYUV *) x));
}
static void *_p_Magick__DrawableAffineTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableAffine *) x));
}
static void *_p_Magick__DrawableArcTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableArc *) x));
}
static void *_p_Magick__DrawableBezierTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableBezier *) x));
}
static void *_p_Magick__DrawableCircleTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableCircle *) x));
}
static void *_p_Magick__DrawableClipPathTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableClipPath *) x));
}
static void *_p_Magick__DrawableColorTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableColor *) x));
}
static void *_p_Magick__DrawableCompositeImageTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableCompositeImage *) x));
}
static void *_p_Magick__DrawableDashArrayTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableDashArray *) x));
}
static void *_p_Magick__DrawableDashOffsetTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableDashOffset *) x));
}
static void *_p_Magick__DrawableDensityTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableDensity *) x));
}
static void *_p_Magick__DrawableEllipseTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableEllipse *) x));
}
static void *_p_Magick__DrawableFillColorTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableFillColor *) x));
}
static void *_p_Magick__DrawableFillOpacityTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableFillOpacity *) x));
}
static void *_p_Magick__DrawableFillRuleTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableFillRule *) x));
}
static void *_p_Magick__DrawableFontTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableFont *) x));
}
static void *_p_Magick__DrawableGravityTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableGravity *) x));
}
static void *_p_Magick__DrawableLineTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableLine *) x));
}
static void *_p_Magick__DrawableMatteTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableMatte *) x));
}
static void *_p_Magick__DrawableMiterLimitTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableMiterLimit *) x));
}
static void *_p_Magick__DrawablePathTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawablePath *) x));
}
static void *_p_Magick__DrawablePointTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawablePoint *) x));
}
static void *_p_Magick__DrawablePointSizeTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawablePointSize *) x));
}
static void *_p_Magick__DrawablePolygonTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawablePolygon *) x));
}
static void *_p_Magick__DrawablePolylineTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawablePolyline *) x));
}
static void *_p_Magick__DrawablePopClipPathTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawablePopClipPath *) x));
}
static void *_p_Magick__DrawablePopGraphicContextTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawablePopGraphicContext *) x));
}
static void *_p_Magick__DrawablePopPatternTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawablePopPattern *) x));
}
static void *_p_Magick__DrawablePushClipPathTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawablePushClipPath *) x));
}
static void *_p_Magick__DrawablePushGraphicContextTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawablePushGraphicContext *) x));
}
static void *_p_Magick__DrawablePushPatternTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawablePushPattern *) x));
}
static void *_p_Magick__DrawableRectangleTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableRectangle *) x));
}
static void *_p_Magick__DrawableRotationTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableRotation *) x));
}
static void *_p_Magick__DrawableRoundRectangleTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableRoundRectangle *) x));
}
static void *_p_Magick__DrawableScalingTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableScaling *) x));
}
static void *_p_Magick__DrawableSkewXTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableSkewX *) x));
}
static void *_p_Magick__DrawableSkewYTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableSkewY *) x));
}
static void *_p_Magick__DrawableStrokeAntialiasTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableStrokeAntialias *) x));
}
static void *_p_Magick__DrawableStrokeColorTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableStrokeColor *) x));
}
static void *_p_Magick__DrawableStrokeLineCapTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableStrokeLineCap *) x));
}
static void *_p_Magick__DrawableStrokeLineJoinTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableStrokeLineJoin *) x));
}
static void *_p_Magick__DrawableStrokeOpacityTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableStrokeOpacity *) x));
}
static void *_p_Magick__DrawableStrokeWidthTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableStrokeWidth *) x));
}
static void *_p_Magick__DrawableTextTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableText *) x));
}
static void *_p_Magick__DrawableTextAntialiasTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableTextAntialias *) x));
}
static void *_p_Magick__DrawableTextDecorationTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableTextDecoration *) x));
}
static void *_p_Magick__DrawableTextDirectionTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableTextDirection *) x));
}
static void *_p_Magick__DrawableTextInterlineSpacingTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableTextInterlineSpacing *) x));
}
static void *_p_Magick__DrawableTextInterwordSpacingTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableTextInterwordSpacing *) x));
}
static void *_p_Magick__DrawableTextKerningTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableTextKerning *) x));
}
static void *_p_Magick__DrawableTextUnderColorTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableTextUnderColor *) x));
}
static void *_p_Magick__DrawableTranslationTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableTranslation *) x));
}
static void *_p_Magick__DrawableViewboxTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableViewbox *) x));
}
static void *_p_Magick__ErrorBlobTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorBlob *) x));
}
static void *_p_Magick__ErrorCacheTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorCache *) x));
}
static void *_p_Magick__ErrorCoderTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorCoder *) x));
}
static void *_p_Magick__ErrorConfigureTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorConfigure *) x));
}
static void *_p_Magick__ErrorCorruptImageTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorCorruptImage *) x));
}
static void *_p_Magick__ErrorDelegateTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorDelegate *) x));
}
static void *_p_Magick__ErrorDrawTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorDraw *) x));
}
static void *_p_Magick__ErrorFileOpenTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorFileOpen *) x));
}
static void *_p_Magick__ErrorImageTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorImage *) x));
}
static void *_p_Magick__ErrorMissingDelegateTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorMissingDelegate *) x));
}
static void *_p_Magick__ErrorModuleTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorModule *) x));
}
static void *_p_Magick__ErrorMonitorTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorMonitor *) x));
}
static void *_p_Magick__ErrorOptionTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorOption *) x));
}
static void *_p_Magick__ErrorPolicyTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorPolicy *) x));
}
static void *_p_Magick__ErrorRegistryTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorRegistry *) x));
}
static void *_p_Magick__ErrorResourceLimitTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorResourceLimit *) x));
}
static void *_p_Magick__ErrorStreamTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorStream *) x));
}
static void *_p_Magick__ErrorTypeTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorType *) x));
}
static void *_p_Magick__ErrorUndefinedTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorUndefined *) x));
}
static void *_p_Magick__ErrorXServerTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorXServer *) x));
}
static void *_p_Magick__ErrorTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *)  ((Magick::Error *) x));
}
static void *_p_Magick__ErrorBlobTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorBlob *) x));
}
static void *_p_Magick__ErrorCacheTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorCache *) x));
}
static void *_p_Magick__ErrorCoderTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorCoder *) x));
}
static void *_p_Magick__ErrorConfigureTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorConfigure *) x));
}
static void *_p_Magick__ErrorCorruptImageTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorCorruptImage *) x));
}
static void *_p_Magick__ErrorDelegateTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorDelegate *) x));
}
static void *_p_Magick__ErrorDrawTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorDraw *) x));
}
static void *_p_Magick__ErrorFileOpenTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorFileOpen *) x));
}
static void *_p_Magick__ErrorImageTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorImage *) x));
}
static void *_p_Magick__ErrorMissingDelegateTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorMissingDelegate *) x));
}
static void *_p_Magick__ErrorModuleTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorModule *) x));
}
static void *_p_Magick__ErrorMonitorTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorMonitor *) x));
}
static void *_p_Magick__ErrorOptionTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorOption *) x));
}
static void *_p_Magick__ErrorPolicyTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorPolicy *) x));
}
static void *_p_Magick__ErrorRegistryTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorRegistry *) x));
}
static void *_p_Magick__ErrorResourceLimitTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorResourceLimit *) x));
}
static void *_p_Magick__ErrorStreamTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorStream *) x));
}
static void *_p_Magick__ErrorTypeTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorType *) x));
}
static void *_p_Magick__ErrorUndefinedTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorUndefined *) x));
}
static void *_p_Magick__ErrorXServerTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorXServer *) x));
}
static void *_p_Magick__WarningTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *)  ((Magick::Warning *) x));
}
static void *_p_Magick__WarningBlobTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningBlob *) x));
}
static void *_p_Magick__WarningCacheTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningCache *) x));
}
static void *_p_Magick__WarningCoderTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningCoder *) x));
}
static void *_p_Magick__WarningConfigureTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningConfigure *) x));
}
static void *_p_Magick__WarningCorruptImageTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningCorruptImage *) x));
}
static void *_p_Magick__WarningDelegateTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningDelegate *) x));
}
static void *_p_Magick__WarningDrawTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningDraw *) x));
}
static void *_p_Magick__WarningFileOpenTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningFileOpen *) x));
}
static void *_p_Magick__WarningImageTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningImage *) x));
}
static void *_p_Magick__WarningMissingDelegateTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningMissingDelegate *) x));
}
static void *_p_Magick__WarningModuleTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningModule *) x));
}
static void *_p_Magick__WarningMonitorTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningMonitor *) x));
}
static void *_p_Magick__WarningOptionTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningOption *) x));
}
static void *_p_Magick__WarningPolicyTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningPolicy *) x));
}
static void *_p_Magick__WarningRegistryTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningRegistry *) x));
}
static void *_p_Magick__WarningResourceLimitTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningResourceLimit *) x));
}
static void *_p_Magick__WarningStreamTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningStream *) x));
}
static void *_p_Magick__WarningTypeTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningType *) x));
}
static void *_p_Magick__WarningUndefinedTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningUndefined *) x));
}
static void *_p_Magick__WarningXServerTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningXServer *) x));
}
static void *_p_Magick__MontageFramedTo_p_Magick__Montage(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Montage *)  ((Magick::MontageFramed *) x));
}
static void *_p_Magick__PathArcAbsTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathArcAbs *) x));
}
static void *_p_Magick__PathArcRelTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathArcRel *) x));
}
static void *_p_Magick__PathClosePathTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathClosePath *) x));
}
static void *_p_Magick__PathCurvetoAbsTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathCurvetoAbs *) x));
}
static void *_p_Magick__PathCurvetoRelTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathCurvetoRel *) x));
}
static void *_p_Magick__PathLinetoAbsTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathLinetoAbs *) x));
}
static void *_p_Magick__PathLinetoHorizontalAbsTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathLinetoHorizontalAbs *) x));
}
static void *_p_Magick__PathLinetoHorizontalRelTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathLinetoHorizontalRel *) x));
}
static void *_p_Magick__PathLinetoRelTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathLinetoRel *) x));
}
static void *_p_Magick__PathLinetoVerticalAbsTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathLinetoVerticalAbs *) x));
}
static void *_p_Magick__PathLinetoVerticalRelTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathLinetoVerticalRel *) x));
}
static void *_p_Magick__PathMovetoAbsTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathMovetoAbs *) x));
}
static void *_p_Magick__PathMovetoRelTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathMovetoRel *) x));
}
static void *_p_Magick__PathQuadraticCurvetoAbsTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathQuadraticCurvetoAbs *) x));
}
static void *_p_Magick__PathQuadraticCurvetoRelTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathQuadraticCurvetoRel *) x));
}
static void *_p_Magick__PathSmoothCurvetoAbsTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathSmoothCurvetoAbs *) x));
}
static void *_p_Magick__PathSmoothCurvetoRelTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathSmoothCurvetoRel *) x));
}
static void *_p_Magick__PathSmoothQuadraticCurvetoAbsTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathSmoothQuadraticCurvetoAbs *) x));
}
static void *_p_Magick__PathSmoothQuadraticCurvetoRelTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathSmoothQuadraticCurvetoRel *) x));
}
static void *_p_Magick__WarningBlobTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningBlob *) x));
}
static void *_p_Magick__WarningCacheTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningCache *) x));
}
static void *_p_Magick__WarningCoderTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningCoder *) x));
}
static void *_p_Magick__WarningConfigureTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningConfigure *) x));
}
static void *_p_Magick__WarningCorruptImageTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningCorruptImage *) x));
}
static void *_p_Magick__WarningDelegateTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningDelegate *) x));
}
static void *_p_Magick__WarningDrawTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningDraw *) x));
}
static void *_p_Magick__WarningFileOpenTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningFileOpen *) x));
}
static void *_p_Magick__WarningImageTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningImage *) x));
}
static void *_p_Magick__WarningMissingDelegateTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningMissingDelegate *) x));
}
static void *_p_Magick__WarningModuleTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningModule *) x));
}
static void *_p_Magick__WarningMonitorTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningMonitor *) x));
}
static void *_p_Magick__WarningOptionTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningOption *) x));
}
static void *_p_Magick__WarningPolicyTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningPolicy *) x));
}
static void *_p_Magick__WarningRegistryTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningRegistry *) x));
}
static void *_p_Magick__WarningResourceLimitTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningResourceLimit *) x));
}
static void *_p_Magick__WarningStreamTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningStream *) x));
}
static void *_p_Magick__WarningTypeTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningType *) x));
}
static void *_p_Magick__WarningUndefinedTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningUndefined *) x));
}
static void *_p_Magick__WarningXServerTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningXServer *) x));
}
static void *_p_Magick__ErrorTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *) ((Magick::Error *) x));
}
static void *_p_Magick__ErrorBlobTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorBlob *) x));
}
static void *_p_Magick__ErrorCacheTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorCache *) x));
}
static void *_p_Magick__ErrorCoderTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorCoder *) x));
}
static void *_p_Magick__ErrorConfigureTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorConfigure *) x));
}
static void *_p_Magick__ErrorCorruptImageTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorCorruptImage *) x));
}
static void *_p_Magick__ErrorDelegateTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorDelegate *) x));
}
static void *_p_Magick__ErrorDrawTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorDraw *) x));
}
static void *_p_Magick__ErrorFileOpenTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorFileOpen *) x));
}
static void *_p_Magick__ErrorImageTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorImage *) x));
}
static void *_p_Magick__ErrorMissingDelegateTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorMissingDelegate *) x));
}
static void *_p_Magick__ErrorModuleTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorModule *) x));
}
static void *_p_Magick__ErrorMonitorTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorMonitor *) x));
}
static void *_p_Magick__ErrorOptionTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorOption *) x));
}
static void *_p_Magick__ErrorPolicyTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorPolicy *) x));
}
static void *_p_Magick__ErrorRegistryTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorRegistry *) x));
}
static void *_p_Magick__ErrorResourceLimitTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorResourceLimit *) x));
}
static void *_p_Magick__ErrorStreamTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorStream *) x));
}
static void *_p_Magick__ErrorTypeTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorType *) x));
}
static void *_p_Magick__ErrorUndefinedTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorUndefined *) x));
}
static void *_p_Magick__ErrorXServerTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorXServer *) x));
}
static void *_p_Magick__ExceptionTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *)  ((Magick::Exception *) x));
}
static void *_p_Magick__WarningTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *) ((Magick::Warning *) x));
}
static void *_p_Magick__WarningBlobTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningBlob *) x));
}
static void *_p_Magick__WarningCacheTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningCache *) x));
}
static void *_p_Magick__WarningCoderTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningCoder *) x));
}
static void *_p_Magick__WarningConfigureTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningConfigure *) x));
}
static void *_p_Magick__WarningCorruptImageTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningCorruptImage *) x));
}
static void *_p_Magick__WarningDelegateTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningDelegate *) x));
}
static void *_p_Magick__WarningDrawTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningDraw *) x));
}
static void *_p_Magick__WarningFileOpenTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningFileOpen *) x));
}
static void *_p_Magick__WarningImageTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningImage *) x));
}
static void *_p_Magick__WarningMissingDelegateTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningMissingDelegate *) x));
}
static void *_p_Magick__WarningModuleTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningModule *) x));
}
static void *_p_Magick__WarningMonitorTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningMonitor *) x));
}
static void *_p_Magick__WarningOptionTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningOption *) x));
}
static void *_p_Magick__WarningPolicyTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningPolicy *) x));
}
static void *_p_Magick__WarningRegistryTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningRegistry *) x));
}
static void *_p_Magick__WarningResourceLimitTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningResourceLimit *) x));
}
static void *_p_Magick__WarningStreamTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningStream *) x));
}
static void *_p_Magick__WarningTypeTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningType *) x));
}
static void *_p_Magick__WarningUndefinedTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningUndefined *) x));
}
static void *_p_Magick__WarningXServerTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningXServer *) x));
}
static swig_type_info _swigt__p_Color = {"_p_Color", "Color *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Drawable = {"_p_Drawable", "Drawable *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_DrawableAffine = {"_p_DrawableAffine", "DrawableAffine *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_DrawableList = {"_p_DrawableList", "DrawableList *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Image = {"_p_Image", "Image *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ImageChannelStatistics = {"_p_ImageChannelStatistics", "ImageChannelStatistics *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ImageStatistics = {"_p_ImageStatistics", "ImageStatistics *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__AlignType = {"_p_MagickCore__AlignType", "MagickCore::AlignType *|enum MagickCore::AlignType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__AlphaChannelType = {"_p_MagickCore__AlphaChannelType", "MagickCore::AlphaChannelType *|enum MagickCore::AlphaChannelType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__AutoThresholdMethod = {"_p_MagickCore__AutoThresholdMethod", "MagickCore::AutoThresholdMethod *|enum MagickCore::AutoThresholdMethod *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__CacheType = {"_p_MagickCore__CacheType", "MagickCore::CacheType *|enum MagickCore::CacheType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__ChannelType = {"_p_MagickCore__ChannelType", "MagickCore::ChannelType *|enum MagickCore::ChannelType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__ClassType = {"_p_MagickCore__ClassType", "MagickCore::ClassType *|enum MagickCore::ClassType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__ClipPathUnits = {"_p_MagickCore__ClipPathUnits", "MagickCore::ClipPathUnits *|enum MagickCore::ClipPathUnits *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__ColorspaceType = {"_p_MagickCore__ColorspaceType", "MagickCore::ColorspaceType *|enum MagickCore::ColorspaceType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__CommandOption = {"_p_MagickCore__CommandOption", "MagickCore::CommandOption *|enum MagickCore::CommandOption *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__CommandOptionFlags = {"_p_MagickCore__CommandOptionFlags", "MagickCore::CommandOptionFlags *|enum MagickCore::CommandOptionFlags *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__ComplexOperator = {"_p_MagickCore__ComplexOperator", "MagickCore::ComplexOperator *|enum MagickCore::ComplexOperator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__ComplianceType = {"_p_MagickCore__ComplianceType", "MagickCore::ComplianceType *|enum MagickCore::ComplianceType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__CompositeOperator = {"_p_MagickCore__CompositeOperator", "MagickCore::CompositeOperator *|enum MagickCore::CompositeOperator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__CompressionType = {"_p_MagickCore__CompressionType", "MagickCore::CompressionType *|enum MagickCore::CompressionType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__DecorationType = {"_p_MagickCore__DecorationType", "MagickCore::DecorationType *|enum MagickCore::DecorationType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__DirectionType = {"_p_MagickCore__DirectionType", "MagickCore::DirectionType *|enum MagickCore::DirectionType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__DisposeType = {"_p_MagickCore__DisposeType", "MagickCore::DisposeType *|enum MagickCore::DisposeType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__DistortImageMethod = {"_p_MagickCore__DistortImageMethod", "MagickCore::DistortImageMethod *|enum MagickCore::DistortImageMethod *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__DitherMethod = {"_p_MagickCore__DitherMethod", "MagickCore::DitherMethod *|enum MagickCore::DitherMethod *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__EndianType = {"_p_MagickCore__EndianType", "MagickCore::EndianType *|enum MagickCore::EndianType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__ExceptionType = {"_p_MagickCore__ExceptionType", "MagickCore::ExceptionType *|enum MagickCore::ExceptionType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__FillRule = {"_p_MagickCore__FillRule", "MagickCore::FillRule *|enum MagickCore::FillRule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__FilterTypes = {"_p_MagickCore__FilterTypes", "MagickCore::FilterTypes *|enum MagickCore::FilterTypes *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__GeometryFlags = {"_p_MagickCore__GeometryFlags", "MagickCore::GeometryFlags *|enum MagickCore::GeometryFlags *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__GradientType = {"_p_MagickCore__GradientType", "MagickCore::GradientType *|enum MagickCore::GradientType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__GravityType = {"_p_MagickCore__GravityType", "MagickCore::GravityType *|enum MagickCore::GravityType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__ImageLayerMethod = {"_p_MagickCore__ImageLayerMethod", "MagickCore::ImageLayerMethod *|enum MagickCore::ImageLayerMethod *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__ImageMagickOpenCLMode = {"_p_MagickCore__ImageMagickOpenCLMode", "MagickCore::ImageMagickOpenCLMode *|enum MagickCore::ImageMagickOpenCLMode *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__ImageType = {"_p_MagickCore__ImageType", "MagickCore::ImageType *|enum MagickCore::ImageType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__InterlaceType = {"_p_MagickCore__InterlaceType", "MagickCore::InterlaceType *|enum MagickCore::InterlaceType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__InterpolatePixelMethod = {"_p_MagickCore__InterpolatePixelMethod", "MagickCore::InterpolatePixelMethod *|enum MagickCore::InterpolatePixelMethod *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__KernelInfo = {"_p_MagickCore__KernelInfo", "MagickCore::KernelInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__KernelInfoType = {"_p_MagickCore__KernelInfoType", "MagickCore::KernelInfoType *|enum MagickCore::KernelInfoType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__LineCap = {"_p_MagickCore__LineCap", "MagickCore::LineCap *|enum MagickCore::LineCap *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__LineJoin = {"_p_MagickCore__LineJoin", "MagickCore::LineJoin *|enum MagickCore::LineJoin *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__LogEventType = {"_p_MagickCore__LogEventType", "MagickCore::LogEventType *|enum MagickCore::LogEventType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__MagickBooleanType = {"_p_MagickCore__MagickBooleanType", "MagickCore::MagickBooleanType *|enum MagickCore::MagickBooleanType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__MagickEvaluateOperator = {"_p_MagickCore__MagickEvaluateOperator", "MagickCore::MagickEvaluateOperator *|enum MagickCore::MagickEvaluateOperator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__MagickFormatType = {"_p_MagickCore__MagickFormatType", "MagickCore::MagickFormatType *|enum MagickCore::MagickFormatType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__MagickFunction = {"_p_MagickCore__MagickFunction", "MagickCore::MagickFunction *|enum MagickCore::MagickFunction *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__MagickLayerMethod = {"_p_MagickCore__MagickLayerMethod", "MagickCore::MagickLayerMethod *|enum MagickCore::MagickLayerMethod *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__MagickModuleType = {"_p_MagickCore__MagickModuleType", "MagickCore::MagickModuleType *|enum MagickCore::MagickModuleType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__MagickOpenCLEnvParam = {"_p_MagickCore__MagickOpenCLEnvParam", "MagickCore::MagickOpenCLEnvParam *|enum MagickCore::MagickOpenCLEnvParam *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__MagickOpenCLProgram = {"_p_MagickCore__MagickOpenCLProgram", "MagickCore::MagickOpenCLProgram *|enum MagickCore::MagickOpenCLProgram *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__MagickThreadSupport = {"_p_MagickCore__MagickThreadSupport", "MagickCore::MagickThreadSupport *|enum MagickCore::MagickThreadSupport *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__MapMode = {"_p_MagickCore__MapMode", "MagickCore::MapMode *|enum MagickCore::MapMode *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__MetricType = {"_p_MagickCore__MetricType", "MagickCore::MetricType *|enum MagickCore::MetricType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__MontageMode = {"_p_MagickCore__MontageMode", "MagickCore::MontageMode *|enum MagickCore::MontageMode *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__MorphologyMethod = {"_p_MagickCore__MorphologyMethod", "MagickCore::MorphologyMethod *|enum MagickCore::MorphologyMethod *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__NoiseType = {"_p_MagickCore__NoiseType", "MagickCore::NoiseType *|enum MagickCore::NoiseType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__OrientationType = {"_p_MagickCore__OrientationType", "MagickCore::OrientationType *|enum MagickCore::OrientationType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__PaintMethod = {"_p_MagickCore__PaintMethod", "MagickCore::PaintMethod *|enum MagickCore::PaintMethod *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__PathType = {"_p_MagickCore__PathType", "MagickCore::PathType *|enum MagickCore::PathType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__PixelComponent = {"_p_MagickCore__PixelComponent", "MagickCore::PixelComponent *|enum MagickCore::PixelComponent *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__PixelIntensityMethod = {"_p_MagickCore__PixelIntensityMethod", "MagickCore::PixelIntensityMethod *|enum MagickCore::PixelIntensityMethod *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__PolicyDomain = {"_p_MagickCore__PolicyDomain", "MagickCore::PolicyDomain *|enum MagickCore::PolicyDomain *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__PolicyRights = {"_p_MagickCore__PolicyRights", "MagickCore::PolicyRights *|enum MagickCore::PolicyRights *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__PreviewType = {"_p_MagickCore__PreviewType", "MagickCore::PreviewType *|enum MagickCore::PreviewType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__PrimitiveType = {"_p_MagickCore__PrimitiveType", "MagickCore::PrimitiveType *|enum MagickCore::PrimitiveType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__QuantumAlphaType = {"_p_MagickCore__QuantumAlphaType", "MagickCore::QuantumAlphaType *|enum MagickCore::QuantumAlphaType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__QuantumFormatType = {"_p_MagickCore__QuantumFormatType", "MagickCore::QuantumFormatType *|enum MagickCore::QuantumFormatType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__QuantumType = {"_p_MagickCore__QuantumType", "MagickCore::QuantumType *|enum MagickCore::QuantumType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__ReferenceType = {"_p_MagickCore__ReferenceType", "MagickCore::ReferenceType *|enum MagickCore::ReferenceType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__RegistryType = {"_p_MagickCore__RegistryType", "MagickCore::RegistryType *|enum MagickCore::RegistryType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__RenderingIntent = {"_p_MagickCore__RenderingIntent", "MagickCore::RenderingIntent *|enum MagickCore::RenderingIntent *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__ResolutionType = {"_p_MagickCore__ResolutionType", "MagickCore::ResolutionType *|enum MagickCore::ResolutionType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__ResourceType = {"_p_MagickCore__ResourceType", "MagickCore::ResourceType *|enum MagickCore::ResourceType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__SemaphoreInfo = {"_p_MagickCore__SemaphoreInfo", "MagickCore::SemaphoreInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__SparseColorMethod = {"_p_MagickCore__SparseColorMethod", "MagickCore::SparseColorMethod *|enum MagickCore::SparseColorMethod *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__SpreadMethod = {"_p_MagickCore__SpreadMethod", "MagickCore::SpreadMethod *|enum MagickCore::SpreadMethod *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__StatisticType = {"_p_MagickCore__StatisticType", "MagickCore::StatisticType *|enum MagickCore::StatisticType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__StorageType = {"_p_MagickCore__StorageType", "MagickCore::StorageType *|enum MagickCore::StorageType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__StretchType = {"_p_MagickCore__StretchType", "MagickCore::StretchType *|enum MagickCore::StretchType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__StyleType = {"_p_MagickCore__StyleType", "MagickCore::StyleType *|enum MagickCore::StyleType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__TimerState = {"_p_MagickCore__TimerState", "MagickCore::TimerState *|enum MagickCore::TimerState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__TransmitType = {"_p_MagickCore__TransmitType", "MagickCore::TransmitType *|enum MagickCore::TransmitType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__ValidateType = {"_p_MagickCore__ValidateType", "MagickCore::ValidateType *|enum MagickCore::ValidateType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore__VirtualPixelMethod = {"_p_MagickCore__VirtualPixelMethod", "MagickCore::VirtualPixelMethod *|enum MagickCore::VirtualPixelMethod *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___AffineMatrix = {"_p_MagickCore___AffineMatrix", "MagickCore::AffineMatrix *|MagickCore::_AffineMatrix *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___ChannelFeatures = {"_p_MagickCore___ChannelFeatures", "MagickCore::ChannelFeatures *|MagickCore::_ChannelFeatures *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___ChannelMoments = {"_p_MagickCore___ChannelMoments", "MagickCore::ChannelMoments *|MagickCore::_ChannelMoments *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___ChannelPerceptualHash = {"_p_MagickCore___ChannelPerceptualHash", "MagickCore::ChannelPerceptualHash *|MagickCore::_ChannelPerceptualHash *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___ChannelStatistics = {"_p_MagickCore___ChannelStatistics", "MagickCore::ChannelStatistics *|MagickCore::_ChannelStatistics *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___ChromaticityInfo = {"_p_MagickCore___ChromaticityInfo", "MagickCore::ChromaticityInfo *|MagickCore::_ChromaticityInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___CoderInfo = {"_p_MagickCore___CoderInfo", "MagickCore::CoderInfo *|MagickCore::_CoderInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___ColorInfo = {"_p_MagickCore___ColorInfo", "MagickCore::ColorInfo *|MagickCore::_ColorInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___ColorPacket = {"_p_MagickCore___ColorPacket", "MagickCore::ColorPacket *|MagickCore::_ColorPacket *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___ConfigureInfo = {"_p_MagickCore___ConfigureInfo", "MagickCore::ConfigureInfo *|MagickCore::_ConfigureInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___DelegateInfo = {"_p_MagickCore___DelegateInfo", "MagickCore::DelegateInfo *|MagickCore::_DelegateInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___DoublePixelPacket = {"_p_MagickCore___DoublePixelPacket", "MagickCore::DoublePixelPacket *|MagickCore::_DoublePixelPacket *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___DrawInfo = {"_p_MagickCore___DrawInfo", "MagickCore::DrawInfo *|MagickCore::_DrawInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___ElementReference = {"_p_MagickCore___ElementReference", "MagickCore::ElementReference *|MagickCore::_ElementReference *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___ErrorInfo = {"_p_MagickCore___ErrorInfo", "MagickCore::ErrorInfo *|MagickCore::_ErrorInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___ExceptionInfo = {"_p_MagickCore___ExceptionInfo", "MagickCore::ExceptionInfo *|MagickCore::_ExceptionInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___FrameInfo = {"_p_MagickCore___FrameInfo", "MagickCore::FrameInfo *|MagickCore::_FrameInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___GeometryInfo = {"_p_MagickCore___GeometryInfo", "MagickCore::GeometryInfo *|MagickCore::_GeometryInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___GradientInfo = {"_p_MagickCore___GradientInfo", "MagickCore::GradientInfo *|MagickCore::_GradientInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___Image = {"_p_MagickCore___Image", "MagickCore::Image *|MagickCore::_Image *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___ImageAttribute = {"_p_MagickCore___ImageAttribute", "MagickCore::ImageAttribute *|MagickCore::_ImageAttribute *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___ImageInfo = {"_p_MagickCore___ImageInfo", "MagickCore::ImageInfo *|MagickCore::_ImageInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___LocaleInfo = {"_p_MagickCore___LocaleInfo", "MagickCore::LocaleInfo *|MagickCore::_LocaleInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___LongPixelPacket = {"_p_MagickCore___LongPixelPacket", "MagickCore::LongPixelPacket *|MagickCore::_LongPixelPacket *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___MagicInfo = {"_p_MagickCore___MagicInfo", "MagickCore::MagicInfo *|MagickCore::_MagicInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___MagickInfo = {"_p_MagickCore___MagickInfo", "MagickCore::MagickInfo *|MagickCore::_MagickInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___MagickPixelPacket = {"_p_MagickCore___MagickPixelPacket", "MagickCore::MagickPixelPacket *|MagickCore::_MagickPixelPacket *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___ModuleInfo = {"_p_MagickCore___ModuleInfo", "MagickCore::ModuleInfo *|MagickCore::_ModuleInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___MontageInfo = {"_p_MagickCore___MontageInfo", "MagickCore::MontageInfo *|MagickCore::_MontageInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___OffsetInfo = {"_p_MagickCore___OffsetInfo", "MagickCore::OffsetInfo *|MagickCore::_OffsetInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___OptionInfo = {"_p_MagickCore___OptionInfo", "MagickCore::OptionInfo *|MagickCore::_OptionInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___PixelPacket = {"_p_MagickCore___PixelPacket", "MagickCore::PixelPacket *|MagickCore::_PixelPacket *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___PointInfo = {"_p_MagickCore___PointInfo", "MagickCore::PointInfo *|MagickCore::_PointInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___PrimaryInfo = {"_p_MagickCore___PrimaryInfo", "MagickCore::PrimaryInfo *|MagickCore::_PrimaryInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___PrimitiveInfo = {"_p_MagickCore___PrimitiveInfo", "MagickCore::PrimitiveInfo *|MagickCore::_PrimitiveInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___ProfileInfo = {"_p_MagickCore___ProfileInfo", "MagickCore::ProfileInfo *|MagickCore::_ProfileInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___QuantizeInfo = {"_p_MagickCore___QuantizeInfo", "MagickCore::QuantizeInfo *|MagickCore::_QuantizeInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___QuantumPixelPacket = {"_p_MagickCore___QuantumPixelPacket", "MagickCore::QuantumPixelPacket *|MagickCore::_QuantumPixelPacket *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___RectangleInfo = {"_p_MagickCore___RectangleInfo", "MagickCore::RectangleInfo *|MagickCore::_RectangleInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___SegmentInfo = {"_p_MagickCore___SegmentInfo", "MagickCore::SegmentInfo *|MagickCore::_SegmentInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___StopInfo = {"_p_MagickCore___StopInfo", "MagickCore::StopInfo *|MagickCore::_StopInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___StringInfo = {"_p_MagickCore___StringInfo", "MagickCore::StringInfo *|MagickCore::_StringInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___Timer = {"_p_MagickCore___Timer", "MagickCore::Timer *|MagickCore::_Timer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___TimerInfo = {"_p_MagickCore___TimerInfo", "MagickCore::TimerInfo *|MagickCore::_TimerInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___TypeInfo = {"_p_MagickCore___TypeInfo", "MagickCore::TypeInfo *|MagickCore::_TypeInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___TypeMetric = {"_p_MagickCore___TypeMetric", "MagickCore::TypeMetric *|MagickCore::_TypeMetric *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MagickCore___XImportInfo = {"_p_MagickCore___XImportInfo", "MagickCore::XImportInfo *|MagickCore::_XImportInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__Blob = {"_p_Magick__Blob", "Magick::Blob *|p_Magick__Blob", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ChannelMoments = {"_p_Magick__ChannelMoments", "Magick::ChannelMoments *|p_Magick__ChannelMoments", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__CoderInfo = {"_p_Magick__CoderInfo", "p_Magick__CoderInfo|Magick::CoderInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__Color = {"_p_Magick__Color", "p_Magick__Color|Magick::Color *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ColorGray = {"_p_Magick__ColorGray", "Magick::ColorGray *|p_Magick__ColorGray", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ColorHSL = {"_p_Magick__ColorHSL", "p_Magick__ColorHSL|Magick::ColorHSL *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ColorMono = {"_p_Magick__ColorMono", "p_Magick__ColorMono|Magick::ColorMono *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ColorRGB = {"_p_Magick__ColorRGB", "Magick::ColorRGB *|p_Magick__ColorRGB", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ColorYUV = {"_p_Magick__ColorYUV", "Magick::ColorYUV *|p_Magick__ColorYUV", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__Coordinate = {"_p_Magick__Coordinate", "p_Magick__Coordinate|Magick::Coordinate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__Drawable = {"_p_Magick__Drawable", "p_Magick__Drawable|Magick::Drawable *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableAffine = {"_p_Magick__DrawableAffine", "Magick::DrawableAffine *|p_Magick__DrawableAffine", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableArc = {"_p_Magick__DrawableArc", "p_Magick__DrawableArc|Magick::DrawableArc *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableBase = {"_p_Magick__DrawableBase", "p_Magick__DrawableBase|Magick::DrawableBase *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableBezier = {"_p_Magick__DrawableBezier", "Magick::DrawableBezier *|p_Magick__DrawableBezier", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableCircle = {"_p_Magick__DrawableCircle", "Magick::DrawableCircle *|p_Magick__DrawableCircle", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableClipPath = {"_p_Magick__DrawableClipPath", "Magick::DrawableClipPath *|p_Magick__DrawableClipPath", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableColor = {"_p_Magick__DrawableColor", "Magick::DrawableColor *|p_Magick__DrawableColor", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableCompositeImage = {"_p_Magick__DrawableCompositeImage", "p_Magick__DrawableCompositeImage|Magick::DrawableCompositeImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableDashArray = {"_p_Magick__DrawableDashArray", "Magick::DrawableDashArray *|p_Magick__DrawableDashArray", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableDashOffset = {"_p_Magick__DrawableDashOffset", "Magick::DrawableDashOffset *|p_Magick__DrawableDashOffset", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableDensity = {"_p_Magick__DrawableDensity", "Magick::DrawableDensity *|p_Magick__DrawableDensity", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableEllipse = {"_p_Magick__DrawableEllipse", "Magick::DrawableEllipse *|p_Magick__DrawableEllipse", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableFillColor = {"_p_Magick__DrawableFillColor", "p_Magick__DrawableFillColor|Magick::DrawableFillColor *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableFillOpacity = {"_p_Magick__DrawableFillOpacity", "Magick::DrawableFillOpacity *|p_Magick__DrawableFillOpacity", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableFillRule = {"_p_Magick__DrawableFillRule", "p_Magick__DrawableFillRule|Magick::DrawableFillRule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableFont = {"_p_Magick__DrawableFont", "p_Magick__DrawableFont|Magick::DrawableFont *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableGravity = {"_p_Magick__DrawableGravity", "Magick::DrawableGravity *|p_Magick__DrawableGravity", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableLine = {"_p_Magick__DrawableLine", "p_Magick__DrawableLine|Magick::DrawableLine *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableMatte = {"_p_Magick__DrawableMatte", "Magick::DrawableMatte *|p_Magick__DrawableMatte", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableMiterLimit = {"_p_Magick__DrawableMiterLimit", "Magick::DrawableMiterLimit *|p_Magick__DrawableMiterLimit", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawablePath = {"_p_Magick__DrawablePath", "Magick::DrawablePath *|p_Magick__DrawablePath", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawablePoint = {"_p_Magick__DrawablePoint", "p_Magick__DrawablePoint|Magick::DrawablePoint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawablePointSize = {"_p_Magick__DrawablePointSize", "Magick::DrawablePointSize *|p_Magick__DrawablePointSize", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawablePolygon = {"_p_Magick__DrawablePolygon", "Magick::DrawablePolygon *|p_Magick__DrawablePolygon", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawablePolyline = {"_p_Magick__DrawablePolyline", "Magick::DrawablePolyline *|p_Magick__DrawablePolyline", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawablePopClipPath = {"_p_Magick__DrawablePopClipPath", "p_Magick__DrawablePopClipPath|Magick::DrawablePopClipPath *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawablePopGraphicContext = {"_p_Magick__DrawablePopGraphicContext", "p_Magick__DrawablePopGraphicContext|Magick::DrawablePopGraphicContext *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawablePopPattern = {"_p_Magick__DrawablePopPattern", "p_Magick__DrawablePopPattern|Magick::DrawablePopPattern *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawablePushClipPath = {"_p_Magick__DrawablePushClipPath", "Magick::DrawablePushClipPath *|p_Magick__DrawablePushClipPath", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawablePushGraphicContext = {"_p_Magick__DrawablePushGraphicContext", "p_Magick__DrawablePushGraphicContext|Magick::DrawablePushGraphicContext *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawablePushPattern = {"_p_Magick__DrawablePushPattern", "p_Magick__DrawablePushPattern|Magick::DrawablePushPattern *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableRectangle = {"_p_Magick__DrawableRectangle", "p_Magick__DrawableRectangle|Magick::DrawableRectangle *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableRotation = {"_p_Magick__DrawableRotation", "p_Magick__DrawableRotation|Magick::DrawableRotation *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableRoundRectangle = {"_p_Magick__DrawableRoundRectangle", "p_Magick__DrawableRoundRectangle|Magick::DrawableRoundRectangle *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableScaling = {"_p_Magick__DrawableScaling", "Magick::DrawableScaling *|p_Magick__DrawableScaling", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableSkewX = {"_p_Magick__DrawableSkewX", "Magick::DrawableSkewX *|p_Magick__DrawableSkewX", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableSkewY = {"_p_Magick__DrawableSkewY", "Magick::DrawableSkewY *|p_Magick__DrawableSkewY", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableStrokeAntialias = {"_p_Magick__DrawableStrokeAntialias", "Magick::DrawableStrokeAntialias *|p_Magick__DrawableStrokeAntialias", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableStrokeColor = {"_p_Magick__DrawableStrokeColor", "p_Magick__DrawableStrokeColor|Magick::DrawableStrokeColor *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableStrokeLineCap = {"_p_Magick__DrawableStrokeLineCap", "Magick::DrawableStrokeLineCap *|p_Magick__DrawableStrokeLineCap", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableStrokeLineJoin = {"_p_Magick__DrawableStrokeLineJoin", "Magick::DrawableStrokeLineJoin *|p_Magick__DrawableStrokeLineJoin", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableStrokeOpacity = {"_p_Magick__DrawableStrokeOpacity", "p_Magick__DrawableStrokeOpacity|Magick::DrawableStrokeOpacity *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableStrokeWidth = {"_p_Magick__DrawableStrokeWidth", "p_Magick__DrawableStrokeWidth|Magick::DrawableStrokeWidth *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableText = {"_p_Magick__DrawableText", "p_Magick__DrawableText|Magick::DrawableText *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableTextAntialias = {"_p_Magick__DrawableTextAntialias", "Magick::DrawableTextAntialias *|p_Magick__DrawableTextAntialias", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableTextDecoration = {"_p_Magick__DrawableTextDecoration", "p_Magick__DrawableTextDecoration|Magick::DrawableTextDecoration *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableTextDirection = {"_p_Magick__DrawableTextDirection", "Magick::DrawableTextDirection *|p_Magick__DrawableTextDirection", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableTextInterlineSpacing = {"_p_Magick__DrawableTextInterlineSpacing", "Magick::DrawableTextInterlineSpacing *|p_Magick__DrawableTextInterlineSpacing", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableTextInterwordSpacing = {"_p_Magick__DrawableTextInterwordSpacing", "p_Magick__DrawableTextInterwordSpacing|Magick::DrawableTextInterwordSpacing *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableTextKerning = {"_p_Magick__DrawableTextKerning", "Magick::DrawableTextKerning *|p_Magick__DrawableTextKerning", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableTextUnderColor = {"_p_Magick__DrawableTextUnderColor", "p_Magick__DrawableTextUnderColor|Magick::DrawableTextUnderColor *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableTranslation = {"_p_Magick__DrawableTranslation", "p_Magick__DrawableTranslation|Magick::DrawableTranslation *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__DrawableViewbox = {"_p_Magick__DrawableViewbox", "Magick::DrawableViewbox *|p_Magick__DrawableViewbox", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__Error = {"_p_Magick__Error", "Magick::Error *|p_Magick__Error", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ErrorBlob = {"_p_Magick__ErrorBlob", "p_Magick__ErrorBlob", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ErrorCache = {"_p_Magick__ErrorCache", "p_Magick__ErrorCache", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ErrorCoder = {"_p_Magick__ErrorCoder", "p_Magick__ErrorCoder", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ErrorConfigure = {"_p_Magick__ErrorConfigure", "p_Magick__ErrorConfigure", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ErrorCorruptImage = {"_p_Magick__ErrorCorruptImage", "p_Magick__ErrorCorruptImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ErrorDelegate = {"_p_Magick__ErrorDelegate", "p_Magick__ErrorDelegate", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ErrorDraw = {"_p_Magick__ErrorDraw", "p_Magick__ErrorDraw", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ErrorFileOpen = {"_p_Magick__ErrorFileOpen", "p_Magick__ErrorFileOpen", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ErrorImage = {"_p_Magick__ErrorImage", "p_Magick__ErrorImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ErrorMissingDelegate = {"_p_Magick__ErrorMissingDelegate", "p_Magick__ErrorMissingDelegate", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ErrorModule = {"_p_Magick__ErrorModule", "p_Magick__ErrorModule", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ErrorMonitor = {"_p_Magick__ErrorMonitor", "p_Magick__ErrorMonitor", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ErrorOption = {"_p_Magick__ErrorOption", "p_Magick__ErrorOption", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ErrorPolicy = {"_p_Magick__ErrorPolicy", "p_Magick__ErrorPolicy", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ErrorRegistry = {"_p_Magick__ErrorRegistry", "p_Magick__ErrorRegistry", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ErrorResourceLimit = {"_p_Magick__ErrorResourceLimit", "p_Magick__ErrorResourceLimit", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ErrorStream = {"_p_Magick__ErrorStream", "p_Magick__ErrorStream", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ErrorType = {"_p_Magick__ErrorType", "p_Magick__ErrorType", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ErrorUndefined = {"_p_Magick__ErrorUndefined", "p_Magick__ErrorUndefined", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ErrorXServer = {"_p_Magick__ErrorXServer", "p_Magick__ErrorXServer", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__Exception = {"_p_Magick__Exception", "p_Magick__Exception|Magick::Exception *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__Geometry = {"_p_Magick__Geometry", "Magick::Geometry *|p_Magick__Geometry", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__Image = {"_p_Magick__Image", "p_Magick__Image|Magick::Image *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ImageMoments = {"_p_Magick__ImageMoments", "p_Magick__ImageMoments|Magick::ImageMoments *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__Image___ImageStatistics = {"_p_Magick__Image___ImageStatistics", "Magick::Image::ImageStatistics *|Magick::Image::_ImageStatistics *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__Montage = {"_p_Magick__Montage", "p_Magick__Montage|Magick::Montage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__MontageFramed = {"_p_Magick__MontageFramed", "Magick::MontageFramed *|p_Magick__MontageFramed", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__Offset = {"_p_Magick__Offset", "Magick::Offset *|p_Magick__Offset", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__Options = {"_p_Magick__Options", "Magick::Options *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__PathArcAbs = {"_p_Magick__PathArcAbs", "p_Magick__PathArcAbs|Magick::PathArcAbs *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__PathArcArgs = {"_p_Magick__PathArcArgs", "p_Magick__PathArcArgs|Magick::PathArcArgs *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__PathArcRel = {"_p_Magick__PathArcRel", "p_Magick__PathArcRel|Magick::PathArcRel *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__PathClosePath = {"_p_Magick__PathClosePath", "Magick::PathClosePath *|p_Magick__PathClosePath", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__PathCurvetoAbs = {"_p_Magick__PathCurvetoAbs", "p_Magick__PathCurvetoAbs|Magick::PathCurvetoAbs *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__PathCurvetoArgs = {"_p_Magick__PathCurvetoArgs", "Magick::PathCurvetoArgs *|p_Magick__PathCurvetoArgs", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__PathCurvetoRel = {"_p_Magick__PathCurvetoRel", "p_Magick__PathCurvetoRel|Magick::PathCurvetoRel *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__PathLinetoAbs = {"_p_Magick__PathLinetoAbs", "p_Magick__PathLinetoAbs|Magick::PathLinetoAbs *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__PathLinetoHorizontalAbs = {"_p_Magick__PathLinetoHorizontalAbs", "p_Magick__PathLinetoHorizontalAbs|Magick::PathLinetoHorizontalAbs *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__PathLinetoHorizontalRel = {"_p_Magick__PathLinetoHorizontalRel", "p_Magick__PathLinetoHorizontalRel|Magick::PathLinetoHorizontalRel *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__PathLinetoRel = {"_p_Magick__PathLinetoRel", "Magick::PathLinetoRel *|p_Magick__PathLinetoRel", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__PathLinetoVerticalAbs = {"_p_Magick__PathLinetoVerticalAbs", "Magick::PathLinetoVerticalAbs *|p_Magick__PathLinetoVerticalAbs", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__PathLinetoVerticalRel = {"_p_Magick__PathLinetoVerticalRel", "Magick::PathLinetoVerticalRel *|p_Magick__PathLinetoVerticalRel", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__PathMovetoAbs = {"_p_Magick__PathMovetoAbs", "Magick::PathMovetoAbs *|p_Magick__PathMovetoAbs", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__PathMovetoRel = {"_p_Magick__PathMovetoRel", "p_Magick__PathMovetoRel|Magick::PathMovetoRel *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__PathQuadraticCurvetoAbs = {"_p_Magick__PathQuadraticCurvetoAbs", "p_Magick__PathQuadraticCurvetoAbs|Magick::PathQuadraticCurvetoAbs *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__PathQuadraticCurvetoArgs = {"_p_Magick__PathQuadraticCurvetoArgs", "Magick::PathQuadraticCurvetoArgs *|p_Magick__PathQuadraticCurvetoArgs", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__PathQuadraticCurvetoRel = {"_p_Magick__PathQuadraticCurvetoRel", "p_Magick__PathQuadraticCurvetoRel|Magick::PathQuadraticCurvetoRel *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__PathSmoothCurvetoAbs = {"_p_Magick__PathSmoothCurvetoAbs", "Magick::PathSmoothCurvetoAbs *|p_Magick__PathSmoothCurvetoAbs", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__PathSmoothCurvetoRel = {"_p_Magick__PathSmoothCurvetoRel", "Magick::PathSmoothCurvetoRel *|p_Magick__PathSmoothCurvetoRel", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__PathSmoothQuadraticCurvetoAbs = {"_p_Magick__PathSmoothQuadraticCurvetoAbs", "p_Magick__PathSmoothQuadraticCurvetoAbs|Magick::PathSmoothQuadraticCurvetoAbs *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__PathSmoothQuadraticCurvetoRel = {"_p_Magick__PathSmoothQuadraticCurvetoRel", "p_Magick__PathSmoothQuadraticCurvetoRel|Magick::PathSmoothQuadraticCurvetoRel *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__PixelData = {"_p_Magick__PixelData", "Magick::PixelData *|p_Magick__PixelData", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__Pixels = {"_p_Magick__Pixels", "Magick::Pixels *|p_Magick__Pixels", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ReadOptions = {"_p_Magick__ReadOptions", "Magick::ReadOptions *|p_Magick__ReadOptions", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__ResourceLimits = {"_p_Magick__ResourceLimits", "p_Magick__ResourceLimits", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__TypeMetric = {"_p_Magick__TypeMetric", "p_Magick__TypeMetric|Magick::TypeMetric *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__VPath = {"_p_Magick__VPath", "p_Magick__VPath|Magick::VPath *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__VPathBase = {"_p_Magick__VPathBase", "Magick::VPathBase *|p_Magick__VPathBase", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__Warning = {"_p_Magick__Warning", "p_Magick__Warning|Magick::Warning *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__WarningBlob = {"_p_Magick__WarningBlob", "p_Magick__WarningBlob", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__WarningCache = {"_p_Magick__WarningCache", "p_Magick__WarningCache", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__WarningCoder = {"_p_Magick__WarningCoder", "p_Magick__WarningCoder", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__WarningConfigure = {"_p_Magick__WarningConfigure", "p_Magick__WarningConfigure", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__WarningCorruptImage = {"_p_Magick__WarningCorruptImage", "p_Magick__WarningCorruptImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__WarningDelegate = {"_p_Magick__WarningDelegate", "p_Magick__WarningDelegate", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__WarningDraw = {"_p_Magick__WarningDraw", "p_Magick__WarningDraw", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__WarningFileOpen = {"_p_Magick__WarningFileOpen", "p_Magick__WarningFileOpen", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__WarningImage = {"_p_Magick__WarningImage", "p_Magick__WarningImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__WarningMissingDelegate = {"_p_Magick__WarningMissingDelegate", "p_Magick__WarningMissingDelegate", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__WarningModule = {"_p_Magick__WarningModule", "p_Magick__WarningModule", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__WarningMonitor = {"_p_Magick__WarningMonitor", "p_Magick__WarningMonitor", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__WarningOption = {"_p_Magick__WarningOption", "p_Magick__WarningOption", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__WarningPolicy = {"_p_Magick__WarningPolicy", "p_Magick__WarningPolicy", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__WarningRegistry = {"_p_Magick__WarningRegistry", "p_Magick__WarningRegistry", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__WarningResourceLimit = {"_p_Magick__WarningResourceLimit", "p_Magick__WarningResourceLimit", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__WarningStream = {"_p_Magick__WarningStream", "p_Magick__WarningStream", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__WarningType = {"_p_Magick__WarningType", "p_Magick__WarningType", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__WarningUndefined = {"_p_Magick__WarningUndefined", "p_Magick__WarningUndefined", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__WarningXServer = {"_p_Magick__WarningXServer", "p_Magick__WarningXServer", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__adaptiveBlurImage = {"_p_Magick__adaptiveBlurImage", "p_Magick__adaptiveBlurImage|Magick::adaptiveBlurImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__adaptiveThresholdImage = {"_p_Magick__adaptiveThresholdImage", "p_Magick__adaptiveThresholdImage|Magick::adaptiveThresholdImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__addNoiseImage = {"_p_Magick__addNoiseImage", "Magick::addNoiseImage *|p_Magick__addNoiseImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__adjoinImage = {"_p_Magick__adjoinImage", "Magick::adjoinImage *|p_Magick__adjoinImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__affineTransformImage = {"_p_Magick__affineTransformImage", "p_Magick__affineTransformImage|Magick::affineTransformImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__animationDelayImage = {"_p_Magick__animationDelayImage", "Magick::animationDelayImage *|p_Magick__animationDelayImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__animationIterationsImage = {"_p_Magick__animationIterationsImage", "Magick::animationIterationsImage *|p_Magick__animationIterationsImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__annotateImage = {"_p_Magick__annotateImage", "Magick::annotateImage *|p_Magick__annotateImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__antiAliasImage = {"_p_Magick__antiAliasImage", "p_Magick__antiAliasImage|Magick::antiAliasImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__backgroundColorImage = {"_p_Magick__backgroundColorImage", "Magick::backgroundColorImage *|p_Magick__backgroundColorImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__backgroundTextureImage = {"_p_Magick__backgroundTextureImage", "p_Magick__backgroundTextureImage|Magick::backgroundTextureImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__blurImage = {"_p_Magick__blurImage", "p_Magick__blurImage|Magick::blurImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__borderColorImage = {"_p_Magick__borderColorImage", "p_Magick__borderColorImage|Magick::borderColorImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__borderImage = {"_p_Magick__borderImage", "p_Magick__borderImage|Magick::borderImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__boxColorImage = {"_p_Magick__boxColorImage", "Magick::boxColorImage *|p_Magick__boxColorImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__cdlImage = {"_p_Magick__cdlImage", "Magick::cdlImage *|p_Magick__cdlImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__channelImage = {"_p_Magick__channelImage", "Magick::channelImage *|p_Magick__channelImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__charcoalImage = {"_p_Magick__charcoalImage", "p_Magick__charcoalImage|Magick::charcoalImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__chopImage = {"_p_Magick__chopImage", "Magick::chopImage *|p_Magick__chopImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__chromaBluePrimaryImage = {"_p_Magick__chromaBluePrimaryImage", "p_Magick__chromaBluePrimaryImage|Magick::chromaBluePrimaryImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__chromaGreenPrimaryImage = {"_p_Magick__chromaGreenPrimaryImage", "Magick::chromaGreenPrimaryImage *|p_Magick__chromaGreenPrimaryImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__chromaRedPrimaryImage = {"_p_Magick__chromaRedPrimaryImage", "p_Magick__chromaRedPrimaryImage|Magick::chromaRedPrimaryImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__chromaWhitePointImage = {"_p_Magick__chromaWhitePointImage", "p_Magick__chromaWhitePointImage|Magick::chromaWhitePointImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__colorFuzzImage = {"_p_Magick__colorFuzzImage", "p_Magick__colorFuzzImage|Magick::colorFuzzImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__colorMapImage = {"_p_Magick__colorMapImage", "p_Magick__colorMapImage|Magick::colorMapImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__colorMatrixImage = {"_p_Magick__colorMatrixImage", "Magick::colorMatrixImage *|p_Magick__colorMatrixImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__colorSpaceImage = {"_p_Magick__colorSpaceImage", "p_Magick__colorSpaceImage|Magick::colorSpaceImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__colorizeImage = {"_p_Magick__colorizeImage", "p_Magick__colorizeImage|Magick::colorizeImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__commentImage = {"_p_Magick__commentImage", "p_Magick__commentImage|Magick::commentImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__composeImage = {"_p_Magick__composeImage", "p_Magick__composeImage|Magick::composeImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__compositeImage = {"_p_Magick__compositeImage", "p_Magick__compositeImage|Magick::compositeImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__compressTypeImage = {"_p_Magick__compressTypeImage", "Magick::compressTypeImage *|p_Magick__compressTypeImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__contrastImage = {"_p_Magick__contrastImage", "Magick::contrastImage *|p_Magick__contrastImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__cropImage = {"_p_Magick__cropImage", "Magick::cropImage *|p_Magick__cropImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__cycleColormapImage = {"_p_Magick__cycleColormapImage", "p_Magick__cycleColormapImage|Magick::cycleColormapImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__densityImage = {"_p_Magick__densityImage", "Magick::densityImage *|p_Magick__densityImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__depthImage = {"_p_Magick__depthImage", "p_Magick__depthImage|Magick::depthImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__despeckleImage = {"_p_Magick__despeckleImage", "Magick::despeckleImage *|p_Magick__despeckleImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__distortImage = {"_p_Magick__distortImage", "p_Magick__distortImage|Magick::distortImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__drawImage = {"_p_Magick__drawImage", "p_Magick__drawImage|Magick::drawImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__edgeImage = {"_p_Magick__edgeImage", "p_Magick__edgeImage|Magick::edgeImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__embossImage = {"_p_Magick__embossImage", "Magick::embossImage *|p_Magick__embossImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__endianImage = {"_p_Magick__endianImage", "Magick::endianImage *|p_Magick__endianImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__enhanceImage = {"_p_Magick__enhanceImage", "p_Magick__enhanceImage|Magick::enhanceImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__equalizeImage = {"_p_Magick__equalizeImage", "Magick::equalizeImage *|p_Magick__equalizeImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__fileNameImage = {"_p_Magick__fileNameImage", "p_Magick__fileNameImage|Magick::fileNameImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__fillColorImage = {"_p_Magick__fillColorImage", "p_Magick__fillColorImage|Magick::fillColorImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__filterTypeImage = {"_p_Magick__filterTypeImage", "Magick::filterTypeImage *|p_Magick__filterTypeImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__flipImage = {"_p_Magick__flipImage", "Magick::flipImage *|p_Magick__flipImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__floodFillColorImage = {"_p_Magick__floodFillColorImage", "Magick::floodFillColorImage *|p_Magick__floodFillColorImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__floodFillTextureImage = {"_p_Magick__floodFillTextureImage", "Magick::floodFillTextureImage *|p_Magick__floodFillTextureImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__flopImage = {"_p_Magick__flopImage", "Magick::flopImage *|p_Magick__flopImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__fontImage = {"_p_Magick__fontImage", "p_Magick__fontImage|Magick::fontImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__fontPointsizeImage = {"_p_Magick__fontPointsizeImage", "Magick::fontPointsizeImage *|p_Magick__fontPointsizeImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__frameImage = {"_p_Magick__frameImage", "p_Magick__frameImage|Magick::frameImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__gammaImage = {"_p_Magick__gammaImage", "p_Magick__gammaImage|Magick::gammaImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__gaussianBlurImage = {"_p_Magick__gaussianBlurImage", "Magick::gaussianBlurImage *|p_Magick__gaussianBlurImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__gifDisposeMethodImage = {"_p_Magick__gifDisposeMethodImage", "p_Magick__gifDisposeMethodImage|Magick::gifDisposeMethodImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__haldClutImage = {"_p_Magick__haldClutImage", "p_Magick__haldClutImage|Magick::haldClutImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__implodeImage = {"_p_Magick__implodeImage", "p_Magick__implodeImage|Magick::implodeImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__interlaceTypeImage = {"_p_Magick__interlaceTypeImage", "p_Magick__interlaceTypeImage|Magick::interlaceTypeImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__inverseFourierTransformImage = {"_p_Magick__inverseFourierTransformImage", "Magick::inverseFourierTransformImage *|p_Magick__inverseFourierTransformImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__isValidImage = {"_p_Magick__isValidImage", "p_Magick__isValidImage|Magick::isValidImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__labelImage = {"_p_Magick__labelImage", "Magick::labelImage *|p_Magick__labelImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__levelChannelImage = {"_p_Magick__levelChannelImage", "Magick::levelChannelImage *|p_Magick__levelChannelImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__levelImage = {"_p_Magick__levelImage", "p_Magick__levelImage|Magick::levelImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__lineWidthImage = {"_p_Magick__lineWidthImage", "Magick::lineWidthImage *|p_Magick__lineWidthImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__magickImage = {"_p_Magick__magickImage", "p_Magick__magickImage|Magick::magickImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__magnifyImage = {"_p_Magick__magnifyImage", "Magick::magnifyImage *|p_Magick__magnifyImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__mapImage = {"_p_Magick__mapImage", "p_Magick__mapImage|Magick::mapImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__matteColorImage = {"_p_Magick__matteColorImage", "Magick::matteColorImage *|p_Magick__matteColorImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__matteFloodfillImage = {"_p_Magick__matteFloodfillImage", "Magick::matteFloodfillImage *|p_Magick__matteFloodfillImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__matteImage = {"_p_Magick__matteImage", "p_Magick__matteImage|Magick::matteImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__medianFilterImage = {"_p_Magick__medianFilterImage", "p_Magick__medianFilterImage|Magick::medianFilterImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__mergeLayersImage = {"_p_Magick__mergeLayersImage", "Magick::mergeLayersImage *|p_Magick__mergeLayersImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__minifyImage = {"_p_Magick__minifyImage", "Magick::minifyImage *|p_Magick__minifyImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__modulateImage = {"_p_Magick__modulateImage", "Magick::modulateImage *|p_Magick__modulateImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__monochromeImage = {"_p_Magick__monochromeImage", "Magick::monochromeImage *|p_Magick__monochromeImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__negateImage = {"_p_Magick__negateImage", "Magick::negateImage *|p_Magick__negateImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__normalizeImage = {"_p_Magick__normalizeImage", "Magick::normalizeImage *|p_Magick__normalizeImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__oilPaintImage = {"_p_Magick__oilPaintImage", "p_Magick__oilPaintImage|Magick::oilPaintImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__opacityImage = {"_p_Magick__opacityImage", "p_Magick__opacityImage|Magick::opacityImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__opaqueImage = {"_p_Magick__opaqueImage", "p_Magick__opaqueImage|Magick::opaqueImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__pageImage = {"_p_Magick__pageImage", "p_Magick__pageImage|Magick::pageImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__penColorImage = {"_p_Magick__penColorImage", "p_Magick__penColorImage|Magick::penColorImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__penTextureImage = {"_p_Magick__penTextureImage", "p_Magick__penTextureImage|Magick::penTextureImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__pixelColorImage = {"_p_Magick__pixelColorImage", "p_Magick__pixelColorImage|Magick::pixelColorImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__qualityImage = {"_p_Magick__qualityImage", "p_Magick__qualityImage|Magick::qualityImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__quantizeColorSpaceImage = {"_p_Magick__quantizeColorSpaceImage", "Magick::quantizeColorSpaceImage *|p_Magick__quantizeColorSpaceImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__quantizeColorsImage = {"_p_Magick__quantizeColorsImage", "Magick::quantizeColorsImage *|p_Magick__quantizeColorsImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__quantizeDitherImage = {"_p_Magick__quantizeDitherImage", "Magick::quantizeDitherImage *|p_Magick__quantizeDitherImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__quantizeImage = {"_p_Magick__quantizeImage", "Magick::quantizeImage *|p_Magick__quantizeImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__quantizeTreeDepthImage = {"_p_Magick__quantizeTreeDepthImage", "p_Magick__quantizeTreeDepthImage|Magick::quantizeTreeDepthImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__raiseImage = {"_p_Magick__raiseImage", "p_Magick__raiseImage|Magick::raiseImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__reduceNoiseImage = {"_p_Magick__reduceNoiseImage", "Magick::reduceNoiseImage *|p_Magick__reduceNoiseImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__renderingIntentImage = {"_p_Magick__renderingIntentImage", "p_Magick__renderingIntentImage|Magick::renderingIntentImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__resizeImage = {"_p_Magick__resizeImage", "p_Magick__resizeImage|Magick::resizeImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__resolutionUnitsImage = {"_p_Magick__resolutionUnitsImage", "Magick::resolutionUnitsImage *|p_Magick__resolutionUnitsImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__rollImage = {"_p_Magick__rollImage", "Magick::rollImage *|p_Magick__rollImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__rotateImage = {"_p_Magick__rotateImage", "p_Magick__rotateImage|Magick::rotateImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__sampleImage = {"_p_Magick__sampleImage", "Magick::sampleImage *|p_Magick__sampleImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__scaleImage = {"_p_Magick__scaleImage", "p_Magick__scaleImage|Magick::scaleImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__sceneImage = {"_p_Magick__sceneImage", "p_Magick__sceneImage|Magick::sceneImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__segmentImage = {"_p_Magick__segmentImage", "Magick::segmentImage *|p_Magick__segmentImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__shadeImage = {"_p_Magick__shadeImage", "p_Magick__shadeImage|Magick::shadeImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__shadowImage = {"_p_Magick__shadowImage", "p_Magick__shadowImage|Magick::shadowImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__sharpenImage = {"_p_Magick__sharpenImage", "p_Magick__sharpenImage|Magick::sharpenImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__shaveImage = {"_p_Magick__shaveImage", "p_Magick__shaveImage|Magick::shaveImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__shearImage = {"_p_Magick__shearImage", "Magick::shearImage *|p_Magick__shearImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__sigmoidalContrastImage = {"_p_Magick__sigmoidalContrastImage", "p_Magick__sigmoidalContrastImage|Magick::sigmoidalContrastImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__sizeImage = {"_p_Magick__sizeImage", "p_Magick__sizeImage|Magick::sizeImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__solarizeImage = {"_p_Magick__solarizeImage", "p_Magick__solarizeImage|Magick::solarizeImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__spliceImage = {"_p_Magick__spliceImage", "p_Magick__spliceImage|Magick::spliceImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__spreadImage = {"_p_Magick__spreadImage", "p_Magick__spreadImage|Magick::spreadImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__steganoImage = {"_p_Magick__steganoImage", "p_Magick__steganoImage|Magick::steganoImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__stereoImage = {"_p_Magick__stereoImage", "Magick::stereoImage *|p_Magick__stereoImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__stripImage = {"_p_Magick__stripImage", "p_Magick__stripImage|Magick::stripImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__strokeColorImage = {"_p_Magick__strokeColorImage", "Magick::strokeColorImage *|p_Magick__strokeColorImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__subImageImage = {"_p_Magick__subImageImage", "Magick::subImageImage *|p_Magick__subImageImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__subRangeImage = {"_p_Magick__subRangeImage", "Magick::subRangeImage *|p_Magick__subRangeImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__swirlImage = {"_p_Magick__swirlImage", "Magick::swirlImage *|p_Magick__swirlImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__textureImage = {"_p_Magick__textureImage", "p_Magick__textureImage|Magick::textureImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__thresholdImage = {"_p_Magick__thresholdImage", "Magick::thresholdImage *|p_Magick__thresholdImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__tileNameImage = {"_p_Magick__tileNameImage", "Magick::tileNameImage *|p_Magick__tileNameImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__transformImage = {"_p_Magick__transformImage", "Magick::transformImage *|p_Magick__transformImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__transparentImage = {"_p_Magick__transparentImage", "Magick::transparentImage *|p_Magick__transparentImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__trimImage = {"_p_Magick__trimImage", "p_Magick__trimImage|Magick::trimImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__typeImage = {"_p_Magick__typeImage", "Magick::typeImage *|p_Magick__typeImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__verboseImage = {"_p_Magick__verboseImage", "p_Magick__verboseImage|Magick::verboseImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__viewImage = {"_p_Magick__viewImage", "Magick::viewImage *|p_Magick__viewImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__waveImage = {"_p_Magick__waveImage", "Magick::waveImage *|p_Magick__waveImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__x11DisplayImage = {"_p_Magick__x11DisplayImage", "p_Magick__x11DisplayImage|Magick::x11DisplayImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Magick__zoomImage = {"_p_Magick__zoomImage", "p_Magick__zoomImage|Magick::zoomImage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_PixelPacket = {"_p_PixelPacket", "PixelPacket *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__Ascii85Info = {"_p__Ascii85Info", "MagickCore::Ascii85Info *|_Ascii85Info *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__BlobInfo = {"_p__BlobInfo", "MagickCore::BlobInfo *|_BlobInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__CacheView = {"_p__CacheView", "MagickCore::CacheView *|MagickCore::CacheView_ *|_CacheView *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__DrawingWand = {"_p__DrawingWand", "MagickCore::DrawingWand *|_DrawingWand *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__HashmapInfo = {"_p__HashmapInfo", "MagickCore::HashmapInfo *|_HashmapInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__ImageView = {"_p__ImageView", "MagickCore::ImageView *|_ImageView *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__LinkedListInfo = {"_p__LinkedListInfo", "MagickCore::LinkedListInfo *|_LinkedListInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__LogInfo = {"_p__LogInfo", "MagickCore::LogInfo *|_LogInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__MagickWand = {"_p__MagickWand", "MagickCore::MagickWand *|_MagickWand *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__MatrixInfo = {"_p__MatrixInfo", "MagickCore::MatrixInfo *|_MatrixInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__MemoryInfo = {"_p__MemoryInfo", "MagickCore::MemoryInfo *|_MemoryInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__MimeInfo = {"_p__MimeInfo", "MagickCore::MimeInfo *|_MimeInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__PixelIterator = {"_p__PixelIterator", "MagickCore::PixelIterator *|_PixelIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__PixelView = {"_p__PixelView", "MagickCore::PixelView *|_PixelView *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__PixelWand = {"_p__PixelWand", "MagickCore::PixelWand *|_PixelWand *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__PolicyInfo = {"_p__PolicyInfo", "MagickCore::PolicyInfo *|_PolicyInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__QuantumInfo = {"_p__QuantumInfo", "MagickCore::QuantumInfo *|_QuantumInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__RandomInfo = {"_p__RandomInfo", "MagickCore::RandomInfo *|_RandomInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__ResampleFilter = {"_p__ResampleFilter", "MagickCore::ResampleFilter *|_ResampleFilter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__ResizeFilter = {"_p__ResizeFilter", "MagickCore::ResizeFilter *|_ResizeFilter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__SplayTreeInfo = {"_p__SplayTreeInfo", "MagickCore::SplayTreeInfo *|_SplayTreeInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__ThresholdMap = {"_p__ThresholdMap", "MagickCore::ThresholdMap *|_ThresholdMap *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__TokenInfo = {"_p__TokenInfo", "MagickCore::TokenInfo *|_TokenInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__ViewInfo = {"_p__ViewInfo", "MagickCore::ViewInfo *|_ViewInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__WandView = {"_p__WandView", "MagickCore::WandView *|_WandView *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__XMLTreeInfo = {"_p__XMLTreeInfo", "MagickCore::XMLTreeInfo *|_XMLTreeInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_double = {"_p_double", "MagickCore::ExtendedRationalType *|MagickCore::MagickDoubleType *|MagickCore::MagickRealType *|double *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_p_MagickCore___Image_q_const__int_p_p_q_const__char_p_MagickCore___ExceptionInfo__size_t = {"_p_f_p_p_MagickCore___Image_q_const__int_p_p_q_const__char_p_MagickCore___ExceptionInfo__size_t", "MagickCore::ImageFilterHandler *|size_t (*)(MagickCore::_Image **,int const,char const **,MagickCore::_ExceptionInfo *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_q_const__MagickCore__ImageInfo_p_MagickCore__ExceptionInfo__p_MagickCore___Image = {"_p_f_p_q_const__MagickCore__ImageInfo_p_MagickCore__ExceptionInfo__p_MagickCore___Image", "MagickCore::DecodeImageHandler *|MagickCore::_Image *(*)(MagickCore::ImageInfo const *,MagickCore::ExceptionInfo *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_q_const__MagickCore__ImageInfo_p_MagickCore__Image__MagickCore__MagickBooleanType = {"_p_f_p_q_const__MagickCore__ImageInfo_p_MagickCore__Image__MagickCore__MagickBooleanType", "MagickCore::EncodeImageHandler *|enum MagickCore::MagickBooleanType (*)(MagickCore::ImageInfo const *,MagickCore::Image *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_q_const__unsigned_char_q_const__size_t__MagickCore__MagickBooleanType = {"_p_f_p_q_const__unsigned_char_q_const__size_t__MagickCore__MagickBooleanType", "MagickCore::IsImageFormatHandler *|enum MagickCore::MagickBooleanType (*)(unsigned char const *,size_t const)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_float = {"_p_float", "MagickCore::MagickFloatType *|float *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_long_long = {"_p_long_long", "MagickCore::ExtendedSignedIntegralType *|MagickCore::MagickOffsetType *|long long *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_off_t = {"_p_off_t", "off_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_MagickCore___Image = {"_p_p_MagickCore___Image", "MagickCore::Image **|MagickCore::_Image **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_size_t = {"_p_size_t", "size_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ssize_t = {"_p_ssize_t", "::ssize_t *|MagickCore::SignedQuantum *|ssize_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__exception = {"_p_std__exception", "std::exception *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__listT_Magick__Coordinate_t = {"_p_std__listT_Magick__Coordinate_t", "Magick::CoordinateList *|std::list< Magick::Coordinate > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__listT_Magick__Drawable_t = {"_p_std__listT_Magick__Drawable_t", "Magick::DrawableList *|std::list< Magick::Drawable > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__listT_Magick__PathArcArgs_t = {"_p_std__listT_Magick__PathArcArgs_t", "Magick::PathArcArgsList *|std::list< Magick::PathArcArgs > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__listT_Magick__PathCurvetoArgs_t = {"_p_std__listT_Magick__PathCurvetoArgs_t", "Magick::PathCurveToArgsList *|std::list< Magick::PathCurvetoArgs > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__listT_Magick__PathQuadraticCurvetoArgs_t = {"_p_std__listT_Magick__PathQuadraticCurvetoArgs_t", "Magick::PathQuadraticCurvetoArgsList *|std::list< Magick::PathQuadraticCurvetoArgs > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__listT_Magick__VPath_t = {"_p_std__listT_Magick__VPath_t", "Magick::VPathList *|std::list< Magick::VPath > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "unsigned char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "MagickCore::MagickStatusType *|unsigned int *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "MagickCore::ExtendedUnsignedIntegralType *|MagickCore::MagickSizeType *|MagickCore::QuantumAny *|unsigned long long *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "Magick::IndexPacket *|MagickCore::IndexPacket *|MagickCore::Quantum *|unsigned short *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_void = {"_p_void", "void *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_Color,
  &_swigt__p_Drawable,
  &_swigt__p_DrawableAffine,
  &_swigt__p_DrawableList,
  &_swigt__p_Image,
  &_swigt__p_ImageChannelStatistics,
  &_swigt__p_ImageStatistics,
  &_swigt__p_MagickCore__AlignType,
  &_swigt__p_MagickCore__AlphaChannelType,
  &_swigt__p_MagickCore__AutoThresholdMethod,
  &_swigt__p_MagickCore__CacheType,
  &_swigt__p_MagickCore__ChannelType,
  &_swigt__p_MagickCore__ClassType,
  &_swigt__p_MagickCore__ClipPathUnits,
  &_swigt__p_MagickCore__ColorspaceType,
  &_swigt__p_MagickCore__CommandOption,
  &_swigt__p_MagickCore__CommandOptionFlags,
  &_swigt__p_MagickCore__ComplexOperator,
  &_swigt__p_MagickCore__ComplianceType,
  &_swigt__p_MagickCore__CompositeOperator,
  &_swigt__p_MagickCore__CompressionType,
  &_swigt__p_MagickCore__DecorationType,
  &_swigt__p_MagickCore__DirectionType,
  &_swigt__p_MagickCore__DisposeType,
  &_swigt__p_MagickCore__DistortImageMethod,
  &_swigt__p_MagickCore__DitherMethod,
  &_swigt__p_MagickCore__EndianType,
  &_swigt__p_MagickCore__ExceptionType,
  &_swigt__p_MagickCore__FillRule,
  &_swigt__p_MagickCore__FilterTypes,
  &_swigt__p_MagickCore__GeometryFlags,
  &_swigt__p_MagickCore__GradientType,
  &_swigt__p_MagickCore__GravityType,
  &_swigt__p_MagickCore__ImageLayerMethod,
  &_swigt__p_MagickCore__ImageMagickOpenCLMode,
  &_swigt__p_MagickCore__ImageType,
  &_swigt__p_MagickCore__InterlaceType,
  &_swigt__p_MagickCore__InterpolatePixelMethod,
  &_swigt__p_MagickCore__KernelInfo,
  &_swigt__p_MagickCore__KernelInfoType,
  &_swigt__p_MagickCore__LineCap,
  &_swigt__p_MagickCore__LineJoin,
  &_swigt__p_MagickCore__LogEventType,
  &_swigt__p_MagickCore__MagickBooleanType,
  &_swigt__p_MagickCore__MagickEvaluateOperator,
  &_swigt__p_MagickCore__MagickFormatType,
  &_swigt__p_MagickCore__MagickFunction,
  &_swigt__p_MagickCore__MagickLayerMethod,
  &_swigt__p_MagickCore__MagickModuleType,
  &_swigt__p_MagickCore__MagickOpenCLEnvParam,
  &_swigt__p_MagickCore__MagickOpenCLProgram,
  &_swigt__p_MagickCore__MagickThreadSupport,
  &_swigt__p_MagickCore__MapMode,
  &_swigt__p_MagickCore__MetricType,
  &_swigt__p_MagickCore__MontageMode,
  &_swigt__p_MagickCore__MorphologyMethod,
  &_swigt__p_MagickCore__NoiseType,
  &_swigt__p_MagickCore__OrientationType,
  &_swigt__p_MagickCore__PaintMethod,
  &_swigt__p_MagickCore__PathType,
  &_swigt__p_MagickCore__PixelComponent,
  &_swigt__p_MagickCore__PixelIntensityMethod,
  &_swigt__p_MagickCore__PolicyDomain,
  &_swigt__p_MagickCore__PolicyRights,
  &_swigt__p_MagickCore__PreviewType,
  &_swigt__p_MagickCore__PrimitiveType,
  &_swigt__p_MagickCore__QuantumAlphaType,
  &_swigt__p_MagickCore__QuantumFormatType,
  &_swigt__p_MagickCore__QuantumType,
  &_swigt__p_MagickCore__ReferenceType,
  &_swigt__p_MagickCore__RegistryType,
  &_swigt__p_MagickCore__RenderingIntent,
  &_swigt__p_MagickCore__ResolutionType,
  &_swigt__p_MagickCore__ResourceType,
  &_swigt__p_MagickCore__SemaphoreInfo,
  &_swigt__p_MagickCore__SparseColorMethod,
  &_swigt__p_MagickCore__SpreadMethod,
  &_swigt__p_MagickCore__StatisticType,
  &_swigt__p_MagickCore__StorageType,
  &_swigt__p_MagickCore__StretchType,
  &_swigt__p_MagickCore__StyleType,
  &_swigt__p_MagickCore__TimerState,
  &_swigt__p_MagickCore__TransmitType,
  &_swigt__p_MagickCore__ValidateType,
  &_swigt__p_MagickCore__VirtualPixelMethod,
  &_swigt__p_MagickCore___AffineMatrix,
  &_swigt__p_MagickCore___ChannelFeatures,
  &_swigt__p_MagickCore___ChannelMoments,
  &_swigt__p_MagickCore___ChannelPerceptualHash,
  &_swigt__p_MagickCore___ChannelStatistics,
  &_swigt__p_MagickCore___ChromaticityInfo,
  &_swigt__p_MagickCore___CoderInfo,
  &_swigt__p_MagickCore___ColorInfo,
  &_swigt__p_MagickCore___ColorPacket,
  &_swigt__p_MagickCore___ConfigureInfo,
  &_swigt__p_MagickCore___DelegateInfo,
  &_swigt__p_MagickCore___DoublePixelPacket,
  &_swigt__p_MagickCore___DrawInfo,
  &_swigt__p_MagickCore___ElementReference,
  &_swigt__p_MagickCore___ErrorInfo,
  &_swigt__p_MagickCore___ExceptionInfo,
  &_swigt__p_MagickCore___FrameInfo,
  &_swigt__p_MagickCore___GeometryInfo,
  &_swigt__p_MagickCore___GradientInfo,
  &_swigt__p_MagickCore___Image,
  &_swigt__p_MagickCore___ImageAttribute,
  &_swigt__p_MagickCore___ImageInfo,
  &_swigt__p_MagickCore___LocaleInfo,
  &_swigt__p_MagickCore___LongPixelPacket,
  &_swigt__p_MagickCore___MagicInfo,
  &_swigt__p_MagickCore___MagickInfo,
  &_swigt__p_MagickCore___MagickPixelPacket,
  &_swigt__p_MagickCore___ModuleInfo,
  &_swigt__p_MagickCore___MontageInfo,
  &_swigt__p_MagickCore___OffsetInfo,
  &_swigt__p_MagickCore___OptionInfo,
  &_swigt__p_MagickCore___PixelPacket,
  &_swigt__p_MagickCore___PointInfo,
  &_swigt__p_MagickCore___PrimaryInfo,
  &_swigt__p_MagickCore___PrimitiveInfo,
  &_swigt__p_MagickCore___ProfileInfo,
  &_swigt__p_MagickCore___QuantizeInfo,
  &_swigt__p_MagickCore___QuantumPixelPacket,
  &_swigt__p_MagickCore___RectangleInfo,
  &_swigt__p_MagickCore___SegmentInfo,
  &_swigt__p_MagickCore___StopInfo,
  &_swigt__p_MagickCore___StringInfo,
  &_swigt__p_MagickCore___Timer,
  &_swigt__p_MagickCore___TimerInfo,
  &_swigt__p_MagickCore___TypeInfo,
  &_swigt__p_MagickCore___TypeMetric,
  &_swigt__p_MagickCore___XImportInfo,
  &_swigt__p_Magick__Blob,
  &_swigt__p_Magick__ChannelMoments,
  &_swigt__p_Magick__CoderInfo,
  &_swigt__p_Magick__Color,
  &_swigt__p_Magick__ColorGray,
  &_swigt__p_Magick__ColorHSL,
  &_swigt__p_Magick__ColorMono,
  &_swigt__p_Magick__ColorRGB,
  &_swigt__p_Magick__ColorYUV,
  &_swigt__p_Magick__Coordinate,
  &_swigt__p_Magick__Drawable,
  &_swigt__p_Magick__DrawableAffine,
  &_swigt__p_Magick__DrawableArc,
  &_swigt__p_Magick__DrawableBase,
  &_swigt__p_Magick__DrawableBezier,
  &_swigt__p_Magick__DrawableCircle,
  &_swigt__p_Magick__DrawableClipPath,
  &_swigt__p_Magick__DrawableColor,
  &_swigt__p_Magick__DrawableCompositeImage,
  &_swigt__p_Magick__DrawableDashArray,
  &_swigt__p_Magick__DrawableDashOffset,
  &_swigt__p_Magick__DrawableDensity,
  &_swigt__p_Magick__DrawableEllipse,
  &_swigt__p_Magick__DrawableFillColor,
  &_swigt__p_Magick__DrawableFillOpacity,
  &_swigt__p_Magick__DrawableFillRule,
  &_swigt__p_Magick__DrawableFont,
  &_swigt__p_Magick__DrawableGravity,
  &_swigt__p_Magick__DrawableLine,
  &_swigt__p_Magick__DrawableMatte,
  &_swigt__p_Magick__DrawableMiterLimit,
  &_swigt__p_Magick__DrawablePath,
  &_swigt__p_Magick__DrawablePoint,
  &_swigt__p_Magick__DrawablePointSize,
  &_swigt__p_Magick__DrawablePolygon,
  &_swigt__p_Magick__DrawablePolyline,
  &_swigt__p_Magick__DrawablePopClipPath,
  &_swigt__p_Magick__DrawablePopGraphicContext,
  &_swigt__p_Magick__DrawablePopPattern,
  &_swigt__p_Magick__DrawablePushClipPath,
  &_swigt__p_Magick__DrawablePushGraphicContext,
  &_swigt__p_Magick__DrawablePushPattern,
  &_swigt__p_Magick__DrawableRectangle,
  &_swigt__p_Magick__DrawableRotation,
  &_swigt__p_Magick__DrawableRoundRectangle,
  &_swigt__p_Magick__DrawableScaling,
  &_swigt__p_Magick__DrawableSkewX,
  &_swigt__p_Magick__DrawableSkewY,
  &_swigt__p_Magick__DrawableStrokeAntialias,
  &_swigt__p_Magick__DrawableStrokeColor,
  &_swigt__p_Magick__DrawableStrokeLineCap,
  &_swigt__p_Magick__DrawableStrokeLineJoin,
  &_swigt__p_Magick__DrawableStrokeOpacity,
  &_swigt__p_Magick__DrawableStrokeWidth,
  &_swigt__p_Magick__DrawableText,
  &_swigt__p_Magick__DrawableTextAntialias,
  &_swigt__p_Magick__DrawableTextDecoration,
  &_swigt__p_Magick__DrawableTextDirection,
  &_swigt__p_Magick__DrawableTextInterlineSpacing,
  &_swigt__p_Magick__DrawableTextInterwordSpacing,
  &_swigt__p_Magick__DrawableTextKerning,
  &_swigt__p_Magick__DrawableTextUnderColor,
  &_swigt__p_Magick__DrawableTranslation,
  &_swigt__p_Magick__DrawableViewbox,
  &_swigt__p_Magick__Error,
  &_swigt__p_Magick__ErrorBlob,
  &_swigt__p_Magick__ErrorCache,
  &_swigt__p_Magick__ErrorCoder,
  &_swigt__p_Magick__ErrorConfigure,
  &_swigt__p_Magick__ErrorCorruptImage,
  &_swigt__p_Magick__ErrorDelegate,
  &_swigt__p_Magick__ErrorDraw,
  &_swigt__p_Magick__ErrorFileOpen,
  &_swigt__p_Magick__ErrorImage,
  &_swigt__p_Magick__ErrorMissingDelegate,
  &_swigt__p_Magick__ErrorModule,
  &_swigt__p_Magick__ErrorMonitor,
  &_swigt__p_Magick__ErrorOption,
  &_swigt__p_Magick__ErrorPolicy,
  &_swigt__p_Magick__ErrorRegistry,
  &_swigt__p_Magick__ErrorResourceLimit,
  &_swigt__p_Magick__ErrorStream,
  &_swigt__p_Magick__ErrorType,
  &_swigt__p_Magick__ErrorUndefined,
  &_swigt__p_Magick__ErrorXServer,
  &_swigt__p_Magick__Exception,
  &_swigt__p_Magick__Geometry,
  &_swigt__p_Magick__Image,
  &_swigt__p_Magick__ImageMoments,
  &_swigt__p_Magick__Image___ImageStatistics,
  &_swigt__p_Magick__Montage,
  &_swigt__p_Magick__MontageFramed,
  &_swigt__p_Magick__Offset,
  &_swigt__p_Magick__Options,
  &_swigt__p_Magick__PathArcAbs,
  &_swigt__p_Magick__PathArcArgs,
  &_swigt__p_Magick__PathArcRel,
  &_swigt__p_Magick__PathClosePath,
  &_swigt__p_Magick__PathCurvetoAbs,
  &_swigt__p_Magick__PathCurvetoArgs,
  &_swigt__p_Magick__PathCurvetoRel,
  &_swigt__p_Magick__PathLinetoAbs,
  &_swigt__p_Magick__PathLinetoHorizontalAbs,
  &_swigt__p_Magick__PathLinetoHorizontalRel,
  &_swigt__p_Magick__PathLinetoRel,
  &_swigt__p_Magick__PathLinetoVerticalAbs,
  &_swigt__p_Magick__PathLinetoVerticalRel,
  &_swigt__p_Magick__PathMovetoAbs,
  &_swigt__p_Magick__PathMovetoRel,
  &_swigt__p_Magick__PathQuadraticCurvetoAbs,
  &_swigt__p_Magick__PathQuadraticCurvetoArgs,
  &_swigt__p_Magick__PathQuadraticCurvetoRel,
  &_swigt__p_Magick__PathSmoothCurvetoAbs,
  &_swigt__p_Magick__PathSmoothCurvetoRel,
  &_swigt__p_Magick__PathSmoothQuadraticCurvetoAbs,
  &_swigt__p_Magick__PathSmoothQuadraticCurvetoRel,
  &_swigt__p_Magick__PixelData,
  &_swigt__p_Magick__Pixels,
  &_swigt__p_Magick__ReadOptions,
  &_swigt__p_Magick__ResourceLimits,
  &_swigt__p_Magick__TypeMetric,
  &_swigt__p_Magick__VPath,
  &_swigt__p_Magick__VPathBase,
  &_swigt__p_Magick__Warning,
  &_swigt__p_Magick__WarningBlob,
  &_swigt__p_Magick__WarningCache,
  &_swigt__p_Magick__WarningCoder,
  &_swigt__p_Magick__WarningConfigure,
  &_swigt__p_Magick__WarningCorruptImage,
  &_swigt__p_Magick__WarningDelegate,
  &_swigt__p_Magick__WarningDraw,
  &_swigt__p_Magick__WarningFileOpen,
  &_swigt__p_Magick__WarningImage,
  &_swigt__p_Magick__WarningMissingDelegate,
  &_swigt__p_Magick__WarningModule,
  &_swigt__p_Magick__WarningMonitor,
  &_swigt__p_Magick__WarningOption,
  &_swigt__p_Magick__WarningPolicy,
  &_swigt__p_Magick__WarningRegistry,
  &_swigt__p_Magick__WarningResourceLimit,
  &_swigt__p_Magick__WarningStream,
  &_swigt__p_Magick__WarningType,
  &_swigt__p_Magick__WarningUndefined,
  &_swigt__p_Magick__WarningXServer,
  &_swigt__p_Magick__adaptiveBlurImage,
  &_swigt__p_Magick__adaptiveThresholdImage,
  &_swigt__p_Magick__addNoiseImage,
  &_swigt__p_Magick__adjoinImage,
  &_swigt__p_Magick__affineTransformImage,
  &_swigt__p_Magick__animationDelayImage,
  &_swigt__p_Magick__animationIterationsImage,
  &_swigt__p_Magick__annotateImage,
  &_swigt__p_Magick__antiAliasImage,
  &_swigt__p_Magick__backgroundColorImage,
  &_swigt__p_Magick__backgroundTextureImage,
  &_swigt__p_Magick__blurImage,
  &_swigt__p_Magick__borderColorImage,
  &_swigt__p_Magick__borderImage,
  &_swigt__p_Magick__boxColorImage,
  &_swigt__p_Magick__cdlImage,
  &_swigt__p_Magick__channelImage,
  &_swigt__p_Magick__charcoalImage,
  &_swigt__p_Magick__chopImage,
  &_swigt__p_Magick__chromaBluePrimaryImage,
  &_swigt__p_Magick__chromaGreenPrimaryImage,
  &_swigt__p_Magick__chromaRedPrimaryImage,
  &_swigt__p_Magick__chromaWhitePointImage,
  &_swigt__p_Magick__colorFuzzImage,
  &_swigt__p_Magick__colorMapImage,
  &_swigt__p_Magick__colorMatrixImage,
  &_swigt__p_Magick__colorSpaceImage,
  &_swigt__p_Magick__colorizeImage,
  &_swigt__p_Magick__commentImage,
  &_swigt__p_Magick__composeImage,
  &_swigt__p_Magick__compositeImage,
  &_swigt__p_Magick__compressTypeImage,
  &_swigt__p_Magick__contrastImage,
  &_swigt__p_Magick__cropImage,
  &_swigt__p_Magick__cycleColormapImage,
  &_swigt__p_Magick__densityImage,
  &_swigt__p_Magick__depthImage,
  &_swigt__p_Magick__despeckleImage,
  &_swigt__p_Magick__distortImage,
  &_swigt__p_Magick__drawImage,
  &_swigt__p_Magick__edgeImage,
  &_swigt__p_Magick__embossImage,
  &_swigt__p_Magick__endianImage,
  &_swigt__p_Magick__enhanceImage,
  &_swigt__p_Magick__equalizeImage,
  &_swigt__p_Magick__fileNameImage,
  &_swigt__p_Magick__fillColorImage,
  &_swigt__p_Magick__filterTypeImage,
  &_swigt__p_Magick__flipImage,
  &_swigt__p_Magick__floodFillColorImage,
  &_swigt__p_Magick__floodFillTextureImage,
  &_swigt__p_Magick__flopImage,
  &_swigt__p_Magick__fontImage,
  &_swigt__p_Magick__fontPointsizeImage,
  &_swigt__p_Magick__frameImage,
  &_swigt__p_Magick__gammaImage,
  &_swigt__p_Magick__gaussianBlurImage,
  &_swigt__p_Magick__gifDisposeMethodImage,
  &_swigt__p_Magick__haldClutImage,
  &_swigt__p_Magick__implodeImage,
  &_swigt__p_Magick__interlaceTypeImage,
  &_swigt__p_Magick__inverseFourierTransformImage,
  &_swigt__p_Magick__isValidImage,
  &_swigt__p_Magick__labelImage,
  &_swigt__p_Magick__levelChannelImage,
  &_swigt__p_Magick__levelImage,
  &_swigt__p_Magick__lineWidthImage,
  &_swigt__p_Magick__magickImage,
  &_swigt__p_Magick__magnifyImage,
  &_swigt__p_Magick__mapImage,
  &_swigt__p_Magick__matteColorImage,
  &_swigt__p_Magick__matteFloodfillImage,
  &_swigt__p_Magick__matteImage,
  &_swigt__p_Magick__medianFilterImage,
  &_swigt__p_Magick__mergeLayersImage,
  &_swigt__p_Magick__minifyImage,
  &_swigt__p_Magick__modulateImage,
  &_swigt__p_Magick__monochromeImage,
  &_swigt__p_Magick__negateImage,
  &_swigt__p_Magick__normalizeImage,
  &_swigt__p_Magick__oilPaintImage,
  &_swigt__p_Magick__opacityImage,
  &_swigt__p_Magick__opaqueImage,
  &_swigt__p_Magick__pageImage,
  &_swigt__p_Magick__penColorImage,
  &_swigt__p_Magick__penTextureImage,
  &_swigt__p_Magick__pixelColorImage,
  &_swigt__p_Magick__qualityImage,
  &_swigt__p_Magick__quantizeColorSpaceImage,
  &_swigt__p_Magick__quantizeColorsImage,
  &_swigt__p_Magick__quantizeDitherImage,
  &_swigt__p_Magick__quantizeImage,
  &_swigt__p_Magick__quantizeTreeDepthImage,
  &_swigt__p_Magick__raiseImage,
  &_swigt__p_Magick__reduceNoiseImage,
  &_swigt__p_Magick__renderingIntentImage,
  &_swigt__p_Magick__resizeImage,
  &_swigt__p_Magick__resolutionUnitsImage,
  &_swigt__p_Magick__rollImage,
  &_swigt__p_Magick__rotateImage,
  &_swigt__p_Magick__sampleImage,
  &_swigt__p_Magick__scaleImage,
  &_swigt__p_Magick__sceneImage,
  &_swigt__p_Magick__segmentImage,
  &_swigt__p_Magick__shadeImage,
  &_swigt__p_Magick__shadowImage,
  &_swigt__p_Magick__sharpenImage,
  &_swigt__p_Magick__shaveImage,
  &_swigt__p_Magick__shearImage,
  &_swigt__p_Magick__sigmoidalContrastImage,
  &_swigt__p_Magick__sizeImage,
  &_swigt__p_Magick__solarizeImage,
  &_swigt__p_Magick__spliceImage,
  &_swigt__p_Magick__spreadImage,
  &_swigt__p_Magick__steganoImage,
  &_swigt__p_Magick__stereoImage,
  &_swigt__p_Magick__stripImage,
  &_swigt__p_Magick__strokeColorImage,
  &_swigt__p_Magick__subImageImage,
  &_swigt__p_Magick__subRangeImage,
  &_swigt__p_Magick__swirlImage,
  &_swigt__p_Magick__textureImage,
  &_swigt__p_Magick__thresholdImage,
  &_swigt__p_Magick__tileNameImage,
  &_swigt__p_Magick__transformImage,
  &_swigt__p_Magick__transparentImage,
  &_swigt__p_Magick__trimImage,
  &_swigt__p_Magick__typeImage,
  &_swigt__p_Magick__verboseImage,
  &_swigt__p_Magick__viewImage,
  &_swigt__p_Magick__waveImage,
  &_swigt__p_Magick__x11DisplayImage,
  &_swigt__p_Magick__zoomImage,
  &_swigt__p_PixelPacket,
  &_swigt__p__Ascii85Info,
  &_swigt__p__BlobInfo,
  &_swigt__p__CacheView,
  &_swigt__p__DrawingWand,
  &_swigt__p__HashmapInfo,
  &_swigt__p__ImageView,
  &_swigt__p__LinkedListInfo,
  &_swigt__p__LogInfo,
  &_swigt__p__MagickWand,
  &_swigt__p__MatrixInfo,
  &_swigt__p__MemoryInfo,
  &_swigt__p__MimeInfo,
  &_swigt__p__PixelIterator,
  &_swigt__p__PixelView,
  &_swigt__p__PixelWand,
  &_swigt__p__PolicyInfo,
  &_swigt__p__QuantumInfo,
  &_swigt__p__RandomInfo,
  &_swigt__p__ResampleFilter,
  &_swigt__p__ResizeFilter,
  &_swigt__p__SplayTreeInfo,
  &_swigt__p__ThresholdMap,
  &_swigt__p__TokenInfo,
  &_swigt__p__ViewInfo,
  &_swigt__p__WandView,
  &_swigt__p__XMLTreeInfo,
  &_swigt__p_char,
  &_swigt__p_double,
  &_swigt__p_f_p_p_MagickCore___Image_q_const__int_p_p_q_const__char_p_MagickCore___ExceptionInfo__size_t,
  &_swigt__p_f_p_q_const__MagickCore__ImageInfo_p_MagickCore__ExceptionInfo__p_MagickCore___Image,
  &_swigt__p_f_p_q_const__MagickCore__ImageInfo_p_MagickCore__Image__MagickCore__MagickBooleanType,
  &_swigt__p_f_p_q_const__unsigned_char_q_const__size_t__MagickCore__MagickBooleanType,
  &_swigt__p_float,
  &_swigt__p_long_long,
  &_swigt__p_off_t,
  &_swigt__p_p_MagickCore___Image,
  &_swigt__p_p_char,
  &_swigt__p_size_t,
  &_swigt__p_ssize_t,
  &_swigt__p_std__exception,
  &_swigt__p_std__listT_Magick__Coordinate_t,
  &_swigt__p_std__listT_Magick__Drawable_t,
  &_swigt__p_std__listT_Magick__PathArcArgs_t,
  &_swigt__p_std__listT_Magick__PathCurvetoArgs_t,
  &_swigt__p_std__listT_Magick__PathQuadraticCurvetoArgs_t,
  &_swigt__p_std__listT_Magick__VPath_t,
  &_swigt__p_unsigned_char,
  &_swigt__p_unsigned_int,
  &_swigt__p_unsigned_long_long,
  &_swigt__p_unsigned_short,
  &_swigt__p_void,
};

static swig_cast_info _swigc__p_Color[] = {  {&_swigt__p_Color, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Drawable[] = {  {&_swigt__p_Drawable, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_DrawableAffine[] = {  {&_swigt__p_DrawableAffine, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_DrawableList[] = {  {&_swigt__p_DrawableList, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Image[] = {  {&_swigt__p_Image, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ImageChannelStatistics[] = {  {&_swigt__p_ImageChannelStatistics, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ImageStatistics[] = {  {&_swigt__p_ImageStatistics, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__AlignType[] = {  {&_swigt__p_MagickCore__AlignType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__AlphaChannelType[] = {  {&_swigt__p_MagickCore__AlphaChannelType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__AutoThresholdMethod[] = {  {&_swigt__p_MagickCore__AutoThresholdMethod, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__CacheType[] = {  {&_swigt__p_MagickCore__CacheType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__ChannelType[] = {  {&_swigt__p_MagickCore__ChannelType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__ClassType[] = {  {&_swigt__p_MagickCore__ClassType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__ClipPathUnits[] = {  {&_swigt__p_MagickCore__ClipPathUnits, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__ColorspaceType[] = {  {&_swigt__p_MagickCore__ColorspaceType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__CommandOption[] = {  {&_swigt__p_MagickCore__CommandOption, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__CommandOptionFlags[] = {  {&_swigt__p_MagickCore__CommandOptionFlags, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__ComplexOperator[] = {  {&_swigt__p_MagickCore__ComplexOperator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__ComplianceType[] = {  {&_swigt__p_MagickCore__ComplianceType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__CompositeOperator[] = {  {&_swigt__p_MagickCore__CompositeOperator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__CompressionType[] = {  {&_swigt__p_MagickCore__CompressionType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__DecorationType[] = {  {&_swigt__p_MagickCore__DecorationType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__DirectionType[] = {  {&_swigt__p_MagickCore__DirectionType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__DisposeType[] = {  {&_swigt__p_MagickCore__DisposeType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__DistortImageMethod[] = {  {&_swigt__p_MagickCore__DistortImageMethod, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__DitherMethod[] = {  {&_swigt__p_MagickCore__DitherMethod, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__EndianType[] = {  {&_swigt__p_MagickCore__EndianType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__ExceptionType[] = {  {&_swigt__p_MagickCore__ExceptionType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__FillRule[] = {  {&_swigt__p_MagickCore__FillRule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__FilterTypes[] = {  {&_swigt__p_MagickCore__FilterTypes, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__GeometryFlags[] = {  {&_swigt__p_MagickCore__GeometryFlags, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__GradientType[] = {  {&_swigt__p_MagickCore__GradientType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__GravityType[] = {  {&_swigt__p_MagickCore__GravityType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__ImageLayerMethod[] = {  {&_swigt__p_MagickCore__ImageLayerMethod, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__ImageMagickOpenCLMode[] = {  {&_swigt__p_MagickCore__ImageMagickOpenCLMode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__ImageType[] = {  {&_swigt__p_MagickCore__ImageType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__InterlaceType[] = {  {&_swigt__p_MagickCore__InterlaceType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__InterpolatePixelMethod[] = {  {&_swigt__p_MagickCore__InterpolatePixelMethod, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__KernelInfo[] = {  {&_swigt__p_MagickCore__KernelInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__KernelInfoType[] = {  {&_swigt__p_MagickCore__KernelInfoType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__LineCap[] = {  {&_swigt__p_MagickCore__LineCap, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__LineJoin[] = {  {&_swigt__p_MagickCore__LineJoin, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__LogEventType[] = {  {&_swigt__p_MagickCore__LogEventType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__MagickBooleanType[] = {  {&_swigt__p_MagickCore__MagickBooleanType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__MagickEvaluateOperator[] = {  {&_swigt__p_MagickCore__MagickEvaluateOperator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__MagickFormatType[] = {  {&_swigt__p_MagickCore__MagickFormatType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__MagickFunction[] = {  {&_swigt__p_MagickCore__MagickFunction, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__MagickLayerMethod[] = {  {&_swigt__p_MagickCore__MagickLayerMethod, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__MagickModuleType[] = {  {&_swigt__p_MagickCore__MagickModuleType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__MagickOpenCLEnvParam[] = {  {&_swigt__p_MagickCore__MagickOpenCLEnvParam, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__MagickOpenCLProgram[] = {  {&_swigt__p_MagickCore__MagickOpenCLProgram, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__MagickThreadSupport[] = {  {&_swigt__p_MagickCore__MagickThreadSupport, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__MapMode[] = {  {&_swigt__p_MagickCore__MapMode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__MetricType[] = {  {&_swigt__p_MagickCore__MetricType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__MontageMode[] = {  {&_swigt__p_MagickCore__MontageMode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__MorphologyMethod[] = {  {&_swigt__p_MagickCore__MorphologyMethod, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__NoiseType[] = {  {&_swigt__p_MagickCore__NoiseType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__OrientationType[] = {  {&_swigt__p_MagickCore__OrientationType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__PaintMethod[] = {  {&_swigt__p_MagickCore__PaintMethod, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__PathType[] = {  {&_swigt__p_MagickCore__PathType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__PixelComponent[] = {  {&_swigt__p_MagickCore__PixelComponent, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__PixelIntensityMethod[] = {  {&_swigt__p_MagickCore__PixelIntensityMethod, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__PolicyDomain[] = {  {&_swigt__p_MagickCore__PolicyDomain, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__PolicyRights[] = {  {&_swigt__p_MagickCore__PolicyRights, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__PreviewType[] = {  {&_swigt__p_MagickCore__PreviewType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__PrimitiveType[] = {  {&_swigt__p_MagickCore__PrimitiveType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__QuantumAlphaType[] = {  {&_swigt__p_MagickCore__QuantumAlphaType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__QuantumFormatType[] = {  {&_swigt__p_MagickCore__QuantumFormatType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__QuantumType[] = {  {&_swigt__p_MagickCore__QuantumType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__ReferenceType[] = {  {&_swigt__p_MagickCore__ReferenceType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__RegistryType[] = {  {&_swigt__p_MagickCore__RegistryType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__RenderingIntent[] = {  {&_swigt__p_MagickCore__RenderingIntent, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__ResolutionType[] = {  {&_swigt__p_MagickCore__ResolutionType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__ResourceType[] = {  {&_swigt__p_MagickCore__ResourceType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__SemaphoreInfo[] = {  {&_swigt__p_MagickCore__SemaphoreInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__SparseColorMethod[] = {  {&_swigt__p_MagickCore__SparseColorMethod, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__SpreadMethod[] = {  {&_swigt__p_MagickCore__SpreadMethod, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__StatisticType[] = {  {&_swigt__p_MagickCore__StatisticType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__StorageType[] = {  {&_swigt__p_MagickCore__StorageType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__StretchType[] = {  {&_swigt__p_MagickCore__StretchType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__StyleType[] = {  {&_swigt__p_MagickCore__StyleType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__TimerState[] = {  {&_swigt__p_MagickCore__TimerState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__TransmitType[] = {  {&_swigt__p_MagickCore__TransmitType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__ValidateType[] = {  {&_swigt__p_MagickCore__ValidateType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore__VirtualPixelMethod[] = {  {&_swigt__p_MagickCore__VirtualPixelMethod, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___AffineMatrix[] = {  {&_swigt__p_MagickCore___AffineMatrix, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___ChannelFeatures[] = {  {&_swigt__p_MagickCore___ChannelFeatures, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___ChannelMoments[] = {  {&_swigt__p_MagickCore___ChannelMoments, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___ChannelPerceptualHash[] = {  {&_swigt__p_MagickCore___ChannelPerceptualHash, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___ChannelStatistics[] = {  {&_swigt__p_MagickCore___ChannelStatistics, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___ChromaticityInfo[] = {  {&_swigt__p_MagickCore___ChromaticityInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___CoderInfo[] = {  {&_swigt__p_MagickCore___CoderInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___ColorInfo[] = {  {&_swigt__p_MagickCore___ColorInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___ColorPacket[] = {  {&_swigt__p_MagickCore___ColorPacket, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___ConfigureInfo[] = {  {&_swigt__p_MagickCore___ConfigureInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___DelegateInfo[] = {  {&_swigt__p_MagickCore___DelegateInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___DoublePixelPacket[] = {  {&_swigt__p_MagickCore___DoublePixelPacket, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___DrawInfo[] = {  {&_swigt__p_MagickCore___DrawInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___ElementReference[] = {  {&_swigt__p_MagickCore___ElementReference, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___ErrorInfo[] = {  {&_swigt__p_MagickCore___ErrorInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___ExceptionInfo[] = {  {&_swigt__p_MagickCore___ExceptionInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___FrameInfo[] = {  {&_swigt__p_MagickCore___FrameInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___GeometryInfo[] = {  {&_swigt__p_MagickCore___GeometryInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___GradientInfo[] = {  {&_swigt__p_MagickCore___GradientInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___Image[] = {  {&_swigt__p_MagickCore___Image, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___ImageAttribute[] = {  {&_swigt__p_MagickCore___ImageAttribute, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___ImageInfo[] = {  {&_swigt__p_MagickCore___ImageInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___LocaleInfo[] = {  {&_swigt__p_MagickCore___LocaleInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___LongPixelPacket[] = {  {&_swigt__p_MagickCore___LongPixelPacket, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___MagicInfo[] = {  {&_swigt__p_MagickCore___MagicInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___MagickInfo[] = {  {&_swigt__p_MagickCore___MagickInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___MagickPixelPacket[] = {  {&_swigt__p_MagickCore___MagickPixelPacket, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___ModuleInfo[] = {  {&_swigt__p_MagickCore___ModuleInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___MontageInfo[] = {  {&_swigt__p_MagickCore___MontageInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___OffsetInfo[] = {  {&_swigt__p_MagickCore___OffsetInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___OptionInfo[] = {  {&_swigt__p_MagickCore___OptionInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___PixelPacket[] = {  {&_swigt__p_MagickCore___PixelPacket, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___PointInfo[] = {  {&_swigt__p_MagickCore___PointInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___PrimaryInfo[] = {  {&_swigt__p_MagickCore___PrimaryInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___PrimitiveInfo[] = {  {&_swigt__p_MagickCore___PrimitiveInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___ProfileInfo[] = {  {&_swigt__p_MagickCore___ProfileInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___QuantizeInfo[] = {  {&_swigt__p_MagickCore___QuantizeInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___QuantumPixelPacket[] = {  {&_swigt__p_MagickCore___QuantumPixelPacket, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___RectangleInfo[] = {  {&_swigt__p_MagickCore___RectangleInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___SegmentInfo[] = {  {&_swigt__p_MagickCore___SegmentInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___StopInfo[] = {  {&_swigt__p_MagickCore___StopInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___StringInfo[] = {  {&_swigt__p_MagickCore___StringInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___Timer[] = {  {&_swigt__p_MagickCore___Timer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___TimerInfo[] = {  {&_swigt__p_MagickCore___TimerInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___TypeInfo[] = {  {&_swigt__p_MagickCore___TypeInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___TypeMetric[] = {  {&_swigt__p_MagickCore___TypeMetric, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MagickCore___XImportInfo[] = {  {&_swigt__p_MagickCore___XImportInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__Blob[] = {  {&_swigt__p_Magick__Blob, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ChannelMoments[] = {  {&_swigt__p_Magick__ChannelMoments, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__CoderInfo[] = {  {&_swigt__p_Magick__CoderInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__Color[] = {  {&_swigt__p_Magick__Color, 0, 0, 0},  {&_swigt__p_Magick__ColorGray, _p_Magick__ColorGrayTo_p_Magick__Color, 0, 0},  {&_swigt__p_Magick__ColorHSL, _p_Magick__ColorHSLTo_p_Magick__Color, 0, 0},  {&_swigt__p_Magick__ColorMono, _p_Magick__ColorMonoTo_p_Magick__Color, 0, 0},  {&_swigt__p_Magick__ColorRGB, _p_Magick__ColorRGBTo_p_Magick__Color, 0, 0},  {&_swigt__p_Magick__ColorYUV, _p_Magick__ColorYUVTo_p_Magick__Color, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ColorGray[] = {  {&_swigt__p_Magick__ColorGray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ColorHSL[] = {  {&_swigt__p_Magick__ColorHSL, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ColorMono[] = {  {&_swigt__p_Magick__ColorMono, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ColorRGB[] = {  {&_swigt__p_Magick__ColorRGB, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ColorYUV[] = {  {&_swigt__p_Magick__ColorYUV, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__Coordinate[] = {  {&_swigt__p_Magick__Coordinate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__Drawable[] = {  {&_swigt__p_Magick__Drawable, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableAffine[] = {  {&_swigt__p_Magick__DrawableAffine, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableArc[] = {  {&_swigt__p_Magick__DrawableArc, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableBase[] = {  {&_swigt__p_Magick__DrawableBase, 0, 0, 0},  {&_swigt__p_Magick__DrawableAffine, _p_Magick__DrawableAffineTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableArc, _p_Magick__DrawableArcTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableBezier, _p_Magick__DrawableBezierTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableCircle, _p_Magick__DrawableCircleTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableClipPath, _p_Magick__DrawableClipPathTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableColor, _p_Magick__DrawableColorTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableCompositeImage, _p_Magick__DrawableCompositeImageTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableDashArray, _p_Magick__DrawableDashArrayTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableDashOffset, _p_Magick__DrawableDashOffsetTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableDensity, _p_Magick__DrawableDensityTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableEllipse, _p_Magick__DrawableEllipseTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableFillColor, _p_Magick__DrawableFillColorTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableFillOpacity, _p_Magick__DrawableFillOpacityTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableFillRule, _p_Magick__DrawableFillRuleTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableFont, _p_Magick__DrawableFontTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableGravity, _p_Magick__DrawableGravityTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableLine, _p_Magick__DrawableLineTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableMatte, _p_Magick__DrawableMatteTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableMiterLimit, _p_Magick__DrawableMiterLimitTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawablePath, _p_Magick__DrawablePathTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawablePoint, _p_Magick__DrawablePointTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawablePointSize, _p_Magick__DrawablePointSizeTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawablePolygon, _p_Magick__DrawablePolygonTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawablePolyline, _p_Magick__DrawablePolylineTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawablePopClipPath, _p_Magick__DrawablePopClipPathTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawablePopGraphicContext, _p_Magick__DrawablePopGraphicContextTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawablePopPattern, _p_Magick__DrawablePopPatternTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawablePushClipPath, _p_Magick__DrawablePushClipPathTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawablePushGraphicContext, _p_Magick__DrawablePushGraphicContextTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawablePushPattern, _p_Magick__DrawablePushPatternTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableRectangle, _p_Magick__DrawableRectangleTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableRotation, _p_Magick__DrawableRotationTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableRoundRectangle, _p_Magick__DrawableRoundRectangleTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableScaling, _p_Magick__DrawableScalingTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableSkewX, _p_Magick__DrawableSkewXTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableSkewY, _p_Magick__DrawableSkewYTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableStrokeAntialias, _p_Magick__DrawableStrokeAntialiasTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableStrokeColor, _p_Magick__DrawableStrokeColorTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableStrokeLineCap, _p_Magick__DrawableStrokeLineCapTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableStrokeLineJoin, _p_Magick__DrawableStrokeLineJoinTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableStrokeOpacity, _p_Magick__DrawableStrokeOpacityTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableStrokeWidth, _p_Magick__DrawableStrokeWidthTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableText, _p_Magick__DrawableTextTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableTextAntialias, _p_Magick__DrawableTextAntialiasTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableTextDecoration, _p_Magick__DrawableTextDecorationTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableTextDirection, _p_Magick__DrawableTextDirectionTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableTextInterlineSpacing, _p_Magick__DrawableTextInterlineSpacingTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableTextInterwordSpacing, _p_Magick__DrawableTextInterwordSpacingTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableTextKerning, _p_Magick__DrawableTextKerningTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableTextUnderColor, _p_Magick__DrawableTextUnderColorTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableTranslation, _p_Magick__DrawableTranslationTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableViewbox, _p_Magick__DrawableViewboxTo_p_Magick__DrawableBase, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableBezier[] = {  {&_swigt__p_Magick__DrawableBezier, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableCircle[] = {  {&_swigt__p_Magick__DrawableCircle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableClipPath[] = {  {&_swigt__p_Magick__DrawableClipPath, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableColor[] = {  {&_swigt__p_Magick__DrawableColor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableCompositeImage[] = {  {&_swigt__p_Magick__DrawableCompositeImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableDashArray[] = {  {&_swigt__p_Magick__DrawableDashArray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableDashOffset[] = {  {&_swigt__p_Magick__DrawableDashOffset, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableDensity[] = {  {&_swigt__p_Magick__DrawableDensity, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableEllipse[] = {  {&_swigt__p_Magick__DrawableEllipse, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableFillColor[] = {  {&_swigt__p_Magick__DrawableFillColor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableFillOpacity[] = {  {&_swigt__p_Magick__DrawableFillOpacity, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableFillRule[] = {  {&_swigt__p_Magick__DrawableFillRule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableFont[] = {  {&_swigt__p_Magick__DrawableFont, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableGravity[] = {  {&_swigt__p_Magick__DrawableGravity, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableLine[] = {  {&_swigt__p_Magick__DrawableLine, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableMatte[] = {  {&_swigt__p_Magick__DrawableMatte, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableMiterLimit[] = {  {&_swigt__p_Magick__DrawableMiterLimit, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawablePath[] = {  {&_swigt__p_Magick__DrawablePath, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawablePoint[] = {  {&_swigt__p_Magick__DrawablePoint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawablePointSize[] = {  {&_swigt__p_Magick__DrawablePointSize, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawablePolygon[] = {  {&_swigt__p_Magick__DrawablePolygon, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawablePolyline[] = {  {&_swigt__p_Magick__DrawablePolyline, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawablePopClipPath[] = {  {&_swigt__p_Magick__DrawablePopClipPath, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawablePopGraphicContext[] = {  {&_swigt__p_Magick__DrawablePopGraphicContext, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawablePopPattern[] = {  {&_swigt__p_Magick__DrawablePopPattern, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawablePushClipPath[] = {  {&_swigt__p_Magick__DrawablePushClipPath, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawablePushGraphicContext[] = {  {&_swigt__p_Magick__DrawablePushGraphicContext, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawablePushPattern[] = {  {&_swigt__p_Magick__DrawablePushPattern, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableRectangle[] = {  {&_swigt__p_Magick__DrawableRectangle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableRotation[] = {  {&_swigt__p_Magick__DrawableRotation, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableRoundRectangle[] = {  {&_swigt__p_Magick__DrawableRoundRectangle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableScaling[] = {  {&_swigt__p_Magick__DrawableScaling, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableSkewX[] = {  {&_swigt__p_Magick__DrawableSkewX, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableSkewY[] = {  {&_swigt__p_Magick__DrawableSkewY, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableStrokeAntialias[] = {  {&_swigt__p_Magick__DrawableStrokeAntialias, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableStrokeColor[] = {  {&_swigt__p_Magick__DrawableStrokeColor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableStrokeLineCap[] = {  {&_swigt__p_Magick__DrawableStrokeLineCap, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableStrokeLineJoin[] = {  {&_swigt__p_Magick__DrawableStrokeLineJoin, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableStrokeOpacity[] = {  {&_swigt__p_Magick__DrawableStrokeOpacity, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableStrokeWidth[] = {  {&_swigt__p_Magick__DrawableStrokeWidth, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableText[] = {  {&_swigt__p_Magick__DrawableText, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableTextAntialias[] = {  {&_swigt__p_Magick__DrawableTextAntialias, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableTextDecoration[] = {  {&_swigt__p_Magick__DrawableTextDecoration, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableTextDirection[] = {  {&_swigt__p_Magick__DrawableTextDirection, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableTextInterlineSpacing[] = {  {&_swigt__p_Magick__DrawableTextInterlineSpacing, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableTextInterwordSpacing[] = {  {&_swigt__p_Magick__DrawableTextInterwordSpacing, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableTextKerning[] = {  {&_swigt__p_Magick__DrawableTextKerning, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableTextUnderColor[] = {  {&_swigt__p_Magick__DrawableTextUnderColor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableTranslation[] = {  {&_swigt__p_Magick__DrawableTranslation, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__DrawableViewbox[] = {  {&_swigt__p_Magick__DrawableViewbox, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__Error[] = {  {&_swigt__p_Magick__Error, 0, 0, 0},  {&_swigt__p_Magick__ErrorBlob, _p_Magick__ErrorBlobTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorCache, _p_Magick__ErrorCacheTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorCoder, _p_Magick__ErrorCoderTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorConfigure, _p_Magick__ErrorConfigureTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorCorruptImage, _p_Magick__ErrorCorruptImageTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorDelegate, _p_Magick__ErrorDelegateTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorDraw, _p_Magick__ErrorDrawTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorFileOpen, _p_Magick__ErrorFileOpenTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorImage, _p_Magick__ErrorImageTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorMissingDelegate, _p_Magick__ErrorMissingDelegateTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorModule, _p_Magick__ErrorModuleTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorMonitor, _p_Magick__ErrorMonitorTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorOption, _p_Magick__ErrorOptionTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorPolicy, _p_Magick__ErrorPolicyTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorRegistry, _p_Magick__ErrorRegistryTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorResourceLimit, _p_Magick__ErrorResourceLimitTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorStream, _p_Magick__ErrorStreamTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorType, _p_Magick__ErrorTypeTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorUndefined, _p_Magick__ErrorUndefinedTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorXServer, _p_Magick__ErrorXServerTo_p_Magick__Error, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ErrorBlob[] = {  {&_swigt__p_Magick__ErrorBlob, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ErrorCache[] = {  {&_swigt__p_Magick__ErrorCache, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ErrorCoder[] = {  {&_swigt__p_Magick__ErrorCoder, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ErrorConfigure[] = {  {&_swigt__p_Magick__ErrorConfigure, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ErrorCorruptImage[] = {  {&_swigt__p_Magick__ErrorCorruptImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ErrorDelegate[] = {  {&_swigt__p_Magick__ErrorDelegate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ErrorDraw[] = {  {&_swigt__p_Magick__ErrorDraw, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ErrorFileOpen[] = {  {&_swigt__p_Magick__ErrorFileOpen, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ErrorImage[] = {  {&_swigt__p_Magick__ErrorImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ErrorMissingDelegate[] = {  {&_swigt__p_Magick__ErrorMissingDelegate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ErrorModule[] = {  {&_swigt__p_Magick__ErrorModule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ErrorMonitor[] = {  {&_swigt__p_Magick__ErrorMonitor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ErrorOption[] = {  {&_swigt__p_Magick__ErrorOption, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ErrorPolicy[] = {  {&_swigt__p_Magick__ErrorPolicy, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ErrorRegistry[] = {  {&_swigt__p_Magick__ErrorRegistry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ErrorResourceLimit[] = {  {&_swigt__p_Magick__ErrorResourceLimit, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ErrorStream[] = {  {&_swigt__p_Magick__ErrorStream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ErrorType[] = {  {&_swigt__p_Magick__ErrorType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ErrorUndefined[] = {  {&_swigt__p_Magick__ErrorUndefined, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ErrorXServer[] = {  {&_swigt__p_Magick__ErrorXServer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__Exception[] = {  {&_swigt__p_Magick__Exception, 0, 0, 0},  {&_swigt__p_Magick__Error, _p_Magick__ErrorTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorBlob, _p_Magick__ErrorBlobTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorCache, _p_Magick__ErrorCacheTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorCoder, _p_Magick__ErrorCoderTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorConfigure, _p_Magick__ErrorConfigureTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorCorruptImage, _p_Magick__ErrorCorruptImageTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorDelegate, _p_Magick__ErrorDelegateTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorDraw, _p_Magick__ErrorDrawTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorFileOpen, _p_Magick__ErrorFileOpenTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorImage, _p_Magick__ErrorImageTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorMissingDelegate, _p_Magick__ErrorMissingDelegateTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorModule, _p_Magick__ErrorModuleTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorMonitor, _p_Magick__ErrorMonitorTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorOption, _p_Magick__ErrorOptionTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorPolicy, _p_Magick__ErrorPolicyTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorRegistry, _p_Magick__ErrorRegistryTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorResourceLimit, _p_Magick__ErrorResourceLimitTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorStream, _p_Magick__ErrorStreamTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorType, _p_Magick__ErrorTypeTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorUndefined, _p_Magick__ErrorUndefinedTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorXServer, _p_Magick__ErrorXServerTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__Warning, _p_Magick__WarningTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningBlob, _p_Magick__WarningBlobTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningCache, _p_Magick__WarningCacheTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningCoder, _p_Magick__WarningCoderTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningConfigure, _p_Magick__WarningConfigureTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningCorruptImage, _p_Magick__WarningCorruptImageTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningDelegate, _p_Magick__WarningDelegateTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningDraw, _p_Magick__WarningDrawTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningFileOpen, _p_Magick__WarningFileOpenTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningImage, _p_Magick__WarningImageTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningMissingDelegate, _p_Magick__WarningMissingDelegateTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningModule, _p_Magick__WarningModuleTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningMonitor, _p_Magick__WarningMonitorTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningOption, _p_Magick__WarningOptionTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningPolicy, _p_Magick__WarningPolicyTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningRegistry, _p_Magick__WarningRegistryTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningResourceLimit, _p_Magick__WarningResourceLimitTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningStream, _p_Magick__WarningStreamTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningType, _p_Magick__WarningTypeTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningUndefined, _p_Magick__WarningUndefinedTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningXServer, _p_Magick__WarningXServerTo_p_Magick__Exception, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__Geometry[] = {  {&_swigt__p_Magick__Geometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__Image[] = {  {&_swigt__p_Magick__Image, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ImageMoments[] = {  {&_swigt__p_Magick__ImageMoments, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__Image___ImageStatistics[] = {  {&_swigt__p_Magick__Image___ImageStatistics, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__Montage[] = {  {&_swigt__p_Magick__Montage, 0, 0, 0},  {&_swigt__p_Magick__MontageFramed, _p_Magick__MontageFramedTo_p_Magick__Montage, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__MontageFramed[] = {  {&_swigt__p_Magick__MontageFramed, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__Offset[] = {  {&_swigt__p_Magick__Offset, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__Options[] = {  {&_swigt__p_Magick__Options, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__PathArcAbs[] = {  {&_swigt__p_Magick__PathArcAbs, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__PathArcArgs[] = {  {&_swigt__p_Magick__PathArcArgs, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__PathArcRel[] = {  {&_swigt__p_Magick__PathArcRel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__PathClosePath[] = {  {&_swigt__p_Magick__PathClosePath, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__PathCurvetoAbs[] = {  {&_swigt__p_Magick__PathCurvetoAbs, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__PathCurvetoArgs[] = {  {&_swigt__p_Magick__PathCurvetoArgs, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__PathCurvetoRel[] = {  {&_swigt__p_Magick__PathCurvetoRel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__PathLinetoAbs[] = {  {&_swigt__p_Magick__PathLinetoAbs, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__PathLinetoHorizontalAbs[] = {  {&_swigt__p_Magick__PathLinetoHorizontalAbs, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__PathLinetoHorizontalRel[] = {  {&_swigt__p_Magick__PathLinetoHorizontalRel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__PathLinetoRel[] = {  {&_swigt__p_Magick__PathLinetoRel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__PathLinetoVerticalAbs[] = {  {&_swigt__p_Magick__PathLinetoVerticalAbs, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__PathLinetoVerticalRel[] = {  {&_swigt__p_Magick__PathLinetoVerticalRel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__PathMovetoAbs[] = {  {&_swigt__p_Magick__PathMovetoAbs, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__PathMovetoRel[] = {  {&_swigt__p_Magick__PathMovetoRel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__PathQuadraticCurvetoAbs[] = {  {&_swigt__p_Magick__PathQuadraticCurvetoAbs, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__PathQuadraticCurvetoArgs[] = {  {&_swigt__p_Magick__PathQuadraticCurvetoArgs, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__PathQuadraticCurvetoRel[] = {  {&_swigt__p_Magick__PathQuadraticCurvetoRel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__PathSmoothCurvetoAbs[] = {  {&_swigt__p_Magick__PathSmoothCurvetoAbs, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__PathSmoothCurvetoRel[] = {  {&_swigt__p_Magick__PathSmoothCurvetoRel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__PathSmoothQuadraticCurvetoAbs[] = {  {&_swigt__p_Magick__PathSmoothQuadraticCurvetoAbs, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__PathSmoothQuadraticCurvetoRel[] = {  {&_swigt__p_Magick__PathSmoothQuadraticCurvetoRel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__PixelData[] = {  {&_swigt__p_Magick__PixelData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__Pixels[] = {  {&_swigt__p_Magick__Pixels, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ReadOptions[] = {  {&_swigt__p_Magick__ReadOptions, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__ResourceLimits[] = {  {&_swigt__p_Magick__ResourceLimits, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__TypeMetric[] = {  {&_swigt__p_Magick__TypeMetric, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__VPath[] = {  {&_swigt__p_Magick__VPath, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__VPathBase[] = {  {&_swigt__p_Magick__VPathBase, 0, 0, 0},  {&_swigt__p_Magick__PathArcAbs, _p_Magick__PathArcAbsTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathArcRel, _p_Magick__PathArcRelTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathClosePath, _p_Magick__PathClosePathTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathCurvetoAbs, _p_Magick__PathCurvetoAbsTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathCurvetoRel, _p_Magick__PathCurvetoRelTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathLinetoAbs, _p_Magick__PathLinetoAbsTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathLinetoHorizontalAbs, _p_Magick__PathLinetoHorizontalAbsTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathLinetoHorizontalRel, _p_Magick__PathLinetoHorizontalRelTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathLinetoRel, _p_Magick__PathLinetoRelTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathLinetoVerticalAbs, _p_Magick__PathLinetoVerticalAbsTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathLinetoVerticalRel, _p_Magick__PathLinetoVerticalRelTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathMovetoAbs, _p_Magick__PathMovetoAbsTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathMovetoRel, _p_Magick__PathMovetoRelTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathQuadraticCurvetoAbs, _p_Magick__PathQuadraticCurvetoAbsTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathQuadraticCurvetoRel, _p_Magick__PathQuadraticCurvetoRelTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathSmoothCurvetoAbs, _p_Magick__PathSmoothCurvetoAbsTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathSmoothCurvetoRel, _p_Magick__PathSmoothCurvetoRelTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathSmoothQuadraticCurvetoAbs, _p_Magick__PathSmoothQuadraticCurvetoAbsTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathSmoothQuadraticCurvetoRel, _p_Magick__PathSmoothQuadraticCurvetoRelTo_p_Magick__VPathBase, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__Warning[] = {  {&_swigt__p_Magick__Warning, 0, 0, 0},  {&_swigt__p_Magick__WarningBlob, _p_Magick__WarningBlobTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningCache, _p_Magick__WarningCacheTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningCoder, _p_Magick__WarningCoderTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningConfigure, _p_Magick__WarningConfigureTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningCorruptImage, _p_Magick__WarningCorruptImageTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningDelegate, _p_Magick__WarningDelegateTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningDraw, _p_Magick__WarningDrawTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningFileOpen, _p_Magick__WarningFileOpenTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningImage, _p_Magick__WarningImageTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningMissingDelegate, _p_Magick__WarningMissingDelegateTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningModule, _p_Magick__WarningModuleTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningMonitor, _p_Magick__WarningMonitorTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningOption, _p_Magick__WarningOptionTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningPolicy, _p_Magick__WarningPolicyTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningRegistry, _p_Magick__WarningRegistryTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningResourceLimit, _p_Magick__WarningResourceLimitTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningStream, _p_Magick__WarningStreamTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningType, _p_Magick__WarningTypeTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningUndefined, _p_Magick__WarningUndefinedTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningXServer, _p_Magick__WarningXServerTo_p_Magick__Warning, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__WarningBlob[] = {  {&_swigt__p_Magick__WarningBlob, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__WarningCache[] = {  {&_swigt__p_Magick__WarningCache, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__WarningCoder[] = {  {&_swigt__p_Magick__WarningCoder, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__WarningConfigure[] = {  {&_swigt__p_Magick__WarningConfigure, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__WarningCorruptImage[] = {  {&_swigt__p_Magick__WarningCorruptImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__WarningDelegate[] = {  {&_swigt__p_Magick__WarningDelegate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__WarningDraw[] = {  {&_swigt__p_Magick__WarningDraw, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__WarningFileOpen[] = {  {&_swigt__p_Magick__WarningFileOpen, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__WarningImage[] = {  {&_swigt__p_Magick__WarningImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__WarningMissingDelegate[] = {  {&_swigt__p_Magick__WarningMissingDelegate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__WarningModule[] = {  {&_swigt__p_Magick__WarningModule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__WarningMonitor[] = {  {&_swigt__p_Magick__WarningMonitor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__WarningOption[] = {  {&_swigt__p_Magick__WarningOption, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__WarningPolicy[] = {  {&_swigt__p_Magick__WarningPolicy, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__WarningRegistry[] = {  {&_swigt__p_Magick__WarningRegistry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__WarningResourceLimit[] = {  {&_swigt__p_Magick__WarningResourceLimit, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__WarningStream[] = {  {&_swigt__p_Magick__WarningStream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__WarningType[] = {  {&_swigt__p_Magick__WarningType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__WarningUndefined[] = {  {&_swigt__p_Magick__WarningUndefined, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__WarningXServer[] = {  {&_swigt__p_Magick__WarningXServer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__adaptiveBlurImage[] = {  {&_swigt__p_Magick__adaptiveBlurImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__adaptiveThresholdImage[] = {  {&_swigt__p_Magick__adaptiveThresholdImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__addNoiseImage[] = {  {&_swigt__p_Magick__addNoiseImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__adjoinImage[] = {  {&_swigt__p_Magick__adjoinImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__affineTransformImage[] = {  {&_swigt__p_Magick__affineTransformImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__animationDelayImage[] = {  {&_swigt__p_Magick__animationDelayImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__animationIterationsImage[] = {  {&_swigt__p_Magick__animationIterationsImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__annotateImage[] = {  {&_swigt__p_Magick__annotateImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__antiAliasImage[] = {  {&_swigt__p_Magick__antiAliasImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__backgroundColorImage[] = {  {&_swigt__p_Magick__backgroundColorImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__backgroundTextureImage[] = {  {&_swigt__p_Magick__backgroundTextureImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__blurImage[] = {  {&_swigt__p_Magick__blurImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__borderColorImage[] = {  {&_swigt__p_Magick__borderColorImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__borderImage[] = {  {&_swigt__p_Magick__borderImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__boxColorImage[] = {  {&_swigt__p_Magick__boxColorImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__cdlImage[] = {  {&_swigt__p_Magick__cdlImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__channelImage[] = {  {&_swigt__p_Magick__channelImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__charcoalImage[] = {  {&_swigt__p_Magick__charcoalImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__chopImage[] = {  {&_swigt__p_Magick__chopImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__chromaBluePrimaryImage[] = {  {&_swigt__p_Magick__chromaBluePrimaryImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__chromaGreenPrimaryImage[] = {  {&_swigt__p_Magick__chromaGreenPrimaryImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__chromaRedPrimaryImage[] = {  {&_swigt__p_Magick__chromaRedPrimaryImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__chromaWhitePointImage[] = {  {&_swigt__p_Magick__chromaWhitePointImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__colorFuzzImage[] = {  {&_swigt__p_Magick__colorFuzzImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__colorMapImage[] = {  {&_swigt__p_Magick__colorMapImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__colorMatrixImage[] = {  {&_swigt__p_Magick__colorMatrixImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__colorSpaceImage[] = {  {&_swigt__p_Magick__colorSpaceImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__colorizeImage[] = {  {&_swigt__p_Magick__colorizeImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__commentImage[] = {  {&_swigt__p_Magick__commentImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__composeImage[] = {  {&_swigt__p_Magick__composeImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__compositeImage[] = {  {&_swigt__p_Magick__compositeImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__compressTypeImage[] = {  {&_swigt__p_Magick__compressTypeImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__contrastImage[] = {  {&_swigt__p_Magick__contrastImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__cropImage[] = {  {&_swigt__p_Magick__cropImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__cycleColormapImage[] = {  {&_swigt__p_Magick__cycleColormapImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__densityImage[] = {  {&_swigt__p_Magick__densityImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__depthImage[] = {  {&_swigt__p_Magick__depthImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__despeckleImage[] = {  {&_swigt__p_Magick__despeckleImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__distortImage[] = {  {&_swigt__p_Magick__distortImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__drawImage[] = {  {&_swigt__p_Magick__drawImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__edgeImage[] = {  {&_swigt__p_Magick__edgeImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__embossImage[] = {  {&_swigt__p_Magick__embossImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__endianImage[] = {  {&_swigt__p_Magick__endianImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__enhanceImage[] = {  {&_swigt__p_Magick__enhanceImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__equalizeImage[] = {  {&_swigt__p_Magick__equalizeImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__fileNameImage[] = {  {&_swigt__p_Magick__fileNameImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__fillColorImage[] = {  {&_swigt__p_Magick__fillColorImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__filterTypeImage[] = {  {&_swigt__p_Magick__filterTypeImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__flipImage[] = {  {&_swigt__p_Magick__flipImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__floodFillColorImage[] = {  {&_swigt__p_Magick__floodFillColorImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__floodFillTextureImage[] = {  {&_swigt__p_Magick__floodFillTextureImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__flopImage[] = {  {&_swigt__p_Magick__flopImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__fontImage[] = {  {&_swigt__p_Magick__fontImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__fontPointsizeImage[] = {  {&_swigt__p_Magick__fontPointsizeImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__frameImage[] = {  {&_swigt__p_Magick__frameImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__gammaImage[] = {  {&_swigt__p_Magick__gammaImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__gaussianBlurImage[] = {  {&_swigt__p_Magick__gaussianBlurImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__gifDisposeMethodImage[] = {  {&_swigt__p_Magick__gifDisposeMethodImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__haldClutImage[] = {  {&_swigt__p_Magick__haldClutImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__implodeImage[] = {  {&_swigt__p_Magick__implodeImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__interlaceTypeImage[] = {  {&_swigt__p_Magick__interlaceTypeImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__inverseFourierTransformImage[] = {  {&_swigt__p_Magick__inverseFourierTransformImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__isValidImage[] = {  {&_swigt__p_Magick__isValidImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__labelImage[] = {  {&_swigt__p_Magick__labelImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__levelChannelImage[] = {  {&_swigt__p_Magick__levelChannelImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__levelImage[] = {  {&_swigt__p_Magick__levelImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__lineWidthImage[] = {  {&_swigt__p_Magick__lineWidthImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__magickImage[] = {  {&_swigt__p_Magick__magickImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__magnifyImage[] = {  {&_swigt__p_Magick__magnifyImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__mapImage[] = {  {&_swigt__p_Magick__mapImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__matteColorImage[] = {  {&_swigt__p_Magick__matteColorImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__matteFloodfillImage[] = {  {&_swigt__p_Magick__matteFloodfillImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__matteImage[] = {  {&_swigt__p_Magick__matteImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__medianFilterImage[] = {  {&_swigt__p_Magick__medianFilterImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__mergeLayersImage[] = {  {&_swigt__p_Magick__mergeLayersImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__minifyImage[] = {  {&_swigt__p_Magick__minifyImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__modulateImage[] = {  {&_swigt__p_Magick__modulateImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__monochromeImage[] = {  {&_swigt__p_Magick__monochromeImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__negateImage[] = {  {&_swigt__p_Magick__negateImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__normalizeImage[] = {  {&_swigt__p_Magick__normalizeImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__oilPaintImage[] = {  {&_swigt__p_Magick__oilPaintImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__opacityImage[] = {  {&_swigt__p_Magick__opacityImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__opaqueImage[] = {  {&_swigt__p_Magick__opaqueImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__pageImage[] = {  {&_swigt__p_Magick__pageImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__penColorImage[] = {  {&_swigt__p_Magick__penColorImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__penTextureImage[] = {  {&_swigt__p_Magick__penTextureImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__pixelColorImage[] = {  {&_swigt__p_Magick__pixelColorImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__qualityImage[] = {  {&_swigt__p_Magick__qualityImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__quantizeColorSpaceImage[] = {  {&_swigt__p_Magick__quantizeColorSpaceImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__quantizeColorsImage[] = {  {&_swigt__p_Magick__quantizeColorsImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__quantizeDitherImage[] = {  {&_swigt__p_Magick__quantizeDitherImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__quantizeImage[] = {  {&_swigt__p_Magick__quantizeImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__quantizeTreeDepthImage[] = {  {&_swigt__p_Magick__quantizeTreeDepthImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__raiseImage[] = {  {&_swigt__p_Magick__raiseImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__reduceNoiseImage[] = {  {&_swigt__p_Magick__reduceNoiseImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__renderingIntentImage[] = {  {&_swigt__p_Magick__renderingIntentImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__resizeImage[] = {  {&_swigt__p_Magick__resizeImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__resolutionUnitsImage[] = {  {&_swigt__p_Magick__resolutionUnitsImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__rollImage[] = {  {&_swigt__p_Magick__rollImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__rotateImage[] = {  {&_swigt__p_Magick__rotateImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__sampleImage[] = {  {&_swigt__p_Magick__sampleImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__scaleImage[] = {  {&_swigt__p_Magick__scaleImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__sceneImage[] = {  {&_swigt__p_Magick__sceneImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__segmentImage[] = {  {&_swigt__p_Magick__segmentImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__shadeImage[] = {  {&_swigt__p_Magick__shadeImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__shadowImage[] = {  {&_swigt__p_Magick__shadowImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__sharpenImage[] = {  {&_swigt__p_Magick__sharpenImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__shaveImage[] = {  {&_swigt__p_Magick__shaveImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__shearImage[] = {  {&_swigt__p_Magick__shearImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__sigmoidalContrastImage[] = {  {&_swigt__p_Magick__sigmoidalContrastImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__sizeImage[] = {  {&_swigt__p_Magick__sizeImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__solarizeImage[] = {  {&_swigt__p_Magick__solarizeImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__spliceImage[] = {  {&_swigt__p_Magick__spliceImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__spreadImage[] = {  {&_swigt__p_Magick__spreadImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__steganoImage[] = {  {&_swigt__p_Magick__steganoImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__stereoImage[] = {  {&_swigt__p_Magick__stereoImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__stripImage[] = {  {&_swigt__p_Magick__stripImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__strokeColorImage[] = {  {&_swigt__p_Magick__strokeColorImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__subImageImage[] = {  {&_swigt__p_Magick__subImageImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__subRangeImage[] = {  {&_swigt__p_Magick__subRangeImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__swirlImage[] = {  {&_swigt__p_Magick__swirlImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__textureImage[] = {  {&_swigt__p_Magick__textureImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__thresholdImage[] = {  {&_swigt__p_Magick__thresholdImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__tileNameImage[] = {  {&_swigt__p_Magick__tileNameImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__transformImage[] = {  {&_swigt__p_Magick__transformImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__transparentImage[] = {  {&_swigt__p_Magick__transparentImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__trimImage[] = {  {&_swigt__p_Magick__trimImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__typeImage[] = {  {&_swigt__p_Magick__typeImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__verboseImage[] = {  {&_swigt__p_Magick__verboseImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__viewImage[] = {  {&_swigt__p_Magick__viewImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__waveImage[] = {  {&_swigt__p_Magick__waveImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__x11DisplayImage[] = {  {&_swigt__p_Magick__x11DisplayImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Magick__zoomImage[] = {  {&_swigt__p_Magick__zoomImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PixelPacket[] = {  {&_swigt__p_PixelPacket, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__Ascii85Info[] = {  {&_swigt__p__Ascii85Info, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__BlobInfo[] = {  {&_swigt__p__BlobInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__CacheView[] = {  {&_swigt__p__CacheView, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__DrawingWand[] = {  {&_swigt__p__DrawingWand, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__HashmapInfo[] = {  {&_swigt__p__HashmapInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__ImageView[] = {  {&_swigt__p__ImageView, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__LinkedListInfo[] = {  {&_swigt__p__LinkedListInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__LogInfo[] = {  {&_swigt__p__LogInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__MagickWand[] = {  {&_swigt__p__MagickWand, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__MatrixInfo[] = {  {&_swigt__p__MatrixInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__MemoryInfo[] = {  {&_swigt__p__MemoryInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__MimeInfo[] = {  {&_swigt__p__MimeInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__PixelIterator[] = {  {&_swigt__p__PixelIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__PixelView[] = {  {&_swigt__p__PixelView, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__PixelWand[] = {  {&_swigt__p__PixelWand, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__PolicyInfo[] = {  {&_swigt__p__PolicyInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__QuantumInfo[] = {  {&_swigt__p__QuantumInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__RandomInfo[] = {  {&_swigt__p__RandomInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__ResampleFilter[] = {  {&_swigt__p__ResampleFilter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__ResizeFilter[] = {  {&_swigt__p__ResizeFilter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__SplayTreeInfo[] = {  {&_swigt__p__SplayTreeInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__ThresholdMap[] = {  {&_swigt__p__ThresholdMap, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__TokenInfo[] = {  {&_swigt__p__TokenInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__ViewInfo[] = {  {&_swigt__p__ViewInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__WandView[] = {  {&_swigt__p__WandView, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__XMLTreeInfo[] = {  {&_swigt__p__XMLTreeInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_double[] = {  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_p_MagickCore___Image_q_const__int_p_p_q_const__char_p_MagickCore___ExceptionInfo__size_t[] = {  {&_swigt__p_f_p_p_MagickCore___Image_q_const__int_p_p_q_const__char_p_MagickCore___ExceptionInfo__size_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_q_const__MagickCore__ImageInfo_p_MagickCore__ExceptionInfo__p_MagickCore___Image[] = {  {&_swigt__p_f_p_q_const__MagickCore__ImageInfo_p_MagickCore__ExceptionInfo__p_MagickCore___Image, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_q_const__MagickCore__ImageInfo_p_MagickCore__Image__MagickCore__MagickBooleanType[] = {  {&_swigt__p_f_p_q_const__MagickCore__ImageInfo_p_MagickCore__Image__MagickCore__MagickBooleanType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_q_const__unsigned_char_q_const__size_t__MagickCore__MagickBooleanType[] = {  {&_swigt__p_f_p_q_const__unsigned_char_q_const__size_t__MagickCore__MagickBooleanType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_float[] = {  {&_swigt__p_float, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_long_long[] = {  {&_swigt__p_long_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_off_t[] = {  {&_swigt__p_off_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_MagickCore___Image[] = {  {&_swigt__p_p_MagickCore___Image, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_char[] = {  {&_swigt__p_p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_size_t[] = {  {&_swigt__p_size_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ssize_t[] = {  {&_swigt__p_ssize_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__exception[] = {  {&_swigt__p_std__exception, 0, 0, 0},  {&_swigt__p_Magick__Error, _p_Magick__ErrorTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorBlob, _p_Magick__ErrorBlobTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorCache, _p_Magick__ErrorCacheTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorCoder, _p_Magick__ErrorCoderTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorConfigure, _p_Magick__ErrorConfigureTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorCorruptImage, _p_Magick__ErrorCorruptImageTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorDelegate, _p_Magick__ErrorDelegateTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorDraw, _p_Magick__ErrorDrawTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorFileOpen, _p_Magick__ErrorFileOpenTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorImage, _p_Magick__ErrorImageTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorMissingDelegate, _p_Magick__ErrorMissingDelegateTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorModule, _p_Magick__ErrorModuleTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorMonitor, _p_Magick__ErrorMonitorTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorOption, _p_Magick__ErrorOptionTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorPolicy, _p_Magick__ErrorPolicyTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorRegistry, _p_Magick__ErrorRegistryTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorResourceLimit, _p_Magick__ErrorResourceLimitTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorStream, _p_Magick__ErrorStreamTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorType, _p_Magick__ErrorTypeTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorUndefined, _p_Magick__ErrorUndefinedTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorXServer, _p_Magick__ErrorXServerTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__Exception, _p_Magick__ExceptionTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__Warning, _p_Magick__WarningTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningBlob, _p_Magick__WarningBlobTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningCache, _p_Magick__WarningCacheTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningCoder, _p_Magick__WarningCoderTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningConfigure, _p_Magick__WarningConfigureTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningCorruptImage, _p_Magick__WarningCorruptImageTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningDelegate, _p_Magick__WarningDelegateTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningDraw, _p_Magick__WarningDrawTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningFileOpen, _p_Magick__WarningFileOpenTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningImage, _p_Magick__WarningImageTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningMissingDelegate, _p_Magick__WarningMissingDelegateTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningModule, _p_Magick__WarningModuleTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningMonitor, _p_Magick__WarningMonitorTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningOption, _p_Magick__WarningOptionTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningPolicy, _p_Magick__WarningPolicyTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningRegistry, _p_Magick__WarningRegistryTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningResourceLimit, _p_Magick__WarningResourceLimitTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningStream, _p_Magick__WarningStreamTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningType, _p_Magick__WarningTypeTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningUndefined, _p_Magick__WarningUndefinedTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningXServer, _p_Magick__WarningXServerTo_p_std__exception, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__listT_Magick__Coordinate_t[] = {  {&_swigt__p_std__listT_Magick__Coordinate_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__listT_Magick__Drawable_t[] = {  {&_swigt__p_std__listT_Magick__Drawable_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__listT_Magick__PathArcArgs_t[] = {  {&_swigt__p_std__listT_Magick__PathArcArgs_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__listT_Magick__PathCurvetoArgs_t[] = {  {&_swigt__p_std__listT_Magick__PathCurvetoArgs_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__listT_Magick__PathQuadraticCurvetoArgs_t[] = {  {&_swigt__p_std__listT_Magick__PathQuadraticCurvetoArgs_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__listT_Magick__VPath_t[] = {  {&_swigt__p_std__listT_Magick__VPath_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_char[] = {  {&_swigt__p_unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_int[] = {  {&_swigt__p_unsigned_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_long_long[] = {  {&_swigt__p_unsigned_long_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_short[] = {  {&_swigt__p_unsigned_short, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_void[] = {  {&_swigt__p_void, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_Color,
  _swigc__p_Drawable,
  _swigc__p_DrawableAffine,
  _swigc__p_DrawableList,
  _swigc__p_Image,
  _swigc__p_ImageChannelStatistics,
  _swigc__p_ImageStatistics,
  _swigc__p_MagickCore__AlignType,
  _swigc__p_MagickCore__AlphaChannelType,
  _swigc__p_MagickCore__AutoThresholdMethod,
  _swigc__p_MagickCore__CacheType,
  _swigc__p_MagickCore__ChannelType,
  _swigc__p_MagickCore__ClassType,
  _swigc__p_MagickCore__ClipPathUnits,
  _swigc__p_MagickCore__ColorspaceType,
  _swigc__p_MagickCore__CommandOption,
  _swigc__p_MagickCore__CommandOptionFlags,
  _swigc__p_MagickCore__ComplexOperator,
  _swigc__p_MagickCore__ComplianceType,
  _swigc__p_MagickCore__CompositeOperator,
  _swigc__p_MagickCore__CompressionType,
  _swigc__p_MagickCore__DecorationType,
  _swigc__p_MagickCore__DirectionType,
  _swigc__p_MagickCore__DisposeType,
  _swigc__p_MagickCore__DistortImageMethod,
  _swigc__p_MagickCore__DitherMethod,
  _swigc__p_MagickCore__EndianType,
  _swigc__p_MagickCore__ExceptionType,
  _swigc__p_MagickCore__FillRule,
  _swigc__p_MagickCore__FilterTypes,
  _swigc__p_MagickCore__GeometryFlags,
  _swigc__p_MagickCore__GradientType,
  _swigc__p_MagickCore__GravityType,
  _swigc__p_MagickCore__ImageLayerMethod,
  _swigc__p_MagickCore__ImageMagickOpenCLMode,
  _swigc__p_MagickCore__ImageType,
  _swigc__p_MagickCore__InterlaceType,
  _swigc__p_MagickCore__InterpolatePixelMethod,
  _swigc__p_MagickCore__KernelInfo,
  _swigc__p_MagickCore__KernelInfoType,
  _swigc__p_MagickCore__LineCap,
  _swigc__p_MagickCore__LineJoin,
  _swigc__p_MagickCore__LogEventType,
  _swigc__p_MagickCore__MagickBooleanType,
  _swigc__p_MagickCore__MagickEvaluateOperator,
  _swigc__p_MagickCore__MagickFormatType,
  _swigc__p_MagickCore__MagickFunction,
  _swigc__p_MagickCore__MagickLayerMethod,
  _swigc__p_MagickCore__MagickModuleType,
  _swigc__p_MagickCore__MagickOpenCLEnvParam,
  _swigc__p_MagickCore__MagickOpenCLProgram,
  _swigc__p_MagickCore__MagickThreadSupport,
  _swigc__p_MagickCore__MapMode,
  _swigc__p_MagickCore__MetricType,
  _swigc__p_MagickCore__MontageMode,
  _swigc__p_MagickCore__MorphologyMethod,
  _swigc__p_MagickCore__NoiseType,
  _swigc__p_MagickCore__OrientationType,
  _swigc__p_MagickCore__PaintMethod,
  _swigc__p_MagickCore__PathType,
  _swigc__p_MagickCore__PixelComponent,
  _swigc__p_MagickCore__PixelIntensityMethod,
  _swigc__p_MagickCore__PolicyDomain,
  _swigc__p_MagickCore__PolicyRights,
  _swigc__p_MagickCore__PreviewType,
  _swigc__p_MagickCore__PrimitiveType,
  _swigc__p_MagickCore__QuantumAlphaType,
  _swigc__p_MagickCore__QuantumFormatType,
  _swigc__p_MagickCore__QuantumType,
  _swigc__p_MagickCore__ReferenceType,
  _swigc__p_MagickCore__RegistryType,
  _swigc__p_MagickCore__RenderingIntent,
  _swigc__p_MagickCore__ResolutionType,
  _swigc__p_MagickCore__ResourceType,
  _swigc__p_MagickCore__SemaphoreInfo,
  _swigc__p_MagickCore__SparseColorMethod,
  _swigc__p_MagickCore__SpreadMethod,
  _swigc__p_MagickCore__StatisticType,
  _swigc__p_MagickCore__StorageType,
  _swigc__p_MagickCore__StretchType,
  _swigc__p_MagickCore__StyleType,
  _swigc__p_MagickCore__TimerState,
  _swigc__p_MagickCore__TransmitType,
  _swigc__p_MagickCore__ValidateType,
  _swigc__p_MagickCore__VirtualPixelMethod,
  _swigc__p_MagickCore___AffineMatrix,
  _swigc__p_MagickCore___ChannelFeatures,
  _swigc__p_MagickCore___ChannelMoments,
  _swigc__p_MagickCore___ChannelPerceptualHash,
  _swigc__p_MagickCore___ChannelStatistics,
  _swigc__p_MagickCore___ChromaticityInfo,
  _swigc__p_MagickCore___CoderInfo,
  _swigc__p_MagickCore___ColorInfo,
  _swigc__p_MagickCore___ColorPacket,
  _swigc__p_MagickCore___ConfigureInfo,
  _swigc__p_MagickCore___DelegateInfo,
  _swigc__p_MagickCore___DoublePixelPacket,
  _swigc__p_MagickCore___DrawInfo,
  _swigc__p_MagickCore___ElementReference,
  _swigc__p_MagickCore___ErrorInfo,
  _swigc__p_MagickCore___ExceptionInfo,
  _swigc__p_MagickCore___FrameInfo,
  _swigc__p_MagickCore___GeometryInfo,
  _swigc__p_MagickCore___GradientInfo,
  _swigc__p_MagickCore___Image,
  _swigc__p_MagickCore___ImageAttribute,
  _swigc__p_MagickCore___ImageInfo,
  _swigc__p_MagickCore___LocaleInfo,
  _swigc__p_MagickCore___LongPixelPacket,
  _swigc__p_MagickCore___MagicInfo,
  _swigc__p_MagickCore___MagickInfo,
  _swigc__p_MagickCore___MagickPixelPacket,
  _swigc__p_MagickCore___ModuleInfo,
  _swigc__p_MagickCore___MontageInfo,
  _swigc__p_MagickCore___OffsetInfo,
  _swigc__p_MagickCore___OptionInfo,
  _swigc__p_MagickCore___PixelPacket,
  _swigc__p_MagickCore___PointInfo,
  _swigc__p_MagickCore___PrimaryInfo,
  _swigc__p_MagickCore___PrimitiveInfo,
  _swigc__p_MagickCore___ProfileInfo,
  _swigc__p_MagickCore___QuantizeInfo,
  _swigc__p_MagickCore___QuantumPixelPacket,
  _swigc__p_MagickCore___RectangleInfo,
  _swigc__p_MagickCore___SegmentInfo,
  _swigc__p_MagickCore___StopInfo,
  _swigc__p_MagickCore___StringInfo,
  _swigc__p_MagickCore___Timer,
  _swigc__p_MagickCore___TimerInfo,
  _swigc__p_MagickCore___TypeInfo,
  _swigc__p_MagickCore___TypeMetric,
  _swigc__p_MagickCore___XImportInfo,
  _swigc__p_Magick__Blob,
  _swigc__p_Magick__ChannelMoments,
  _swigc__p_Magick__CoderInfo,
  _swigc__p_Magick__Color,
  _swigc__p_Magick__ColorGray,
  _swigc__p_Magick__ColorHSL,
  _swigc__p_Magick__ColorMono,
  _swigc__p_Magick__ColorRGB,
  _swigc__p_Magick__ColorYUV,
  _swigc__p_Magick__Coordinate,
  _swigc__p_Magick__Drawable,
  _swigc__p_Magick__DrawableAffine,
  _swigc__p_Magick__DrawableArc,
  _swigc__p_Magick__DrawableBase,
  _swigc__p_Magick__DrawableBezier,
  _swigc__p_Magick__DrawableCircle,
  _swigc__p_Magick__DrawableClipPath,
  _swigc__p_Magick__DrawableColor,
  _swigc__p_Magick__DrawableCompositeImage,
  _swigc__p_Magick__DrawableDashArray,
  _swigc__p_Magick__DrawableDashOffset,
  _swigc__p_Magick__DrawableDensity,
  _swigc__p_Magick__DrawableEllipse,
  _swigc__p_Magick__DrawableFillColor,
  _swigc__p_Magick__DrawableFillOpacity,
  _swigc__p_Magick__DrawableFillRule,
  _swigc__p_Magick__DrawableFont,
  _swigc__p_Magick__DrawableGravity,
  _swigc__p_Magick__DrawableLine,
  _swigc__p_Magick__DrawableMatte,
  _swigc__p_Magick__DrawableMiterLimit,
  _swigc__p_Magick__DrawablePath,
  _swigc__p_Magick__DrawablePoint,
  _swigc__p_Magick__DrawablePointSize,
  _swigc__p_Magick__DrawablePolygon,
  _swigc__p_Magick__DrawablePolyline,
  _swigc__p_Magick__DrawablePopClipPath,
  _swigc__p_Magick__DrawablePopGraphicContext,
  _swigc__p_Magick__DrawablePopPattern,
  _swigc__p_Magick__DrawablePushClipPath,
  _swigc__p_Magick__DrawablePushGraphicContext,
  _swigc__p_Magick__DrawablePushPattern,
  _swigc__p_Magick__DrawableRectangle,
  _swigc__p_Magick__DrawableRotation,
  _swigc__p_Magick__DrawableRoundRectangle,
  _swigc__p_Magick__DrawableScaling,
  _swigc__p_Magick__DrawableSkewX,
  _swigc__p_Magick__DrawableSkewY,
  _swigc__p_Magick__DrawableStrokeAntialias,
  _swigc__p_Magick__DrawableStrokeColor,
  _swigc__p_Magick__DrawableStrokeLineCap,
  _swigc__p_Magick__DrawableStrokeLineJoin,
  _swigc__p_Magick__DrawableStrokeOpacity,
  _swigc__p_Magick__DrawableStrokeWidth,
  _swigc__p_Magick__DrawableText,
  _swigc__p_Magick__DrawableTextAntialias,
  _swigc__p_Magick__DrawableTextDecoration,
  _swigc__p_Magick__DrawableTextDirection,
  _swigc__p_Magick__DrawableTextInterlineSpacing,
  _swigc__p_Magick__DrawableTextInterwordSpacing,
  _swigc__p_Magick__DrawableTextKerning,
  _swigc__p_Magick__DrawableTextUnderColor,
  _swigc__p_Magick__DrawableTranslation,
  _swigc__p_Magick__DrawableViewbox,
  _swigc__p_Magick__Error,
  _swigc__p_Magick__ErrorBlob,
  _swigc__p_Magick__ErrorCache,
  _swigc__p_Magick__ErrorCoder,
  _swigc__p_Magick__ErrorConfigure,
  _swigc__p_Magick__ErrorCorruptImage,
  _swigc__p_Magick__ErrorDelegate,
  _swigc__p_Magick__ErrorDraw,
  _swigc__p_Magick__ErrorFileOpen,
  _swigc__p_Magick__ErrorImage,
  _swigc__p_Magick__ErrorMissingDelegate,
  _swigc__p_Magick__ErrorModule,
  _swigc__p_Magick__ErrorMonitor,
  _swigc__p_Magick__ErrorOption,
  _swigc__p_Magick__ErrorPolicy,
  _swigc__p_Magick__ErrorRegistry,
  _swigc__p_Magick__ErrorResourceLimit,
  _swigc__p_Magick__ErrorStream,
  _swigc__p_Magick__ErrorType,
  _swigc__p_Magick__ErrorUndefined,
  _swigc__p_Magick__ErrorXServer,
  _swigc__p_Magick__Exception,
  _swigc__p_Magick__Geometry,
  _swigc__p_Magick__Image,
  _swigc__p_Magick__ImageMoments,
  _swigc__p_Magick__Image___ImageStatistics,
  _swigc__p_Magick__Montage,
  _swigc__p_Magick__MontageFramed,
  _swigc__p_Magick__Offset,
  _swigc__p_Magick__Options,
  _swigc__p_Magick__PathArcAbs,
  _swigc__p_Magick__PathArcArgs,
  _swigc__p_Magick__PathArcRel,
  _swigc__p_Magick__PathClosePath,
  _swigc__p_Magick__PathCurvetoAbs,
  _swigc__p_Magick__PathCurvetoArgs,
  _swigc__p_Magick__PathCurvetoRel,
  _swigc__p_Magick__PathLinetoAbs,
  _swigc__p_Magick__PathLinetoHorizontalAbs,
  _swigc__p_Magick__PathLinetoHorizontalRel,
  _swigc__p_Magick__PathLinetoRel,
  _swigc__p_Magick__PathLinetoVerticalAbs,
  _swigc__p_Magick__PathLinetoVerticalRel,
  _swigc__p_Magick__PathMovetoAbs,
  _swigc__p_Magick__PathMovetoRel,
  _swigc__p_Magick__PathQuadraticCurvetoAbs,
  _swigc__p_Magick__PathQuadraticCurvetoArgs,
  _swigc__p_Magick__PathQuadraticCurvetoRel,
  _swigc__p_Magick__PathSmoothCurvetoAbs,
  _swigc__p_Magick__PathSmoothCurvetoRel,
  _swigc__p_Magick__PathSmoothQuadraticCurvetoAbs,
  _swigc__p_Magick__PathSmoothQuadraticCurvetoRel,
  _swigc__p_Magick__PixelData,
  _swigc__p_Magick__Pixels,
  _swigc__p_Magick__ReadOptions,
  _swigc__p_Magick__ResourceLimits,
  _swigc__p_Magick__TypeMetric,
  _swigc__p_Magick__VPath,
  _swigc__p_Magick__VPathBase,
  _swigc__p_Magick__Warning,
  _swigc__p_Magick__WarningBlob,
  _swigc__p_Magick__WarningCache,
  _swigc__p_Magick__WarningCoder,
  _swigc__p_Magick__WarningConfigure,
  _swigc__p_Magick__WarningCorruptImage,
  _swigc__p_Magick__WarningDelegate,
  _swigc__p_Magick__WarningDraw,
  _swigc__p_Magick__WarningFileOpen,
  _swigc__p_Magick__WarningImage,
  _swigc__p_Magick__WarningMissingDelegate,
  _swigc__p_Magick__WarningModule,
  _swigc__p_Magick__WarningMonitor,
  _swigc__p_Magick__WarningOption,
  _swigc__p_Magick__WarningPolicy,
  _swigc__p_Magick__WarningRegistry,
  _swigc__p_Magick__WarningResourceLimit,
  _swigc__p_Magick__WarningStream,
  _swigc__p_Magick__WarningType,
  _swigc__p_Magick__WarningUndefined,
  _swigc__p_Magick__WarningXServer,
  _swigc__p_Magick__adaptiveBlurImage,
  _swigc__p_Magick__adaptiveThresholdImage,
  _swigc__p_Magick__addNoiseImage,
  _swigc__p_Magick__adjoinImage,
  _swigc__p_Magick__affineTransformImage,
  _swigc__p_Magick__animationDelayImage,
  _swigc__p_Magick__animationIterationsImage,
  _swigc__p_Magick__annotateImage,
  _swigc__p_Magick__antiAliasImage,
  _swigc__p_Magick__backgroundColorImage,
  _swigc__p_Magick__backgroundTextureImage,
  _swigc__p_Magick__blurImage,
  _swigc__p_Magick__borderColorImage,
  _swigc__p_Magick__borderImage,
  _swigc__p_Magick__boxColorImage,
  _swigc__p_Magick__cdlImage,
  _swigc__p_Magick__channelImage,
  _swigc__p_Magick__charcoalImage,
  _swigc__p_Magick__chopImage,
  _swigc__p_Magick__chromaBluePrimaryImage,
  _swigc__p_Magick__chromaGreenPrimaryImage,
  _swigc__p_Magick__chromaRedPrimaryImage,
  _swigc__p_Magick__chromaWhitePointImage,
  _swigc__p_Magick__colorFuzzImage,
  _swigc__p_Magick__colorMapImage,
  _swigc__p_Magick__colorMatrixImage,
  _swigc__p_Magick__colorSpaceImage,
  _swigc__p_Magick__colorizeImage,
  _swigc__p_Magick__commentImage,
  _swigc__p_Magick__composeImage,
  _swigc__p_Magick__compositeImage,
  _swigc__p_Magick__compressTypeImage,
  _swigc__p_Magick__contrastImage,
  _swigc__p_Magick__cropImage,
  _swigc__p_Magick__cycleColormapImage,
  _swigc__p_Magick__densityImage,
  _swigc__p_Magick__depthImage,
  _swigc__p_Magick__despeckleImage,
  _swigc__p_Magick__distortImage,
  _swigc__p_Magick__drawImage,
  _swigc__p_Magick__edgeImage,
  _swigc__p_Magick__embossImage,
  _swigc__p_Magick__endianImage,
  _swigc__p_Magick__enhanceImage,
  _swigc__p_Magick__equalizeImage,
  _swigc__p_Magick__fileNameImage,
  _swigc__p_Magick__fillColorImage,
  _swigc__p_Magick__filterTypeImage,
  _swigc__p_Magick__flipImage,
  _swigc__p_Magick__floodFillColorImage,
  _swigc__p_Magick__floodFillTextureImage,
  _swigc__p_Magick__flopImage,
  _swigc__p_Magick__fontImage,
  _swigc__p_Magick__fontPointsizeImage,
  _swigc__p_Magick__frameImage,
  _swigc__p_Magick__gammaImage,
  _swigc__p_Magick__gaussianBlurImage,
  _swigc__p_Magick__gifDisposeMethodImage,
  _swigc__p_Magick__haldClutImage,
  _swigc__p_Magick__implodeImage,
  _swigc__p_Magick__interlaceTypeImage,
  _swigc__p_Magick__inverseFourierTransformImage,
  _swigc__p_Magick__isValidImage,
  _swigc__p_Magick__labelImage,
  _swigc__p_Magick__levelChannelImage,
  _swigc__p_Magick__levelImage,
  _swigc__p_Magick__lineWidthImage,
  _swigc__p_Magick__magickImage,
  _swigc__p_Magick__magnifyImage,
  _swigc__p_Magick__mapImage,
  _swigc__p_Magick__matteColorImage,
  _swigc__p_Magick__matteFloodfillImage,
  _swigc__p_Magick__matteImage,
  _swigc__p_Magick__medianFilterImage,
  _swigc__p_Magick__mergeLayersImage,
  _swigc__p_Magick__minifyImage,
  _swigc__p_Magick__modulateImage,
  _swigc__p_Magick__monochromeImage,
  _swigc__p_Magick__negateImage,
  _swigc__p_Magick__normalizeImage,
  _swigc__p_Magick__oilPaintImage,
  _swigc__p_Magick__opacityImage,
  _swigc__p_Magick__opaqueImage,
  _swigc__p_Magick__pageImage,
  _swigc__p_Magick__penColorImage,
  _swigc__p_Magick__penTextureImage,
  _swigc__p_Magick__pixelColorImage,
  _swigc__p_Magick__qualityImage,
  _swigc__p_Magick__quantizeColorSpaceImage,
  _swigc__p_Magick__quantizeColorsImage,
  _swigc__p_Magick__quantizeDitherImage,
  _swigc__p_Magick__quantizeImage,
  _swigc__p_Magick__quantizeTreeDepthImage,
  _swigc__p_Magick__raiseImage,
  _swigc__p_Magick__reduceNoiseImage,
  _swigc__p_Magick__renderingIntentImage,
  _swigc__p_Magick__resizeImage,
  _swigc__p_Magick__resolutionUnitsImage,
  _swigc__p_Magick__rollImage,
  _swigc__p_Magick__rotateImage,
  _swigc__p_Magick__sampleImage,
  _swigc__p_Magick__scaleImage,
  _swigc__p_Magick__sceneImage,
  _swigc__p_Magick__segmentImage,
  _swigc__p_Magick__shadeImage,
  _swigc__p_Magick__shadowImage,
  _swigc__p_Magick__sharpenImage,
  _swigc__p_Magick__shaveImage,
  _swigc__p_Magick__shearImage,
  _swigc__p_Magick__sigmoidalContrastImage,
  _swigc__p_Magick__sizeImage,
  _swigc__p_Magick__solarizeImage,
  _swigc__p_Magick__spliceImage,
  _swigc__p_Magick__spreadImage,
  _swigc__p_Magick__steganoImage,
  _swigc__p_Magick__stereoImage,
  _swigc__p_Magick__stripImage,
  _swigc__p_Magick__strokeColorImage,
  _swigc__p_Magick__subImageImage,
  _swigc__p_Magick__subRangeImage,
  _swigc__p_Magick__swirlImage,
  _swigc__p_Magick__textureImage,
  _swigc__p_Magick__thresholdImage,
  _swigc__p_Magick__tileNameImage,
  _swigc__p_Magick__transformImage,
  _swigc__p_Magick__transparentImage,
  _swigc__p_Magick__trimImage,
  _swigc__p_Magick__typeImage,
  _swigc__p_Magick__verboseImage,
  _swigc__p_Magick__viewImage,
  _swigc__p_Magick__waveImage,
  _swigc__p_Magick__x11DisplayImage,
  _swigc__p_Magick__zoomImage,
  _swigc__p_PixelPacket,
  _swigc__p__Ascii85Info,
  _swigc__p__BlobInfo,
  _swigc__p__CacheView,
  _swigc__p__DrawingWand,
  _swigc__p__HashmapInfo,
  _swigc__p__ImageView,
  _swigc__p__LinkedListInfo,
  _swigc__p__LogInfo,
  _swigc__p__MagickWand,
  _swigc__p__MatrixInfo,
  _swigc__p__MemoryInfo,
  _swigc__p__MimeInfo,
  _swigc__p__PixelIterator,
  _swigc__p__PixelView,
  _swigc__p__PixelWand,
  _swigc__p__PolicyInfo,
  _swigc__p__QuantumInfo,
  _swigc__p__RandomInfo,
  _swigc__p__ResampleFilter,
  _swigc__p__ResizeFilter,
  _swigc__p__SplayTreeInfo,
  _swigc__p__ThresholdMap,
  _swigc__p__TokenInfo,
  _swigc__p__ViewInfo,
  _swigc__p__WandView,
  _swigc__p__XMLTreeInfo,
  _swigc__p_char,
  _swigc__p_double,
  _swigc__p_f_p_p_MagickCore___Image_q_const__int_p_p_q_const__char_p_MagickCore___ExceptionInfo__size_t,
  _swigc__p_f_p_q_const__MagickCore__ImageInfo_p_MagickCore__ExceptionInfo__p_MagickCore___Image,
  _swigc__p_f_p_q_const__MagickCore__ImageInfo_p_MagickCore__Image__MagickCore__MagickBooleanType,
  _swigc__p_f_p_q_const__unsigned_char_q_const__size_t__MagickCore__MagickBooleanType,
  _swigc__p_float,
  _swigc__p_long_long,
  _swigc__p_off_t,
  _swigc__p_p_MagickCore___Image,
  _swigc__p_p_char,
  _swigc__p_size_t,
  _swigc__p_ssize_t,
  _swigc__p_std__exception,
  _swigc__p_std__listT_Magick__Coordinate_t,
  _swigc__p_std__listT_Magick__Drawable_t,
  _swigc__p_std__listT_Magick__PathArcArgs_t,
  _swigc__p_std__listT_Magick__PathCurvetoArgs_t,
  _swigc__p_std__listT_Magick__PathQuadraticCurvetoArgs_t,
  _swigc__p_std__listT_Magick__VPath_t,
  _swigc__p_unsigned_char,
  _swigc__p_unsigned_int,
  _swigc__p_unsigned_long_long,
  _swigc__p_unsigned_short,
  _swigc__p_void,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */




SWIGRUNTIME void
SWIG_V8_SetModule(v8::Local<v8::Context> context, swig_module_info *swig_module) {
  v8::Local<v8::Object> global_obj = context->Global();
  v8::Local<v8::External> mod = SWIGV8_EXTERNAL_NEW(swig_module);
  assert(!mod.IsEmpty());
  v8::Local<v8::Private> privateKey = v8::Private::ForApi(v8::Isolate::GetCurrent(), SWIGV8_STRING_NEW("swig_module_info_data"));
  global_obj->SetPrivate(context, privateKey, mod);
}

SWIGRUNTIME swig_module_info *
SWIG_V8_GetModule(v8::Local<v8::Context> context) {
  v8::Local<v8::Object> global_obj = context->Global();
  v8::Local<v8::Private> privateKey = v8::Private::ForApi(v8::Isolate::GetCurrent(), SWIGV8_STRING_NEW("swig_module_info_data"));
  v8::Local<v8::Value> moduleinfo;
  if (!global_obj->GetPrivate(context, privateKey).ToLocal(&moduleinfo))
    return 0;

  if (moduleinfo.IsEmpty() || moduleinfo->IsNull() || moduleinfo->IsUndefined())
  {
    // It's not yet loaded
    return 0;
  }

  v8::Local<v8::External> moduleinfo_extern = v8::Local<v8::External>::Cast(moduleinfo);

  if (moduleinfo_extern.IsEmpty() || moduleinfo_extern->IsNull() || moduleinfo_extern->IsUndefined())
  {
    // Something's not right
    return 0;
  }

  void *ptr = moduleinfo_extern->Value();
  assert(ptr);
  swig_module_info *retptr = static_cast<swig_module_info *>(ptr);
  assert(retptr);
  return retptr;
}

#define SWIG_GetModule(clientdata)                SWIG_V8_GetModule(clientdata)
#define SWIG_SetModule(clientdata, pointer)       SWIG_V8_SetModule(clientdata, pointer)
#define SWIG_INIT_CLIENT_DATA_TYPE                v8::Local<v8::Context>


/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic
 * memory is used. Also, since swig_type_info structures store pointers to
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization.
 * The idea is that swig generates all the structures that are needed.
 * The runtime then collects these partially filled structures.
 * The SWIG_InitializeModule function takes these initial arrays out of
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned statically to an initial
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded.
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif

#ifndef SWIG_INIT_CLIENT_DATA_TYPE
#define SWIG_INIT_CLIENT_DATA_TYPE void *
#endif

SWIGRUNTIME void
SWIG_InitializeModule(SWIG_INIT_CLIENT_DATA_TYPE clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int init;

  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }

  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    iter=module_head;
    do {
      if (iter==&swig_module) {
        /* Our module is already in the list, so there's nothing more to do. */
        return;
      }
      iter=iter->next;
    } while (iter!= module_head);

    /* otherwise we must add our module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }

  /* When multiple interpreters are used, a module could have already been initialized in
     a different interpreter, but not yet have a pointer in this interpreter.
     In this case, we do not want to continue adding types... everything should be
     set up already */
  if (init == 0) return;

  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %lu\n", (unsigned long)swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;

#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
#endif

    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
	type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }

    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {

      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
	if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
	if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
	  printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
	  cast->type = ret;
	  ret = 0;
	} else {
	  /* Check for casting already in the list */
	  swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
	  if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
	  if (!ocast) ret = 0;
	}
      }

      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
	printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;

#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
  printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;

  if (init_run) return;
  init_run = 1;

  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{ /* c-mode */
#endif
}
#endif


#if !defined(NODE_MODULE_VERSION) || (NODE_MODULE_VERSION < 12)
// Note: 'extern "C"'' disables name mangling which makes it easier to load the symbol manually
extern "C" void SWIGV8_INIT (SWIGV8_OBJECT exports_obj)
#elif (NODE_MODULE_VERSION < 64)
void SWIGV8_INIT (SWIGV8_OBJECT exports_obj, SWIGV8_VALUE /*module*/, void*)
#else
void SWIGV8_INIT (SWIGV8_OBJECT exports_obj, SWIGV8_VALUE /*module*/, v8::Local<v8::Context> context, void*)
#endif
{
#if !defined(NODE_MODULE_VERSION) || NODE_MODULE_VERSION < 64
  v8::Local<v8::Context> context = SWIGV8_CURRENT_CONTEXT();
#endif

  SWIG_InitializeModule(context);



SWIGRUNTIME void
SWIG_V8_SetModule(v8::Local<v8::Context> context, swig_module_info *swig_module) {
  v8::Local<v8::Object> global_obj = context->Global();
  v8::Local<v8::External> mod = SWIGV8_EXTERNAL_NEW(swig_module);
  assert(!mod.IsEmpty());
  v8::Local<v8::Private> privateKey = v8::Private::ForApi(v8::Isolate::GetCurrent(), SWIGV8_STRING_NEW("swig_module_info_data"));
  global_obj->SetPrivate(context, privateKey, mod);
}

SWIGRUNTIME swig_module_info *
SWIG_V8_GetModule(v8::Local<v8::Context> context) {
  v8::Local<v8::Object> global_obj = context->Global();
  v8::Local<v8::Private> privateKey = v8::Private::ForApi(v8::Isolate::GetCurrent(), SWIGV8_STRING_NEW("swig_module_info_data"));
  v8::Local<v8::Value> moduleinfo;
  if (!global_obj->GetPrivate(context, privateKey).ToLocal(&moduleinfo))
    return 0;

  if (moduleinfo.IsEmpty() || moduleinfo->IsNull() || moduleinfo->IsUndefined())
  {
    // It's not yet loaded
    return 0;
  }

  v8::Local<v8::External> moduleinfo_extern = v8::Local<v8::External>::Cast(moduleinfo);

  if (moduleinfo_extern.IsEmpty() || moduleinfo_extern->IsNull() || moduleinfo_extern->IsUndefined())
  {
    // Something's not right
    return 0;
  }

  void *ptr = moduleinfo_extern->Value();
  assert(ptr);
  swig_module_info *retptr = static_cast<swig_module_info *>(ptr);
  assert(retptr);
  return retptr;
}

#define SWIG_GetModule(clientdata)                SWIG_V8_GetModule(clientdata)
#define SWIG_SetModule(clientdata, pointer)       SWIG_V8_SetModule(clientdata, pointer)
#define SWIG_INIT_CLIENT_DATA_TYPE                v8::Local<v8::Context>


/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic
 * memory is used. Also, since swig_type_info structures store pointers to
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization.
 * The idea is that swig generates all the structures that are needed.
 * The runtime then collects these partially filled structures.
 * The SWIG_InitializeModule function takes these initial arrays out of
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned statically to an initial
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded.
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif

#ifndef SWIG_INIT_CLIENT_DATA_TYPE
#define SWIG_INIT_CLIENT_DATA_TYPE void *
#endif

SWIGRUNTIME void
SWIG_InitializeModule(SWIG_INIT_CLIENT_DATA_TYPE clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int init;

  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }

  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    iter=module_head;
    do {
      if (iter==&swig_module) {
        /* Our module is already in the list, so there's nothing more to do. */
        return;
      }
      iter=iter->next;
    } while (iter!= module_head);

    /* otherwise we must add our module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }

  /* When multiple interpreters are used, a module could have already been initialized in
     a different interpreter, but not yet have a pointer in this interpreter.
     In this case, we do not want to continue adding types... everything should be
     set up already */
  if (init == 0) return;

  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %lu\n", (unsigned long)swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;

#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
#endif

    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
	type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }

    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {

      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
	if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
	if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
	  printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
	  cast->type = ret;
	  ret = 0;
	} else {
	  /* Check for casting already in the list */
	  swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
	  if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
	  if (!ocast) ret = 0;
	}
      }

      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
	printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;

#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
  printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;

  if (init_run) return;
  init_run = 1;

  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{ /* c-mode */
#endif
}
#endif


#if !defined(NODE_MODULE_VERSION) || (NODE_MODULE_VERSION < 12)
// Note: 'extern "C"'' disables name mangling which makes it easier to load the symbol manually
extern "C" void SWIGV8_INIT (SWIGV8_OBJECT exports_obj)
#elif (NODE_MODULE_VERSION < 64)
void SWIGV8_INIT (SWIGV8_OBJECT exports_obj, SWIGV8_VALUE /*module*/, void*)
#else
void SWIGV8_INIT (SWIGV8_OBJECT exports_obj, SWIGV8_VALUE /*module*/, v8::Local<v8::Context> context, void*)
#endif
{
#if !defined(NODE_MODULE_VERSION) || NODE_MODULE_VERSION < 64
  v8::Local<v8::Context> context = SWIGV8_CURRENT_CONTEXT();
#endif

  SWIG_InitializeModule(context);


  // a class template for creating proxies of undefined types
  SWIGV8_SET_CLASS_TEMPL(SWIGV8_SWIGTYPE_Proxy_class_templ, SWIGV8_CreateClassTemplate("SwigProxy"));

  /* create objects for namespaces */
  

  /* create class templates */
  /* Name: _exports_TypeMetric, Type: p_Magick__TypeMetric, Dtor: _wrap_delete_TypeMetric */
SWIGV8_FUNCTION_TEMPLATE _exports_TypeMetric_class = SWIGV8_CreateClassTemplate("_exports_TypeMetric");
SWIGV8_SET_CLASS_TEMPL(_exports_TypeMetric_clientData.class_templ, _exports_TypeMetric_class);
_exports_TypeMetric_clientData.dtor = _wrap_delete_TypeMetric;
if (SWIGTYPE_p_Magick__TypeMetric->clientdata == 0) {
  SWIGTYPE_p_Magick__TypeMetric->clientdata = &_exports_TypeMetric_clientData;
}
/* Name: _exports_Geometry, Type: p_Magick__Geometry, Dtor: _wrap_delete_Geometry */
SWIGV8_FUNCTION_TEMPLATE _exports_Geometry_class = SWIGV8_CreateClassTemplate("_exports_Geometry");
SWIGV8_SET_CLASS_TEMPL(_exports_Geometry_clientData.class_templ, _exports_Geometry_class);
_exports_Geometry_clientData.dtor = _wrap_delete_Geometry;
if (SWIGTYPE_p_Magick__Geometry->clientdata == 0) {
  SWIGTYPE_p_Magick__Geometry->clientdata = &_exports_Geometry_clientData;
}
/* Name: _exports_Offset, Type: p_Magick__Offset, Dtor: _wrap_delete_Offset */
SWIGV8_FUNCTION_TEMPLATE _exports_Offset_class = SWIGV8_CreateClassTemplate("_exports_Offset");
SWIGV8_SET_CLASS_TEMPL(_exports_Offset_clientData.class_templ, _exports_Offset_class);
_exports_Offset_clientData.dtor = _wrap_delete_Offset;
if (SWIGTYPE_p_Magick__Offset->clientdata == 0) {
  SWIGTYPE_p_Magick__Offset->clientdata = &_exports_Offset_clientData;
}
/* Name: _exports_Pixels, Type: p_Magick__Pixels, Dtor: _wrap_delete_Pixels */
SWIGV8_FUNCTION_TEMPLATE _exports_Pixels_class = SWIGV8_CreateClassTemplate("_exports_Pixels");
SWIGV8_SET_CLASS_TEMPL(_exports_Pixels_clientData.class_templ, _exports_Pixels_class);
_exports_Pixels_clientData.dtor = _wrap_delete_Pixels;
if (SWIGTYPE_p_Magick__Pixels->clientdata == 0) {
  SWIGTYPE_p_Magick__Pixels->clientdata = &_exports_Pixels_clientData;
}
/* Name: _exports_PixelData, Type: p_Magick__PixelData, Dtor: _wrap_delete_PixelData */
SWIGV8_FUNCTION_TEMPLATE _exports_PixelData_class = SWIGV8_CreateClassTemplate("_exports_PixelData");
SWIGV8_SET_CLASS_TEMPL(_exports_PixelData_clientData.class_templ, _exports_PixelData_class);
_exports_PixelData_clientData.dtor = _wrap_delete_PixelData;
if (SWIGTYPE_p_Magick__PixelData->clientdata == 0) {
  SWIGTYPE_p_Magick__PixelData->clientdata = &_exports_PixelData_clientData;
}
/* Name: _exports_ResourceLimits, Type: p_Magick__ResourceLimits, Dtor: _wrap_delete_ResourceLimits */
SWIGV8_FUNCTION_TEMPLATE _exports_ResourceLimits_class = SWIGV8_CreateClassTemplate("_exports_ResourceLimits");
SWIGV8_SET_CLASS_TEMPL(_exports_ResourceLimits_clientData.class_templ, _exports_ResourceLimits_class);
_exports_ResourceLimits_clientData.dtor = _wrap_delete_ResourceLimits;
if (SWIGTYPE_p_Magick__ResourceLimits->clientdata == 0) {
  SWIGTYPE_p_Magick__ResourceLimits->clientdata = &_exports_ResourceLimits_clientData;
}
/* Name: _exports_adaptiveBlurImage, Type: p_Magick__adaptiveBlurImage, Dtor: _wrap_delete_adaptiveBlurImage */
SWIGV8_FUNCTION_TEMPLATE _exports_adaptiveBlurImage_class = SWIGV8_CreateClassTemplate("_exports_adaptiveBlurImage");
SWIGV8_SET_CLASS_TEMPL(_exports_adaptiveBlurImage_clientData.class_templ, _exports_adaptiveBlurImage_class);
_exports_adaptiveBlurImage_clientData.dtor = _wrap_delete_adaptiveBlurImage;
if (SWIGTYPE_p_Magick__adaptiveBlurImage->clientdata == 0) {
  SWIGTYPE_p_Magick__adaptiveBlurImage->clientdata = &_exports_adaptiveBlurImage_clientData;
}
/* Name: _exports_adaptiveThresholdImage, Type: p_Magick__adaptiveThresholdImage, Dtor: _wrap_delete_adaptiveThresholdImage */
SWIGV8_FUNCTION_TEMPLATE _exports_adaptiveThresholdImage_class = SWIGV8_CreateClassTemplate("_exports_adaptiveThresholdImage");
SWIGV8_SET_CLASS_TEMPL(_exports_adaptiveThresholdImage_clientData.class_templ, _exports_adaptiveThresholdImage_class);
_exports_adaptiveThresholdImage_clientData.dtor = _wrap_delete_adaptiveThresholdImage;
if (SWIGTYPE_p_Magick__adaptiveThresholdImage->clientdata == 0) {
  SWIGTYPE_p_Magick__adaptiveThresholdImage->clientdata = &_exports_adaptiveThresholdImage_clientData;
}
/* Name: _exports_addNoiseImage, Type: p_Magick__addNoiseImage, Dtor: _wrap_delete_addNoiseImage */
SWIGV8_FUNCTION_TEMPLATE _exports_addNoiseImage_class = SWIGV8_CreateClassTemplate("_exports_addNoiseImage");
SWIGV8_SET_CLASS_TEMPL(_exports_addNoiseImage_clientData.class_templ, _exports_addNoiseImage_class);
_exports_addNoiseImage_clientData.dtor = _wrap_delete_addNoiseImage;
if (SWIGTYPE_p_Magick__addNoiseImage->clientdata == 0) {
  SWIGTYPE_p_Magick__addNoiseImage->clientdata = &_exports_addNoiseImage_clientData;
}
/* Name: _exports_affineTransformImage, Type: p_Magick__affineTransformImage, Dtor: _wrap_delete_affineTransformImage */
SWIGV8_FUNCTION_TEMPLATE _exports_affineTransformImage_class = SWIGV8_CreateClassTemplate("_exports_affineTransformImage");
SWIGV8_SET_CLASS_TEMPL(_exports_affineTransformImage_clientData.class_templ, _exports_affineTransformImage_class);
_exports_affineTransformImage_clientData.dtor = _wrap_delete_affineTransformImage;
if (SWIGTYPE_p_Magick__affineTransformImage->clientdata == 0) {
  SWIGTYPE_p_Magick__affineTransformImage->clientdata = &_exports_affineTransformImage_clientData;
}
/* Name: _exports_annotateImage, Type: p_Magick__annotateImage, Dtor: _wrap_delete_annotateImage */
SWIGV8_FUNCTION_TEMPLATE _exports_annotateImage_class = SWIGV8_CreateClassTemplate("_exports_annotateImage");
SWIGV8_SET_CLASS_TEMPL(_exports_annotateImage_clientData.class_templ, _exports_annotateImage_class);
_exports_annotateImage_clientData.dtor = _wrap_delete_annotateImage;
if (SWIGTYPE_p_Magick__annotateImage->clientdata == 0) {
  SWIGTYPE_p_Magick__annotateImage->clientdata = &_exports_annotateImage_clientData;
}
/* Name: _exports_blurImage, Type: p_Magick__blurImage, Dtor: _wrap_delete_blurImage */
SWIGV8_FUNCTION_TEMPLATE _exports_blurImage_class = SWIGV8_CreateClassTemplate("_exports_blurImage");
SWIGV8_SET_CLASS_TEMPL(_exports_blurImage_clientData.class_templ, _exports_blurImage_class);
_exports_blurImage_clientData.dtor = _wrap_delete_blurImage;
if (SWIGTYPE_p_Magick__blurImage->clientdata == 0) {
  SWIGTYPE_p_Magick__blurImage->clientdata = &_exports_blurImage_clientData;
}
/* Name: _exports_borderImage, Type: p_Magick__borderImage, Dtor: _wrap_delete_borderImage */
SWIGV8_FUNCTION_TEMPLATE _exports_borderImage_class = SWIGV8_CreateClassTemplate("_exports_borderImage");
SWIGV8_SET_CLASS_TEMPL(_exports_borderImage_clientData.class_templ, _exports_borderImage_class);
_exports_borderImage_clientData.dtor = _wrap_delete_borderImage;
if (SWIGTYPE_p_Magick__borderImage->clientdata == 0) {
  SWIGTYPE_p_Magick__borderImage->clientdata = &_exports_borderImage_clientData;
}
/* Name: _exports_channelImage, Type: p_Magick__channelImage, Dtor: _wrap_delete_channelImage */
SWIGV8_FUNCTION_TEMPLATE _exports_channelImage_class = SWIGV8_CreateClassTemplate("_exports_channelImage");
SWIGV8_SET_CLASS_TEMPL(_exports_channelImage_clientData.class_templ, _exports_channelImage_class);
_exports_channelImage_clientData.dtor = _wrap_delete_channelImage;
if (SWIGTYPE_p_Magick__channelImage->clientdata == 0) {
  SWIGTYPE_p_Magick__channelImage->clientdata = &_exports_channelImage_clientData;
}
/* Name: _exports_charcoalImage, Type: p_Magick__charcoalImage, Dtor: _wrap_delete_charcoalImage */
SWIGV8_FUNCTION_TEMPLATE _exports_charcoalImage_class = SWIGV8_CreateClassTemplate("_exports_charcoalImage");
SWIGV8_SET_CLASS_TEMPL(_exports_charcoalImage_clientData.class_templ, _exports_charcoalImage_class);
_exports_charcoalImage_clientData.dtor = _wrap_delete_charcoalImage;
if (SWIGTYPE_p_Magick__charcoalImage->clientdata == 0) {
  SWIGTYPE_p_Magick__charcoalImage->clientdata = &_exports_charcoalImage_clientData;
}
/* Name: _exports_chopImage, Type: p_Magick__chopImage, Dtor: _wrap_delete_chopImage */
SWIGV8_FUNCTION_TEMPLATE _exports_chopImage_class = SWIGV8_CreateClassTemplate("_exports_chopImage");
SWIGV8_SET_CLASS_TEMPL(_exports_chopImage_clientData.class_templ, _exports_chopImage_class);
_exports_chopImage_clientData.dtor = _wrap_delete_chopImage;
if (SWIGTYPE_p_Magick__chopImage->clientdata == 0) {
  SWIGTYPE_p_Magick__chopImage->clientdata = &_exports_chopImage_clientData;
}
/* Name: _exports_cdlImage, Type: p_Magick__cdlImage, Dtor: _wrap_delete_cdlImage */
SWIGV8_FUNCTION_TEMPLATE _exports_cdlImage_class = SWIGV8_CreateClassTemplate("_exports_cdlImage");
SWIGV8_SET_CLASS_TEMPL(_exports_cdlImage_clientData.class_templ, _exports_cdlImage_class);
_exports_cdlImage_clientData.dtor = _wrap_delete_cdlImage;
if (SWIGTYPE_p_Magick__cdlImage->clientdata == 0) {
  SWIGTYPE_p_Magick__cdlImage->clientdata = &_exports_cdlImage_clientData;
}
/* Name: _exports_colorizeImage, Type: p_Magick__colorizeImage, Dtor: _wrap_delete_colorizeImage */
SWIGV8_FUNCTION_TEMPLATE _exports_colorizeImage_class = SWIGV8_CreateClassTemplate("_exports_colorizeImage");
SWIGV8_SET_CLASS_TEMPL(_exports_colorizeImage_clientData.class_templ, _exports_colorizeImage_class);
_exports_colorizeImage_clientData.dtor = _wrap_delete_colorizeImage;
if (SWIGTYPE_p_Magick__colorizeImage->clientdata == 0) {
  SWIGTYPE_p_Magick__colorizeImage->clientdata = &_exports_colorizeImage_clientData;
}
/* Name: _exports_colorMatrixImage, Type: p_Magick__colorMatrixImage, Dtor: _wrap_delete_colorMatrixImage */
SWIGV8_FUNCTION_TEMPLATE _exports_colorMatrixImage_class = SWIGV8_CreateClassTemplate("_exports_colorMatrixImage");
SWIGV8_SET_CLASS_TEMPL(_exports_colorMatrixImage_clientData.class_templ, _exports_colorMatrixImage_class);
_exports_colorMatrixImage_clientData.dtor = _wrap_delete_colorMatrixImage;
if (SWIGTYPE_p_Magick__colorMatrixImage->clientdata == 0) {
  SWIGTYPE_p_Magick__colorMatrixImage->clientdata = &_exports_colorMatrixImage_clientData;
}
/* Name: _exports_colorSpaceImage, Type: p_Magick__colorSpaceImage, Dtor: _wrap_delete_colorSpaceImage */
SWIGV8_FUNCTION_TEMPLATE _exports_colorSpaceImage_class = SWIGV8_CreateClassTemplate("_exports_colorSpaceImage");
SWIGV8_SET_CLASS_TEMPL(_exports_colorSpaceImage_clientData.class_templ, _exports_colorSpaceImage_class);
_exports_colorSpaceImage_clientData.dtor = _wrap_delete_colorSpaceImage;
if (SWIGTYPE_p_Magick__colorSpaceImage->clientdata == 0) {
  SWIGTYPE_p_Magick__colorSpaceImage->clientdata = &_exports_colorSpaceImage_clientData;
}
/* Name: _exports_commentImage, Type: p_Magick__commentImage, Dtor: _wrap_delete_commentImage */
SWIGV8_FUNCTION_TEMPLATE _exports_commentImage_class = SWIGV8_CreateClassTemplate("_exports_commentImage");
SWIGV8_SET_CLASS_TEMPL(_exports_commentImage_clientData.class_templ, _exports_commentImage_class);
_exports_commentImage_clientData.dtor = _wrap_delete_commentImage;
if (SWIGTYPE_p_Magick__commentImage->clientdata == 0) {
  SWIGTYPE_p_Magick__commentImage->clientdata = &_exports_commentImage_clientData;
}
/* Name: _exports_compositeImage, Type: p_Magick__compositeImage, Dtor: _wrap_delete_compositeImage */
SWIGV8_FUNCTION_TEMPLATE _exports_compositeImage_class = SWIGV8_CreateClassTemplate("_exports_compositeImage");
SWIGV8_SET_CLASS_TEMPL(_exports_compositeImage_clientData.class_templ, _exports_compositeImage_class);
_exports_compositeImage_clientData.dtor = _wrap_delete_compositeImage;
if (SWIGTYPE_p_Magick__compositeImage->clientdata == 0) {
  SWIGTYPE_p_Magick__compositeImage->clientdata = &_exports_compositeImage_clientData;
}
/* Name: _exports_contrastImage, Type: p_Magick__contrastImage, Dtor: _wrap_delete_contrastImage */
SWIGV8_FUNCTION_TEMPLATE _exports_contrastImage_class = SWIGV8_CreateClassTemplate("_exports_contrastImage");
SWIGV8_SET_CLASS_TEMPL(_exports_contrastImage_clientData.class_templ, _exports_contrastImage_class);
_exports_contrastImage_clientData.dtor = _wrap_delete_contrastImage;
if (SWIGTYPE_p_Magick__contrastImage->clientdata == 0) {
  SWIGTYPE_p_Magick__contrastImage->clientdata = &_exports_contrastImage_clientData;
}
/* Name: _exports_cropImage, Type: p_Magick__cropImage, Dtor: _wrap_delete_cropImage */
SWIGV8_FUNCTION_TEMPLATE _exports_cropImage_class = SWIGV8_CreateClassTemplate("_exports_cropImage");
SWIGV8_SET_CLASS_TEMPL(_exports_cropImage_clientData.class_templ, _exports_cropImage_class);
_exports_cropImage_clientData.dtor = _wrap_delete_cropImage;
if (SWIGTYPE_p_Magick__cropImage->clientdata == 0) {
  SWIGTYPE_p_Magick__cropImage->clientdata = &_exports_cropImage_clientData;
}
/* Name: _exports_cycleColormapImage, Type: p_Magick__cycleColormapImage, Dtor: _wrap_delete_cycleColormapImage */
SWIGV8_FUNCTION_TEMPLATE _exports_cycleColormapImage_class = SWIGV8_CreateClassTemplate("_exports_cycleColormapImage");
SWIGV8_SET_CLASS_TEMPL(_exports_cycleColormapImage_clientData.class_templ, _exports_cycleColormapImage_class);
_exports_cycleColormapImage_clientData.dtor = _wrap_delete_cycleColormapImage;
if (SWIGTYPE_p_Magick__cycleColormapImage->clientdata == 0) {
  SWIGTYPE_p_Magick__cycleColormapImage->clientdata = &_exports_cycleColormapImage_clientData;
}
/* Name: _exports_despeckleImage, Type: p_Magick__despeckleImage, Dtor: _wrap_delete_despeckleImage */
SWIGV8_FUNCTION_TEMPLATE _exports_despeckleImage_class = SWIGV8_CreateClassTemplate("_exports_despeckleImage");
SWIGV8_SET_CLASS_TEMPL(_exports_despeckleImage_clientData.class_templ, _exports_despeckleImage_class);
_exports_despeckleImage_clientData.dtor = _wrap_delete_despeckleImage;
if (SWIGTYPE_p_Magick__despeckleImage->clientdata == 0) {
  SWIGTYPE_p_Magick__despeckleImage->clientdata = &_exports_despeckleImage_clientData;
}
/* Name: _exports_distortImage, Type: p_Magick__distortImage, Dtor: _wrap_delete_distortImage */
SWIGV8_FUNCTION_TEMPLATE _exports_distortImage_class = SWIGV8_CreateClassTemplate("_exports_distortImage");
SWIGV8_SET_CLASS_TEMPL(_exports_distortImage_clientData.class_templ, _exports_distortImage_class);
_exports_distortImage_clientData.dtor = _wrap_delete_distortImage;
if (SWIGTYPE_p_Magick__distortImage->clientdata == 0) {
  SWIGTYPE_p_Magick__distortImage->clientdata = &_exports_distortImage_clientData;
}
/* Name: _exports_drawImage, Type: p_Magick__drawImage, Dtor: _wrap_delete_drawImage */
SWIGV8_FUNCTION_TEMPLATE _exports_drawImage_class = SWIGV8_CreateClassTemplate("_exports_drawImage");
SWIGV8_SET_CLASS_TEMPL(_exports_drawImage_clientData.class_templ, _exports_drawImage_class);
_exports_drawImage_clientData.dtor = _wrap_delete_drawImage;
if (SWIGTYPE_p_Magick__drawImage->clientdata == 0) {
  SWIGTYPE_p_Magick__drawImage->clientdata = &_exports_drawImage_clientData;
}
/* Name: _exports_edgeImage, Type: p_Magick__edgeImage, Dtor: _wrap_delete_edgeImage */
SWIGV8_FUNCTION_TEMPLATE _exports_edgeImage_class = SWIGV8_CreateClassTemplate("_exports_edgeImage");
SWIGV8_SET_CLASS_TEMPL(_exports_edgeImage_clientData.class_templ, _exports_edgeImage_class);
_exports_edgeImage_clientData.dtor = _wrap_delete_edgeImage;
if (SWIGTYPE_p_Magick__edgeImage->clientdata == 0) {
  SWIGTYPE_p_Magick__edgeImage->clientdata = &_exports_edgeImage_clientData;
}
/* Name: _exports_embossImage, Type: p_Magick__embossImage, Dtor: _wrap_delete_embossImage */
SWIGV8_FUNCTION_TEMPLATE _exports_embossImage_class = SWIGV8_CreateClassTemplate("_exports_embossImage");
SWIGV8_SET_CLASS_TEMPL(_exports_embossImage_clientData.class_templ, _exports_embossImage_class);
_exports_embossImage_clientData.dtor = _wrap_delete_embossImage;
if (SWIGTYPE_p_Magick__embossImage->clientdata == 0) {
  SWIGTYPE_p_Magick__embossImage->clientdata = &_exports_embossImage_clientData;
}
/* Name: _exports_enhanceImage, Type: p_Magick__enhanceImage, Dtor: _wrap_delete_enhanceImage */
SWIGV8_FUNCTION_TEMPLATE _exports_enhanceImage_class = SWIGV8_CreateClassTemplate("_exports_enhanceImage");
SWIGV8_SET_CLASS_TEMPL(_exports_enhanceImage_clientData.class_templ, _exports_enhanceImage_class);
_exports_enhanceImage_clientData.dtor = _wrap_delete_enhanceImage;
if (SWIGTYPE_p_Magick__enhanceImage->clientdata == 0) {
  SWIGTYPE_p_Magick__enhanceImage->clientdata = &_exports_enhanceImage_clientData;
}
/* Name: _exports_equalizeImage, Type: p_Magick__equalizeImage, Dtor: _wrap_delete_equalizeImage */
SWIGV8_FUNCTION_TEMPLATE _exports_equalizeImage_class = SWIGV8_CreateClassTemplate("_exports_equalizeImage");
SWIGV8_SET_CLASS_TEMPL(_exports_equalizeImage_clientData.class_templ, _exports_equalizeImage_class);
_exports_equalizeImage_clientData.dtor = _wrap_delete_equalizeImage;
if (SWIGTYPE_p_Magick__equalizeImage->clientdata == 0) {
  SWIGTYPE_p_Magick__equalizeImage->clientdata = &_exports_equalizeImage_clientData;
}
/* Name: _exports_fillColorImage, Type: p_Magick__fillColorImage, Dtor: _wrap_delete_fillColorImage */
SWIGV8_FUNCTION_TEMPLATE _exports_fillColorImage_class = SWIGV8_CreateClassTemplate("_exports_fillColorImage");
SWIGV8_SET_CLASS_TEMPL(_exports_fillColorImage_clientData.class_templ, _exports_fillColorImage_class);
_exports_fillColorImage_clientData.dtor = _wrap_delete_fillColorImage;
if (SWIGTYPE_p_Magick__fillColorImage->clientdata == 0) {
  SWIGTYPE_p_Magick__fillColorImage->clientdata = &_exports_fillColorImage_clientData;
}
/* Name: _exports_flipImage, Type: p_Magick__flipImage, Dtor: _wrap_delete_flipImage */
SWIGV8_FUNCTION_TEMPLATE _exports_flipImage_class = SWIGV8_CreateClassTemplate("_exports_flipImage");
SWIGV8_SET_CLASS_TEMPL(_exports_flipImage_clientData.class_templ, _exports_flipImage_class);
_exports_flipImage_clientData.dtor = _wrap_delete_flipImage;
if (SWIGTYPE_p_Magick__flipImage->clientdata == 0) {
  SWIGTYPE_p_Magick__flipImage->clientdata = &_exports_flipImage_clientData;
}
/* Name: _exports_floodFillColorImage, Type: p_Magick__floodFillColorImage, Dtor: _wrap_delete_floodFillColorImage */
SWIGV8_FUNCTION_TEMPLATE _exports_floodFillColorImage_class = SWIGV8_CreateClassTemplate("_exports_floodFillColorImage");
SWIGV8_SET_CLASS_TEMPL(_exports_floodFillColorImage_clientData.class_templ, _exports_floodFillColorImage_class);
_exports_floodFillColorImage_clientData.dtor = _wrap_delete_floodFillColorImage;
if (SWIGTYPE_p_Magick__floodFillColorImage->clientdata == 0) {
  SWIGTYPE_p_Magick__floodFillColorImage->clientdata = &_exports_floodFillColorImage_clientData;
}
/* Name: _exports_floodFillTextureImage, Type: p_Magick__floodFillTextureImage, Dtor: _wrap_delete_floodFillTextureImage */
SWIGV8_FUNCTION_TEMPLATE _exports_floodFillTextureImage_class = SWIGV8_CreateClassTemplate("_exports_floodFillTextureImage");
SWIGV8_SET_CLASS_TEMPL(_exports_floodFillTextureImage_clientData.class_templ, _exports_floodFillTextureImage_class);
_exports_floodFillTextureImage_clientData.dtor = _wrap_delete_floodFillTextureImage;
if (SWIGTYPE_p_Magick__floodFillTextureImage->clientdata == 0) {
  SWIGTYPE_p_Magick__floodFillTextureImage->clientdata = &_exports_floodFillTextureImage_clientData;
}
/* Name: _exports_flopImage, Type: p_Magick__flopImage, Dtor: _wrap_delete_flopImage */
SWIGV8_FUNCTION_TEMPLATE _exports_flopImage_class = SWIGV8_CreateClassTemplate("_exports_flopImage");
SWIGV8_SET_CLASS_TEMPL(_exports_flopImage_clientData.class_templ, _exports_flopImage_class);
_exports_flopImage_clientData.dtor = _wrap_delete_flopImage;
if (SWIGTYPE_p_Magick__flopImage->clientdata == 0) {
  SWIGTYPE_p_Magick__flopImage->clientdata = &_exports_flopImage_clientData;
}
/* Name: _exports_frameImage, Type: p_Magick__frameImage, Dtor: _wrap_delete_frameImage */
SWIGV8_FUNCTION_TEMPLATE _exports_frameImage_class = SWIGV8_CreateClassTemplate("_exports_frameImage");
SWIGV8_SET_CLASS_TEMPL(_exports_frameImage_clientData.class_templ, _exports_frameImage_class);
_exports_frameImage_clientData.dtor = _wrap_delete_frameImage;
if (SWIGTYPE_p_Magick__frameImage->clientdata == 0) {
  SWIGTYPE_p_Magick__frameImage->clientdata = &_exports_frameImage_clientData;
}
/* Name: _exports_gammaImage, Type: p_Magick__gammaImage, Dtor: _wrap_delete_gammaImage */
SWIGV8_FUNCTION_TEMPLATE _exports_gammaImage_class = SWIGV8_CreateClassTemplate("_exports_gammaImage");
SWIGV8_SET_CLASS_TEMPL(_exports_gammaImage_clientData.class_templ, _exports_gammaImage_class);
_exports_gammaImage_clientData.dtor = _wrap_delete_gammaImage;
if (SWIGTYPE_p_Magick__gammaImage->clientdata == 0) {
  SWIGTYPE_p_Magick__gammaImage->clientdata = &_exports_gammaImage_clientData;
}
/* Name: _exports_gaussianBlurImage, Type: p_Magick__gaussianBlurImage, Dtor: _wrap_delete_gaussianBlurImage */
SWIGV8_FUNCTION_TEMPLATE _exports_gaussianBlurImage_class = SWIGV8_CreateClassTemplate("_exports_gaussianBlurImage");
SWIGV8_SET_CLASS_TEMPL(_exports_gaussianBlurImage_clientData.class_templ, _exports_gaussianBlurImage_class);
_exports_gaussianBlurImage_clientData.dtor = _wrap_delete_gaussianBlurImage;
if (SWIGTYPE_p_Magick__gaussianBlurImage->clientdata == 0) {
  SWIGTYPE_p_Magick__gaussianBlurImage->clientdata = &_exports_gaussianBlurImage_clientData;
}
/* Name: _exports_haldClutImage, Type: p_Magick__haldClutImage, Dtor: _wrap_delete_haldClutImage */
SWIGV8_FUNCTION_TEMPLATE _exports_haldClutImage_class = SWIGV8_CreateClassTemplate("_exports_haldClutImage");
SWIGV8_SET_CLASS_TEMPL(_exports_haldClutImage_clientData.class_templ, _exports_haldClutImage_class);
_exports_haldClutImage_clientData.dtor = _wrap_delete_haldClutImage;
if (SWIGTYPE_p_Magick__haldClutImage->clientdata == 0) {
  SWIGTYPE_p_Magick__haldClutImage->clientdata = &_exports_haldClutImage_clientData;
}
/* Name: _exports_implodeImage, Type: p_Magick__implodeImage, Dtor: _wrap_delete_implodeImage */
SWIGV8_FUNCTION_TEMPLATE _exports_implodeImage_class = SWIGV8_CreateClassTemplate("_exports_implodeImage");
SWIGV8_SET_CLASS_TEMPL(_exports_implodeImage_clientData.class_templ, _exports_implodeImage_class);
_exports_implodeImage_clientData.dtor = _wrap_delete_implodeImage;
if (SWIGTYPE_p_Magick__implodeImage->clientdata == 0) {
  SWIGTYPE_p_Magick__implodeImage->clientdata = &_exports_implodeImage_clientData;
}
/* Name: _exports_inverseFourierTransformImage, Type: p_Magick__inverseFourierTransformImage, Dtor: _wrap_delete_inverseFourierTransformImage */
SWIGV8_FUNCTION_TEMPLATE _exports_inverseFourierTransformImage_class = SWIGV8_CreateClassTemplate("_exports_inverseFourierTransformImage");
SWIGV8_SET_CLASS_TEMPL(_exports_inverseFourierTransformImage_clientData.class_templ, _exports_inverseFourierTransformImage_class);
_exports_inverseFourierTransformImage_clientData.dtor = _wrap_delete_inverseFourierTransformImage;
if (SWIGTYPE_p_Magick__inverseFourierTransformImage->clientdata == 0) {
  SWIGTYPE_p_Magick__inverseFourierTransformImage->clientdata = &_exports_inverseFourierTransformImage_clientData;
}
/* Name: _exports_isValidImage, Type: p_Magick__isValidImage, Dtor: _wrap_delete_isValidImage */
SWIGV8_FUNCTION_TEMPLATE _exports_isValidImage_class = SWIGV8_CreateClassTemplate("_exports_isValidImage");
SWIGV8_SET_CLASS_TEMPL(_exports_isValidImage_clientData.class_templ, _exports_isValidImage_class);
_exports_isValidImage_clientData.dtor = _wrap_delete_isValidImage;
if (SWIGTYPE_p_Magick__isValidImage->clientdata == 0) {
  SWIGTYPE_p_Magick__isValidImage->clientdata = &_exports_isValidImage_clientData;
}
/* Name: _exports_labelImage, Type: p_Magick__labelImage, Dtor: _wrap_delete_labelImage */
SWIGV8_FUNCTION_TEMPLATE _exports_labelImage_class = SWIGV8_CreateClassTemplate("_exports_labelImage");
SWIGV8_SET_CLASS_TEMPL(_exports_labelImage_clientData.class_templ, _exports_labelImage_class);
_exports_labelImage_clientData.dtor = _wrap_delete_labelImage;
if (SWIGTYPE_p_Magick__labelImage->clientdata == 0) {
  SWIGTYPE_p_Magick__labelImage->clientdata = &_exports_labelImage_clientData;
}
/* Name: _exports_levelImage, Type: p_Magick__levelImage, Dtor: _wrap_delete_levelImage */
SWIGV8_FUNCTION_TEMPLATE _exports_levelImage_class = SWIGV8_CreateClassTemplate("_exports_levelImage");
SWIGV8_SET_CLASS_TEMPL(_exports_levelImage_clientData.class_templ, _exports_levelImage_class);
_exports_levelImage_clientData.dtor = _wrap_delete_levelImage;
if (SWIGTYPE_p_Magick__levelImage->clientdata == 0) {
  SWIGTYPE_p_Magick__levelImage->clientdata = &_exports_levelImage_clientData;
}
/* Name: _exports_levelChannelImage, Type: p_Magick__levelChannelImage, Dtor: _wrap_delete_levelChannelImage */
SWIGV8_FUNCTION_TEMPLATE _exports_levelChannelImage_class = SWIGV8_CreateClassTemplate("_exports_levelChannelImage");
SWIGV8_SET_CLASS_TEMPL(_exports_levelChannelImage_clientData.class_templ, _exports_levelChannelImage_class);
_exports_levelChannelImage_clientData.dtor = _wrap_delete_levelChannelImage;
if (SWIGTYPE_p_Magick__levelChannelImage->clientdata == 0) {
  SWIGTYPE_p_Magick__levelChannelImage->clientdata = &_exports_levelChannelImage_clientData;
}
/* Name: _exports_magnifyImage, Type: p_Magick__magnifyImage, Dtor: _wrap_delete_magnifyImage */
SWIGV8_FUNCTION_TEMPLATE _exports_magnifyImage_class = SWIGV8_CreateClassTemplate("_exports_magnifyImage");
SWIGV8_SET_CLASS_TEMPL(_exports_magnifyImage_clientData.class_templ, _exports_magnifyImage_class);
_exports_magnifyImage_clientData.dtor = _wrap_delete_magnifyImage;
if (SWIGTYPE_p_Magick__magnifyImage->clientdata == 0) {
  SWIGTYPE_p_Magick__magnifyImage->clientdata = &_exports_magnifyImage_clientData;
}
/* Name: _exports_mapImage, Type: p_Magick__mapImage, Dtor: _wrap_delete_mapImage */
SWIGV8_FUNCTION_TEMPLATE _exports_mapImage_class = SWIGV8_CreateClassTemplate("_exports_mapImage");
SWIGV8_SET_CLASS_TEMPL(_exports_mapImage_clientData.class_templ, _exports_mapImage_class);
_exports_mapImage_clientData.dtor = _wrap_delete_mapImage;
if (SWIGTYPE_p_Magick__mapImage->clientdata == 0) {
  SWIGTYPE_p_Magick__mapImage->clientdata = &_exports_mapImage_clientData;
}
/* Name: _exports_matteFloodfillImage, Type: p_Magick__matteFloodfillImage, Dtor: _wrap_delete_matteFloodfillImage */
SWIGV8_FUNCTION_TEMPLATE _exports_matteFloodfillImage_class = SWIGV8_CreateClassTemplate("_exports_matteFloodfillImage");
SWIGV8_SET_CLASS_TEMPL(_exports_matteFloodfillImage_clientData.class_templ, _exports_matteFloodfillImage_class);
_exports_matteFloodfillImage_clientData.dtor = _wrap_delete_matteFloodfillImage;
if (SWIGTYPE_p_Magick__matteFloodfillImage->clientdata == 0) {
  SWIGTYPE_p_Magick__matteFloodfillImage->clientdata = &_exports_matteFloodfillImage_clientData;
}
/* Name: _exports_medianFilterImage, Type: p_Magick__medianFilterImage, Dtor: _wrap_delete_medianFilterImage */
SWIGV8_FUNCTION_TEMPLATE _exports_medianFilterImage_class = SWIGV8_CreateClassTemplate("_exports_medianFilterImage");
SWIGV8_SET_CLASS_TEMPL(_exports_medianFilterImage_clientData.class_templ, _exports_medianFilterImage_class);
_exports_medianFilterImage_clientData.dtor = _wrap_delete_medianFilterImage;
if (SWIGTYPE_p_Magick__medianFilterImage->clientdata == 0) {
  SWIGTYPE_p_Magick__medianFilterImage->clientdata = &_exports_medianFilterImage_clientData;
}
/* Name: _exports_mergeLayersImage, Type: p_Magick__mergeLayersImage, Dtor: _wrap_delete_mergeLayersImage */
SWIGV8_FUNCTION_TEMPLATE _exports_mergeLayersImage_class = SWIGV8_CreateClassTemplate("_exports_mergeLayersImage");
SWIGV8_SET_CLASS_TEMPL(_exports_mergeLayersImage_clientData.class_templ, _exports_mergeLayersImage_class);
_exports_mergeLayersImage_clientData.dtor = _wrap_delete_mergeLayersImage;
if (SWIGTYPE_p_Magick__mergeLayersImage->clientdata == 0) {
  SWIGTYPE_p_Magick__mergeLayersImage->clientdata = &_exports_mergeLayersImage_clientData;
}
/* Name: _exports_minifyImage, Type: p_Magick__minifyImage, Dtor: _wrap_delete_minifyImage */
SWIGV8_FUNCTION_TEMPLATE _exports_minifyImage_class = SWIGV8_CreateClassTemplate("_exports_minifyImage");
SWIGV8_SET_CLASS_TEMPL(_exports_minifyImage_clientData.class_templ, _exports_minifyImage_class);
_exports_minifyImage_clientData.dtor = _wrap_delete_minifyImage;
if (SWIGTYPE_p_Magick__minifyImage->clientdata == 0) {
  SWIGTYPE_p_Magick__minifyImage->clientdata = &_exports_minifyImage_clientData;
}
/* Name: _exports_modulateImage, Type: p_Magick__modulateImage, Dtor: _wrap_delete_modulateImage */
SWIGV8_FUNCTION_TEMPLATE _exports_modulateImage_class = SWIGV8_CreateClassTemplate("_exports_modulateImage");
SWIGV8_SET_CLASS_TEMPL(_exports_modulateImage_clientData.class_templ, _exports_modulateImage_class);
_exports_modulateImage_clientData.dtor = _wrap_delete_modulateImage;
if (SWIGTYPE_p_Magick__modulateImage->clientdata == 0) {
  SWIGTYPE_p_Magick__modulateImage->clientdata = &_exports_modulateImage_clientData;
}
/* Name: _exports_negateImage, Type: p_Magick__negateImage, Dtor: _wrap_delete_negateImage */
SWIGV8_FUNCTION_TEMPLATE _exports_negateImage_class = SWIGV8_CreateClassTemplate("_exports_negateImage");
SWIGV8_SET_CLASS_TEMPL(_exports_negateImage_clientData.class_templ, _exports_negateImage_class);
_exports_negateImage_clientData.dtor = _wrap_delete_negateImage;
if (SWIGTYPE_p_Magick__negateImage->clientdata == 0) {
  SWIGTYPE_p_Magick__negateImage->clientdata = &_exports_negateImage_clientData;
}
/* Name: _exports_normalizeImage, Type: p_Magick__normalizeImage, Dtor: _wrap_delete_normalizeImage */
SWIGV8_FUNCTION_TEMPLATE _exports_normalizeImage_class = SWIGV8_CreateClassTemplate("_exports_normalizeImage");
SWIGV8_SET_CLASS_TEMPL(_exports_normalizeImage_clientData.class_templ, _exports_normalizeImage_class);
_exports_normalizeImage_clientData.dtor = _wrap_delete_normalizeImage;
if (SWIGTYPE_p_Magick__normalizeImage->clientdata == 0) {
  SWIGTYPE_p_Magick__normalizeImage->clientdata = &_exports_normalizeImage_clientData;
}
/* Name: _exports_oilPaintImage, Type: p_Magick__oilPaintImage, Dtor: _wrap_delete_oilPaintImage */
SWIGV8_FUNCTION_TEMPLATE _exports_oilPaintImage_class = SWIGV8_CreateClassTemplate("_exports_oilPaintImage");
SWIGV8_SET_CLASS_TEMPL(_exports_oilPaintImage_clientData.class_templ, _exports_oilPaintImage_class);
_exports_oilPaintImage_clientData.dtor = _wrap_delete_oilPaintImage;
if (SWIGTYPE_p_Magick__oilPaintImage->clientdata == 0) {
  SWIGTYPE_p_Magick__oilPaintImage->clientdata = &_exports_oilPaintImage_clientData;
}
/* Name: _exports_opacityImage, Type: p_Magick__opacityImage, Dtor: _wrap_delete_opacityImage */
SWIGV8_FUNCTION_TEMPLATE _exports_opacityImage_class = SWIGV8_CreateClassTemplate("_exports_opacityImage");
SWIGV8_SET_CLASS_TEMPL(_exports_opacityImage_clientData.class_templ, _exports_opacityImage_class);
_exports_opacityImage_clientData.dtor = _wrap_delete_opacityImage;
if (SWIGTYPE_p_Magick__opacityImage->clientdata == 0) {
  SWIGTYPE_p_Magick__opacityImage->clientdata = &_exports_opacityImage_clientData;
}
/* Name: _exports_opaqueImage, Type: p_Magick__opaqueImage, Dtor: _wrap_delete_opaqueImage */
SWIGV8_FUNCTION_TEMPLATE _exports_opaqueImage_class = SWIGV8_CreateClassTemplate("_exports_opaqueImage");
SWIGV8_SET_CLASS_TEMPL(_exports_opaqueImage_clientData.class_templ, _exports_opaqueImage_class);
_exports_opaqueImage_clientData.dtor = _wrap_delete_opaqueImage;
if (SWIGTYPE_p_Magick__opaqueImage->clientdata == 0) {
  SWIGTYPE_p_Magick__opaqueImage->clientdata = &_exports_opaqueImage_clientData;
}
/* Name: _exports_quantizeImage, Type: p_Magick__quantizeImage, Dtor: _wrap_delete_quantizeImage */
SWIGV8_FUNCTION_TEMPLATE _exports_quantizeImage_class = SWIGV8_CreateClassTemplate("_exports_quantizeImage");
SWIGV8_SET_CLASS_TEMPL(_exports_quantizeImage_clientData.class_templ, _exports_quantizeImage_class);
_exports_quantizeImage_clientData.dtor = _wrap_delete_quantizeImage;
if (SWIGTYPE_p_Magick__quantizeImage->clientdata == 0) {
  SWIGTYPE_p_Magick__quantizeImage->clientdata = &_exports_quantizeImage_clientData;
}
/* Name: _exports_raiseImage, Type: p_Magick__raiseImage, Dtor: _wrap_delete_raiseImage */
SWIGV8_FUNCTION_TEMPLATE _exports_raiseImage_class = SWIGV8_CreateClassTemplate("_exports_raiseImage");
SWIGV8_SET_CLASS_TEMPL(_exports_raiseImage_clientData.class_templ, _exports_raiseImage_class);
_exports_raiseImage_clientData.dtor = _wrap_delete_raiseImage;
if (SWIGTYPE_p_Magick__raiseImage->clientdata == 0) {
  SWIGTYPE_p_Magick__raiseImage->clientdata = &_exports_raiseImage_clientData;
}
/* Name: _exports_ReadOptions, Type: p_Magick__ReadOptions, Dtor: _wrap_delete_ReadOptions */
SWIGV8_FUNCTION_TEMPLATE _exports_ReadOptions_class = SWIGV8_CreateClassTemplate("_exports_ReadOptions");
SWIGV8_SET_CLASS_TEMPL(_exports_ReadOptions_clientData.class_templ, _exports_ReadOptions_class);
_exports_ReadOptions_clientData.dtor = _wrap_delete_ReadOptions;
if (SWIGTYPE_p_Magick__ReadOptions->clientdata == 0) {
  SWIGTYPE_p_Magick__ReadOptions->clientdata = &_exports_ReadOptions_clientData;
}
/* Name: _exports_reduceNoiseImage, Type: p_Magick__reduceNoiseImage, Dtor: _wrap_delete_reduceNoiseImage */
SWIGV8_FUNCTION_TEMPLATE _exports_reduceNoiseImage_class = SWIGV8_CreateClassTemplate("_exports_reduceNoiseImage");
SWIGV8_SET_CLASS_TEMPL(_exports_reduceNoiseImage_clientData.class_templ, _exports_reduceNoiseImage_class);
_exports_reduceNoiseImage_clientData.dtor = _wrap_delete_reduceNoiseImage;
if (SWIGTYPE_p_Magick__reduceNoiseImage->clientdata == 0) {
  SWIGTYPE_p_Magick__reduceNoiseImage->clientdata = &_exports_reduceNoiseImage_clientData;
}
/* Name: _exports_resizeImage, Type: p_Magick__resizeImage, Dtor: _wrap_delete_resizeImage */
SWIGV8_FUNCTION_TEMPLATE _exports_resizeImage_class = SWIGV8_CreateClassTemplate("_exports_resizeImage");
SWIGV8_SET_CLASS_TEMPL(_exports_resizeImage_clientData.class_templ, _exports_resizeImage_class);
_exports_resizeImage_clientData.dtor = _wrap_delete_resizeImage;
if (SWIGTYPE_p_Magick__resizeImage->clientdata == 0) {
  SWIGTYPE_p_Magick__resizeImage->clientdata = &_exports_resizeImage_clientData;
}
/* Name: _exports_rollImage, Type: p_Magick__rollImage, Dtor: _wrap_delete_rollImage */
SWIGV8_FUNCTION_TEMPLATE _exports_rollImage_class = SWIGV8_CreateClassTemplate("_exports_rollImage");
SWIGV8_SET_CLASS_TEMPL(_exports_rollImage_clientData.class_templ, _exports_rollImage_class);
_exports_rollImage_clientData.dtor = _wrap_delete_rollImage;
if (SWIGTYPE_p_Magick__rollImage->clientdata == 0) {
  SWIGTYPE_p_Magick__rollImage->clientdata = &_exports_rollImage_clientData;
}
/* Name: _exports_rotateImage, Type: p_Magick__rotateImage, Dtor: _wrap_delete_rotateImage */
SWIGV8_FUNCTION_TEMPLATE _exports_rotateImage_class = SWIGV8_CreateClassTemplate("_exports_rotateImage");
SWIGV8_SET_CLASS_TEMPL(_exports_rotateImage_clientData.class_templ, _exports_rotateImage_class);
_exports_rotateImage_clientData.dtor = _wrap_delete_rotateImage;
if (SWIGTYPE_p_Magick__rotateImage->clientdata == 0) {
  SWIGTYPE_p_Magick__rotateImage->clientdata = &_exports_rotateImage_clientData;
}
/* Name: _exports_sampleImage, Type: p_Magick__sampleImage, Dtor: _wrap_delete_sampleImage */
SWIGV8_FUNCTION_TEMPLATE _exports_sampleImage_class = SWIGV8_CreateClassTemplate("_exports_sampleImage");
SWIGV8_SET_CLASS_TEMPL(_exports_sampleImage_clientData.class_templ, _exports_sampleImage_class);
_exports_sampleImage_clientData.dtor = _wrap_delete_sampleImage;
if (SWIGTYPE_p_Magick__sampleImage->clientdata == 0) {
  SWIGTYPE_p_Magick__sampleImage->clientdata = &_exports_sampleImage_clientData;
}
/* Name: _exports_scaleImage, Type: p_Magick__scaleImage, Dtor: _wrap_delete_scaleImage */
SWIGV8_FUNCTION_TEMPLATE _exports_scaleImage_class = SWIGV8_CreateClassTemplate("_exports_scaleImage");
SWIGV8_SET_CLASS_TEMPL(_exports_scaleImage_clientData.class_templ, _exports_scaleImage_class);
_exports_scaleImage_clientData.dtor = _wrap_delete_scaleImage;
if (SWIGTYPE_p_Magick__scaleImage->clientdata == 0) {
  SWIGTYPE_p_Magick__scaleImage->clientdata = &_exports_scaleImage_clientData;
}
/* Name: _exports_segmentImage, Type: p_Magick__segmentImage, Dtor: _wrap_delete_segmentImage */
SWIGV8_FUNCTION_TEMPLATE _exports_segmentImage_class = SWIGV8_CreateClassTemplate("_exports_segmentImage");
SWIGV8_SET_CLASS_TEMPL(_exports_segmentImage_clientData.class_templ, _exports_segmentImage_class);
_exports_segmentImage_clientData.dtor = _wrap_delete_segmentImage;
if (SWIGTYPE_p_Magick__segmentImage->clientdata == 0) {
  SWIGTYPE_p_Magick__segmentImage->clientdata = &_exports_segmentImage_clientData;
}
/* Name: _exports_shadeImage, Type: p_Magick__shadeImage, Dtor: _wrap_delete_shadeImage */
SWIGV8_FUNCTION_TEMPLATE _exports_shadeImage_class = SWIGV8_CreateClassTemplate("_exports_shadeImage");
SWIGV8_SET_CLASS_TEMPL(_exports_shadeImage_clientData.class_templ, _exports_shadeImage_class);
_exports_shadeImage_clientData.dtor = _wrap_delete_shadeImage;
if (SWIGTYPE_p_Magick__shadeImage->clientdata == 0) {
  SWIGTYPE_p_Magick__shadeImage->clientdata = &_exports_shadeImage_clientData;
}
/* Name: _exports_shadowImage, Type: p_Magick__shadowImage, Dtor: _wrap_delete_shadowImage */
SWIGV8_FUNCTION_TEMPLATE _exports_shadowImage_class = SWIGV8_CreateClassTemplate("_exports_shadowImage");
SWIGV8_SET_CLASS_TEMPL(_exports_shadowImage_clientData.class_templ, _exports_shadowImage_class);
_exports_shadowImage_clientData.dtor = _wrap_delete_shadowImage;
if (SWIGTYPE_p_Magick__shadowImage->clientdata == 0) {
  SWIGTYPE_p_Magick__shadowImage->clientdata = &_exports_shadowImage_clientData;
}
/* Name: _exports_sharpenImage, Type: p_Magick__sharpenImage, Dtor: _wrap_delete_sharpenImage */
SWIGV8_FUNCTION_TEMPLATE _exports_sharpenImage_class = SWIGV8_CreateClassTemplate("_exports_sharpenImage");
SWIGV8_SET_CLASS_TEMPL(_exports_sharpenImage_clientData.class_templ, _exports_sharpenImage_class);
_exports_sharpenImage_clientData.dtor = _wrap_delete_sharpenImage;
if (SWIGTYPE_p_Magick__sharpenImage->clientdata == 0) {
  SWIGTYPE_p_Magick__sharpenImage->clientdata = &_exports_sharpenImage_clientData;
}
/* Name: _exports_shaveImage, Type: p_Magick__shaveImage, Dtor: _wrap_delete_shaveImage */
SWIGV8_FUNCTION_TEMPLATE _exports_shaveImage_class = SWIGV8_CreateClassTemplate("_exports_shaveImage");
SWIGV8_SET_CLASS_TEMPL(_exports_shaveImage_clientData.class_templ, _exports_shaveImage_class);
_exports_shaveImage_clientData.dtor = _wrap_delete_shaveImage;
if (SWIGTYPE_p_Magick__shaveImage->clientdata == 0) {
  SWIGTYPE_p_Magick__shaveImage->clientdata = &_exports_shaveImage_clientData;
}
/* Name: _exports_shearImage, Type: p_Magick__shearImage, Dtor: _wrap_delete_shearImage */
SWIGV8_FUNCTION_TEMPLATE _exports_shearImage_class = SWIGV8_CreateClassTemplate("_exports_shearImage");
SWIGV8_SET_CLASS_TEMPL(_exports_shearImage_clientData.class_templ, _exports_shearImage_class);
_exports_shearImage_clientData.dtor = _wrap_delete_shearImage;
if (SWIGTYPE_p_Magick__shearImage->clientdata == 0) {
  SWIGTYPE_p_Magick__shearImage->clientdata = &_exports_shearImage_clientData;
}
/* Name: _exports_solarizeImage, Type: p_Magick__solarizeImage, Dtor: _wrap_delete_solarizeImage */
SWIGV8_FUNCTION_TEMPLATE _exports_solarizeImage_class = SWIGV8_CreateClassTemplate("_exports_solarizeImage");
SWIGV8_SET_CLASS_TEMPL(_exports_solarizeImage_clientData.class_templ, _exports_solarizeImage_class);
_exports_solarizeImage_clientData.dtor = _wrap_delete_solarizeImage;
if (SWIGTYPE_p_Magick__solarizeImage->clientdata == 0) {
  SWIGTYPE_p_Magick__solarizeImage->clientdata = &_exports_solarizeImage_clientData;
}
/* Name: _exports_spliceImage, Type: p_Magick__spliceImage, Dtor: _wrap_delete_spliceImage */
SWIGV8_FUNCTION_TEMPLATE _exports_spliceImage_class = SWIGV8_CreateClassTemplate("_exports_spliceImage");
SWIGV8_SET_CLASS_TEMPL(_exports_spliceImage_clientData.class_templ, _exports_spliceImage_class);
_exports_spliceImage_clientData.dtor = _wrap_delete_spliceImage;
if (SWIGTYPE_p_Magick__spliceImage->clientdata == 0) {
  SWIGTYPE_p_Magick__spliceImage->clientdata = &_exports_spliceImage_clientData;
}
/* Name: _exports_spreadImage, Type: p_Magick__spreadImage, Dtor: _wrap_delete_spreadImage */
SWIGV8_FUNCTION_TEMPLATE _exports_spreadImage_class = SWIGV8_CreateClassTemplate("_exports_spreadImage");
SWIGV8_SET_CLASS_TEMPL(_exports_spreadImage_clientData.class_templ, _exports_spreadImage_class);
_exports_spreadImage_clientData.dtor = _wrap_delete_spreadImage;
if (SWIGTYPE_p_Magick__spreadImage->clientdata == 0) {
  SWIGTYPE_p_Magick__spreadImage->clientdata = &_exports_spreadImage_clientData;
}
/* Name: _exports_steganoImage, Type: p_Magick__steganoImage, Dtor: _wrap_delete_steganoImage */
SWIGV8_FUNCTION_TEMPLATE _exports_steganoImage_class = SWIGV8_CreateClassTemplate("_exports_steganoImage");
SWIGV8_SET_CLASS_TEMPL(_exports_steganoImage_clientData.class_templ, _exports_steganoImage_class);
_exports_steganoImage_clientData.dtor = _wrap_delete_steganoImage;
if (SWIGTYPE_p_Magick__steganoImage->clientdata == 0) {
  SWIGTYPE_p_Magick__steganoImage->clientdata = &_exports_steganoImage_clientData;
}
/* Name: _exports_stereoImage, Type: p_Magick__stereoImage, Dtor: _wrap_delete_stereoImage */
SWIGV8_FUNCTION_TEMPLATE _exports_stereoImage_class = SWIGV8_CreateClassTemplate("_exports_stereoImage");
SWIGV8_SET_CLASS_TEMPL(_exports_stereoImage_clientData.class_templ, _exports_stereoImage_class);
_exports_stereoImage_clientData.dtor = _wrap_delete_stereoImage;
if (SWIGTYPE_p_Magick__stereoImage->clientdata == 0) {
  SWIGTYPE_p_Magick__stereoImage->clientdata = &_exports_stereoImage_clientData;
}
/* Name: _exports_strokeColorImage, Type: p_Magick__strokeColorImage, Dtor: _wrap_delete_strokeColorImage */
SWIGV8_FUNCTION_TEMPLATE _exports_strokeColorImage_class = SWIGV8_CreateClassTemplate("_exports_strokeColorImage");
SWIGV8_SET_CLASS_TEMPL(_exports_strokeColorImage_clientData.class_templ, _exports_strokeColorImage_class);
_exports_strokeColorImage_clientData.dtor = _wrap_delete_strokeColorImage;
if (SWIGTYPE_p_Magick__strokeColorImage->clientdata == 0) {
  SWIGTYPE_p_Magick__strokeColorImage->clientdata = &_exports_strokeColorImage_clientData;
}
/* Name: _exports_swirlImage, Type: p_Magick__swirlImage, Dtor: _wrap_delete_swirlImage */
SWIGV8_FUNCTION_TEMPLATE _exports_swirlImage_class = SWIGV8_CreateClassTemplate("_exports_swirlImage");
SWIGV8_SET_CLASS_TEMPL(_exports_swirlImage_clientData.class_templ, _exports_swirlImage_class);
_exports_swirlImage_clientData.dtor = _wrap_delete_swirlImage;
if (SWIGTYPE_p_Magick__swirlImage->clientdata == 0) {
  SWIGTYPE_p_Magick__swirlImage->clientdata = &_exports_swirlImage_clientData;
}
/* Name: _exports_textureImage, Type: p_Magick__textureImage, Dtor: _wrap_delete_textureImage */
SWIGV8_FUNCTION_TEMPLATE _exports_textureImage_class = SWIGV8_CreateClassTemplate("_exports_textureImage");
SWIGV8_SET_CLASS_TEMPL(_exports_textureImage_clientData.class_templ, _exports_textureImage_class);
_exports_textureImage_clientData.dtor = _wrap_delete_textureImage;
if (SWIGTYPE_p_Magick__textureImage->clientdata == 0) {
  SWIGTYPE_p_Magick__textureImage->clientdata = &_exports_textureImage_clientData;
}
/* Name: _exports_thresholdImage, Type: p_Magick__thresholdImage, Dtor: _wrap_delete_thresholdImage */
SWIGV8_FUNCTION_TEMPLATE _exports_thresholdImage_class = SWIGV8_CreateClassTemplate("_exports_thresholdImage");
SWIGV8_SET_CLASS_TEMPL(_exports_thresholdImage_clientData.class_templ, _exports_thresholdImage_class);
_exports_thresholdImage_clientData.dtor = _wrap_delete_thresholdImage;
if (SWIGTYPE_p_Magick__thresholdImage->clientdata == 0) {
  SWIGTYPE_p_Magick__thresholdImage->clientdata = &_exports_thresholdImage_clientData;
}
/* Name: _exports_transformImage, Type: p_Magick__transformImage, Dtor: _wrap_delete_transformImage */
SWIGV8_FUNCTION_TEMPLATE _exports_transformImage_class = SWIGV8_CreateClassTemplate("_exports_transformImage");
SWIGV8_SET_CLASS_TEMPL(_exports_transformImage_clientData.class_templ, _exports_transformImage_class);
_exports_transformImage_clientData.dtor = _wrap_delete_transformImage;
if (SWIGTYPE_p_Magick__transformImage->clientdata == 0) {
  SWIGTYPE_p_Magick__transformImage->clientdata = &_exports_transformImage_clientData;
}
/* Name: _exports_transparentImage, Type: p_Magick__transparentImage, Dtor: _wrap_delete_transparentImage */
SWIGV8_FUNCTION_TEMPLATE _exports_transparentImage_class = SWIGV8_CreateClassTemplate("_exports_transparentImage");
SWIGV8_SET_CLASS_TEMPL(_exports_transparentImage_clientData.class_templ, _exports_transparentImage_class);
_exports_transparentImage_clientData.dtor = _wrap_delete_transparentImage;
if (SWIGTYPE_p_Magick__transparentImage->clientdata == 0) {
  SWIGTYPE_p_Magick__transparentImage->clientdata = &_exports_transparentImage_clientData;
}
/* Name: _exports_trimImage, Type: p_Magick__trimImage, Dtor: _wrap_delete_trimImage */
SWIGV8_FUNCTION_TEMPLATE _exports_trimImage_class = SWIGV8_CreateClassTemplate("_exports_trimImage");
SWIGV8_SET_CLASS_TEMPL(_exports_trimImage_clientData.class_templ, _exports_trimImage_class);
_exports_trimImage_clientData.dtor = _wrap_delete_trimImage;
if (SWIGTYPE_p_Magick__trimImage->clientdata == 0) {
  SWIGTYPE_p_Magick__trimImage->clientdata = &_exports_trimImage_clientData;
}
/* Name: _exports_waveImage, Type: p_Magick__waveImage, Dtor: _wrap_delete_waveImage */
SWIGV8_FUNCTION_TEMPLATE _exports_waveImage_class = SWIGV8_CreateClassTemplate("_exports_waveImage");
SWIGV8_SET_CLASS_TEMPL(_exports_waveImage_clientData.class_templ, _exports_waveImage_class);
_exports_waveImage_clientData.dtor = _wrap_delete_waveImage;
if (SWIGTYPE_p_Magick__waveImage->clientdata == 0) {
  SWIGTYPE_p_Magick__waveImage->clientdata = &_exports_waveImage_clientData;
}
/* Name: _exports_zoomImage, Type: p_Magick__zoomImage, Dtor: _wrap_delete_zoomImage */
SWIGV8_FUNCTION_TEMPLATE _exports_zoomImage_class = SWIGV8_CreateClassTemplate("_exports_zoomImage");
SWIGV8_SET_CLASS_TEMPL(_exports_zoomImage_clientData.class_templ, _exports_zoomImage_class);
_exports_zoomImage_clientData.dtor = _wrap_delete_zoomImage;
if (SWIGTYPE_p_Magick__zoomImage->clientdata == 0) {
  SWIGTYPE_p_Magick__zoomImage->clientdata = &_exports_zoomImage_clientData;
}
/* Name: _exports_antiAliasImage, Type: p_Magick__antiAliasImage, Dtor: _wrap_delete_antiAliasImage */
SWIGV8_FUNCTION_TEMPLATE _exports_antiAliasImage_class = SWIGV8_CreateClassTemplate("_exports_antiAliasImage");
SWIGV8_SET_CLASS_TEMPL(_exports_antiAliasImage_clientData.class_templ, _exports_antiAliasImage_class);
_exports_antiAliasImage_clientData.dtor = _wrap_delete_antiAliasImage;
if (SWIGTYPE_p_Magick__antiAliasImage->clientdata == 0) {
  SWIGTYPE_p_Magick__antiAliasImage->clientdata = &_exports_antiAliasImage_clientData;
}
/* Name: _exports_adjoinImage, Type: p_Magick__adjoinImage, Dtor: _wrap_delete_adjoinImage */
SWIGV8_FUNCTION_TEMPLATE _exports_adjoinImage_class = SWIGV8_CreateClassTemplate("_exports_adjoinImage");
SWIGV8_SET_CLASS_TEMPL(_exports_adjoinImage_clientData.class_templ, _exports_adjoinImage_class);
_exports_adjoinImage_clientData.dtor = _wrap_delete_adjoinImage;
if (SWIGTYPE_p_Magick__adjoinImage->clientdata == 0) {
  SWIGTYPE_p_Magick__adjoinImage->clientdata = &_exports_adjoinImage_clientData;
}
/* Name: _exports_animationDelayImage, Type: p_Magick__animationDelayImage, Dtor: _wrap_delete_animationDelayImage */
SWIGV8_FUNCTION_TEMPLATE _exports_animationDelayImage_class = SWIGV8_CreateClassTemplate("_exports_animationDelayImage");
SWIGV8_SET_CLASS_TEMPL(_exports_animationDelayImage_clientData.class_templ, _exports_animationDelayImage_class);
_exports_animationDelayImage_clientData.dtor = _wrap_delete_animationDelayImage;
if (SWIGTYPE_p_Magick__animationDelayImage->clientdata == 0) {
  SWIGTYPE_p_Magick__animationDelayImage->clientdata = &_exports_animationDelayImage_clientData;
}
/* Name: _exports_animationIterationsImage, Type: p_Magick__animationIterationsImage, Dtor: _wrap_delete_animationIterationsImage */
SWIGV8_FUNCTION_TEMPLATE _exports_animationIterationsImage_class = SWIGV8_CreateClassTemplate("_exports_animationIterationsImage");
SWIGV8_SET_CLASS_TEMPL(_exports_animationIterationsImage_clientData.class_templ, _exports_animationIterationsImage_class);
_exports_animationIterationsImage_clientData.dtor = _wrap_delete_animationIterationsImage;
if (SWIGTYPE_p_Magick__animationIterationsImage->clientdata == 0) {
  SWIGTYPE_p_Magick__animationIterationsImage->clientdata = &_exports_animationIterationsImage_clientData;
}
/* Name: _exports_backgroundColorImage, Type: p_Magick__backgroundColorImage, Dtor: _wrap_delete_backgroundColorImage */
SWIGV8_FUNCTION_TEMPLATE _exports_backgroundColorImage_class = SWIGV8_CreateClassTemplate("_exports_backgroundColorImage");
SWIGV8_SET_CLASS_TEMPL(_exports_backgroundColorImage_clientData.class_templ, _exports_backgroundColorImage_class);
_exports_backgroundColorImage_clientData.dtor = _wrap_delete_backgroundColorImage;
if (SWIGTYPE_p_Magick__backgroundColorImage->clientdata == 0) {
  SWIGTYPE_p_Magick__backgroundColorImage->clientdata = &_exports_backgroundColorImage_clientData;
}
/* Name: _exports_backgroundTextureImage, Type: p_Magick__backgroundTextureImage, Dtor: _wrap_delete_backgroundTextureImage */
SWIGV8_FUNCTION_TEMPLATE _exports_backgroundTextureImage_class = SWIGV8_CreateClassTemplate("_exports_backgroundTextureImage");
SWIGV8_SET_CLASS_TEMPL(_exports_backgroundTextureImage_clientData.class_templ, _exports_backgroundTextureImage_class);
_exports_backgroundTextureImage_clientData.dtor = _wrap_delete_backgroundTextureImage;
if (SWIGTYPE_p_Magick__backgroundTextureImage->clientdata == 0) {
  SWIGTYPE_p_Magick__backgroundTextureImage->clientdata = &_exports_backgroundTextureImage_clientData;
}
/* Name: _exports_borderColorImage, Type: p_Magick__borderColorImage, Dtor: _wrap_delete_borderColorImage */
SWIGV8_FUNCTION_TEMPLATE _exports_borderColorImage_class = SWIGV8_CreateClassTemplate("_exports_borderColorImage");
SWIGV8_SET_CLASS_TEMPL(_exports_borderColorImage_clientData.class_templ, _exports_borderColorImage_class);
_exports_borderColorImage_clientData.dtor = _wrap_delete_borderColorImage;
if (SWIGTYPE_p_Magick__borderColorImage->clientdata == 0) {
  SWIGTYPE_p_Magick__borderColorImage->clientdata = &_exports_borderColorImage_clientData;
}
/* Name: _exports_boxColorImage, Type: p_Magick__boxColorImage, Dtor: _wrap_delete_boxColorImage */
SWIGV8_FUNCTION_TEMPLATE _exports_boxColorImage_class = SWIGV8_CreateClassTemplate("_exports_boxColorImage");
SWIGV8_SET_CLASS_TEMPL(_exports_boxColorImage_clientData.class_templ, _exports_boxColorImage_class);
_exports_boxColorImage_clientData.dtor = _wrap_delete_boxColorImage;
if (SWIGTYPE_p_Magick__boxColorImage->clientdata == 0) {
  SWIGTYPE_p_Magick__boxColorImage->clientdata = &_exports_boxColorImage_clientData;
}
/* Name: _exports_chromaBluePrimaryImage, Type: p_Magick__chromaBluePrimaryImage, Dtor: _wrap_delete_chromaBluePrimaryImage */
SWIGV8_FUNCTION_TEMPLATE _exports_chromaBluePrimaryImage_class = SWIGV8_CreateClassTemplate("_exports_chromaBluePrimaryImage");
SWIGV8_SET_CLASS_TEMPL(_exports_chromaBluePrimaryImage_clientData.class_templ, _exports_chromaBluePrimaryImage_class);
_exports_chromaBluePrimaryImage_clientData.dtor = _wrap_delete_chromaBluePrimaryImage;
if (SWIGTYPE_p_Magick__chromaBluePrimaryImage->clientdata == 0) {
  SWIGTYPE_p_Magick__chromaBluePrimaryImage->clientdata = &_exports_chromaBluePrimaryImage_clientData;
}
/* Name: _exports_chromaGreenPrimaryImage, Type: p_Magick__chromaGreenPrimaryImage, Dtor: _wrap_delete_chromaGreenPrimaryImage */
SWIGV8_FUNCTION_TEMPLATE _exports_chromaGreenPrimaryImage_class = SWIGV8_CreateClassTemplate("_exports_chromaGreenPrimaryImage");
SWIGV8_SET_CLASS_TEMPL(_exports_chromaGreenPrimaryImage_clientData.class_templ, _exports_chromaGreenPrimaryImage_class);
_exports_chromaGreenPrimaryImage_clientData.dtor = _wrap_delete_chromaGreenPrimaryImage;
if (SWIGTYPE_p_Magick__chromaGreenPrimaryImage->clientdata == 0) {
  SWIGTYPE_p_Magick__chromaGreenPrimaryImage->clientdata = &_exports_chromaGreenPrimaryImage_clientData;
}
/* Name: _exports_chromaRedPrimaryImage, Type: p_Magick__chromaRedPrimaryImage, Dtor: _wrap_delete_chromaRedPrimaryImage */
SWIGV8_FUNCTION_TEMPLATE _exports_chromaRedPrimaryImage_class = SWIGV8_CreateClassTemplate("_exports_chromaRedPrimaryImage");
SWIGV8_SET_CLASS_TEMPL(_exports_chromaRedPrimaryImage_clientData.class_templ, _exports_chromaRedPrimaryImage_class);
_exports_chromaRedPrimaryImage_clientData.dtor = _wrap_delete_chromaRedPrimaryImage;
if (SWIGTYPE_p_Magick__chromaRedPrimaryImage->clientdata == 0) {
  SWIGTYPE_p_Magick__chromaRedPrimaryImage->clientdata = &_exports_chromaRedPrimaryImage_clientData;
}
/* Name: _exports_chromaWhitePointImage, Type: p_Magick__chromaWhitePointImage, Dtor: _wrap_delete_chromaWhitePointImage */
SWIGV8_FUNCTION_TEMPLATE _exports_chromaWhitePointImage_class = SWIGV8_CreateClassTemplate("_exports_chromaWhitePointImage");
SWIGV8_SET_CLASS_TEMPL(_exports_chromaWhitePointImage_clientData.class_templ, _exports_chromaWhitePointImage_class);
_exports_chromaWhitePointImage_clientData.dtor = _wrap_delete_chromaWhitePointImage;
if (SWIGTYPE_p_Magick__chromaWhitePointImage->clientdata == 0) {
  SWIGTYPE_p_Magick__chromaWhitePointImage->clientdata = &_exports_chromaWhitePointImage_clientData;
}
/* Name: _exports_colorFuzzImage, Type: p_Magick__colorFuzzImage, Dtor: _wrap_delete_colorFuzzImage */
SWIGV8_FUNCTION_TEMPLATE _exports_colorFuzzImage_class = SWIGV8_CreateClassTemplate("_exports_colorFuzzImage");
SWIGV8_SET_CLASS_TEMPL(_exports_colorFuzzImage_clientData.class_templ, _exports_colorFuzzImage_class);
_exports_colorFuzzImage_clientData.dtor = _wrap_delete_colorFuzzImage;
if (SWIGTYPE_p_Magick__colorFuzzImage->clientdata == 0) {
  SWIGTYPE_p_Magick__colorFuzzImage->clientdata = &_exports_colorFuzzImage_clientData;
}
/* Name: _exports_colorMapImage, Type: p_Magick__colorMapImage, Dtor: _wrap_delete_colorMapImage */
SWIGV8_FUNCTION_TEMPLATE _exports_colorMapImage_class = SWIGV8_CreateClassTemplate("_exports_colorMapImage");
SWIGV8_SET_CLASS_TEMPL(_exports_colorMapImage_clientData.class_templ, _exports_colorMapImage_class);
_exports_colorMapImage_clientData.dtor = _wrap_delete_colorMapImage;
if (SWIGTYPE_p_Magick__colorMapImage->clientdata == 0) {
  SWIGTYPE_p_Magick__colorMapImage->clientdata = &_exports_colorMapImage_clientData;
}
/* Name: _exports_composeImage, Type: p_Magick__composeImage, Dtor: _wrap_delete_composeImage */
SWIGV8_FUNCTION_TEMPLATE _exports_composeImage_class = SWIGV8_CreateClassTemplate("_exports_composeImage");
SWIGV8_SET_CLASS_TEMPL(_exports_composeImage_clientData.class_templ, _exports_composeImage_class);
_exports_composeImage_clientData.dtor = _wrap_delete_composeImage;
if (SWIGTYPE_p_Magick__composeImage->clientdata == 0) {
  SWIGTYPE_p_Magick__composeImage->clientdata = &_exports_composeImage_clientData;
}
/* Name: _exports_compressTypeImage, Type: p_Magick__compressTypeImage, Dtor: _wrap_delete_compressTypeImage */
SWIGV8_FUNCTION_TEMPLATE _exports_compressTypeImage_class = SWIGV8_CreateClassTemplate("_exports_compressTypeImage");
SWIGV8_SET_CLASS_TEMPL(_exports_compressTypeImage_clientData.class_templ, _exports_compressTypeImage_class);
_exports_compressTypeImage_clientData.dtor = _wrap_delete_compressTypeImage;
if (SWIGTYPE_p_Magick__compressTypeImage->clientdata == 0) {
  SWIGTYPE_p_Magick__compressTypeImage->clientdata = &_exports_compressTypeImage_clientData;
}
/* Name: _exports_densityImage, Type: p_Magick__densityImage, Dtor: _wrap_delete_densityImage */
SWIGV8_FUNCTION_TEMPLATE _exports_densityImage_class = SWIGV8_CreateClassTemplate("_exports_densityImage");
SWIGV8_SET_CLASS_TEMPL(_exports_densityImage_clientData.class_templ, _exports_densityImage_class);
_exports_densityImage_clientData.dtor = _wrap_delete_densityImage;
if (SWIGTYPE_p_Magick__densityImage->clientdata == 0) {
  SWIGTYPE_p_Magick__densityImage->clientdata = &_exports_densityImage_clientData;
}
/* Name: _exports_depthImage, Type: p_Magick__depthImage, Dtor: _wrap_delete_depthImage */
SWIGV8_FUNCTION_TEMPLATE _exports_depthImage_class = SWIGV8_CreateClassTemplate("_exports_depthImage");
SWIGV8_SET_CLASS_TEMPL(_exports_depthImage_clientData.class_templ, _exports_depthImage_class);
_exports_depthImage_clientData.dtor = _wrap_delete_depthImage;
if (SWIGTYPE_p_Magick__depthImage->clientdata == 0) {
  SWIGTYPE_p_Magick__depthImage->clientdata = &_exports_depthImage_clientData;
}
/* Name: _exports_endianImage, Type: p_Magick__endianImage, Dtor: _wrap_delete_endianImage */
SWIGV8_FUNCTION_TEMPLATE _exports_endianImage_class = SWIGV8_CreateClassTemplate("_exports_endianImage");
SWIGV8_SET_CLASS_TEMPL(_exports_endianImage_clientData.class_templ, _exports_endianImage_class);
_exports_endianImage_clientData.dtor = _wrap_delete_endianImage;
if (SWIGTYPE_p_Magick__endianImage->clientdata == 0) {
  SWIGTYPE_p_Magick__endianImage->clientdata = &_exports_endianImage_clientData;
}
/* Name: _exports_fileNameImage, Type: p_Magick__fileNameImage, Dtor: _wrap_delete_fileNameImage */
SWIGV8_FUNCTION_TEMPLATE _exports_fileNameImage_class = SWIGV8_CreateClassTemplate("_exports_fileNameImage");
SWIGV8_SET_CLASS_TEMPL(_exports_fileNameImage_clientData.class_templ, _exports_fileNameImage_class);
_exports_fileNameImage_clientData.dtor = _wrap_delete_fileNameImage;
if (SWIGTYPE_p_Magick__fileNameImage->clientdata == 0) {
  SWIGTYPE_p_Magick__fileNameImage->clientdata = &_exports_fileNameImage_clientData;
}
/* Name: _exports_filterTypeImage, Type: p_Magick__filterTypeImage, Dtor: _wrap_delete_filterTypeImage */
SWIGV8_FUNCTION_TEMPLATE _exports_filterTypeImage_class = SWIGV8_CreateClassTemplate("_exports_filterTypeImage");
SWIGV8_SET_CLASS_TEMPL(_exports_filterTypeImage_clientData.class_templ, _exports_filterTypeImage_class);
_exports_filterTypeImage_clientData.dtor = _wrap_delete_filterTypeImage;
if (SWIGTYPE_p_Magick__filterTypeImage->clientdata == 0) {
  SWIGTYPE_p_Magick__filterTypeImage->clientdata = &_exports_filterTypeImage_clientData;
}
/* Name: _exports_fontImage, Type: p_Magick__fontImage, Dtor: _wrap_delete_fontImage */
SWIGV8_FUNCTION_TEMPLATE _exports_fontImage_class = SWIGV8_CreateClassTemplate("_exports_fontImage");
SWIGV8_SET_CLASS_TEMPL(_exports_fontImage_clientData.class_templ, _exports_fontImage_class);
_exports_fontImage_clientData.dtor = _wrap_delete_fontImage;
if (SWIGTYPE_p_Magick__fontImage->clientdata == 0) {
  SWIGTYPE_p_Magick__fontImage->clientdata = &_exports_fontImage_clientData;
}
/* Name: _exports_fontPointsizeImage, Type: p_Magick__fontPointsizeImage, Dtor: _wrap_delete_fontPointsizeImage */
SWIGV8_FUNCTION_TEMPLATE _exports_fontPointsizeImage_class = SWIGV8_CreateClassTemplate("_exports_fontPointsizeImage");
SWIGV8_SET_CLASS_TEMPL(_exports_fontPointsizeImage_clientData.class_templ, _exports_fontPointsizeImage_class);
_exports_fontPointsizeImage_clientData.dtor = _wrap_delete_fontPointsizeImage;
if (SWIGTYPE_p_Magick__fontPointsizeImage->clientdata == 0) {
  SWIGTYPE_p_Magick__fontPointsizeImage->clientdata = &_exports_fontPointsizeImage_clientData;
}
/* Name: _exports_gifDisposeMethodImage, Type: p_Magick__gifDisposeMethodImage, Dtor: _wrap_delete_gifDisposeMethodImage */
SWIGV8_FUNCTION_TEMPLATE _exports_gifDisposeMethodImage_class = SWIGV8_CreateClassTemplate("_exports_gifDisposeMethodImage");
SWIGV8_SET_CLASS_TEMPL(_exports_gifDisposeMethodImage_clientData.class_templ, _exports_gifDisposeMethodImage_class);
_exports_gifDisposeMethodImage_clientData.dtor = _wrap_delete_gifDisposeMethodImage;
if (SWIGTYPE_p_Magick__gifDisposeMethodImage->clientdata == 0) {
  SWIGTYPE_p_Magick__gifDisposeMethodImage->clientdata = &_exports_gifDisposeMethodImage_clientData;
}
/* Name: _exports_interlaceTypeImage, Type: p_Magick__interlaceTypeImage, Dtor: _wrap_delete_interlaceTypeImage */
SWIGV8_FUNCTION_TEMPLATE _exports_interlaceTypeImage_class = SWIGV8_CreateClassTemplate("_exports_interlaceTypeImage");
SWIGV8_SET_CLASS_TEMPL(_exports_interlaceTypeImage_clientData.class_templ, _exports_interlaceTypeImage_class);
_exports_interlaceTypeImage_clientData.dtor = _wrap_delete_interlaceTypeImage;
if (SWIGTYPE_p_Magick__interlaceTypeImage->clientdata == 0) {
  SWIGTYPE_p_Magick__interlaceTypeImage->clientdata = &_exports_interlaceTypeImage_clientData;
}
/* Name: _exports_lineWidthImage, Type: p_Magick__lineWidthImage, Dtor: _wrap_delete_lineWidthImage */
SWIGV8_FUNCTION_TEMPLATE _exports_lineWidthImage_class = SWIGV8_CreateClassTemplate("_exports_lineWidthImage");
SWIGV8_SET_CLASS_TEMPL(_exports_lineWidthImage_clientData.class_templ, _exports_lineWidthImage_class);
_exports_lineWidthImage_clientData.dtor = _wrap_delete_lineWidthImage;
if (SWIGTYPE_p_Magick__lineWidthImage->clientdata == 0) {
  SWIGTYPE_p_Magick__lineWidthImage->clientdata = &_exports_lineWidthImage_clientData;
}
/* Name: _exports_magickImage, Type: p_Magick__magickImage, Dtor: _wrap_delete_magickImage */
SWIGV8_FUNCTION_TEMPLATE _exports_magickImage_class = SWIGV8_CreateClassTemplate("_exports_magickImage");
SWIGV8_SET_CLASS_TEMPL(_exports_magickImage_clientData.class_templ, _exports_magickImage_class);
_exports_magickImage_clientData.dtor = _wrap_delete_magickImage;
if (SWIGTYPE_p_Magick__magickImage->clientdata == 0) {
  SWIGTYPE_p_Magick__magickImage->clientdata = &_exports_magickImage_clientData;
}
/* Name: _exports_matteImage, Type: p_Magick__matteImage, Dtor: _wrap_delete_matteImage */
SWIGV8_FUNCTION_TEMPLATE _exports_matteImage_class = SWIGV8_CreateClassTemplate("_exports_matteImage");
SWIGV8_SET_CLASS_TEMPL(_exports_matteImage_clientData.class_templ, _exports_matteImage_class);
_exports_matteImage_clientData.dtor = _wrap_delete_matteImage;
if (SWIGTYPE_p_Magick__matteImage->clientdata == 0) {
  SWIGTYPE_p_Magick__matteImage->clientdata = &_exports_matteImage_clientData;
}
/* Name: _exports_matteColorImage, Type: p_Magick__matteColorImage, Dtor: _wrap_delete_matteColorImage */
SWIGV8_FUNCTION_TEMPLATE _exports_matteColorImage_class = SWIGV8_CreateClassTemplate("_exports_matteColorImage");
SWIGV8_SET_CLASS_TEMPL(_exports_matteColorImage_clientData.class_templ, _exports_matteColorImage_class);
_exports_matteColorImage_clientData.dtor = _wrap_delete_matteColorImage;
if (SWIGTYPE_p_Magick__matteColorImage->clientdata == 0) {
  SWIGTYPE_p_Magick__matteColorImage->clientdata = &_exports_matteColorImage_clientData;
}
/* Name: _exports_monochromeImage, Type: p_Magick__monochromeImage, Dtor: _wrap_delete_monochromeImage */
SWIGV8_FUNCTION_TEMPLATE _exports_monochromeImage_class = SWIGV8_CreateClassTemplate("_exports_monochromeImage");
SWIGV8_SET_CLASS_TEMPL(_exports_monochromeImage_clientData.class_templ, _exports_monochromeImage_class);
_exports_monochromeImage_clientData.dtor = _wrap_delete_monochromeImage;
if (SWIGTYPE_p_Magick__monochromeImage->clientdata == 0) {
  SWIGTYPE_p_Magick__monochromeImage->clientdata = &_exports_monochromeImage_clientData;
}
/* Name: _exports_penColorImage, Type: p_Magick__penColorImage, Dtor: _wrap_delete_penColorImage */
SWIGV8_FUNCTION_TEMPLATE _exports_penColorImage_class = SWIGV8_CreateClassTemplate("_exports_penColorImage");
SWIGV8_SET_CLASS_TEMPL(_exports_penColorImage_clientData.class_templ, _exports_penColorImage_class);
_exports_penColorImage_clientData.dtor = _wrap_delete_penColorImage;
if (SWIGTYPE_p_Magick__penColorImage->clientdata == 0) {
  SWIGTYPE_p_Magick__penColorImage->clientdata = &_exports_penColorImage_clientData;
}
/* Name: _exports_penTextureImage, Type: p_Magick__penTextureImage, Dtor: _wrap_delete_penTextureImage */
SWIGV8_FUNCTION_TEMPLATE _exports_penTextureImage_class = SWIGV8_CreateClassTemplate("_exports_penTextureImage");
SWIGV8_SET_CLASS_TEMPL(_exports_penTextureImage_clientData.class_templ, _exports_penTextureImage_class);
_exports_penTextureImage_clientData.dtor = _wrap_delete_penTextureImage;
if (SWIGTYPE_p_Magick__penTextureImage->clientdata == 0) {
  SWIGTYPE_p_Magick__penTextureImage->clientdata = &_exports_penTextureImage_clientData;
}
/* Name: _exports_pixelColorImage, Type: p_Magick__pixelColorImage, Dtor: _wrap_delete_pixelColorImage */
SWIGV8_FUNCTION_TEMPLATE _exports_pixelColorImage_class = SWIGV8_CreateClassTemplate("_exports_pixelColorImage");
SWIGV8_SET_CLASS_TEMPL(_exports_pixelColorImage_clientData.class_templ, _exports_pixelColorImage_class);
_exports_pixelColorImage_clientData.dtor = _wrap_delete_pixelColorImage;
if (SWIGTYPE_p_Magick__pixelColorImage->clientdata == 0) {
  SWIGTYPE_p_Magick__pixelColorImage->clientdata = &_exports_pixelColorImage_clientData;
}
/* Name: _exports_pageImage, Type: p_Magick__pageImage, Dtor: _wrap_delete_pageImage */
SWIGV8_FUNCTION_TEMPLATE _exports_pageImage_class = SWIGV8_CreateClassTemplate("_exports_pageImage");
SWIGV8_SET_CLASS_TEMPL(_exports_pageImage_clientData.class_templ, _exports_pageImage_class);
_exports_pageImage_clientData.dtor = _wrap_delete_pageImage;
if (SWIGTYPE_p_Magick__pageImage->clientdata == 0) {
  SWIGTYPE_p_Magick__pageImage->clientdata = &_exports_pageImage_clientData;
}
/* Name: _exports_qualityImage, Type: p_Magick__qualityImage, Dtor: _wrap_delete_qualityImage */
SWIGV8_FUNCTION_TEMPLATE _exports_qualityImage_class = SWIGV8_CreateClassTemplate("_exports_qualityImage");
SWIGV8_SET_CLASS_TEMPL(_exports_qualityImage_clientData.class_templ, _exports_qualityImage_class);
_exports_qualityImage_clientData.dtor = _wrap_delete_qualityImage;
if (SWIGTYPE_p_Magick__qualityImage->clientdata == 0) {
  SWIGTYPE_p_Magick__qualityImage->clientdata = &_exports_qualityImage_clientData;
}
/* Name: _exports_quantizeColorsImage, Type: p_Magick__quantizeColorsImage, Dtor: _wrap_delete_quantizeColorsImage */
SWIGV8_FUNCTION_TEMPLATE _exports_quantizeColorsImage_class = SWIGV8_CreateClassTemplate("_exports_quantizeColorsImage");
SWIGV8_SET_CLASS_TEMPL(_exports_quantizeColorsImage_clientData.class_templ, _exports_quantizeColorsImage_class);
_exports_quantizeColorsImage_clientData.dtor = _wrap_delete_quantizeColorsImage;
if (SWIGTYPE_p_Magick__quantizeColorsImage->clientdata == 0) {
  SWIGTYPE_p_Magick__quantizeColorsImage->clientdata = &_exports_quantizeColorsImage_clientData;
}
/* Name: _exports_quantizeColorSpaceImage, Type: p_Magick__quantizeColorSpaceImage, Dtor: _wrap_delete_quantizeColorSpaceImage */
SWIGV8_FUNCTION_TEMPLATE _exports_quantizeColorSpaceImage_class = SWIGV8_CreateClassTemplate("_exports_quantizeColorSpaceImage");
SWIGV8_SET_CLASS_TEMPL(_exports_quantizeColorSpaceImage_clientData.class_templ, _exports_quantizeColorSpaceImage_class);
_exports_quantizeColorSpaceImage_clientData.dtor = _wrap_delete_quantizeColorSpaceImage;
if (SWIGTYPE_p_Magick__quantizeColorSpaceImage->clientdata == 0) {
  SWIGTYPE_p_Magick__quantizeColorSpaceImage->clientdata = &_exports_quantizeColorSpaceImage_clientData;
}
/* Name: _exports_quantizeDitherImage, Type: p_Magick__quantizeDitherImage, Dtor: _wrap_delete_quantizeDitherImage */
SWIGV8_FUNCTION_TEMPLATE _exports_quantizeDitherImage_class = SWIGV8_CreateClassTemplate("_exports_quantizeDitherImage");
SWIGV8_SET_CLASS_TEMPL(_exports_quantizeDitherImage_clientData.class_templ, _exports_quantizeDitherImage_class);
_exports_quantizeDitherImage_clientData.dtor = _wrap_delete_quantizeDitherImage;
if (SWIGTYPE_p_Magick__quantizeDitherImage->clientdata == 0) {
  SWIGTYPE_p_Magick__quantizeDitherImage->clientdata = &_exports_quantizeDitherImage_clientData;
}
/* Name: _exports_quantizeTreeDepthImage, Type: p_Magick__quantizeTreeDepthImage, Dtor: _wrap_delete_quantizeTreeDepthImage */
SWIGV8_FUNCTION_TEMPLATE _exports_quantizeTreeDepthImage_class = SWIGV8_CreateClassTemplate("_exports_quantizeTreeDepthImage");
SWIGV8_SET_CLASS_TEMPL(_exports_quantizeTreeDepthImage_clientData.class_templ, _exports_quantizeTreeDepthImage_class);
_exports_quantizeTreeDepthImage_clientData.dtor = _wrap_delete_quantizeTreeDepthImage;
if (SWIGTYPE_p_Magick__quantizeTreeDepthImage->clientdata == 0) {
  SWIGTYPE_p_Magick__quantizeTreeDepthImage->clientdata = &_exports_quantizeTreeDepthImage_clientData;
}
/* Name: _exports_renderingIntentImage, Type: p_Magick__renderingIntentImage, Dtor: _wrap_delete_renderingIntentImage */
SWIGV8_FUNCTION_TEMPLATE _exports_renderingIntentImage_class = SWIGV8_CreateClassTemplate("_exports_renderingIntentImage");
SWIGV8_SET_CLASS_TEMPL(_exports_renderingIntentImage_clientData.class_templ, _exports_renderingIntentImage_class);
_exports_renderingIntentImage_clientData.dtor = _wrap_delete_renderingIntentImage;
if (SWIGTYPE_p_Magick__renderingIntentImage->clientdata == 0) {
  SWIGTYPE_p_Magick__renderingIntentImage->clientdata = &_exports_renderingIntentImage_clientData;
}
/* Name: _exports_resolutionUnitsImage, Type: p_Magick__resolutionUnitsImage, Dtor: _wrap_delete_resolutionUnitsImage */
SWIGV8_FUNCTION_TEMPLATE _exports_resolutionUnitsImage_class = SWIGV8_CreateClassTemplate("_exports_resolutionUnitsImage");
SWIGV8_SET_CLASS_TEMPL(_exports_resolutionUnitsImage_clientData.class_templ, _exports_resolutionUnitsImage_class);
_exports_resolutionUnitsImage_clientData.dtor = _wrap_delete_resolutionUnitsImage;
if (SWIGTYPE_p_Magick__resolutionUnitsImage->clientdata == 0) {
  SWIGTYPE_p_Magick__resolutionUnitsImage->clientdata = &_exports_resolutionUnitsImage_clientData;
}
/* Name: _exports_sceneImage, Type: p_Magick__sceneImage, Dtor: _wrap_delete_sceneImage */
SWIGV8_FUNCTION_TEMPLATE _exports_sceneImage_class = SWIGV8_CreateClassTemplate("_exports_sceneImage");
SWIGV8_SET_CLASS_TEMPL(_exports_sceneImage_clientData.class_templ, _exports_sceneImage_class);
_exports_sceneImage_clientData.dtor = _wrap_delete_sceneImage;
if (SWIGTYPE_p_Magick__sceneImage->clientdata == 0) {
  SWIGTYPE_p_Magick__sceneImage->clientdata = &_exports_sceneImage_clientData;
}
/* Name: _exports_sigmoidalContrastImage, Type: p_Magick__sigmoidalContrastImage, Dtor: _wrap_delete_sigmoidalContrastImage */
SWIGV8_FUNCTION_TEMPLATE _exports_sigmoidalContrastImage_class = SWIGV8_CreateClassTemplate("_exports_sigmoidalContrastImage");
SWIGV8_SET_CLASS_TEMPL(_exports_sigmoidalContrastImage_clientData.class_templ, _exports_sigmoidalContrastImage_class);
_exports_sigmoidalContrastImage_clientData.dtor = _wrap_delete_sigmoidalContrastImage;
if (SWIGTYPE_p_Magick__sigmoidalContrastImage->clientdata == 0) {
  SWIGTYPE_p_Magick__sigmoidalContrastImage->clientdata = &_exports_sigmoidalContrastImage_clientData;
}
/* Name: _exports_sizeImage, Type: p_Magick__sizeImage, Dtor: _wrap_delete_sizeImage */
SWIGV8_FUNCTION_TEMPLATE _exports_sizeImage_class = SWIGV8_CreateClassTemplate("_exports_sizeImage");
SWIGV8_SET_CLASS_TEMPL(_exports_sizeImage_clientData.class_templ, _exports_sizeImage_class);
_exports_sizeImage_clientData.dtor = _wrap_delete_sizeImage;
if (SWIGTYPE_p_Magick__sizeImage->clientdata == 0) {
  SWIGTYPE_p_Magick__sizeImage->clientdata = &_exports_sizeImage_clientData;
}
/* Name: _exports_stripImage, Type: p_Magick__stripImage, Dtor: _wrap_delete_stripImage */
SWIGV8_FUNCTION_TEMPLATE _exports_stripImage_class = SWIGV8_CreateClassTemplate("_exports_stripImage");
SWIGV8_SET_CLASS_TEMPL(_exports_stripImage_clientData.class_templ, _exports_stripImage_class);
_exports_stripImage_clientData.dtor = _wrap_delete_stripImage;
if (SWIGTYPE_p_Magick__stripImage->clientdata == 0) {
  SWIGTYPE_p_Magick__stripImage->clientdata = &_exports_stripImage_clientData;
}
/* Name: _exports_subImageImage, Type: p_Magick__subImageImage, Dtor: _wrap_delete_subImageImage */
SWIGV8_FUNCTION_TEMPLATE _exports_subImageImage_class = SWIGV8_CreateClassTemplate("_exports_subImageImage");
SWIGV8_SET_CLASS_TEMPL(_exports_subImageImage_clientData.class_templ, _exports_subImageImage_class);
_exports_subImageImage_clientData.dtor = _wrap_delete_subImageImage;
if (SWIGTYPE_p_Magick__subImageImage->clientdata == 0) {
  SWIGTYPE_p_Magick__subImageImage->clientdata = &_exports_subImageImage_clientData;
}
/* Name: _exports_subRangeImage, Type: p_Magick__subRangeImage, Dtor: _wrap_delete_subRangeImage */
SWIGV8_FUNCTION_TEMPLATE _exports_subRangeImage_class = SWIGV8_CreateClassTemplate("_exports_subRangeImage");
SWIGV8_SET_CLASS_TEMPL(_exports_subRangeImage_clientData.class_templ, _exports_subRangeImage_class);
_exports_subRangeImage_clientData.dtor = _wrap_delete_subRangeImage;
if (SWIGTYPE_p_Magick__subRangeImage->clientdata == 0) {
  SWIGTYPE_p_Magick__subRangeImage->clientdata = &_exports_subRangeImage_clientData;
}
/* Name: _exports_tileNameImage, Type: p_Magick__tileNameImage, Dtor: _wrap_delete_tileNameImage */
SWIGV8_FUNCTION_TEMPLATE _exports_tileNameImage_class = SWIGV8_CreateClassTemplate("_exports_tileNameImage");
SWIGV8_SET_CLASS_TEMPL(_exports_tileNameImage_clientData.class_templ, _exports_tileNameImage_class);
_exports_tileNameImage_clientData.dtor = _wrap_delete_tileNameImage;
if (SWIGTYPE_p_Magick__tileNameImage->clientdata == 0) {
  SWIGTYPE_p_Magick__tileNameImage->clientdata = &_exports_tileNameImage_clientData;
}
/* Name: _exports_typeImage, Type: p_Magick__typeImage, Dtor: _wrap_delete_typeImage */
SWIGV8_FUNCTION_TEMPLATE _exports_typeImage_class = SWIGV8_CreateClassTemplate("_exports_typeImage");
SWIGV8_SET_CLASS_TEMPL(_exports_typeImage_clientData.class_templ, _exports_typeImage_class);
_exports_typeImage_clientData.dtor = _wrap_delete_typeImage;
if (SWIGTYPE_p_Magick__typeImage->clientdata == 0) {
  SWIGTYPE_p_Magick__typeImage->clientdata = &_exports_typeImage_clientData;
}
/* Name: _exports_verboseImage, Type: p_Magick__verboseImage, Dtor: _wrap_delete_verboseImage */
SWIGV8_FUNCTION_TEMPLATE _exports_verboseImage_class = SWIGV8_CreateClassTemplate("_exports_verboseImage");
SWIGV8_SET_CLASS_TEMPL(_exports_verboseImage_clientData.class_templ, _exports_verboseImage_class);
_exports_verboseImage_clientData.dtor = _wrap_delete_verboseImage;
if (SWIGTYPE_p_Magick__verboseImage->clientdata == 0) {
  SWIGTYPE_p_Magick__verboseImage->clientdata = &_exports_verboseImage_clientData;
}
/* Name: _exports_viewImage, Type: p_Magick__viewImage, Dtor: _wrap_delete_viewImage */
SWIGV8_FUNCTION_TEMPLATE _exports_viewImage_class = SWIGV8_CreateClassTemplate("_exports_viewImage");
SWIGV8_SET_CLASS_TEMPL(_exports_viewImage_clientData.class_templ, _exports_viewImage_class);
_exports_viewImage_clientData.dtor = _wrap_delete_viewImage;
if (SWIGTYPE_p_Magick__viewImage->clientdata == 0) {
  SWIGTYPE_p_Magick__viewImage->clientdata = &_exports_viewImage_clientData;
}
/* Name: _exports_x11DisplayImage, Type: p_Magick__x11DisplayImage, Dtor: _wrap_delete_x11DisplayImage */
SWIGV8_FUNCTION_TEMPLATE _exports_x11DisplayImage_class = SWIGV8_CreateClassTemplate("_exports_x11DisplayImage");
SWIGV8_SET_CLASS_TEMPL(_exports_x11DisplayImage_clientData.class_templ, _exports_x11DisplayImage_class);
_exports_x11DisplayImage_clientData.dtor = _wrap_delete_x11DisplayImage;
if (SWIGTYPE_p_Magick__x11DisplayImage->clientdata == 0) {
  SWIGTYPE_p_Magick__x11DisplayImage->clientdata = &_exports_x11DisplayImage_clientData;
}
/* Name: _exports_Blob, Type: p_Magick__Blob, Dtor: _wrap_delete_Blob */
SWIGV8_FUNCTION_TEMPLATE _exports_Blob_class = SWIGV8_CreateClassTemplate("_exports_Blob");
SWIGV8_SET_CLASS_TEMPL(_exports_Blob_clientData.class_templ, _exports_Blob_class);
_exports_Blob_clientData.dtor = _wrap_delete_Blob;
if (SWIGTYPE_p_Magick__Blob->clientdata == 0) {
  SWIGTYPE_p_Magick__Blob->clientdata = &_exports_Blob_clientData;
}
/* Name: _exports_ChannelMoments, Type: p_Magick__ChannelMoments, Dtor: _wrap_delete_ChannelMoments */
SWIGV8_FUNCTION_TEMPLATE _exports_ChannelMoments_class = SWIGV8_CreateClassTemplate("_exports_ChannelMoments");
SWIGV8_SET_CLASS_TEMPL(_exports_ChannelMoments_clientData.class_templ, _exports_ChannelMoments_class);
_exports_ChannelMoments_clientData.dtor = _wrap_delete_ChannelMoments;
if (SWIGTYPE_p_Magick__ChannelMoments->clientdata == 0) {
  SWIGTYPE_p_Magick__ChannelMoments->clientdata = &_exports_ChannelMoments_clientData;
}
/* Name: _exports_ImageMoments, Type: p_Magick__ImageMoments, Dtor: _wrap_delete_ImageMoments */
SWIGV8_FUNCTION_TEMPLATE _exports_ImageMoments_class = SWIGV8_CreateClassTemplate("_exports_ImageMoments");
SWIGV8_SET_CLASS_TEMPL(_exports_ImageMoments_clientData.class_templ, _exports_ImageMoments_class);
_exports_ImageMoments_clientData.dtor = _wrap_delete_ImageMoments;
if (SWIGTYPE_p_Magick__ImageMoments->clientdata == 0) {
  SWIGTYPE_p_Magick__ImageMoments->clientdata = &_exports_ImageMoments_clientData;
}
/* Name: _exports_CoderInfo, Type: p_Magick__CoderInfo, Dtor: _wrap_delete_CoderInfo */
SWIGV8_FUNCTION_TEMPLATE _exports_CoderInfo_class = SWIGV8_CreateClassTemplate("_exports_CoderInfo");
SWIGV8_SET_CLASS_TEMPL(_exports_CoderInfo_clientData.class_templ, _exports_CoderInfo_class);
_exports_CoderInfo_clientData.dtor = _wrap_delete_CoderInfo;
if (SWIGTYPE_p_Magick__CoderInfo->clientdata == 0) {
  SWIGTYPE_p_Magick__CoderInfo->clientdata = &_exports_CoderInfo_clientData;
}
/* Name: _exports_Color, Type: p_Magick__Color, Dtor: _wrap_delete_Color */
SWIGV8_FUNCTION_TEMPLATE _exports_Color_class = SWIGV8_CreateClassTemplate("_exports_Color");
SWIGV8_SET_CLASS_TEMPL(_exports_Color_clientData.class_templ, _exports_Color_class);
_exports_Color_clientData.dtor = _wrap_delete_Color;
if (SWIGTYPE_p_Magick__Color->clientdata == 0) {
  SWIGTYPE_p_Magick__Color->clientdata = &_exports_Color_clientData;
}
/* Name: _exports_ColorGray, Type: p_Magick__ColorGray, Dtor: _wrap_delete_ColorGray */
SWIGV8_FUNCTION_TEMPLATE _exports_ColorGray_class = SWIGV8_CreateClassTemplate("_exports_ColorGray");
SWIGV8_SET_CLASS_TEMPL(_exports_ColorGray_clientData.class_templ, _exports_ColorGray_class);
_exports_ColorGray_clientData.dtor = _wrap_delete_ColorGray;
if (SWIGTYPE_p_Magick__ColorGray->clientdata == 0) {
  SWIGTYPE_p_Magick__ColorGray->clientdata = &_exports_ColorGray_clientData;
}
/* Name: _exports_ColorHSL, Type: p_Magick__ColorHSL, Dtor: _wrap_delete_ColorHSL */
SWIGV8_FUNCTION_TEMPLATE _exports_ColorHSL_class = SWIGV8_CreateClassTemplate("_exports_ColorHSL");
SWIGV8_SET_CLASS_TEMPL(_exports_ColorHSL_clientData.class_templ, _exports_ColorHSL_class);
_exports_ColorHSL_clientData.dtor = _wrap_delete_ColorHSL;
if (SWIGTYPE_p_Magick__ColorHSL->clientdata == 0) {
  SWIGTYPE_p_Magick__ColorHSL->clientdata = &_exports_ColorHSL_clientData;
}
/* Name: _exports_ColorMono, Type: p_Magick__ColorMono, Dtor: _wrap_delete_ColorMono */
SWIGV8_FUNCTION_TEMPLATE _exports_ColorMono_class = SWIGV8_CreateClassTemplate("_exports_ColorMono");
SWIGV8_SET_CLASS_TEMPL(_exports_ColorMono_clientData.class_templ, _exports_ColorMono_class);
_exports_ColorMono_clientData.dtor = _wrap_delete_ColorMono;
if (SWIGTYPE_p_Magick__ColorMono->clientdata == 0) {
  SWIGTYPE_p_Magick__ColorMono->clientdata = &_exports_ColorMono_clientData;
}
/* Name: _exports_ColorRGB, Type: p_Magick__ColorRGB, Dtor: _wrap_delete_ColorRGB */
SWIGV8_FUNCTION_TEMPLATE _exports_ColorRGB_class = SWIGV8_CreateClassTemplate("_exports_ColorRGB");
SWIGV8_SET_CLASS_TEMPL(_exports_ColorRGB_clientData.class_templ, _exports_ColorRGB_class);
_exports_ColorRGB_clientData.dtor = _wrap_delete_ColorRGB;
if (SWIGTYPE_p_Magick__ColorRGB->clientdata == 0) {
  SWIGTYPE_p_Magick__ColorRGB->clientdata = &_exports_ColorRGB_clientData;
}
/* Name: _exports_ColorYUV, Type: p_Magick__ColorYUV, Dtor: _wrap_delete_ColorYUV */
SWIGV8_FUNCTION_TEMPLATE _exports_ColorYUV_class = SWIGV8_CreateClassTemplate("_exports_ColorYUV");
SWIGV8_SET_CLASS_TEMPL(_exports_ColorYUV_clientData.class_templ, _exports_ColorYUV_class);
_exports_ColorYUV_clientData.dtor = _wrap_delete_ColorYUV;
if (SWIGTYPE_p_Magick__ColorYUV->clientdata == 0) {
  SWIGTYPE_p_Magick__ColorYUV->clientdata = &_exports_ColorYUV_clientData;
}
/* Name: _exports_Coordinate, Type: p_Magick__Coordinate, Dtor: _wrap_delete_Coordinate */
SWIGV8_FUNCTION_TEMPLATE _exports_Coordinate_class = SWIGV8_CreateClassTemplate("_exports_Coordinate");
SWIGV8_SET_CLASS_TEMPL(_exports_Coordinate_clientData.class_templ, _exports_Coordinate_class);
_exports_Coordinate_clientData.dtor = _wrap_delete_Coordinate;
if (SWIGTYPE_p_Magick__Coordinate->clientdata == 0) {
  SWIGTYPE_p_Magick__Coordinate->clientdata = &_exports_Coordinate_clientData;
}
/* Name: _exports_DrawableBase, Type: p_Magick__DrawableBase, Dtor: _wrap_delete_DrawableBase */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableBase_class = SWIGV8_CreateClassTemplate("_exports_DrawableBase");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableBase_clientData.class_templ, _exports_DrawableBase_class);
_exports_DrawableBase_clientData.dtor = _wrap_delete_DrawableBase;
if (SWIGTYPE_p_Magick__DrawableBase->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableBase->clientdata = &_exports_DrawableBase_clientData;
}
/* Name: _exports_Drawable, Type: p_Magick__Drawable, Dtor: _wrap_delete_Drawable */
SWIGV8_FUNCTION_TEMPLATE _exports_Drawable_class = SWIGV8_CreateClassTemplate("_exports_Drawable");
SWIGV8_SET_CLASS_TEMPL(_exports_Drawable_clientData.class_templ, _exports_Drawable_class);
_exports_Drawable_clientData.dtor = _wrap_delete_Drawable;
if (SWIGTYPE_p_Magick__Drawable->clientdata == 0) {
  SWIGTYPE_p_Magick__Drawable->clientdata = &_exports_Drawable_clientData;
}
/* Name: _exports_VPathBase, Type: p_Magick__VPathBase, Dtor: _wrap_delete_VPathBase */
SWIGV8_FUNCTION_TEMPLATE _exports_VPathBase_class = SWIGV8_CreateClassTemplate("_exports_VPathBase");
SWIGV8_SET_CLASS_TEMPL(_exports_VPathBase_clientData.class_templ, _exports_VPathBase_class);
_exports_VPathBase_clientData.dtor = _wrap_delete_VPathBase;
if (SWIGTYPE_p_Magick__VPathBase->clientdata == 0) {
  SWIGTYPE_p_Magick__VPathBase->clientdata = &_exports_VPathBase_clientData;
}
/* Name: _exports_VPath, Type: p_Magick__VPath, Dtor: _wrap_delete_VPath */
SWIGV8_FUNCTION_TEMPLATE _exports_VPath_class = SWIGV8_CreateClassTemplate("_exports_VPath");
SWIGV8_SET_CLASS_TEMPL(_exports_VPath_clientData.class_templ, _exports_VPath_class);
_exports_VPath_clientData.dtor = _wrap_delete_VPath;
if (SWIGTYPE_p_Magick__VPath->clientdata == 0) {
  SWIGTYPE_p_Magick__VPath->clientdata = &_exports_VPath_clientData;
}
/* Name: _exports_DrawableAffine, Type: p_Magick__DrawableAffine, Dtor: _wrap_delete_DrawableAffine */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableAffine_class = SWIGV8_CreateClassTemplate("_exports_DrawableAffine");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableAffine_clientData.class_templ, _exports_DrawableAffine_class);
_exports_DrawableAffine_clientData.dtor = _wrap_delete_DrawableAffine;
if (SWIGTYPE_p_Magick__DrawableAffine->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableAffine->clientdata = &_exports_DrawableAffine_clientData;
}
/* Name: _exports_DrawableArc, Type: p_Magick__DrawableArc, Dtor: _wrap_delete_DrawableArc */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableArc_class = SWIGV8_CreateClassTemplate("_exports_DrawableArc");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableArc_clientData.class_templ, _exports_DrawableArc_class);
_exports_DrawableArc_clientData.dtor = _wrap_delete_DrawableArc;
if (SWIGTYPE_p_Magick__DrawableArc->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableArc->clientdata = &_exports_DrawableArc_clientData;
}
/* Name: _exports_DrawableBezier, Type: p_Magick__DrawableBezier, Dtor: _wrap_delete_DrawableBezier */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableBezier_class = SWIGV8_CreateClassTemplate("_exports_DrawableBezier");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableBezier_clientData.class_templ, _exports_DrawableBezier_class);
_exports_DrawableBezier_clientData.dtor = _wrap_delete_DrawableBezier;
if (SWIGTYPE_p_Magick__DrawableBezier->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableBezier->clientdata = &_exports_DrawableBezier_clientData;
}
/* Name: _exports_DrawablePopClipPath, Type: p_Magick__DrawablePopClipPath, Dtor: _wrap_delete_DrawablePopClipPath */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawablePopClipPath_class = SWIGV8_CreateClassTemplate("_exports_DrawablePopClipPath");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawablePopClipPath_clientData.class_templ, _exports_DrawablePopClipPath_class);
_exports_DrawablePopClipPath_clientData.dtor = _wrap_delete_DrawablePopClipPath;
if (SWIGTYPE_p_Magick__DrawablePopClipPath->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawablePopClipPath->clientdata = &_exports_DrawablePopClipPath_clientData;
}
/* Name: _exports_DrawablePushClipPath, Type: p_Magick__DrawablePushClipPath, Dtor: _wrap_delete_DrawablePushClipPath */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawablePushClipPath_class = SWIGV8_CreateClassTemplate("_exports_DrawablePushClipPath");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawablePushClipPath_clientData.class_templ, _exports_DrawablePushClipPath_class);
_exports_DrawablePushClipPath_clientData.dtor = _wrap_delete_DrawablePushClipPath;
if (SWIGTYPE_p_Magick__DrawablePushClipPath->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawablePushClipPath->clientdata = &_exports_DrawablePushClipPath_clientData;
}
/* Name: _exports_DrawableClipPath, Type: p_Magick__DrawableClipPath, Dtor: _wrap_delete_DrawableClipPath */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableClipPath_class = SWIGV8_CreateClassTemplate("_exports_DrawableClipPath");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableClipPath_clientData.class_templ, _exports_DrawableClipPath_class);
_exports_DrawableClipPath_clientData.dtor = _wrap_delete_DrawableClipPath;
if (SWIGTYPE_p_Magick__DrawableClipPath->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableClipPath->clientdata = &_exports_DrawableClipPath_clientData;
}
/* Name: _exports_DrawableCircle, Type: p_Magick__DrawableCircle, Dtor: _wrap_delete_DrawableCircle */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableCircle_class = SWIGV8_CreateClassTemplate("_exports_DrawableCircle");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableCircle_clientData.class_templ, _exports_DrawableCircle_class);
_exports_DrawableCircle_clientData.dtor = _wrap_delete_DrawableCircle;
if (SWIGTYPE_p_Magick__DrawableCircle->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableCircle->clientdata = &_exports_DrawableCircle_clientData;
}
/* Name: _exports_DrawableColor, Type: p_Magick__DrawableColor, Dtor: _wrap_delete_DrawableColor */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableColor_class = SWIGV8_CreateClassTemplate("_exports_DrawableColor");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableColor_clientData.class_templ, _exports_DrawableColor_class);
_exports_DrawableColor_clientData.dtor = _wrap_delete_DrawableColor;
if (SWIGTYPE_p_Magick__DrawableColor->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableColor->clientdata = &_exports_DrawableColor_clientData;
}
/* Name: _exports_DrawableCompositeImage, Type: p_Magick__DrawableCompositeImage, Dtor: _wrap_delete_DrawableCompositeImage */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableCompositeImage_class = SWIGV8_CreateClassTemplate("_exports_DrawableCompositeImage");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableCompositeImage_clientData.class_templ, _exports_DrawableCompositeImage_class);
_exports_DrawableCompositeImage_clientData.dtor = _wrap_delete_DrawableCompositeImage;
if (SWIGTYPE_p_Magick__DrawableCompositeImage->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableCompositeImage->clientdata = &_exports_DrawableCompositeImage_clientData;
}
/* Name: _exports_DrawableDensity, Type: p_Magick__DrawableDensity, Dtor: _wrap_delete_DrawableDensity */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableDensity_class = SWIGV8_CreateClassTemplate("_exports_DrawableDensity");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableDensity_clientData.class_templ, _exports_DrawableDensity_class);
_exports_DrawableDensity_clientData.dtor = _wrap_delete_DrawableDensity;
if (SWIGTYPE_p_Magick__DrawableDensity->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableDensity->clientdata = &_exports_DrawableDensity_clientData;
}
/* Name: _exports_DrawableEllipse, Type: p_Magick__DrawableEllipse, Dtor: _wrap_delete_DrawableEllipse */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableEllipse_class = SWIGV8_CreateClassTemplate("_exports_DrawableEllipse");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableEllipse_clientData.class_templ, _exports_DrawableEllipse_class);
_exports_DrawableEllipse_clientData.dtor = _wrap_delete_DrawableEllipse;
if (SWIGTYPE_p_Magick__DrawableEllipse->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableEllipse->clientdata = &_exports_DrawableEllipse_clientData;
}
/* Name: _exports_DrawableFillColor, Type: p_Magick__DrawableFillColor, Dtor: _wrap_delete_DrawableFillColor */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableFillColor_class = SWIGV8_CreateClassTemplate("_exports_DrawableFillColor");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableFillColor_clientData.class_templ, _exports_DrawableFillColor_class);
_exports_DrawableFillColor_clientData.dtor = _wrap_delete_DrawableFillColor;
if (SWIGTYPE_p_Magick__DrawableFillColor->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableFillColor->clientdata = &_exports_DrawableFillColor_clientData;
}
/* Name: _exports_DrawableFillRule, Type: p_Magick__DrawableFillRule, Dtor: _wrap_delete_DrawableFillRule */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableFillRule_class = SWIGV8_CreateClassTemplate("_exports_DrawableFillRule");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableFillRule_clientData.class_templ, _exports_DrawableFillRule_class);
_exports_DrawableFillRule_clientData.dtor = _wrap_delete_DrawableFillRule;
if (SWIGTYPE_p_Magick__DrawableFillRule->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableFillRule->clientdata = &_exports_DrawableFillRule_clientData;
}
/* Name: _exports_DrawableFillOpacity, Type: p_Magick__DrawableFillOpacity, Dtor: _wrap_delete_DrawableFillOpacity */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableFillOpacity_class = SWIGV8_CreateClassTemplate("_exports_DrawableFillOpacity");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableFillOpacity_clientData.class_templ, _exports_DrawableFillOpacity_class);
_exports_DrawableFillOpacity_clientData.dtor = _wrap_delete_DrawableFillOpacity;
if (SWIGTYPE_p_Magick__DrawableFillOpacity->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableFillOpacity->clientdata = &_exports_DrawableFillOpacity_clientData;
}
/* Name: _exports_DrawableFont, Type: p_Magick__DrawableFont, Dtor: _wrap_delete_DrawableFont */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableFont_class = SWIGV8_CreateClassTemplate("_exports_DrawableFont");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableFont_clientData.class_templ, _exports_DrawableFont_class);
_exports_DrawableFont_clientData.dtor = _wrap_delete_DrawableFont;
if (SWIGTYPE_p_Magick__DrawableFont->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableFont->clientdata = &_exports_DrawableFont_clientData;
}
/* Name: _exports_DrawableGravity, Type: p_Magick__DrawableGravity, Dtor: _wrap_delete_DrawableGravity */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableGravity_class = SWIGV8_CreateClassTemplate("_exports_DrawableGravity");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableGravity_clientData.class_templ, _exports_DrawableGravity_class);
_exports_DrawableGravity_clientData.dtor = _wrap_delete_DrawableGravity;
if (SWIGTYPE_p_Magick__DrawableGravity->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableGravity->clientdata = &_exports_DrawableGravity_clientData;
}
/* Name: _exports_DrawableLine, Type: p_Magick__DrawableLine, Dtor: _wrap_delete_DrawableLine */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableLine_class = SWIGV8_CreateClassTemplate("_exports_DrawableLine");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableLine_clientData.class_templ, _exports_DrawableLine_class);
_exports_DrawableLine_clientData.dtor = _wrap_delete_DrawableLine;
if (SWIGTYPE_p_Magick__DrawableLine->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableLine->clientdata = &_exports_DrawableLine_clientData;
}
/* Name: _exports_DrawableMatte, Type: p_Magick__DrawableMatte, Dtor: _wrap_delete_DrawableMatte */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableMatte_class = SWIGV8_CreateClassTemplate("_exports_DrawableMatte");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableMatte_clientData.class_templ, _exports_DrawableMatte_class);
_exports_DrawableMatte_clientData.dtor = _wrap_delete_DrawableMatte;
if (SWIGTYPE_p_Magick__DrawableMatte->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableMatte->clientdata = &_exports_DrawableMatte_clientData;
}
/* Name: _exports_DrawablePath, Type: p_Magick__DrawablePath, Dtor: _wrap_delete_DrawablePath */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawablePath_class = SWIGV8_CreateClassTemplate("_exports_DrawablePath");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawablePath_clientData.class_templ, _exports_DrawablePath_class);
_exports_DrawablePath_clientData.dtor = _wrap_delete_DrawablePath;
if (SWIGTYPE_p_Magick__DrawablePath->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawablePath->clientdata = &_exports_DrawablePath_clientData;
}
/* Name: _exports_DrawablePoint, Type: p_Magick__DrawablePoint, Dtor: _wrap_delete_DrawablePoint */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawablePoint_class = SWIGV8_CreateClassTemplate("_exports_DrawablePoint");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawablePoint_clientData.class_templ, _exports_DrawablePoint_class);
_exports_DrawablePoint_clientData.dtor = _wrap_delete_DrawablePoint;
if (SWIGTYPE_p_Magick__DrawablePoint->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawablePoint->clientdata = &_exports_DrawablePoint_clientData;
}
/* Name: _exports_DrawablePointSize, Type: p_Magick__DrawablePointSize, Dtor: _wrap_delete_DrawablePointSize */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawablePointSize_class = SWIGV8_CreateClassTemplate("_exports_DrawablePointSize");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawablePointSize_clientData.class_templ, _exports_DrawablePointSize_class);
_exports_DrawablePointSize_clientData.dtor = _wrap_delete_DrawablePointSize;
if (SWIGTYPE_p_Magick__DrawablePointSize->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawablePointSize->clientdata = &_exports_DrawablePointSize_clientData;
}
/* Name: _exports_DrawablePolygon, Type: p_Magick__DrawablePolygon, Dtor: _wrap_delete_DrawablePolygon */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawablePolygon_class = SWIGV8_CreateClassTemplate("_exports_DrawablePolygon");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawablePolygon_clientData.class_templ, _exports_DrawablePolygon_class);
_exports_DrawablePolygon_clientData.dtor = _wrap_delete_DrawablePolygon;
if (SWIGTYPE_p_Magick__DrawablePolygon->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawablePolygon->clientdata = &_exports_DrawablePolygon_clientData;
}
/* Name: _exports_DrawablePolyline, Type: p_Magick__DrawablePolyline, Dtor: _wrap_delete_DrawablePolyline */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawablePolyline_class = SWIGV8_CreateClassTemplate("_exports_DrawablePolyline");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawablePolyline_clientData.class_templ, _exports_DrawablePolyline_class);
_exports_DrawablePolyline_clientData.dtor = _wrap_delete_DrawablePolyline;
if (SWIGTYPE_p_Magick__DrawablePolyline->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawablePolyline->clientdata = &_exports_DrawablePolyline_clientData;
}
/* Name: _exports_DrawablePopGraphicContext, Type: p_Magick__DrawablePopGraphicContext, Dtor: _wrap_delete_DrawablePopGraphicContext */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawablePopGraphicContext_class = SWIGV8_CreateClassTemplate("_exports_DrawablePopGraphicContext");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawablePopGraphicContext_clientData.class_templ, _exports_DrawablePopGraphicContext_class);
_exports_DrawablePopGraphicContext_clientData.dtor = _wrap_delete_DrawablePopGraphicContext;
if (SWIGTYPE_p_Magick__DrawablePopGraphicContext->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawablePopGraphicContext->clientdata = &_exports_DrawablePopGraphicContext_clientData;
}
/* Name: _exports_DrawablePushGraphicContext, Type: p_Magick__DrawablePushGraphicContext, Dtor: _wrap_delete_DrawablePushGraphicContext */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawablePushGraphicContext_class = SWIGV8_CreateClassTemplate("_exports_DrawablePushGraphicContext");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawablePushGraphicContext_clientData.class_templ, _exports_DrawablePushGraphicContext_class);
_exports_DrawablePushGraphicContext_clientData.dtor = _wrap_delete_DrawablePushGraphicContext;
if (SWIGTYPE_p_Magick__DrawablePushGraphicContext->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawablePushGraphicContext->clientdata = &_exports_DrawablePushGraphicContext_clientData;
}
/* Name: _exports_DrawablePopPattern, Type: p_Magick__DrawablePopPattern, Dtor: _wrap_delete_DrawablePopPattern */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawablePopPattern_class = SWIGV8_CreateClassTemplate("_exports_DrawablePopPattern");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawablePopPattern_clientData.class_templ, _exports_DrawablePopPattern_class);
_exports_DrawablePopPattern_clientData.dtor = _wrap_delete_DrawablePopPattern;
if (SWIGTYPE_p_Magick__DrawablePopPattern->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawablePopPattern->clientdata = &_exports_DrawablePopPattern_clientData;
}
/* Name: _exports_DrawablePushPattern, Type: p_Magick__DrawablePushPattern, Dtor: _wrap_delete_DrawablePushPattern */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawablePushPattern_class = SWIGV8_CreateClassTemplate("_exports_DrawablePushPattern");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawablePushPattern_clientData.class_templ, _exports_DrawablePushPattern_class);
_exports_DrawablePushPattern_clientData.dtor = _wrap_delete_DrawablePushPattern;
if (SWIGTYPE_p_Magick__DrawablePushPattern->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawablePushPattern->clientdata = &_exports_DrawablePushPattern_clientData;
}
/* Name: _exports_DrawableRectangle, Type: p_Magick__DrawableRectangle, Dtor: _wrap_delete_DrawableRectangle */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableRectangle_class = SWIGV8_CreateClassTemplate("_exports_DrawableRectangle");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableRectangle_clientData.class_templ, _exports_DrawableRectangle_class);
_exports_DrawableRectangle_clientData.dtor = _wrap_delete_DrawableRectangle;
if (SWIGTYPE_p_Magick__DrawableRectangle->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableRectangle->clientdata = &_exports_DrawableRectangle_clientData;
}
/* Name: _exports_DrawableRotation, Type: p_Magick__DrawableRotation, Dtor: _wrap_delete_DrawableRotation */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableRotation_class = SWIGV8_CreateClassTemplate("_exports_DrawableRotation");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableRotation_clientData.class_templ, _exports_DrawableRotation_class);
_exports_DrawableRotation_clientData.dtor = _wrap_delete_DrawableRotation;
if (SWIGTYPE_p_Magick__DrawableRotation->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableRotation->clientdata = &_exports_DrawableRotation_clientData;
}
/* Name: _exports_DrawableRoundRectangle, Type: p_Magick__DrawableRoundRectangle, Dtor: _wrap_delete_DrawableRoundRectangle */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableRoundRectangle_class = SWIGV8_CreateClassTemplate("_exports_DrawableRoundRectangle");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableRoundRectangle_clientData.class_templ, _exports_DrawableRoundRectangle_class);
_exports_DrawableRoundRectangle_clientData.dtor = _wrap_delete_DrawableRoundRectangle;
if (SWIGTYPE_p_Magick__DrawableRoundRectangle->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableRoundRectangle->clientdata = &_exports_DrawableRoundRectangle_clientData;
}
/* Name: _exports_DrawableScaling, Type: p_Magick__DrawableScaling, Dtor: _wrap_delete_DrawableScaling */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableScaling_class = SWIGV8_CreateClassTemplate("_exports_DrawableScaling");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableScaling_clientData.class_templ, _exports_DrawableScaling_class);
_exports_DrawableScaling_clientData.dtor = _wrap_delete_DrawableScaling;
if (SWIGTYPE_p_Magick__DrawableScaling->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableScaling->clientdata = &_exports_DrawableScaling_clientData;
}
/* Name: _exports_DrawableSkewX, Type: p_Magick__DrawableSkewX, Dtor: _wrap_delete_DrawableSkewX */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableSkewX_class = SWIGV8_CreateClassTemplate("_exports_DrawableSkewX");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableSkewX_clientData.class_templ, _exports_DrawableSkewX_class);
_exports_DrawableSkewX_clientData.dtor = _wrap_delete_DrawableSkewX;
if (SWIGTYPE_p_Magick__DrawableSkewX->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableSkewX->clientdata = &_exports_DrawableSkewX_clientData;
}
/* Name: _exports_DrawableSkewY, Type: p_Magick__DrawableSkewY, Dtor: _wrap_delete_DrawableSkewY */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableSkewY_class = SWIGV8_CreateClassTemplate("_exports_DrawableSkewY");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableSkewY_clientData.class_templ, _exports_DrawableSkewY_class);
_exports_DrawableSkewY_clientData.dtor = _wrap_delete_DrawableSkewY;
if (SWIGTYPE_p_Magick__DrawableSkewY->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableSkewY->clientdata = &_exports_DrawableSkewY_clientData;
}
/* Name: _exports_DrawableDashArray, Type: p_Magick__DrawableDashArray, Dtor: _wrap_delete_DrawableDashArray */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableDashArray_class = SWIGV8_CreateClassTemplate("_exports_DrawableDashArray");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableDashArray_clientData.class_templ, _exports_DrawableDashArray_class);
_exports_DrawableDashArray_clientData.dtor = _wrap_delete_DrawableDashArray;
if (SWIGTYPE_p_Magick__DrawableDashArray->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableDashArray->clientdata = &_exports_DrawableDashArray_clientData;
}
/* Name: _exports_DrawableDashOffset, Type: p_Magick__DrawableDashOffset, Dtor: _wrap_delete_DrawableDashOffset */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableDashOffset_class = SWIGV8_CreateClassTemplate("_exports_DrawableDashOffset");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableDashOffset_clientData.class_templ, _exports_DrawableDashOffset_class);
_exports_DrawableDashOffset_clientData.dtor = _wrap_delete_DrawableDashOffset;
if (SWIGTYPE_p_Magick__DrawableDashOffset->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableDashOffset->clientdata = &_exports_DrawableDashOffset_clientData;
}
/* Name: _exports_DrawableStrokeLineCap, Type: p_Magick__DrawableStrokeLineCap, Dtor: _wrap_delete_DrawableStrokeLineCap */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableStrokeLineCap_class = SWIGV8_CreateClassTemplate("_exports_DrawableStrokeLineCap");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableStrokeLineCap_clientData.class_templ, _exports_DrawableStrokeLineCap_class);
_exports_DrawableStrokeLineCap_clientData.dtor = _wrap_delete_DrawableStrokeLineCap;
if (SWIGTYPE_p_Magick__DrawableStrokeLineCap->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableStrokeLineCap->clientdata = &_exports_DrawableStrokeLineCap_clientData;
}
/* Name: _exports_DrawableStrokeLineJoin, Type: p_Magick__DrawableStrokeLineJoin, Dtor: _wrap_delete_DrawableStrokeLineJoin */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableStrokeLineJoin_class = SWIGV8_CreateClassTemplate("_exports_DrawableStrokeLineJoin");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableStrokeLineJoin_clientData.class_templ, _exports_DrawableStrokeLineJoin_class);
_exports_DrawableStrokeLineJoin_clientData.dtor = _wrap_delete_DrawableStrokeLineJoin;
if (SWIGTYPE_p_Magick__DrawableStrokeLineJoin->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableStrokeLineJoin->clientdata = &_exports_DrawableStrokeLineJoin_clientData;
}
/* Name: _exports_DrawableMiterLimit, Type: p_Magick__DrawableMiterLimit, Dtor: _wrap_delete_DrawableMiterLimit */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableMiterLimit_class = SWIGV8_CreateClassTemplate("_exports_DrawableMiterLimit");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableMiterLimit_clientData.class_templ, _exports_DrawableMiterLimit_class);
_exports_DrawableMiterLimit_clientData.dtor = _wrap_delete_DrawableMiterLimit;
if (SWIGTYPE_p_Magick__DrawableMiterLimit->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableMiterLimit->clientdata = &_exports_DrawableMiterLimit_clientData;
}
/* Name: _exports_DrawableStrokeAntialias, Type: p_Magick__DrawableStrokeAntialias, Dtor: _wrap_delete_DrawableStrokeAntialias */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableStrokeAntialias_class = SWIGV8_CreateClassTemplate("_exports_DrawableStrokeAntialias");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableStrokeAntialias_clientData.class_templ, _exports_DrawableStrokeAntialias_class);
_exports_DrawableStrokeAntialias_clientData.dtor = _wrap_delete_DrawableStrokeAntialias;
if (SWIGTYPE_p_Magick__DrawableStrokeAntialias->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableStrokeAntialias->clientdata = &_exports_DrawableStrokeAntialias_clientData;
}
/* Name: _exports_DrawableStrokeColor, Type: p_Magick__DrawableStrokeColor, Dtor: _wrap_delete_DrawableStrokeColor */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableStrokeColor_class = SWIGV8_CreateClassTemplate("_exports_DrawableStrokeColor");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableStrokeColor_clientData.class_templ, _exports_DrawableStrokeColor_class);
_exports_DrawableStrokeColor_clientData.dtor = _wrap_delete_DrawableStrokeColor;
if (SWIGTYPE_p_Magick__DrawableStrokeColor->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableStrokeColor->clientdata = &_exports_DrawableStrokeColor_clientData;
}
/* Name: _exports_DrawableStrokeOpacity, Type: p_Magick__DrawableStrokeOpacity, Dtor: _wrap_delete_DrawableStrokeOpacity */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableStrokeOpacity_class = SWIGV8_CreateClassTemplate("_exports_DrawableStrokeOpacity");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableStrokeOpacity_clientData.class_templ, _exports_DrawableStrokeOpacity_class);
_exports_DrawableStrokeOpacity_clientData.dtor = _wrap_delete_DrawableStrokeOpacity;
if (SWIGTYPE_p_Magick__DrawableStrokeOpacity->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableStrokeOpacity->clientdata = &_exports_DrawableStrokeOpacity_clientData;
}
/* Name: _exports_DrawableStrokeWidth, Type: p_Magick__DrawableStrokeWidth, Dtor: _wrap_delete_DrawableStrokeWidth */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableStrokeWidth_class = SWIGV8_CreateClassTemplate("_exports_DrawableStrokeWidth");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableStrokeWidth_clientData.class_templ, _exports_DrawableStrokeWidth_class);
_exports_DrawableStrokeWidth_clientData.dtor = _wrap_delete_DrawableStrokeWidth;
if (SWIGTYPE_p_Magick__DrawableStrokeWidth->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableStrokeWidth->clientdata = &_exports_DrawableStrokeWidth_clientData;
}
/* Name: _exports_DrawableText, Type: p_Magick__DrawableText, Dtor: _wrap_delete_DrawableText */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableText_class = SWIGV8_CreateClassTemplate("_exports_DrawableText");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableText_clientData.class_templ, _exports_DrawableText_class);
_exports_DrawableText_clientData.dtor = _wrap_delete_DrawableText;
if (SWIGTYPE_p_Magick__DrawableText->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableText->clientdata = &_exports_DrawableText_clientData;
}
/* Name: _exports_DrawableTextAntialias, Type: p_Magick__DrawableTextAntialias, Dtor: _wrap_delete_DrawableTextAntialias */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableTextAntialias_class = SWIGV8_CreateClassTemplate("_exports_DrawableTextAntialias");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableTextAntialias_clientData.class_templ, _exports_DrawableTextAntialias_class);
_exports_DrawableTextAntialias_clientData.dtor = _wrap_delete_DrawableTextAntialias;
if (SWIGTYPE_p_Magick__DrawableTextAntialias->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableTextAntialias->clientdata = &_exports_DrawableTextAntialias_clientData;
}
/* Name: _exports_DrawableTextDecoration, Type: p_Magick__DrawableTextDecoration, Dtor: _wrap_delete_DrawableTextDecoration */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableTextDecoration_class = SWIGV8_CreateClassTemplate("_exports_DrawableTextDecoration");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableTextDecoration_clientData.class_templ, _exports_DrawableTextDecoration_class);
_exports_DrawableTextDecoration_clientData.dtor = _wrap_delete_DrawableTextDecoration;
if (SWIGTYPE_p_Magick__DrawableTextDecoration->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableTextDecoration->clientdata = &_exports_DrawableTextDecoration_clientData;
}
/* Name: _exports_DrawableTextDirection, Type: p_Magick__DrawableTextDirection, Dtor: _wrap_delete_DrawableTextDirection */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableTextDirection_class = SWIGV8_CreateClassTemplate("_exports_DrawableTextDirection");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableTextDirection_clientData.class_templ, _exports_DrawableTextDirection_class);
_exports_DrawableTextDirection_clientData.dtor = _wrap_delete_DrawableTextDirection;
if (SWIGTYPE_p_Magick__DrawableTextDirection->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableTextDirection->clientdata = &_exports_DrawableTextDirection_clientData;
}
/* Name: _exports_DrawableTextInterlineSpacing, Type: p_Magick__DrawableTextInterlineSpacing, Dtor: _wrap_delete_DrawableTextInterlineSpacing */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableTextInterlineSpacing_class = SWIGV8_CreateClassTemplate("_exports_DrawableTextInterlineSpacing");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableTextInterlineSpacing_clientData.class_templ, _exports_DrawableTextInterlineSpacing_class);
_exports_DrawableTextInterlineSpacing_clientData.dtor = _wrap_delete_DrawableTextInterlineSpacing;
if (SWIGTYPE_p_Magick__DrawableTextInterlineSpacing->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableTextInterlineSpacing->clientdata = &_exports_DrawableTextInterlineSpacing_clientData;
}
/* Name: _exports_DrawableTextInterwordSpacing, Type: p_Magick__DrawableTextInterwordSpacing, Dtor: _wrap_delete_DrawableTextInterwordSpacing */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableTextInterwordSpacing_class = SWIGV8_CreateClassTemplate("_exports_DrawableTextInterwordSpacing");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableTextInterwordSpacing_clientData.class_templ, _exports_DrawableTextInterwordSpacing_class);
_exports_DrawableTextInterwordSpacing_clientData.dtor = _wrap_delete_DrawableTextInterwordSpacing;
if (SWIGTYPE_p_Magick__DrawableTextInterwordSpacing->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableTextInterwordSpacing->clientdata = &_exports_DrawableTextInterwordSpacing_clientData;
}
/* Name: _exports_DrawableTextKerning, Type: p_Magick__DrawableTextKerning, Dtor: _wrap_delete_DrawableTextKerning */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableTextKerning_class = SWIGV8_CreateClassTemplate("_exports_DrawableTextKerning");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableTextKerning_clientData.class_templ, _exports_DrawableTextKerning_class);
_exports_DrawableTextKerning_clientData.dtor = _wrap_delete_DrawableTextKerning;
if (SWIGTYPE_p_Magick__DrawableTextKerning->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableTextKerning->clientdata = &_exports_DrawableTextKerning_clientData;
}
/* Name: _exports_DrawableTextUnderColor, Type: p_Magick__DrawableTextUnderColor, Dtor: _wrap_delete_DrawableTextUnderColor */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableTextUnderColor_class = SWIGV8_CreateClassTemplate("_exports_DrawableTextUnderColor");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableTextUnderColor_clientData.class_templ, _exports_DrawableTextUnderColor_class);
_exports_DrawableTextUnderColor_clientData.dtor = _wrap_delete_DrawableTextUnderColor;
if (SWIGTYPE_p_Magick__DrawableTextUnderColor->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableTextUnderColor->clientdata = &_exports_DrawableTextUnderColor_clientData;
}
/* Name: _exports_DrawableTranslation, Type: p_Magick__DrawableTranslation, Dtor: _wrap_delete_DrawableTranslation */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableTranslation_class = SWIGV8_CreateClassTemplate("_exports_DrawableTranslation");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableTranslation_clientData.class_templ, _exports_DrawableTranslation_class);
_exports_DrawableTranslation_clientData.dtor = _wrap_delete_DrawableTranslation;
if (SWIGTYPE_p_Magick__DrawableTranslation->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableTranslation->clientdata = &_exports_DrawableTranslation_clientData;
}
/* Name: _exports_DrawableViewbox, Type: p_Magick__DrawableViewbox, Dtor: _wrap_delete_DrawableViewbox */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableViewbox_class = SWIGV8_CreateClassTemplate("_exports_DrawableViewbox");
SWIGV8_SET_CLASS_TEMPL(_exports_DrawableViewbox_clientData.class_templ, _exports_DrawableViewbox_class);
_exports_DrawableViewbox_clientData.dtor = _wrap_delete_DrawableViewbox;
if (SWIGTYPE_p_Magick__DrawableViewbox->clientdata == 0) {
  SWIGTYPE_p_Magick__DrawableViewbox->clientdata = &_exports_DrawableViewbox_clientData;
}
/* Name: _exports_PathArcArgs, Type: p_Magick__PathArcArgs, Dtor: _wrap_delete_PathArcArgs */
SWIGV8_FUNCTION_TEMPLATE _exports_PathArcArgs_class = SWIGV8_CreateClassTemplate("_exports_PathArcArgs");
SWIGV8_SET_CLASS_TEMPL(_exports_PathArcArgs_clientData.class_templ, _exports_PathArcArgs_class);
_exports_PathArcArgs_clientData.dtor = _wrap_delete_PathArcArgs;
if (SWIGTYPE_p_Magick__PathArcArgs->clientdata == 0) {
  SWIGTYPE_p_Magick__PathArcArgs->clientdata = &_exports_PathArcArgs_clientData;
}
/* Name: _exports_PathArcAbs, Type: p_Magick__PathArcAbs, Dtor: _wrap_delete_PathArcAbs */
SWIGV8_FUNCTION_TEMPLATE _exports_PathArcAbs_class = SWIGV8_CreateClassTemplate("_exports_PathArcAbs");
SWIGV8_SET_CLASS_TEMPL(_exports_PathArcAbs_clientData.class_templ, _exports_PathArcAbs_class);
_exports_PathArcAbs_clientData.dtor = _wrap_delete_PathArcAbs;
if (SWIGTYPE_p_Magick__PathArcAbs->clientdata == 0) {
  SWIGTYPE_p_Magick__PathArcAbs->clientdata = &_exports_PathArcAbs_clientData;
}
/* Name: _exports_PathArcRel, Type: p_Magick__PathArcRel, Dtor: _wrap_delete_PathArcRel */
SWIGV8_FUNCTION_TEMPLATE _exports_PathArcRel_class = SWIGV8_CreateClassTemplate("_exports_PathArcRel");
SWIGV8_SET_CLASS_TEMPL(_exports_PathArcRel_clientData.class_templ, _exports_PathArcRel_class);
_exports_PathArcRel_clientData.dtor = _wrap_delete_PathArcRel;
if (SWIGTYPE_p_Magick__PathArcRel->clientdata == 0) {
  SWIGTYPE_p_Magick__PathArcRel->clientdata = &_exports_PathArcRel_clientData;
}
/* Name: _exports_PathClosePath, Type: p_Magick__PathClosePath, Dtor: _wrap_delete_PathClosePath */
SWIGV8_FUNCTION_TEMPLATE _exports_PathClosePath_class = SWIGV8_CreateClassTemplate("_exports_PathClosePath");
SWIGV8_SET_CLASS_TEMPL(_exports_PathClosePath_clientData.class_templ, _exports_PathClosePath_class);
_exports_PathClosePath_clientData.dtor = _wrap_delete_PathClosePath;
if (SWIGTYPE_p_Magick__PathClosePath->clientdata == 0) {
  SWIGTYPE_p_Magick__PathClosePath->clientdata = &_exports_PathClosePath_clientData;
}
/* Name: _exports_PathCurvetoArgs, Type: p_Magick__PathCurvetoArgs, Dtor: _wrap_delete_PathCurvetoArgs */
SWIGV8_FUNCTION_TEMPLATE _exports_PathCurvetoArgs_class = SWIGV8_CreateClassTemplate("_exports_PathCurvetoArgs");
SWIGV8_SET_CLASS_TEMPL(_exports_PathCurvetoArgs_clientData.class_templ, _exports_PathCurvetoArgs_class);
_exports_PathCurvetoArgs_clientData.dtor = _wrap_delete_PathCurvetoArgs;
if (SWIGTYPE_p_Magick__PathCurvetoArgs->clientdata == 0) {
  SWIGTYPE_p_Magick__PathCurvetoArgs->clientdata = &_exports_PathCurvetoArgs_clientData;
}
/* Name: _exports_PathCurvetoAbs, Type: p_Magick__PathCurvetoAbs, Dtor: _wrap_delete_PathCurvetoAbs */
SWIGV8_FUNCTION_TEMPLATE _exports_PathCurvetoAbs_class = SWIGV8_CreateClassTemplate("_exports_PathCurvetoAbs");
SWIGV8_SET_CLASS_TEMPL(_exports_PathCurvetoAbs_clientData.class_templ, _exports_PathCurvetoAbs_class);
_exports_PathCurvetoAbs_clientData.dtor = _wrap_delete_PathCurvetoAbs;
if (SWIGTYPE_p_Magick__PathCurvetoAbs->clientdata == 0) {
  SWIGTYPE_p_Magick__PathCurvetoAbs->clientdata = &_exports_PathCurvetoAbs_clientData;
}
/* Name: _exports_PathCurvetoRel, Type: p_Magick__PathCurvetoRel, Dtor: _wrap_delete_PathCurvetoRel */
SWIGV8_FUNCTION_TEMPLATE _exports_PathCurvetoRel_class = SWIGV8_CreateClassTemplate("_exports_PathCurvetoRel");
SWIGV8_SET_CLASS_TEMPL(_exports_PathCurvetoRel_clientData.class_templ, _exports_PathCurvetoRel_class);
_exports_PathCurvetoRel_clientData.dtor = _wrap_delete_PathCurvetoRel;
if (SWIGTYPE_p_Magick__PathCurvetoRel->clientdata == 0) {
  SWIGTYPE_p_Magick__PathCurvetoRel->clientdata = &_exports_PathCurvetoRel_clientData;
}
/* Name: _exports_PathSmoothCurvetoAbs, Type: p_Magick__PathSmoothCurvetoAbs, Dtor: _wrap_delete_PathSmoothCurvetoAbs */
SWIGV8_FUNCTION_TEMPLATE _exports_PathSmoothCurvetoAbs_class = SWIGV8_CreateClassTemplate("_exports_PathSmoothCurvetoAbs");
SWIGV8_SET_CLASS_TEMPL(_exports_PathSmoothCurvetoAbs_clientData.class_templ, _exports_PathSmoothCurvetoAbs_class);
_exports_PathSmoothCurvetoAbs_clientData.dtor = _wrap_delete_PathSmoothCurvetoAbs;
if (SWIGTYPE_p_Magick__PathSmoothCurvetoAbs->clientdata == 0) {
  SWIGTYPE_p_Magick__PathSmoothCurvetoAbs->clientdata = &_exports_PathSmoothCurvetoAbs_clientData;
}
/* Name: _exports_PathSmoothCurvetoRel, Type: p_Magick__PathSmoothCurvetoRel, Dtor: _wrap_delete_PathSmoothCurvetoRel */
SWIGV8_FUNCTION_TEMPLATE _exports_PathSmoothCurvetoRel_class = SWIGV8_CreateClassTemplate("_exports_PathSmoothCurvetoRel");
SWIGV8_SET_CLASS_TEMPL(_exports_PathSmoothCurvetoRel_clientData.class_templ, _exports_PathSmoothCurvetoRel_class);
_exports_PathSmoothCurvetoRel_clientData.dtor = _wrap_delete_PathSmoothCurvetoRel;
if (SWIGTYPE_p_Magick__PathSmoothCurvetoRel->clientdata == 0) {
  SWIGTYPE_p_Magick__PathSmoothCurvetoRel->clientdata = &_exports_PathSmoothCurvetoRel_clientData;
}
/* Name: _exports_PathQuadraticCurvetoArgs, Type: p_Magick__PathQuadraticCurvetoArgs, Dtor: _wrap_delete_PathQuadraticCurvetoArgs */
SWIGV8_FUNCTION_TEMPLATE _exports_PathQuadraticCurvetoArgs_class = SWIGV8_CreateClassTemplate("_exports_PathQuadraticCurvetoArgs");
SWIGV8_SET_CLASS_TEMPL(_exports_PathQuadraticCurvetoArgs_clientData.class_templ, _exports_PathQuadraticCurvetoArgs_class);
_exports_PathQuadraticCurvetoArgs_clientData.dtor = _wrap_delete_PathQuadraticCurvetoArgs;
if (SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs->clientdata == 0) {
  SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs->clientdata = &_exports_PathQuadraticCurvetoArgs_clientData;
}
/* Name: _exports_PathQuadraticCurvetoAbs, Type: p_Magick__PathQuadraticCurvetoAbs, Dtor: _wrap_delete_PathQuadraticCurvetoAbs */
SWIGV8_FUNCTION_TEMPLATE _exports_PathQuadraticCurvetoAbs_class = SWIGV8_CreateClassTemplate("_exports_PathQuadraticCurvetoAbs");
SWIGV8_SET_CLASS_TEMPL(_exports_PathQuadraticCurvetoAbs_clientData.class_templ, _exports_PathQuadraticCurvetoAbs_class);
_exports_PathQuadraticCurvetoAbs_clientData.dtor = _wrap_delete_PathQuadraticCurvetoAbs;
if (SWIGTYPE_p_Magick__PathQuadraticCurvetoAbs->clientdata == 0) {
  SWIGTYPE_p_Magick__PathQuadraticCurvetoAbs->clientdata = &_exports_PathQuadraticCurvetoAbs_clientData;
}
/* Name: _exports_PathQuadraticCurvetoRel, Type: p_Magick__PathQuadraticCurvetoRel, Dtor: _wrap_delete_PathQuadraticCurvetoRel */
SWIGV8_FUNCTION_TEMPLATE _exports_PathQuadraticCurvetoRel_class = SWIGV8_CreateClassTemplate("_exports_PathQuadraticCurvetoRel");
SWIGV8_SET_CLASS_TEMPL(_exports_PathQuadraticCurvetoRel_clientData.class_templ, _exports_PathQuadraticCurvetoRel_class);
_exports_PathQuadraticCurvetoRel_clientData.dtor = _wrap_delete_PathQuadraticCurvetoRel;
if (SWIGTYPE_p_Magick__PathQuadraticCurvetoRel->clientdata == 0) {
  SWIGTYPE_p_Magick__PathQuadraticCurvetoRel->clientdata = &_exports_PathQuadraticCurvetoRel_clientData;
}
/* Name: _exports_PathSmoothQuadraticCurvetoAbs, Type: p_Magick__PathSmoothQuadraticCurvetoAbs, Dtor: _wrap_delete_PathSmoothQuadraticCurvetoAbs */
SWIGV8_FUNCTION_TEMPLATE _exports_PathSmoothQuadraticCurvetoAbs_class = SWIGV8_CreateClassTemplate("_exports_PathSmoothQuadraticCurvetoAbs");
SWIGV8_SET_CLASS_TEMPL(_exports_PathSmoothQuadraticCurvetoAbs_clientData.class_templ, _exports_PathSmoothQuadraticCurvetoAbs_class);
_exports_PathSmoothQuadraticCurvetoAbs_clientData.dtor = _wrap_delete_PathSmoothQuadraticCurvetoAbs;
if (SWIGTYPE_p_Magick__PathSmoothQuadraticCurvetoAbs->clientdata == 0) {
  SWIGTYPE_p_Magick__PathSmoothQuadraticCurvetoAbs->clientdata = &_exports_PathSmoothQuadraticCurvetoAbs_clientData;
}
/* Name: _exports_PathSmoothQuadraticCurvetoRel, Type: p_Magick__PathSmoothQuadraticCurvetoRel, Dtor: _wrap_delete_PathSmoothQuadraticCurvetoRel */
SWIGV8_FUNCTION_TEMPLATE _exports_PathSmoothQuadraticCurvetoRel_class = SWIGV8_CreateClassTemplate("_exports_PathSmoothQuadraticCurvetoRel");
SWIGV8_SET_CLASS_TEMPL(_exports_PathSmoothQuadraticCurvetoRel_clientData.class_templ, _exports_PathSmoothQuadraticCurvetoRel_class);
_exports_PathSmoothQuadraticCurvetoRel_clientData.dtor = _wrap_delete_PathSmoothQuadraticCurvetoRel;
if (SWIGTYPE_p_Magick__PathSmoothQuadraticCurvetoRel->clientdata == 0) {
  SWIGTYPE_p_Magick__PathSmoothQuadraticCurvetoRel->clientdata = &_exports_PathSmoothQuadraticCurvetoRel_clientData;
}
/* Name: _exports_PathLinetoAbs, Type: p_Magick__PathLinetoAbs, Dtor: _wrap_delete_PathLinetoAbs */
SWIGV8_FUNCTION_TEMPLATE _exports_PathLinetoAbs_class = SWIGV8_CreateClassTemplate("_exports_PathLinetoAbs");
SWIGV8_SET_CLASS_TEMPL(_exports_PathLinetoAbs_clientData.class_templ, _exports_PathLinetoAbs_class);
_exports_PathLinetoAbs_clientData.dtor = _wrap_delete_PathLinetoAbs;
if (SWIGTYPE_p_Magick__PathLinetoAbs->clientdata == 0) {
  SWIGTYPE_p_Magick__PathLinetoAbs->clientdata = &_exports_PathLinetoAbs_clientData;
}
/* Name: _exports_PathLinetoRel, Type: p_Magick__PathLinetoRel, Dtor: _wrap_delete_PathLinetoRel */
SWIGV8_FUNCTION_TEMPLATE _exports_PathLinetoRel_class = SWIGV8_CreateClassTemplate("_exports_PathLinetoRel");
SWIGV8_SET_CLASS_TEMPL(_exports_PathLinetoRel_clientData.class_templ, _exports_PathLinetoRel_class);
_exports_PathLinetoRel_clientData.dtor = _wrap_delete_PathLinetoRel;
if (SWIGTYPE_p_Magick__PathLinetoRel->clientdata == 0) {
  SWIGTYPE_p_Magick__PathLinetoRel->clientdata = &_exports_PathLinetoRel_clientData;
}
/* Name: _exports_PathLinetoHorizontalAbs, Type: p_Magick__PathLinetoHorizontalAbs, Dtor: _wrap_delete_PathLinetoHorizontalAbs */
SWIGV8_FUNCTION_TEMPLATE _exports_PathLinetoHorizontalAbs_class = SWIGV8_CreateClassTemplate("_exports_PathLinetoHorizontalAbs");
SWIGV8_SET_CLASS_TEMPL(_exports_PathLinetoHorizontalAbs_clientData.class_templ, _exports_PathLinetoHorizontalAbs_class);
_exports_PathLinetoHorizontalAbs_clientData.dtor = _wrap_delete_PathLinetoHorizontalAbs;
if (SWIGTYPE_p_Magick__PathLinetoHorizontalAbs->clientdata == 0) {
  SWIGTYPE_p_Magick__PathLinetoHorizontalAbs->clientdata = &_exports_PathLinetoHorizontalAbs_clientData;
}
/* Name: _exports_PathLinetoHorizontalRel, Type: p_Magick__PathLinetoHorizontalRel, Dtor: _wrap_delete_PathLinetoHorizontalRel */
SWIGV8_FUNCTION_TEMPLATE _exports_PathLinetoHorizontalRel_class = SWIGV8_CreateClassTemplate("_exports_PathLinetoHorizontalRel");
SWIGV8_SET_CLASS_TEMPL(_exports_PathLinetoHorizontalRel_clientData.class_templ, _exports_PathLinetoHorizontalRel_class);
_exports_PathLinetoHorizontalRel_clientData.dtor = _wrap_delete_PathLinetoHorizontalRel;
if (SWIGTYPE_p_Magick__PathLinetoHorizontalRel->clientdata == 0) {
  SWIGTYPE_p_Magick__PathLinetoHorizontalRel->clientdata = &_exports_PathLinetoHorizontalRel_clientData;
}
/* Name: _exports_PathLinetoVerticalAbs, Type: p_Magick__PathLinetoVerticalAbs, Dtor: _wrap_delete_PathLinetoVerticalAbs */
SWIGV8_FUNCTION_TEMPLATE _exports_PathLinetoVerticalAbs_class = SWIGV8_CreateClassTemplate("_exports_PathLinetoVerticalAbs");
SWIGV8_SET_CLASS_TEMPL(_exports_PathLinetoVerticalAbs_clientData.class_templ, _exports_PathLinetoVerticalAbs_class);
_exports_PathLinetoVerticalAbs_clientData.dtor = _wrap_delete_PathLinetoVerticalAbs;
if (SWIGTYPE_p_Magick__PathLinetoVerticalAbs->clientdata == 0) {
  SWIGTYPE_p_Magick__PathLinetoVerticalAbs->clientdata = &_exports_PathLinetoVerticalAbs_clientData;
}
/* Name: _exports_PathLinetoVerticalRel, Type: p_Magick__PathLinetoVerticalRel, Dtor: _wrap_delete_PathLinetoVerticalRel */
SWIGV8_FUNCTION_TEMPLATE _exports_PathLinetoVerticalRel_class = SWIGV8_CreateClassTemplate("_exports_PathLinetoVerticalRel");
SWIGV8_SET_CLASS_TEMPL(_exports_PathLinetoVerticalRel_clientData.class_templ, _exports_PathLinetoVerticalRel_class);
_exports_PathLinetoVerticalRel_clientData.dtor = _wrap_delete_PathLinetoVerticalRel;
if (SWIGTYPE_p_Magick__PathLinetoVerticalRel->clientdata == 0) {
  SWIGTYPE_p_Magick__PathLinetoVerticalRel->clientdata = &_exports_PathLinetoVerticalRel_clientData;
}
/* Name: _exports_PathMovetoAbs, Type: p_Magick__PathMovetoAbs, Dtor: _wrap_delete_PathMovetoAbs */
SWIGV8_FUNCTION_TEMPLATE _exports_PathMovetoAbs_class = SWIGV8_CreateClassTemplate("_exports_PathMovetoAbs");
SWIGV8_SET_CLASS_TEMPL(_exports_PathMovetoAbs_clientData.class_templ, _exports_PathMovetoAbs_class);
_exports_PathMovetoAbs_clientData.dtor = _wrap_delete_PathMovetoAbs;
if (SWIGTYPE_p_Magick__PathMovetoAbs->clientdata == 0) {
  SWIGTYPE_p_Magick__PathMovetoAbs->clientdata = &_exports_PathMovetoAbs_clientData;
}
/* Name: _exports_PathMovetoRel, Type: p_Magick__PathMovetoRel, Dtor: _wrap_delete_PathMovetoRel */
SWIGV8_FUNCTION_TEMPLATE _exports_PathMovetoRel_class = SWIGV8_CreateClassTemplate("_exports_PathMovetoRel");
SWIGV8_SET_CLASS_TEMPL(_exports_PathMovetoRel_clientData.class_templ, _exports_PathMovetoRel_class);
_exports_PathMovetoRel_clientData.dtor = _wrap_delete_PathMovetoRel;
if (SWIGTYPE_p_Magick__PathMovetoRel->clientdata == 0) {
  SWIGTYPE_p_Magick__PathMovetoRel->clientdata = &_exports_PathMovetoRel_clientData;
}
/* Name: _exports_Exception, Type: p_Magick__Exception, Dtor: _wrap_delete_Exception */
SWIGV8_FUNCTION_TEMPLATE _exports_Exception_class = SWIGV8_CreateClassTemplate("_exports_Exception");
SWIGV8_SET_CLASS_TEMPL(_exports_Exception_clientData.class_templ, _exports_Exception_class);
_exports_Exception_clientData.dtor = _wrap_delete_Exception;
if (SWIGTYPE_p_Magick__Exception->clientdata == 0) {
  SWIGTYPE_p_Magick__Exception->clientdata = &_exports_Exception_clientData;
}
/* Name: _exports_Error, Type: p_Magick__Error, Dtor: _wrap_delete_Error */
SWIGV8_FUNCTION_TEMPLATE _exports_Error_class = SWIGV8_CreateClassTemplate("_exports_Error");
SWIGV8_SET_CLASS_TEMPL(_exports_Error_clientData.class_templ, _exports_Error_class);
_exports_Error_clientData.dtor = _wrap_delete_Error;
if (SWIGTYPE_p_Magick__Error->clientdata == 0) {
  SWIGTYPE_p_Magick__Error->clientdata = &_exports_Error_clientData;
}
/* Name: _exports_ErrorBlob, Type: p_Magick__ErrorBlob, Dtor: _wrap_delete_ErrorBlob */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorBlob_class = SWIGV8_CreateClassTemplate("_exports_ErrorBlob");
SWIGV8_SET_CLASS_TEMPL(_exports_ErrorBlob_clientData.class_templ, _exports_ErrorBlob_class);
_exports_ErrorBlob_clientData.dtor = _wrap_delete_ErrorBlob;
if (SWIGTYPE_p_Magick__ErrorBlob->clientdata == 0) {
  SWIGTYPE_p_Magick__ErrorBlob->clientdata = &_exports_ErrorBlob_clientData;
}
/* Name: _exports_ErrorCache, Type: p_Magick__ErrorCache, Dtor: _wrap_delete_ErrorCache */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorCache_class = SWIGV8_CreateClassTemplate("_exports_ErrorCache");
SWIGV8_SET_CLASS_TEMPL(_exports_ErrorCache_clientData.class_templ, _exports_ErrorCache_class);
_exports_ErrorCache_clientData.dtor = _wrap_delete_ErrorCache;
if (SWIGTYPE_p_Magick__ErrorCache->clientdata == 0) {
  SWIGTYPE_p_Magick__ErrorCache->clientdata = &_exports_ErrorCache_clientData;
}
/* Name: _exports_ErrorCoder, Type: p_Magick__ErrorCoder, Dtor: _wrap_delete_ErrorCoder */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorCoder_class = SWIGV8_CreateClassTemplate("_exports_ErrorCoder");
SWIGV8_SET_CLASS_TEMPL(_exports_ErrorCoder_clientData.class_templ, _exports_ErrorCoder_class);
_exports_ErrorCoder_clientData.dtor = _wrap_delete_ErrorCoder;
if (SWIGTYPE_p_Magick__ErrorCoder->clientdata == 0) {
  SWIGTYPE_p_Magick__ErrorCoder->clientdata = &_exports_ErrorCoder_clientData;
}
/* Name: _exports_ErrorConfigure, Type: p_Magick__ErrorConfigure, Dtor: _wrap_delete_ErrorConfigure */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorConfigure_class = SWIGV8_CreateClassTemplate("_exports_ErrorConfigure");
SWIGV8_SET_CLASS_TEMPL(_exports_ErrorConfigure_clientData.class_templ, _exports_ErrorConfigure_class);
_exports_ErrorConfigure_clientData.dtor = _wrap_delete_ErrorConfigure;
if (SWIGTYPE_p_Magick__ErrorConfigure->clientdata == 0) {
  SWIGTYPE_p_Magick__ErrorConfigure->clientdata = &_exports_ErrorConfigure_clientData;
}
/* Name: _exports_ErrorCorruptImage, Type: p_Magick__ErrorCorruptImage, Dtor: _wrap_delete_ErrorCorruptImage */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorCorruptImage_class = SWIGV8_CreateClassTemplate("_exports_ErrorCorruptImage");
SWIGV8_SET_CLASS_TEMPL(_exports_ErrorCorruptImage_clientData.class_templ, _exports_ErrorCorruptImage_class);
_exports_ErrorCorruptImage_clientData.dtor = _wrap_delete_ErrorCorruptImage;
if (SWIGTYPE_p_Magick__ErrorCorruptImage->clientdata == 0) {
  SWIGTYPE_p_Magick__ErrorCorruptImage->clientdata = &_exports_ErrorCorruptImage_clientData;
}
/* Name: _exports_ErrorDelegate, Type: p_Magick__ErrorDelegate, Dtor: _wrap_delete_ErrorDelegate */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorDelegate_class = SWIGV8_CreateClassTemplate("_exports_ErrorDelegate");
SWIGV8_SET_CLASS_TEMPL(_exports_ErrorDelegate_clientData.class_templ, _exports_ErrorDelegate_class);
_exports_ErrorDelegate_clientData.dtor = _wrap_delete_ErrorDelegate;
if (SWIGTYPE_p_Magick__ErrorDelegate->clientdata == 0) {
  SWIGTYPE_p_Magick__ErrorDelegate->clientdata = &_exports_ErrorDelegate_clientData;
}
/* Name: _exports_ErrorDraw, Type: p_Magick__ErrorDraw, Dtor: _wrap_delete_ErrorDraw */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorDraw_class = SWIGV8_CreateClassTemplate("_exports_ErrorDraw");
SWIGV8_SET_CLASS_TEMPL(_exports_ErrorDraw_clientData.class_templ, _exports_ErrorDraw_class);
_exports_ErrorDraw_clientData.dtor = _wrap_delete_ErrorDraw;
if (SWIGTYPE_p_Magick__ErrorDraw->clientdata == 0) {
  SWIGTYPE_p_Magick__ErrorDraw->clientdata = &_exports_ErrorDraw_clientData;
}
/* Name: _exports_ErrorFileOpen, Type: p_Magick__ErrorFileOpen, Dtor: _wrap_delete_ErrorFileOpen */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorFileOpen_class = SWIGV8_CreateClassTemplate("_exports_ErrorFileOpen");
SWIGV8_SET_CLASS_TEMPL(_exports_ErrorFileOpen_clientData.class_templ, _exports_ErrorFileOpen_class);
_exports_ErrorFileOpen_clientData.dtor = _wrap_delete_ErrorFileOpen;
if (SWIGTYPE_p_Magick__ErrorFileOpen->clientdata == 0) {
  SWIGTYPE_p_Magick__ErrorFileOpen->clientdata = &_exports_ErrorFileOpen_clientData;
}
/* Name: _exports_ErrorImage, Type: p_Magick__ErrorImage, Dtor: _wrap_delete_ErrorImage */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorImage_class = SWIGV8_CreateClassTemplate("_exports_ErrorImage");
SWIGV8_SET_CLASS_TEMPL(_exports_ErrorImage_clientData.class_templ, _exports_ErrorImage_class);
_exports_ErrorImage_clientData.dtor = _wrap_delete_ErrorImage;
if (SWIGTYPE_p_Magick__ErrorImage->clientdata == 0) {
  SWIGTYPE_p_Magick__ErrorImage->clientdata = &_exports_ErrorImage_clientData;
}
/* Name: _exports_ErrorMissingDelegate, Type: p_Magick__ErrorMissingDelegate, Dtor: _wrap_delete_ErrorMissingDelegate */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorMissingDelegate_class = SWIGV8_CreateClassTemplate("_exports_ErrorMissingDelegate");
SWIGV8_SET_CLASS_TEMPL(_exports_ErrorMissingDelegate_clientData.class_templ, _exports_ErrorMissingDelegate_class);
_exports_ErrorMissingDelegate_clientData.dtor = _wrap_delete_ErrorMissingDelegate;
if (SWIGTYPE_p_Magick__ErrorMissingDelegate->clientdata == 0) {
  SWIGTYPE_p_Magick__ErrorMissingDelegate->clientdata = &_exports_ErrorMissingDelegate_clientData;
}
/* Name: _exports_ErrorModule, Type: p_Magick__ErrorModule, Dtor: _wrap_delete_ErrorModule */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorModule_class = SWIGV8_CreateClassTemplate("_exports_ErrorModule");
SWIGV8_SET_CLASS_TEMPL(_exports_ErrorModule_clientData.class_templ, _exports_ErrorModule_class);
_exports_ErrorModule_clientData.dtor = _wrap_delete_ErrorModule;
if (SWIGTYPE_p_Magick__ErrorModule->clientdata == 0) {
  SWIGTYPE_p_Magick__ErrorModule->clientdata = &_exports_ErrorModule_clientData;
}
/* Name: _exports_ErrorMonitor, Type: p_Magick__ErrorMonitor, Dtor: _wrap_delete_ErrorMonitor */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorMonitor_class = SWIGV8_CreateClassTemplate("_exports_ErrorMonitor");
SWIGV8_SET_CLASS_TEMPL(_exports_ErrorMonitor_clientData.class_templ, _exports_ErrorMonitor_class);
_exports_ErrorMonitor_clientData.dtor = _wrap_delete_ErrorMonitor;
if (SWIGTYPE_p_Magick__ErrorMonitor->clientdata == 0) {
  SWIGTYPE_p_Magick__ErrorMonitor->clientdata = &_exports_ErrorMonitor_clientData;
}
/* Name: _exports_ErrorOption, Type: p_Magick__ErrorOption, Dtor: _wrap_delete_ErrorOption */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorOption_class = SWIGV8_CreateClassTemplate("_exports_ErrorOption");
SWIGV8_SET_CLASS_TEMPL(_exports_ErrorOption_clientData.class_templ, _exports_ErrorOption_class);
_exports_ErrorOption_clientData.dtor = _wrap_delete_ErrorOption;
if (SWIGTYPE_p_Magick__ErrorOption->clientdata == 0) {
  SWIGTYPE_p_Magick__ErrorOption->clientdata = &_exports_ErrorOption_clientData;
}
/* Name: _exports_ErrorPolicy, Type: p_Magick__ErrorPolicy, Dtor: _wrap_delete_ErrorPolicy */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorPolicy_class = SWIGV8_CreateClassTemplate("_exports_ErrorPolicy");
SWIGV8_SET_CLASS_TEMPL(_exports_ErrorPolicy_clientData.class_templ, _exports_ErrorPolicy_class);
_exports_ErrorPolicy_clientData.dtor = _wrap_delete_ErrorPolicy;
if (SWIGTYPE_p_Magick__ErrorPolicy->clientdata == 0) {
  SWIGTYPE_p_Magick__ErrorPolicy->clientdata = &_exports_ErrorPolicy_clientData;
}
/* Name: _exports_ErrorRegistry, Type: p_Magick__ErrorRegistry, Dtor: _wrap_delete_ErrorRegistry */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorRegistry_class = SWIGV8_CreateClassTemplate("_exports_ErrorRegistry");
SWIGV8_SET_CLASS_TEMPL(_exports_ErrorRegistry_clientData.class_templ, _exports_ErrorRegistry_class);
_exports_ErrorRegistry_clientData.dtor = _wrap_delete_ErrorRegistry;
if (SWIGTYPE_p_Magick__ErrorRegistry->clientdata == 0) {
  SWIGTYPE_p_Magick__ErrorRegistry->clientdata = &_exports_ErrorRegistry_clientData;
}
/* Name: _exports_ErrorResourceLimit, Type: p_Magick__ErrorResourceLimit, Dtor: _wrap_delete_ErrorResourceLimit */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorResourceLimit_class = SWIGV8_CreateClassTemplate("_exports_ErrorResourceLimit");
SWIGV8_SET_CLASS_TEMPL(_exports_ErrorResourceLimit_clientData.class_templ, _exports_ErrorResourceLimit_class);
_exports_ErrorResourceLimit_clientData.dtor = _wrap_delete_ErrorResourceLimit;
if (SWIGTYPE_p_Magick__ErrorResourceLimit->clientdata == 0) {
  SWIGTYPE_p_Magick__ErrorResourceLimit->clientdata = &_exports_ErrorResourceLimit_clientData;
}
/* Name: _exports_ErrorStream, Type: p_Magick__ErrorStream, Dtor: _wrap_delete_ErrorStream */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorStream_class = SWIGV8_CreateClassTemplate("_exports_ErrorStream");
SWIGV8_SET_CLASS_TEMPL(_exports_ErrorStream_clientData.class_templ, _exports_ErrorStream_class);
_exports_ErrorStream_clientData.dtor = _wrap_delete_ErrorStream;
if (SWIGTYPE_p_Magick__ErrorStream->clientdata == 0) {
  SWIGTYPE_p_Magick__ErrorStream->clientdata = &_exports_ErrorStream_clientData;
}
/* Name: _exports_ErrorType, Type: p_Magick__ErrorType, Dtor: _wrap_delete_ErrorType */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorType_class = SWIGV8_CreateClassTemplate("_exports_ErrorType");
SWIGV8_SET_CLASS_TEMPL(_exports_ErrorType_clientData.class_templ, _exports_ErrorType_class);
_exports_ErrorType_clientData.dtor = _wrap_delete_ErrorType;
if (SWIGTYPE_p_Magick__ErrorType->clientdata == 0) {
  SWIGTYPE_p_Magick__ErrorType->clientdata = &_exports_ErrorType_clientData;
}
/* Name: _exports_ErrorUndefined, Type: p_Magick__ErrorUndefined, Dtor: _wrap_delete_ErrorUndefined */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorUndefined_class = SWIGV8_CreateClassTemplate("_exports_ErrorUndefined");
SWIGV8_SET_CLASS_TEMPL(_exports_ErrorUndefined_clientData.class_templ, _exports_ErrorUndefined_class);
_exports_ErrorUndefined_clientData.dtor = _wrap_delete_ErrorUndefined;
if (SWIGTYPE_p_Magick__ErrorUndefined->clientdata == 0) {
  SWIGTYPE_p_Magick__ErrorUndefined->clientdata = &_exports_ErrorUndefined_clientData;
}
/* Name: _exports_ErrorXServer, Type: p_Magick__ErrorXServer, Dtor: _wrap_delete_ErrorXServer */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorXServer_class = SWIGV8_CreateClassTemplate("_exports_ErrorXServer");
SWIGV8_SET_CLASS_TEMPL(_exports_ErrorXServer_clientData.class_templ, _exports_ErrorXServer_class);
_exports_ErrorXServer_clientData.dtor = _wrap_delete_ErrorXServer;
if (SWIGTYPE_p_Magick__ErrorXServer->clientdata == 0) {
  SWIGTYPE_p_Magick__ErrorXServer->clientdata = &_exports_ErrorXServer_clientData;
}
/* Name: _exports_Warning, Type: p_Magick__Warning, Dtor: _wrap_delete_Warning */
SWIGV8_FUNCTION_TEMPLATE _exports_Warning_class = SWIGV8_CreateClassTemplate("_exports_Warning");
SWIGV8_SET_CLASS_TEMPL(_exports_Warning_clientData.class_templ, _exports_Warning_class);
_exports_Warning_clientData.dtor = _wrap_delete_Warning;
if (SWIGTYPE_p_Magick__Warning->clientdata == 0) {
  SWIGTYPE_p_Magick__Warning->clientdata = &_exports_Warning_clientData;
}
/* Name: _exports_WarningBlob, Type: p_Magick__WarningBlob, Dtor: _wrap_delete_WarningBlob */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningBlob_class = SWIGV8_CreateClassTemplate("_exports_WarningBlob");
SWIGV8_SET_CLASS_TEMPL(_exports_WarningBlob_clientData.class_templ, _exports_WarningBlob_class);
_exports_WarningBlob_clientData.dtor = _wrap_delete_WarningBlob;
if (SWIGTYPE_p_Magick__WarningBlob->clientdata == 0) {
  SWIGTYPE_p_Magick__WarningBlob->clientdata = &_exports_WarningBlob_clientData;
}
/* Name: _exports_WarningCache, Type: p_Magick__WarningCache, Dtor: _wrap_delete_WarningCache */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningCache_class = SWIGV8_CreateClassTemplate("_exports_WarningCache");
SWIGV8_SET_CLASS_TEMPL(_exports_WarningCache_clientData.class_templ, _exports_WarningCache_class);
_exports_WarningCache_clientData.dtor = _wrap_delete_WarningCache;
if (SWIGTYPE_p_Magick__WarningCache->clientdata == 0) {
  SWIGTYPE_p_Magick__WarningCache->clientdata = &_exports_WarningCache_clientData;
}
/* Name: _exports_WarningCoder, Type: p_Magick__WarningCoder, Dtor: _wrap_delete_WarningCoder */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningCoder_class = SWIGV8_CreateClassTemplate("_exports_WarningCoder");
SWIGV8_SET_CLASS_TEMPL(_exports_WarningCoder_clientData.class_templ, _exports_WarningCoder_class);
_exports_WarningCoder_clientData.dtor = _wrap_delete_WarningCoder;
if (SWIGTYPE_p_Magick__WarningCoder->clientdata == 0) {
  SWIGTYPE_p_Magick__WarningCoder->clientdata = &_exports_WarningCoder_clientData;
}
/* Name: _exports_WarningConfigure, Type: p_Magick__WarningConfigure, Dtor: _wrap_delete_WarningConfigure */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningConfigure_class = SWIGV8_CreateClassTemplate("_exports_WarningConfigure");
SWIGV8_SET_CLASS_TEMPL(_exports_WarningConfigure_clientData.class_templ, _exports_WarningConfigure_class);
_exports_WarningConfigure_clientData.dtor = _wrap_delete_WarningConfigure;
if (SWIGTYPE_p_Magick__WarningConfigure->clientdata == 0) {
  SWIGTYPE_p_Magick__WarningConfigure->clientdata = &_exports_WarningConfigure_clientData;
}
/* Name: _exports_WarningCorruptImage, Type: p_Magick__WarningCorruptImage, Dtor: _wrap_delete_WarningCorruptImage */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningCorruptImage_class = SWIGV8_CreateClassTemplate("_exports_WarningCorruptImage");
SWIGV8_SET_CLASS_TEMPL(_exports_WarningCorruptImage_clientData.class_templ, _exports_WarningCorruptImage_class);
_exports_WarningCorruptImage_clientData.dtor = _wrap_delete_WarningCorruptImage;
if (SWIGTYPE_p_Magick__WarningCorruptImage->clientdata == 0) {
  SWIGTYPE_p_Magick__WarningCorruptImage->clientdata = &_exports_WarningCorruptImage_clientData;
}
/* Name: _exports_WarningDelegate, Type: p_Magick__WarningDelegate, Dtor: _wrap_delete_WarningDelegate */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningDelegate_class = SWIGV8_CreateClassTemplate("_exports_WarningDelegate");
SWIGV8_SET_CLASS_TEMPL(_exports_WarningDelegate_clientData.class_templ, _exports_WarningDelegate_class);
_exports_WarningDelegate_clientData.dtor = _wrap_delete_WarningDelegate;
if (SWIGTYPE_p_Magick__WarningDelegate->clientdata == 0) {
  SWIGTYPE_p_Magick__WarningDelegate->clientdata = &_exports_WarningDelegate_clientData;
}
/* Name: _exports_WarningDraw, Type: p_Magick__WarningDraw, Dtor: _wrap_delete_WarningDraw */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningDraw_class = SWIGV8_CreateClassTemplate("_exports_WarningDraw");
SWIGV8_SET_CLASS_TEMPL(_exports_WarningDraw_clientData.class_templ, _exports_WarningDraw_class);
_exports_WarningDraw_clientData.dtor = _wrap_delete_WarningDraw;
if (SWIGTYPE_p_Magick__WarningDraw->clientdata == 0) {
  SWIGTYPE_p_Magick__WarningDraw->clientdata = &_exports_WarningDraw_clientData;
}
/* Name: _exports_WarningFileOpen, Type: p_Magick__WarningFileOpen, Dtor: _wrap_delete_WarningFileOpen */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningFileOpen_class = SWIGV8_CreateClassTemplate("_exports_WarningFileOpen");
SWIGV8_SET_CLASS_TEMPL(_exports_WarningFileOpen_clientData.class_templ, _exports_WarningFileOpen_class);
_exports_WarningFileOpen_clientData.dtor = _wrap_delete_WarningFileOpen;
if (SWIGTYPE_p_Magick__WarningFileOpen->clientdata == 0) {
  SWIGTYPE_p_Magick__WarningFileOpen->clientdata = &_exports_WarningFileOpen_clientData;
}
/* Name: _exports_WarningImage, Type: p_Magick__WarningImage, Dtor: _wrap_delete_WarningImage */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningImage_class = SWIGV8_CreateClassTemplate("_exports_WarningImage");
SWIGV8_SET_CLASS_TEMPL(_exports_WarningImage_clientData.class_templ, _exports_WarningImage_class);
_exports_WarningImage_clientData.dtor = _wrap_delete_WarningImage;
if (SWIGTYPE_p_Magick__WarningImage->clientdata == 0) {
  SWIGTYPE_p_Magick__WarningImage->clientdata = &_exports_WarningImage_clientData;
}
/* Name: _exports_WarningMissingDelegate, Type: p_Magick__WarningMissingDelegate, Dtor: _wrap_delete_WarningMissingDelegate */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningMissingDelegate_class = SWIGV8_CreateClassTemplate("_exports_WarningMissingDelegate");
SWIGV8_SET_CLASS_TEMPL(_exports_WarningMissingDelegate_clientData.class_templ, _exports_WarningMissingDelegate_class);
_exports_WarningMissingDelegate_clientData.dtor = _wrap_delete_WarningMissingDelegate;
if (SWIGTYPE_p_Magick__WarningMissingDelegate->clientdata == 0) {
  SWIGTYPE_p_Magick__WarningMissingDelegate->clientdata = &_exports_WarningMissingDelegate_clientData;
}
/* Name: _exports_WarningModule, Type: p_Magick__WarningModule, Dtor: _wrap_delete_WarningModule */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningModule_class = SWIGV8_CreateClassTemplate("_exports_WarningModule");
SWIGV8_SET_CLASS_TEMPL(_exports_WarningModule_clientData.class_templ, _exports_WarningModule_class);
_exports_WarningModule_clientData.dtor = _wrap_delete_WarningModule;
if (SWIGTYPE_p_Magick__WarningModule->clientdata == 0) {
  SWIGTYPE_p_Magick__WarningModule->clientdata = &_exports_WarningModule_clientData;
}
/* Name: _exports_WarningMonitor, Type: p_Magick__WarningMonitor, Dtor: _wrap_delete_WarningMonitor */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningMonitor_class = SWIGV8_CreateClassTemplate("_exports_WarningMonitor");
SWIGV8_SET_CLASS_TEMPL(_exports_WarningMonitor_clientData.class_templ, _exports_WarningMonitor_class);
_exports_WarningMonitor_clientData.dtor = _wrap_delete_WarningMonitor;
if (SWIGTYPE_p_Magick__WarningMonitor->clientdata == 0) {
  SWIGTYPE_p_Magick__WarningMonitor->clientdata = &_exports_WarningMonitor_clientData;
}
/* Name: _exports_WarningOption, Type: p_Magick__WarningOption, Dtor: _wrap_delete_WarningOption */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningOption_class = SWIGV8_CreateClassTemplate("_exports_WarningOption");
SWIGV8_SET_CLASS_TEMPL(_exports_WarningOption_clientData.class_templ, _exports_WarningOption_class);
_exports_WarningOption_clientData.dtor = _wrap_delete_WarningOption;
if (SWIGTYPE_p_Magick__WarningOption->clientdata == 0) {
  SWIGTYPE_p_Magick__WarningOption->clientdata = &_exports_WarningOption_clientData;
}
/* Name: _exports_WarningPolicy, Type: p_Magick__WarningPolicy, Dtor: _wrap_delete_WarningPolicy */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningPolicy_class = SWIGV8_CreateClassTemplate("_exports_WarningPolicy");
SWIGV8_SET_CLASS_TEMPL(_exports_WarningPolicy_clientData.class_templ, _exports_WarningPolicy_class);
_exports_WarningPolicy_clientData.dtor = _wrap_delete_WarningPolicy;
if (SWIGTYPE_p_Magick__WarningPolicy->clientdata == 0) {
  SWIGTYPE_p_Magick__WarningPolicy->clientdata = &_exports_WarningPolicy_clientData;
}
/* Name: _exports_WarningRegistry, Type: p_Magick__WarningRegistry, Dtor: _wrap_delete_WarningRegistry */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningRegistry_class = SWIGV8_CreateClassTemplate("_exports_WarningRegistry");
SWIGV8_SET_CLASS_TEMPL(_exports_WarningRegistry_clientData.class_templ, _exports_WarningRegistry_class);
_exports_WarningRegistry_clientData.dtor = _wrap_delete_WarningRegistry;
if (SWIGTYPE_p_Magick__WarningRegistry->clientdata == 0) {
  SWIGTYPE_p_Magick__WarningRegistry->clientdata = &_exports_WarningRegistry_clientData;
}
/* Name: _exports_WarningResourceLimit, Type: p_Magick__WarningResourceLimit, Dtor: _wrap_delete_WarningResourceLimit */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningResourceLimit_class = SWIGV8_CreateClassTemplate("_exports_WarningResourceLimit");
SWIGV8_SET_CLASS_TEMPL(_exports_WarningResourceLimit_clientData.class_templ, _exports_WarningResourceLimit_class);
_exports_WarningResourceLimit_clientData.dtor = _wrap_delete_WarningResourceLimit;
if (SWIGTYPE_p_Magick__WarningResourceLimit->clientdata == 0) {
  SWIGTYPE_p_Magick__WarningResourceLimit->clientdata = &_exports_WarningResourceLimit_clientData;
}
/* Name: _exports_WarningStream, Type: p_Magick__WarningStream, Dtor: _wrap_delete_WarningStream */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningStream_class = SWIGV8_CreateClassTemplate("_exports_WarningStream");
SWIGV8_SET_CLASS_TEMPL(_exports_WarningStream_clientData.class_templ, _exports_WarningStream_class);
_exports_WarningStream_clientData.dtor = _wrap_delete_WarningStream;
if (SWIGTYPE_p_Magick__WarningStream->clientdata == 0) {
  SWIGTYPE_p_Magick__WarningStream->clientdata = &_exports_WarningStream_clientData;
}
/* Name: _exports_WarningType, Type: p_Magick__WarningType, Dtor: _wrap_delete_WarningType */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningType_class = SWIGV8_CreateClassTemplate("_exports_WarningType");
SWIGV8_SET_CLASS_TEMPL(_exports_WarningType_clientData.class_templ, _exports_WarningType_class);
_exports_WarningType_clientData.dtor = _wrap_delete_WarningType;
if (SWIGTYPE_p_Magick__WarningType->clientdata == 0) {
  SWIGTYPE_p_Magick__WarningType->clientdata = &_exports_WarningType_clientData;
}
/* Name: _exports_WarningUndefined, Type: p_Magick__WarningUndefined, Dtor: _wrap_delete_WarningUndefined */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningUndefined_class = SWIGV8_CreateClassTemplate("_exports_WarningUndefined");
SWIGV8_SET_CLASS_TEMPL(_exports_WarningUndefined_clientData.class_templ, _exports_WarningUndefined_class);
_exports_WarningUndefined_clientData.dtor = _wrap_delete_WarningUndefined;
if (SWIGTYPE_p_Magick__WarningUndefined->clientdata == 0) {
  SWIGTYPE_p_Magick__WarningUndefined->clientdata = &_exports_WarningUndefined_clientData;
}
/* Name: _exports_WarningXServer, Type: p_Magick__WarningXServer, Dtor: _wrap_delete_WarningXServer */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningXServer_class = SWIGV8_CreateClassTemplate("_exports_WarningXServer");
SWIGV8_SET_CLASS_TEMPL(_exports_WarningXServer_clientData.class_templ, _exports_WarningXServer_class);
_exports_WarningXServer_clientData.dtor = _wrap_delete_WarningXServer;
if (SWIGTYPE_p_Magick__WarningXServer->clientdata == 0) {
  SWIGTYPE_p_Magick__WarningXServer->clientdata = &_exports_WarningXServer_clientData;
}
/* Name: _exports_Montage, Type: p_Magick__Montage, Dtor: _wrap_delete_Montage */
SWIGV8_FUNCTION_TEMPLATE _exports_Montage_class = SWIGV8_CreateClassTemplate("_exports_Montage");
SWIGV8_SET_CLASS_TEMPL(_exports_Montage_clientData.class_templ, _exports_Montage_class);
_exports_Montage_clientData.dtor = _wrap_delete_Montage;
if (SWIGTYPE_p_Magick__Montage->clientdata == 0) {
  SWIGTYPE_p_Magick__Montage->clientdata = &_exports_Montage_clientData;
}
/* Name: _exports_MontageFramed, Type: p_Magick__MontageFramed, Dtor: _wrap_delete_MontageFramed */
SWIGV8_FUNCTION_TEMPLATE _exports_MontageFramed_class = SWIGV8_CreateClassTemplate("_exports_MontageFramed");
SWIGV8_SET_CLASS_TEMPL(_exports_MontageFramed_clientData.class_templ, _exports_MontageFramed_class);
_exports_MontageFramed_clientData.dtor = _wrap_delete_MontageFramed;
if (SWIGTYPE_p_Magick__MontageFramed->clientdata == 0) {
  SWIGTYPE_p_Magick__MontageFramed->clientdata = &_exports_MontageFramed_clientData;
}
/* Name: _exports_Image, Type: p_Magick__Image, Dtor: _wrap_delete_Image */
SWIGV8_FUNCTION_TEMPLATE _exports_Image_class = SWIGV8_CreateClassTemplate("_exports_Image");
SWIGV8_SET_CLASS_TEMPL(_exports_Image_clientData.class_templ, _exports_Image_class);
_exports_Image_clientData.dtor = _wrap_delete_Image;
if (SWIGTYPE_p_Magick__Image->clientdata == 0) {
  SWIGTYPE_p_Magick__Image->clientdata = &_exports_Image_clientData;
}


  /* register wrapper functions */
  SWIGV8_AddStaticVariable(exports_obj, "MAGICKCORE_QUANTUM_DEPTH", _wrap_MAGICKCORE_QUANTUM_DEPTH, JS_veto_set_variable, context);
SWIGV8_AddStaticVariable(exports_obj, "MAGICKCORE_HDRI_ENABLE", _wrap_MAGICKCORE_HDRI_ENABLE, JS_veto_set_variable, context);
SWIGV8_AddMemberFunction(_exports_TypeMetric_class, "ascent", _wrap_TypeMetric_ascent);
SWIGV8_AddMemberFunction(_exports_TypeMetric_class, "descent", _wrap_TypeMetric_descent);
SWIGV8_AddMemberFunction(_exports_TypeMetric_class, "maxHorizontalAdvance", _wrap_TypeMetric_maxHorizontalAdvance);
SWIGV8_AddMemberFunction(_exports_TypeMetric_class, "textHeight", _wrap_TypeMetric_textHeight);
SWIGV8_AddMemberFunction(_exports_TypeMetric_class, "textWidth", _wrap_TypeMetric_textWidth);
SWIGV8_AddMemberFunction(_exports_TypeMetric_class, "underlinePosition", _wrap_TypeMetric_underlinePosition);
SWIGV8_AddMemberFunction(_exports_TypeMetric_class, "underlineThickness", _wrap_TypeMetric_underlineThickness);
SWIGV8_AddMemberFunction(_exports_Geometry_class, "aspect", _wrap_Geometry__wrap_Geometry_aspect);
SWIGV8_AddMemberFunction(_exports_Geometry_class, "fillArea", _wrap_Geometry__wrap_Geometry_fillArea);
SWIGV8_AddMemberFunction(_exports_Geometry_class, "greater", _wrap_Geometry__wrap_Geometry_greater);
SWIGV8_AddMemberFunction(_exports_Geometry_class, "height", _wrap_Geometry__wrap_Geometry_height);
SWIGV8_AddMemberFunction(_exports_Geometry_class, "isValid", _wrap_Geometry__wrap_Geometry_isValid);
SWIGV8_AddMemberFunction(_exports_Geometry_class, "less", _wrap_Geometry__wrap_Geometry_less);
SWIGV8_AddMemberFunction(_exports_Geometry_class, "limitPixels", _wrap_Geometry__wrap_Geometry_limitPixels);
SWIGV8_AddMemberFunction(_exports_Geometry_class, "percent", _wrap_Geometry__wrap_Geometry_percent);
SWIGV8_AddMemberFunction(_exports_Geometry_class, "width", _wrap_Geometry__wrap_Geometry_width);
SWIGV8_AddMemberFunction(_exports_Geometry_class, "xNegative", _wrap_Geometry__wrap_Geometry_xNegative);
SWIGV8_AddMemberFunction(_exports_Geometry_class, "xOff", _wrap_Geometry__wrap_Geometry_xOff);
SWIGV8_AddMemberFunction(_exports_Geometry_class, "yNegative", _wrap_Geometry__wrap_Geometry_yNegative);
SWIGV8_AddMemberFunction(_exports_Geometry_class, "yOff", _wrap_Geometry__wrap_Geometry_yOff);
SWIGV8_AddMemberFunction(_exports_Geometry_class, "clone", _wrap_Geometry__wrap_Geometry_clone);
SWIGV8_AddMemberFunction(_exports_Offset_class, "clone", _wrap_Offset__wrap_Offset_clone);
SWIGV8_AddMemberFunction(_exports_Offset_class, "x", _wrap_Offset_x);
SWIGV8_AddMemberFunction(_exports_Offset_class, "y", _wrap_Offset_y);
SWIGV8_AddMemberFunction(_exports_Pixels_class, "get", _wrap_Pixels_get);
SWIGV8_AddMemberFunction(_exports_Pixels_class, "getConst", _wrap_Pixels_getConst);
SWIGV8_AddMemberFunction(_exports_Pixels_class, "set", _wrap_Pixels_set);
SWIGV8_AddMemberFunction(_exports_Pixels_class, "sync", _wrap_Pixels_sync);
SWIGV8_AddMemberFunction(_exports_Pixels_class, "columns", _wrap_Pixels_columns);
SWIGV8_AddMemberFunction(_exports_Pixels_class, "indexes", _wrap_Pixels_indexes);
SWIGV8_AddMemberFunction(_exports_Pixels_class, "rows", _wrap_Pixels_rows);
SWIGV8_AddMemberFunction(_exports_Pixels_class, "x", _wrap_Pixels_x);
SWIGV8_AddMemberFunction(_exports_Pixels_class, "y", _wrap_Pixels_y);
SWIGV8_AddMemberFunction(_exports_PixelData_class, "data", _wrap_PixelData_data);
SWIGV8_AddMemberFunction(_exports_PixelData_class, "length", _wrap_PixelData_length);
SWIGV8_AddMemberFunction(_exports_PixelData_class, "size", _wrap_PixelData_size);
SWIGV8_AddMemberFunction(_exports_adaptiveBlurImage_class, "call", _wrap_adaptiveBlurImage_call);
SWIGV8_AddMemberFunction(_exports_adaptiveThresholdImage_class, "call", _wrap_adaptiveThresholdImage_call);
SWIGV8_AddMemberFunction(_exports_addNoiseImage_class, "call", _wrap_addNoiseImage_call);
SWIGV8_AddMemberFunction(_exports_affineTransformImage_class, "call", _wrap_affineTransformImage_call);
SWIGV8_AddMemberFunction(_exports_annotateImage_class, "call", _wrap_annotateImage_call);
SWIGV8_AddMemberFunction(_exports_blurImage_class, "call", _wrap_blurImage_call);
SWIGV8_AddMemberFunction(_exports_borderImage_class, "call", _wrap_borderImage_call);
SWIGV8_AddMemberFunction(_exports_channelImage_class, "call", _wrap_channelImage_call);
SWIGV8_AddMemberFunction(_exports_charcoalImage_class, "call", _wrap_charcoalImage_call);
SWIGV8_AddMemberFunction(_exports_chopImage_class, "call", _wrap_chopImage_call);
SWIGV8_AddMemberFunction(_exports_cdlImage_class, "call", _wrap_cdlImage_call);
SWIGV8_AddMemberFunction(_exports_colorizeImage_class, "call", _wrap_colorizeImage_call);
SWIGV8_AddMemberFunction(_exports_colorMatrixImage_class, "call", _wrap_colorMatrixImage_call);
SWIGV8_AddMemberFunction(_exports_colorSpaceImage_class, "call", _wrap_colorSpaceImage_call);
SWIGV8_AddMemberFunction(_exports_commentImage_class, "call", _wrap_commentImage_call);
SWIGV8_AddMemberFunction(_exports_compositeImage_class, "call", _wrap_compositeImage_call);
SWIGV8_AddMemberFunction(_exports_contrastImage_class, "call", _wrap_contrastImage_call);
SWIGV8_AddMemberFunction(_exports_cropImage_class, "call", _wrap_cropImage_call);
SWIGV8_AddMemberFunction(_exports_cycleColormapImage_class, "call", _wrap_cycleColormapImage_call);
SWIGV8_AddMemberFunction(_exports_despeckleImage_class, "call", _wrap_despeckleImage_call);
SWIGV8_AddMemberFunction(_exports_distortImage_class, "call", _wrap_distortImage_call);
SWIGV8_AddMemberFunction(_exports_drawImage_class, "call", _wrap_drawImage_call);
SWIGV8_AddMemberFunction(_exports_edgeImage_class, "call", _wrap_edgeImage_call);
SWIGV8_AddMemberFunction(_exports_embossImage_class, "call", _wrap_embossImage_call);
SWIGV8_AddMemberFunction(_exports_enhanceImage_class, "call", _wrap_enhanceImage_call);
SWIGV8_AddMemberFunction(_exports_equalizeImage_class, "call", _wrap_equalizeImage_call);
SWIGV8_AddMemberFunction(_exports_fillColorImage_class, "call", _wrap_fillColorImage_call);
SWIGV8_AddMemberFunction(_exports_flipImage_class, "call", _wrap_flipImage_call);
SWIGV8_AddMemberFunction(_exports_floodFillColorImage_class, "call", _wrap_floodFillColorImage_call);
SWIGV8_AddMemberFunction(_exports_floodFillTextureImage_class, "call", _wrap_floodFillTextureImage_call);
SWIGV8_AddMemberFunction(_exports_flopImage_class, "call", _wrap_flopImage_call);
SWIGV8_AddMemberFunction(_exports_frameImage_class, "call", _wrap_frameImage_call);
SWIGV8_AddMemberFunction(_exports_gammaImage_class, "call", _wrap_gammaImage_call);
SWIGV8_AddMemberFunction(_exports_gaussianBlurImage_class, "call", _wrap_gaussianBlurImage_call);
SWIGV8_AddMemberFunction(_exports_haldClutImage_class, "call", _wrap_haldClutImage_call);
SWIGV8_AddMemberFunction(_exports_implodeImage_class, "call", _wrap_implodeImage_call);
SWIGV8_AddMemberFunction(_exports_inverseFourierTransformImage_class, "call", _wrap_inverseFourierTransformImage_call);
SWIGV8_AddMemberFunction(_exports_isValidImage_class, "call", _wrap_isValidImage_call);
SWIGV8_AddMemberFunction(_exports_labelImage_class, "call", _wrap_labelImage_call);
SWIGV8_AddMemberFunction(_exports_levelImage_class, "call", _wrap_levelImage_call);
SWIGV8_AddMemberFunction(_exports_levelChannelImage_class, "call", _wrap_levelChannelImage_call);
SWIGV8_AddMemberFunction(_exports_magnifyImage_class, "call", _wrap_magnifyImage_call);
SWIGV8_AddMemberFunction(_exports_mapImage_class, "call", _wrap_mapImage_call);
SWIGV8_AddMemberFunction(_exports_matteFloodfillImage_class, "call", _wrap_matteFloodfillImage_call);
SWIGV8_AddMemberFunction(_exports_medianFilterImage_class, "call", _wrap_medianFilterImage_call);
SWIGV8_AddMemberFunction(_exports_mergeLayersImage_class, "call", _wrap_mergeLayersImage_call);
SWIGV8_AddMemberFunction(_exports_minifyImage_class, "call", _wrap_minifyImage_call);
SWIGV8_AddMemberFunction(_exports_modulateImage_class, "call", _wrap_modulateImage_call);
SWIGV8_AddMemberFunction(_exports_negateImage_class, "call", _wrap_negateImage_call);
SWIGV8_AddMemberFunction(_exports_normalizeImage_class, "call", _wrap_normalizeImage_call);
SWIGV8_AddMemberFunction(_exports_oilPaintImage_class, "call", _wrap_oilPaintImage_call);
SWIGV8_AddMemberFunction(_exports_opacityImage_class, "call", _wrap_opacityImage_call);
SWIGV8_AddMemberFunction(_exports_opaqueImage_class, "call", _wrap_opaqueImage_call);
SWIGV8_AddMemberFunction(_exports_quantizeImage_class, "call", _wrap_quantizeImage_call);
SWIGV8_AddMemberFunction(_exports_raiseImage_class, "call", _wrap_raiseImage_call);
SWIGV8_AddMemberFunction(_exports_ReadOptions_class, "density", _wrap_ReadOptions__wrap_ReadOptions_density);
SWIGV8_AddMemberFunction(_exports_ReadOptions_class, "depth", _wrap_ReadOptions__wrap_ReadOptions_depth);
SWIGV8_AddMemberFunction(_exports_ReadOptions_class, "quiet", _wrap_ReadOptions__wrap_ReadOptions_quiet);
SWIGV8_AddMemberFunction(_exports_ReadOptions_class, "size", _wrap_ReadOptions__wrap_ReadOptions_size);
SWIGV8_AddMemberFunction(_exports_ReadOptions_class, "imageInfo", _wrap_ReadOptions_imageInfo);
SWIGV8_AddMemberFunction(_exports_reduceNoiseImage_class, "call", _wrap_reduceNoiseImage_call);
SWIGV8_AddMemberFunction(_exports_resizeImage_class, "call", _wrap_resizeImage_call);
SWIGV8_AddMemberFunction(_exports_rollImage_class, "call", _wrap_rollImage_call);
SWIGV8_AddMemberFunction(_exports_rotateImage_class, "call", _wrap_rotateImage_call);
SWIGV8_AddMemberFunction(_exports_sampleImage_class, "call", _wrap_sampleImage_call);
SWIGV8_AddMemberFunction(_exports_scaleImage_class, "call", _wrap_scaleImage_call);
SWIGV8_AddMemberFunction(_exports_segmentImage_class, "call", _wrap_segmentImage_call);
SWIGV8_AddMemberFunction(_exports_shadeImage_class, "call", _wrap_shadeImage_call);
SWIGV8_AddMemberFunction(_exports_shadowImage_class, "call", _wrap_shadowImage_call);
SWIGV8_AddMemberFunction(_exports_sharpenImage_class, "call", _wrap_sharpenImage_call);
SWIGV8_AddMemberFunction(_exports_shaveImage_class, "call", _wrap_shaveImage_call);
SWIGV8_AddMemberFunction(_exports_shearImage_class, "call", _wrap_shearImage_call);
SWIGV8_AddMemberFunction(_exports_solarizeImage_class, "call", _wrap_solarizeImage_call);
SWIGV8_AddMemberFunction(_exports_spliceImage_class, "call", _wrap_spliceImage_call);
SWIGV8_AddMemberFunction(_exports_spreadImage_class, "call", _wrap_spreadImage_call);
SWIGV8_AddMemberFunction(_exports_steganoImage_class, "call", _wrap_steganoImage_call);
SWIGV8_AddMemberFunction(_exports_stereoImage_class, "call", _wrap_stereoImage_call);
SWIGV8_AddMemberFunction(_exports_strokeColorImage_class, "call", _wrap_strokeColorImage_call);
SWIGV8_AddMemberFunction(_exports_swirlImage_class, "call", _wrap_swirlImage_call);
SWIGV8_AddMemberFunction(_exports_textureImage_class, "call", _wrap_textureImage_call);
SWIGV8_AddMemberFunction(_exports_thresholdImage_class, "call", _wrap_thresholdImage_call);
SWIGV8_AddMemberFunction(_exports_transformImage_class, "call", _wrap_transformImage_call);
SWIGV8_AddMemberFunction(_exports_transparentImage_class, "call", _wrap_transparentImage_call);
SWIGV8_AddMemberFunction(_exports_trimImage_class, "call", _wrap_trimImage_call);
SWIGV8_AddMemberFunction(_exports_waveImage_class, "call", _wrap_waveImage_call);
SWIGV8_AddMemberFunction(_exports_zoomImage_class, "call", _wrap_zoomImage_call);
SWIGV8_AddMemberFunction(_exports_antiAliasImage_class, "call", _wrap_antiAliasImage_call);
SWIGV8_AddMemberFunction(_exports_adjoinImage_class, "call", _wrap_adjoinImage_call);
SWIGV8_AddMemberFunction(_exports_animationDelayImage_class, "call", _wrap_animationDelayImage_call);
SWIGV8_AddMemberFunction(_exports_animationIterationsImage_class, "call", _wrap_animationIterationsImage_call);
SWIGV8_AddMemberFunction(_exports_backgroundColorImage_class, "call", _wrap_backgroundColorImage_call);
SWIGV8_AddMemberFunction(_exports_backgroundTextureImage_class, "call", _wrap_backgroundTextureImage_call);
SWIGV8_AddMemberFunction(_exports_borderColorImage_class, "call", _wrap_borderColorImage_call);
SWIGV8_AddMemberFunction(_exports_boxColorImage_class, "call", _wrap_boxColorImage_call);
SWIGV8_AddMemberFunction(_exports_chromaBluePrimaryImage_class, "call", _wrap_chromaBluePrimaryImage_call);
SWIGV8_AddMemberFunction(_exports_chromaGreenPrimaryImage_class, "call", _wrap_chromaGreenPrimaryImage_call);
SWIGV8_AddMemberFunction(_exports_chromaRedPrimaryImage_class, "call", _wrap_chromaRedPrimaryImage_call);
SWIGV8_AddMemberFunction(_exports_chromaWhitePointImage_class, "call", _wrap_chromaWhitePointImage_call);
SWIGV8_AddMemberFunction(_exports_colorFuzzImage_class, "call", _wrap_colorFuzzImage_call);
SWIGV8_AddMemberFunction(_exports_colorMapImage_class, "call", _wrap_colorMapImage_call);
SWIGV8_AddMemberFunction(_exports_composeImage_class, "call", _wrap_composeImage_call);
SWIGV8_AddMemberFunction(_exports_compressTypeImage_class, "call", _wrap_compressTypeImage_call);
SWIGV8_AddMemberFunction(_exports_densityImage_class, "call", _wrap_densityImage_call);
SWIGV8_AddMemberFunction(_exports_depthImage_class, "call", _wrap_depthImage_call);
SWIGV8_AddMemberFunction(_exports_endianImage_class, "call", _wrap_endianImage_call);
SWIGV8_AddMemberFunction(_exports_fileNameImage_class, "call", _wrap_fileNameImage_call);
SWIGV8_AddMemberFunction(_exports_filterTypeImage_class, "call", _wrap_filterTypeImage_call);
SWIGV8_AddMemberFunction(_exports_fontImage_class, "call", _wrap_fontImage_call);
SWIGV8_AddMemberFunction(_exports_fontPointsizeImage_class, "call", _wrap_fontPointsizeImage_call);
SWIGV8_AddMemberFunction(_exports_gifDisposeMethodImage_class, "call", _wrap_gifDisposeMethodImage_call);
SWIGV8_AddMemberFunction(_exports_interlaceTypeImage_class, "call", _wrap_interlaceTypeImage_call);
SWIGV8_AddMemberFunction(_exports_lineWidthImage_class, "call", _wrap_lineWidthImage_call);
SWIGV8_AddMemberFunction(_exports_magickImage_class, "call", _wrap_magickImage_call);
SWIGV8_AddMemberFunction(_exports_matteImage_class, "call", _wrap_matteImage_call);
SWIGV8_AddMemberFunction(_exports_matteColorImage_class, "call", _wrap_matteColorImage_call);
SWIGV8_AddMemberFunction(_exports_monochromeImage_class, "call", _wrap_monochromeImage_call);
SWIGV8_AddMemberFunction(_exports_penColorImage_class, "call", _wrap_penColorImage_call);
SWIGV8_AddMemberFunction(_exports_penTextureImage_class, "call", _wrap_penTextureImage_call);
SWIGV8_AddMemberFunction(_exports_pixelColorImage_class, "call", _wrap_pixelColorImage_call);
SWIGV8_AddMemberFunction(_exports_pageImage_class, "call", _wrap_pageImage_call);
SWIGV8_AddMemberFunction(_exports_qualityImage_class, "call", _wrap_qualityImage_call);
SWIGV8_AddMemberFunction(_exports_quantizeColorsImage_class, "call", _wrap_quantizeColorsImage_call);
SWIGV8_AddMemberFunction(_exports_quantizeColorSpaceImage_class, "call", _wrap_quantizeColorSpaceImage_call);
SWIGV8_AddMemberFunction(_exports_quantizeDitherImage_class, "call", _wrap_quantizeDitherImage_call);
SWIGV8_AddMemberFunction(_exports_quantizeTreeDepthImage_class, "call", _wrap_quantizeTreeDepthImage_call);
SWIGV8_AddMemberFunction(_exports_renderingIntentImage_class, "call", _wrap_renderingIntentImage_call);
SWIGV8_AddMemberFunction(_exports_resolutionUnitsImage_class, "call", _wrap_resolutionUnitsImage_call);
SWIGV8_AddMemberFunction(_exports_sceneImage_class, "call", _wrap_sceneImage_call);
SWIGV8_AddMemberFunction(_exports_sigmoidalContrastImage_class, "call", _wrap_sigmoidalContrastImage_call);
SWIGV8_AddMemberFunction(_exports_sizeImage_class, "call", _wrap_sizeImage_call);
SWIGV8_AddMemberFunction(_exports_stripImage_class, "call", _wrap_stripImage_call);
SWIGV8_AddMemberFunction(_exports_subImageImage_class, "call", _wrap_subImageImage_call);
SWIGV8_AddMemberFunction(_exports_subRangeImage_class, "call", _wrap_subRangeImage_call);
SWIGV8_AddMemberFunction(_exports_tileNameImage_class, "call", _wrap_tileNameImage_call);
SWIGV8_AddMemberFunction(_exports_typeImage_class, "call", _wrap_typeImage_call);
SWIGV8_AddMemberFunction(_exports_verboseImage_class, "call", _wrap_verboseImage_call);
SWIGV8_AddMemberFunction(_exports_viewImage_class, "call", _wrap_viewImage_call);
SWIGV8_AddMemberFunction(_exports_x11DisplayImage_class, "call", _wrap_x11DisplayImage_call);
SWIGV8_AddMemberFunction(_exports_Blob_class, "clone", _wrap_Blob_clone);
SWIGV8_AddMemberFunction(_exports_Blob_class, "base64", _wrap_Blob__wrap_Blob_base64);
SWIGV8_AddMemberFunction(_exports_Blob_class, "data", _wrap_Blob_data);
SWIGV8_AddMemberFunction(_exports_Blob_class, "length", _wrap_Blob_length);
SWIGV8_AddMemberFunction(_exports_Blob_class, "update", _wrap_Blob_update);
SWIGV8_AddMemberFunction(_exports_Blob_class, "updateNoCopy", _wrap_Blob__wrap_Blob_updateNoCopy);
SWIGV8_AddMemberFunction(_exports_ChannelMoments_class, "centroidX", _wrap_ChannelMoments_centroidX);
SWIGV8_AddMemberFunction(_exports_ChannelMoments_class, "centroidY", _wrap_ChannelMoments_centroidY);
SWIGV8_AddMemberFunction(_exports_ChannelMoments_class, "channel", _wrap_ChannelMoments_channel);
SWIGV8_AddMemberFunction(_exports_ChannelMoments_class, "ellipseAxisX", _wrap_ChannelMoments_ellipseAxisX);
SWIGV8_AddMemberFunction(_exports_ChannelMoments_class, "ellipseAxisY", _wrap_ChannelMoments_ellipseAxisY);
SWIGV8_AddMemberFunction(_exports_ChannelMoments_class, "ellipseAngle", _wrap_ChannelMoments_ellipseAngle);
SWIGV8_AddMemberFunction(_exports_ChannelMoments_class, "ellipseEccentricity", _wrap_ChannelMoments_ellipseEccentricity);
SWIGV8_AddMemberFunction(_exports_ChannelMoments_class, "ellipseIntensity", _wrap_ChannelMoments_ellipseIntensity);
SWIGV8_AddMemberFunction(_exports_ChannelMoments_class, "huInvariants", _wrap_ChannelMoments_huInvariants);
SWIGV8_AddMemberFunction(_exports_ImageMoments_class, "channel", _wrap_ImageMoments__wrap_ImageMoments_channel);
SWIGV8_AddStaticVariable(exports_obj, "Magick_CoderInfo_header", _wrap_Magick_CoderInfo_header, JS_veto_set_variable, context);
SWIGV8_AddMemberFunction(_exports_CoderInfo_class, "clone", _wrap_CoderInfo_clone);
SWIGV8_AddMemberFunction(_exports_CoderInfo_class, "description", _wrap_CoderInfo_description);
SWIGV8_AddMemberFunction(_exports_CoderInfo_class, "isMultiFrame", _wrap_CoderInfo_isMultiFrame);
SWIGV8_AddMemberFunction(_exports_CoderInfo_class, "isReadable", _wrap_CoderInfo_isReadable);
SWIGV8_AddMemberFunction(_exports_CoderInfo_class, "isWritable", _wrap_CoderInfo_isWritable);
SWIGV8_AddMemberFunction(_exports_CoderInfo_class, "mimeType", _wrap_CoderInfo_mimeType);
SWIGV8_AddMemberFunction(_exports_CoderInfo_class, "name", _wrap_CoderInfo_name);
SWIGV8_AddMemberFunction(_exports_CoderInfo_class, "unregister", _wrap_CoderInfo_unregister);
SWIGV8_AddMemberFunction(_exports_Color_class, "clone", _wrap_Color__wrap_Color_clone);
SWIGV8_AddMemberFunction(_exports_Color_class, "alpha", _wrap_Color__wrap_Color_alpha);
SWIGV8_AddMemberFunction(_exports_Color_class, "alphaQuantum", _wrap_Color__wrap_Color_alphaQuantum);
SWIGV8_AddMemberFunction(_exports_Color_class, "blueQuantum", _wrap_Color__wrap_Color_blueQuantum);
SWIGV8_AddMemberFunction(_exports_Color_class, "greenQuantum", _wrap_Color__wrap_Color_greenQuantum);
SWIGV8_AddMemberFunction(_exports_Color_class, "isValid", _wrap_Color__wrap_Color_isValid);
SWIGV8_AddMemberFunction(_exports_Color_class, "redQuantum", _wrap_Color__wrap_Color_redQuantum);
SWIGV8_AddMemberFunction(_exports_Color_class, "intensity", _wrap_Color_intensity);
SWIGV8_AddMemberFunction(_exports_ColorGray_class, "shade", _wrap_ColorGray__wrap_ColorGray_shade);
SWIGV8_AddMemberFunction(_exports_ColorGray_class, "clone", _wrap_ColorGray_clone);
SWIGV8_AddMemberFunction(_exports_ColorHSL_class, "clone", _wrap_ColorHSL_clone);
SWIGV8_AddMemberFunction(_exports_ColorHSL_class, "hue", _wrap_ColorHSL__wrap_ColorHSL_hue);
SWIGV8_AddMemberFunction(_exports_ColorHSL_class, "luminosity", _wrap_ColorHSL__wrap_ColorHSL_luminosity);
SWIGV8_AddMemberFunction(_exports_ColorHSL_class, "saturation", _wrap_ColorHSL__wrap_ColorHSL_saturation);
SWIGV8_AddMemberFunction(_exports_ColorMono_class, "clone", _wrap_ColorMono_clone);
SWIGV8_AddMemberFunction(_exports_ColorMono_class, "mono", _wrap_ColorMono__wrap_ColorMono_mono);
SWIGV8_AddMemberFunction(_exports_ColorRGB_class, "clone", _wrap_ColorRGB_clone);
SWIGV8_AddMemberFunction(_exports_ColorRGB_class, "blue", _wrap_ColorRGB__wrap_ColorRGB_blue);
SWIGV8_AddMemberFunction(_exports_ColorRGB_class, "green", _wrap_ColorRGB__wrap_ColorRGB_green);
SWIGV8_AddMemberFunction(_exports_ColorRGB_class, "red", _wrap_ColorRGB__wrap_ColorRGB_red);
SWIGV8_AddMemberFunction(_exports_ColorYUV_class, "clone", _wrap_ColorYUV_clone);
SWIGV8_AddMemberFunction(_exports_ColorYUV_class, "u", _wrap_ColorYUV__wrap_ColorYUV_u);
SWIGV8_AddMemberFunction(_exports_ColorYUV_class, "v", _wrap_ColorYUV__wrap_ColorYUV_v);
SWIGV8_AddMemberFunction(_exports_ColorYUV_class, "y", _wrap_ColorYUV__wrap_ColorYUV_y);
SWIGV8_AddMemberFunction(_exports_Coordinate_class, "x", _wrap_Coordinate__wrap_Coordinate_x);
SWIGV8_AddMemberFunction(_exports_Coordinate_class, "y", _wrap_Coordinate__wrap_Coordinate_y);
SWIGV8_AddMemberFunction(_exports_DrawableBase_class, "call", _wrap_DrawableBase_call);
SWIGV8_AddMemberFunction(_exports_DrawableBase_class, "copy", _wrap_DrawableBase_copy);
SWIGV8_AddMemberFunction(_exports_Drawable_class, "clone", _wrap_Drawable_clone);
SWIGV8_AddMemberFunction(_exports_Drawable_class, "call", _wrap_Drawable_call);
SWIGV8_AddMemberFunction(_exports_VPathBase_class, "call", _wrap_VPathBase_call);
SWIGV8_AddMemberFunction(_exports_VPathBase_class, "copy", _wrap_VPathBase_copy);
SWIGV8_AddMemberFunction(_exports_VPath_class, "clone", _wrap_VPath_clone);
SWIGV8_AddMemberFunction(_exports_VPath_class, "call", _wrap_VPath_call);
SWIGV8_AddMemberFunction(_exports_DrawableAffine_class, "call", _wrap_DrawableAffine_call);
SWIGV8_AddMemberFunction(_exports_DrawableAffine_class, "copy", _wrap_DrawableAffine_copy);
SWIGV8_AddMemberFunction(_exports_DrawableAffine_class, "sx", _wrap_DrawableAffine__wrap_DrawableAffine_sx);
SWIGV8_AddMemberFunction(_exports_DrawableAffine_class, "sy", _wrap_DrawableAffine__wrap_DrawableAffine_sy);
SWIGV8_AddMemberFunction(_exports_DrawableAffine_class, "rx", _wrap_DrawableAffine__wrap_DrawableAffine_rx);
SWIGV8_AddMemberFunction(_exports_DrawableAffine_class, "ry", _wrap_DrawableAffine__wrap_DrawableAffine_ry);
SWIGV8_AddMemberFunction(_exports_DrawableAffine_class, "tx", _wrap_DrawableAffine__wrap_DrawableAffine_tx);
SWIGV8_AddMemberFunction(_exports_DrawableAffine_class, "ty", _wrap_DrawableAffine__wrap_DrawableAffine_ty);
SWIGV8_AddMemberFunction(_exports_DrawableArc_class, "call", _wrap_DrawableArc_call);
SWIGV8_AddMemberFunction(_exports_DrawableArc_class, "copy", _wrap_DrawableArc_copy);
SWIGV8_AddMemberFunction(_exports_DrawableArc_class, "startX", _wrap_DrawableArc__wrap_DrawableArc_startX);
SWIGV8_AddMemberFunction(_exports_DrawableArc_class, "startY", _wrap_DrawableArc__wrap_DrawableArc_startY);
SWIGV8_AddMemberFunction(_exports_DrawableArc_class, "endX", _wrap_DrawableArc__wrap_DrawableArc_endX);
SWIGV8_AddMemberFunction(_exports_DrawableArc_class, "endY", _wrap_DrawableArc__wrap_DrawableArc_endY);
SWIGV8_AddMemberFunction(_exports_DrawableArc_class, "startDegrees", _wrap_DrawableArc__wrap_DrawableArc_startDegrees);
SWIGV8_AddMemberFunction(_exports_DrawableArc_class, "endDegrees", _wrap_DrawableArc__wrap_DrawableArc_endDegrees);
SWIGV8_AddMemberFunction(_exports_DrawableBezier_class, "call", _wrap_DrawableBezier_call);
SWIGV8_AddMemberFunction(_exports_DrawableBezier_class, "copy", _wrap_DrawableBezier_copy);
SWIGV8_AddMemberFunction(_exports_DrawablePopClipPath_class, "call", _wrap_DrawablePopClipPath_call);
SWIGV8_AddMemberFunction(_exports_DrawablePopClipPath_class, "copy", _wrap_DrawablePopClipPath_copy);
SWIGV8_AddMemberFunction(_exports_DrawablePushClipPath_class, "call", _wrap_DrawablePushClipPath_call);
SWIGV8_AddMemberFunction(_exports_DrawablePushClipPath_class, "copy", _wrap_DrawablePushClipPath_copy);
SWIGV8_AddMemberFunction(_exports_DrawableClipPath_class, "call", _wrap_DrawableClipPath_call);
SWIGV8_AddMemberFunction(_exports_DrawableClipPath_class, "copy", _wrap_DrawableClipPath_copy);
SWIGV8_AddMemberFunction(_exports_DrawableClipPath_class, "clip_path", _wrap_DrawableClipPath__wrap_DrawableClipPath_clip_path);
SWIGV8_AddMemberFunction(_exports_DrawableCircle_class, "call", _wrap_DrawableCircle_call);
SWIGV8_AddMemberFunction(_exports_DrawableCircle_class, "copy", _wrap_DrawableCircle_copy);
SWIGV8_AddMemberFunction(_exports_DrawableCircle_class, "originX", _wrap_DrawableCircle__wrap_DrawableCircle_originX);
SWIGV8_AddMemberFunction(_exports_DrawableCircle_class, "originY", _wrap_DrawableCircle__wrap_DrawableCircle_originY);
SWIGV8_AddMemberFunction(_exports_DrawableCircle_class, "perimX", _wrap_DrawableCircle__wrap_DrawableCircle_perimX);
SWIGV8_AddMemberFunction(_exports_DrawableCircle_class, "perimY", _wrap_DrawableCircle__wrap_DrawableCircle_perimY);
SWIGV8_AddMemberFunction(_exports_DrawableColor_class, "call", _wrap_DrawableColor_call);
SWIGV8_AddMemberFunction(_exports_DrawableColor_class, "copy", _wrap_DrawableColor_copy);
SWIGV8_AddMemberFunction(_exports_DrawableColor_class, "x", _wrap_DrawableColor__wrap_DrawableColor_x);
SWIGV8_AddMemberFunction(_exports_DrawableColor_class, "y", _wrap_DrawableColor__wrap_DrawableColor_y);
SWIGV8_AddMemberFunction(_exports_DrawableColor_class, "paintMethod", _wrap_DrawableColor__wrap_DrawableColor_paintMethod);
SWIGV8_AddMemberFunction(_exports_DrawableCompositeImage_class, "clone", _wrap_DrawableCompositeImage_clone);
SWIGV8_AddMemberFunction(_exports_DrawableCompositeImage_class, "call", _wrap_DrawableCompositeImage_call);
SWIGV8_AddMemberFunction(_exports_DrawableCompositeImage_class, "copy", _wrap_DrawableCompositeImage_copy);
SWIGV8_AddMemberFunction(_exports_DrawableCompositeImage_class, "composition", _wrap_DrawableCompositeImage__wrap_DrawableCompositeImage_composition);
SWIGV8_AddMemberFunction(_exports_DrawableCompositeImage_class, "filename", _wrap_DrawableCompositeImage__wrap_DrawableCompositeImage_filename);
SWIGV8_AddMemberFunction(_exports_DrawableCompositeImage_class, "x", _wrap_DrawableCompositeImage__wrap_DrawableCompositeImage_x);
SWIGV8_AddMemberFunction(_exports_DrawableCompositeImage_class, "y", _wrap_DrawableCompositeImage__wrap_DrawableCompositeImage_y);
SWIGV8_AddMemberFunction(_exports_DrawableCompositeImage_class, "width", _wrap_DrawableCompositeImage__wrap_DrawableCompositeImage_width);
SWIGV8_AddMemberFunction(_exports_DrawableCompositeImage_class, "height", _wrap_DrawableCompositeImage__wrap_DrawableCompositeImage_height);
SWIGV8_AddMemberFunction(_exports_DrawableCompositeImage_class, "image", _wrap_DrawableCompositeImage__wrap_DrawableCompositeImage_image);
SWIGV8_AddMemberFunction(_exports_DrawableCompositeImage_class, "magick", _wrap_DrawableCompositeImage__wrap_DrawableCompositeImage_magick);
SWIGV8_AddMemberFunction(_exports_DrawableDensity_class, "call", _wrap_DrawableDensity_call);
SWIGV8_AddMemberFunction(_exports_DrawableDensity_class, "copy", _wrap_DrawableDensity_copy);
SWIGV8_AddMemberFunction(_exports_DrawableEllipse_class, "call", _wrap_DrawableEllipse_call);
SWIGV8_AddMemberFunction(_exports_DrawableEllipse_class, "copy", _wrap_DrawableEllipse_copy);
SWIGV8_AddMemberFunction(_exports_DrawableEllipse_class, "originX", _wrap_DrawableEllipse__wrap_DrawableEllipse_originX);
SWIGV8_AddMemberFunction(_exports_DrawableEllipse_class, "originY", _wrap_DrawableEllipse__wrap_DrawableEllipse_originY);
SWIGV8_AddMemberFunction(_exports_DrawableEllipse_class, "radiusX", _wrap_DrawableEllipse__wrap_DrawableEllipse_radiusX);
SWIGV8_AddMemberFunction(_exports_DrawableEllipse_class, "radiusY", _wrap_DrawableEllipse__wrap_DrawableEllipse_radiusY);
SWIGV8_AddMemberFunction(_exports_DrawableEllipse_class, "arcStart", _wrap_DrawableEllipse__wrap_DrawableEllipse_arcStart);
SWIGV8_AddMemberFunction(_exports_DrawableEllipse_class, "arcEnd", _wrap_DrawableEllipse__wrap_DrawableEllipse_arcEnd);
SWIGV8_AddMemberFunction(_exports_DrawableFillColor_class, "call", _wrap_DrawableFillColor_call);
SWIGV8_AddMemberFunction(_exports_DrawableFillColor_class, "copy", _wrap_DrawableFillColor_copy);
SWIGV8_AddMemberFunction(_exports_DrawableFillColor_class, "color", _wrap_DrawableFillColor__wrap_DrawableFillColor_color);
SWIGV8_AddMemberFunction(_exports_DrawableFillRule_class, "call", _wrap_DrawableFillRule_call);
SWIGV8_AddMemberFunction(_exports_DrawableFillRule_class, "copy", _wrap_DrawableFillRule_copy);
SWIGV8_AddMemberFunction(_exports_DrawableFillRule_class, "fillRule", _wrap_DrawableFillRule__wrap_DrawableFillRule_fillRule);
SWIGV8_AddMemberFunction(_exports_DrawableFillOpacity_class, "call", _wrap_DrawableFillOpacity_call);
SWIGV8_AddMemberFunction(_exports_DrawableFillOpacity_class, "copy", _wrap_DrawableFillOpacity_copy);
SWIGV8_AddMemberFunction(_exports_DrawableFillOpacity_class, "opacity", _wrap_DrawableFillOpacity__wrap_DrawableFillOpacity_opacity);
SWIGV8_AddMemberFunction(_exports_DrawableFont_class, "call", _wrap_DrawableFont_call);
SWIGV8_AddMemberFunction(_exports_DrawableFont_class, "copy", _wrap_DrawableFont_copy);
SWIGV8_AddMemberFunction(_exports_DrawableFont_class, "font", _wrap_DrawableFont__wrap_DrawableFont_font);
SWIGV8_AddMemberFunction(_exports_DrawableGravity_class, "call", _wrap_DrawableGravity_call);
SWIGV8_AddMemberFunction(_exports_DrawableGravity_class, "copy", _wrap_DrawableGravity_copy);
SWIGV8_AddMemberFunction(_exports_DrawableGravity_class, "gravity", _wrap_DrawableGravity__wrap_DrawableGravity_gravity);
SWIGV8_AddMemberFunction(_exports_DrawableLine_class, "call", _wrap_DrawableLine_call);
SWIGV8_AddMemberFunction(_exports_DrawableLine_class, "copy", _wrap_DrawableLine_copy);
SWIGV8_AddMemberFunction(_exports_DrawableLine_class, "startX", _wrap_DrawableLine__wrap_DrawableLine_startX);
SWIGV8_AddMemberFunction(_exports_DrawableLine_class, "startY", _wrap_DrawableLine__wrap_DrawableLine_startY);
SWIGV8_AddMemberFunction(_exports_DrawableLine_class, "endX", _wrap_DrawableLine__wrap_DrawableLine_endX);
SWIGV8_AddMemberFunction(_exports_DrawableLine_class, "endY", _wrap_DrawableLine__wrap_DrawableLine_endY);
SWIGV8_AddMemberFunction(_exports_DrawableMatte_class, "call", _wrap_DrawableMatte_call);
SWIGV8_AddMemberFunction(_exports_DrawableMatte_class, "copy", _wrap_DrawableMatte_copy);
SWIGV8_AddMemberFunction(_exports_DrawableMatte_class, "x", _wrap_DrawableMatte__wrap_DrawableMatte_x);
SWIGV8_AddMemberFunction(_exports_DrawableMatte_class, "y", _wrap_DrawableMatte__wrap_DrawableMatte_y);
SWIGV8_AddMemberFunction(_exports_DrawableMatte_class, "paintMethod", _wrap_DrawableMatte__wrap_DrawableMatte_paintMethod);
SWIGV8_AddMemberFunction(_exports_DrawablePath_class, "call", _wrap_DrawablePath_call);
SWIGV8_AddMemberFunction(_exports_DrawablePath_class, "copy", _wrap_DrawablePath_copy);
SWIGV8_AddMemberFunction(_exports_DrawablePoint_class, "call", _wrap_DrawablePoint_call);
SWIGV8_AddMemberFunction(_exports_DrawablePoint_class, "copy", _wrap_DrawablePoint_copy);
SWIGV8_AddMemberFunction(_exports_DrawablePoint_class, "x", _wrap_DrawablePoint__wrap_DrawablePoint_x);
SWIGV8_AddMemberFunction(_exports_DrawablePoint_class, "y", _wrap_DrawablePoint__wrap_DrawablePoint_y);
SWIGV8_AddMemberFunction(_exports_DrawablePointSize_class, "call", _wrap_DrawablePointSize_call);
SWIGV8_AddMemberFunction(_exports_DrawablePointSize_class, "copy", _wrap_DrawablePointSize_copy);
SWIGV8_AddMemberFunction(_exports_DrawablePointSize_class, "pointSize", _wrap_DrawablePointSize__wrap_DrawablePointSize_pointSize);
SWIGV8_AddMemberFunction(_exports_DrawablePolygon_class, "call", _wrap_DrawablePolygon_call);
SWIGV8_AddMemberFunction(_exports_DrawablePolygon_class, "copy", _wrap_DrawablePolygon_copy);
SWIGV8_AddMemberFunction(_exports_DrawablePolyline_class, "call", _wrap_DrawablePolyline_call);
SWIGV8_AddMemberFunction(_exports_DrawablePolyline_class, "copy", _wrap_DrawablePolyline_copy);
SWIGV8_AddMemberFunction(_exports_DrawablePopGraphicContext_class, "call", _wrap_DrawablePopGraphicContext_call);
SWIGV8_AddMemberFunction(_exports_DrawablePopGraphicContext_class, "copy", _wrap_DrawablePopGraphicContext_copy);
SWIGV8_AddMemberFunction(_exports_DrawablePushGraphicContext_class, "call", _wrap_DrawablePushGraphicContext_call);
SWIGV8_AddMemberFunction(_exports_DrawablePushGraphicContext_class, "copy", _wrap_DrawablePushGraphicContext_copy);
SWIGV8_AddMemberFunction(_exports_DrawablePopPattern_class, "call", _wrap_DrawablePopPattern_call);
SWIGV8_AddMemberFunction(_exports_DrawablePopPattern_class, "copy", _wrap_DrawablePopPattern_copy);
SWIGV8_AddMemberFunction(_exports_DrawablePushPattern_class, "call", _wrap_DrawablePushPattern_call);
SWIGV8_AddMemberFunction(_exports_DrawablePushPattern_class, "copy", _wrap_DrawablePushPattern_copy);
SWIGV8_AddMemberFunction(_exports_DrawableRectangle_class, "call", _wrap_DrawableRectangle_call);
SWIGV8_AddMemberFunction(_exports_DrawableRectangle_class, "copy", _wrap_DrawableRectangle_copy);
SWIGV8_AddMemberFunction(_exports_DrawableRectangle_class, "upperLeftX", _wrap_DrawableRectangle__wrap_DrawableRectangle_upperLeftX);
SWIGV8_AddMemberFunction(_exports_DrawableRectangle_class, "upperLeftY", _wrap_DrawableRectangle__wrap_DrawableRectangle_upperLeftY);
SWIGV8_AddMemberFunction(_exports_DrawableRectangle_class, "lowerRightX", _wrap_DrawableRectangle__wrap_DrawableRectangle_lowerRightX);
SWIGV8_AddMemberFunction(_exports_DrawableRectangle_class, "lowerRightY", _wrap_DrawableRectangle__wrap_DrawableRectangle_lowerRightY);
SWIGV8_AddMemberFunction(_exports_DrawableRotation_class, "call", _wrap_DrawableRotation_call);
SWIGV8_AddMemberFunction(_exports_DrawableRotation_class, "copy", _wrap_DrawableRotation_copy);
SWIGV8_AddMemberFunction(_exports_DrawableRotation_class, "angle", _wrap_DrawableRotation__wrap_DrawableRotation_angle);
SWIGV8_AddMemberFunction(_exports_DrawableRoundRectangle_class, "call", _wrap_DrawableRoundRectangle_call);
SWIGV8_AddMemberFunction(_exports_DrawableRoundRectangle_class, "copy", _wrap_DrawableRoundRectangle_copy);
SWIGV8_AddMemberFunction(_exports_DrawableRoundRectangle_class, "centerX", _wrap_DrawableRoundRectangle__wrap_DrawableRoundRectangle_centerX);
SWIGV8_AddMemberFunction(_exports_DrawableRoundRectangle_class, "centerY", _wrap_DrawableRoundRectangle__wrap_DrawableRoundRectangle_centerY);
SWIGV8_AddMemberFunction(_exports_DrawableRoundRectangle_class, "width", _wrap_DrawableRoundRectangle__wrap_DrawableRoundRectangle_width);
SWIGV8_AddMemberFunction(_exports_DrawableRoundRectangle_class, "hight", _wrap_DrawableRoundRectangle__wrap_DrawableRoundRectangle_hight);
SWIGV8_AddMemberFunction(_exports_DrawableRoundRectangle_class, "upperLeftX", _wrap_DrawableRoundRectangle__wrap_DrawableRoundRectangle_upperLeftX);
SWIGV8_AddMemberFunction(_exports_DrawableRoundRectangle_class, "upperLeftY", _wrap_DrawableRoundRectangle__wrap_DrawableRoundRectangle_upperLeftY);
SWIGV8_AddMemberFunction(_exports_DrawableRoundRectangle_class, "lowerRightX", _wrap_DrawableRoundRectangle__wrap_DrawableRoundRectangle_lowerRightX);
SWIGV8_AddMemberFunction(_exports_DrawableRoundRectangle_class, "lowerRightY", _wrap_DrawableRoundRectangle__wrap_DrawableRoundRectangle_lowerRightY);
SWIGV8_AddMemberFunction(_exports_DrawableRoundRectangle_class, "cornerWidth", _wrap_DrawableRoundRectangle__wrap_DrawableRoundRectangle_cornerWidth);
SWIGV8_AddMemberFunction(_exports_DrawableRoundRectangle_class, "cornerHeight", _wrap_DrawableRoundRectangle__wrap_DrawableRoundRectangle_cornerHeight);
SWIGV8_AddMemberFunction(_exports_DrawableScaling_class, "call", _wrap_DrawableScaling_call);
SWIGV8_AddMemberFunction(_exports_DrawableScaling_class, "copy", _wrap_DrawableScaling_copy);
SWIGV8_AddMemberFunction(_exports_DrawableScaling_class, "x", _wrap_DrawableScaling__wrap_DrawableScaling_x);
SWIGV8_AddMemberFunction(_exports_DrawableScaling_class, "y", _wrap_DrawableScaling__wrap_DrawableScaling_y);
SWIGV8_AddMemberFunction(_exports_DrawableSkewX_class, "call", _wrap_DrawableSkewX_call);
SWIGV8_AddMemberFunction(_exports_DrawableSkewX_class, "copy", _wrap_DrawableSkewX_copy);
SWIGV8_AddMemberFunction(_exports_DrawableSkewX_class, "angle", _wrap_DrawableSkewX__wrap_DrawableSkewX_angle);
SWIGV8_AddMemberFunction(_exports_DrawableSkewY_class, "call", _wrap_DrawableSkewY_call);
SWIGV8_AddMemberFunction(_exports_DrawableSkewY_class, "copy", _wrap_DrawableSkewY_copy);
SWIGV8_AddMemberFunction(_exports_DrawableSkewY_class, "angle", _wrap_DrawableSkewY__wrap_DrawableSkewY_angle);
SWIGV8_AddMemberFunction(_exports_DrawableDashArray_class, "call", _wrap_DrawableDashArray_call);
SWIGV8_AddMemberFunction(_exports_DrawableDashArray_class, "copy", _wrap_DrawableDashArray_copy);
SWIGV8_AddMemberFunction(_exports_DrawableDashArray_class, "dasharray", _wrap_DrawableDashArray__wrap_DrawableDashArray_dasharray);
SWIGV8_AddMemberFunction(_exports_DrawableDashArray_class, "clone", _wrap_DrawableDashArray_clone);
SWIGV8_AddMemberFunction(_exports_DrawableDashOffset_class, "call", _wrap_DrawableDashOffset_call);
SWIGV8_AddMemberFunction(_exports_DrawableDashOffset_class, "copy", _wrap_DrawableDashOffset_copy);
SWIGV8_AddMemberFunction(_exports_DrawableDashOffset_class, "offset", _wrap_DrawableDashOffset__wrap_DrawableDashOffset_offset);
SWIGV8_AddMemberFunction(_exports_DrawableStrokeLineCap_class, "call", _wrap_DrawableStrokeLineCap_call);
SWIGV8_AddMemberFunction(_exports_DrawableStrokeLineCap_class, "copy", _wrap_DrawableStrokeLineCap_copy);
SWIGV8_AddMemberFunction(_exports_DrawableStrokeLineCap_class, "linecap", _wrap_DrawableStrokeLineCap__wrap_DrawableStrokeLineCap_linecap);
SWIGV8_AddMemberFunction(_exports_DrawableStrokeLineJoin_class, "call", _wrap_DrawableStrokeLineJoin_call);
SWIGV8_AddMemberFunction(_exports_DrawableStrokeLineJoin_class, "copy", _wrap_DrawableStrokeLineJoin_copy);
SWIGV8_AddMemberFunction(_exports_DrawableStrokeLineJoin_class, "linejoin", _wrap_DrawableStrokeLineJoin__wrap_DrawableStrokeLineJoin_linejoin);
SWIGV8_AddMemberFunction(_exports_DrawableMiterLimit_class, "call", _wrap_DrawableMiterLimit_call);
SWIGV8_AddMemberFunction(_exports_DrawableMiterLimit_class, "copy", _wrap_DrawableMiterLimit_copy);
SWIGV8_AddMemberFunction(_exports_DrawableMiterLimit_class, "miterlimit", _wrap_DrawableMiterLimit__wrap_DrawableMiterLimit_miterlimit);
SWIGV8_AddMemberFunction(_exports_DrawableStrokeAntialias_class, "call", _wrap_DrawableStrokeAntialias_call);
SWIGV8_AddMemberFunction(_exports_DrawableStrokeAntialias_class, "copy", _wrap_DrawableStrokeAntialias_copy);
SWIGV8_AddMemberFunction(_exports_DrawableStrokeAntialias_class, "flag", _wrap_DrawableStrokeAntialias__wrap_DrawableStrokeAntialias_flag);
SWIGV8_AddMemberFunction(_exports_DrawableStrokeColor_class, "call", _wrap_DrawableStrokeColor_call);
SWIGV8_AddMemberFunction(_exports_DrawableStrokeColor_class, "copy", _wrap_DrawableStrokeColor_copy);
SWIGV8_AddMemberFunction(_exports_DrawableStrokeColor_class, "color", _wrap_DrawableStrokeColor__wrap_DrawableStrokeColor_color);
SWIGV8_AddMemberFunction(_exports_DrawableStrokeOpacity_class, "call", _wrap_DrawableStrokeOpacity_call);
SWIGV8_AddMemberFunction(_exports_DrawableStrokeOpacity_class, "copy", _wrap_DrawableStrokeOpacity_copy);
SWIGV8_AddMemberFunction(_exports_DrawableStrokeOpacity_class, "opacity", _wrap_DrawableStrokeOpacity__wrap_DrawableStrokeOpacity_opacity);
SWIGV8_AddMemberFunction(_exports_DrawableStrokeWidth_class, "call", _wrap_DrawableStrokeWidth_call);
SWIGV8_AddMemberFunction(_exports_DrawableStrokeWidth_class, "copy", _wrap_DrawableStrokeWidth_copy);
SWIGV8_AddMemberFunction(_exports_DrawableStrokeWidth_class, "width", _wrap_DrawableStrokeWidth__wrap_DrawableStrokeWidth_width);
SWIGV8_AddMemberFunction(_exports_DrawableText_class, "call", _wrap_DrawableText_call);
SWIGV8_AddMemberFunction(_exports_DrawableText_class, "copy", _wrap_DrawableText_copy);
SWIGV8_AddMemberFunction(_exports_DrawableText_class, "encoding", _wrap_DrawableText_encoding);
SWIGV8_AddMemberFunction(_exports_DrawableText_class, "x", _wrap_DrawableText__wrap_DrawableText_x);
SWIGV8_AddMemberFunction(_exports_DrawableText_class, "y", _wrap_DrawableText__wrap_DrawableText_y);
SWIGV8_AddMemberFunction(_exports_DrawableText_class, "text", _wrap_DrawableText__wrap_DrawableText_text);
SWIGV8_AddMemberFunction(_exports_DrawableTextAntialias_class, "call", _wrap_DrawableTextAntialias_call);
SWIGV8_AddMemberFunction(_exports_DrawableTextAntialias_class, "copy", _wrap_DrawableTextAntialias_copy);
SWIGV8_AddMemberFunction(_exports_DrawableTextAntialias_class, "flag", _wrap_DrawableTextAntialias__wrap_DrawableTextAntialias_flag);
SWIGV8_AddMemberFunction(_exports_DrawableTextDecoration_class, "call", _wrap_DrawableTextDecoration_call);
SWIGV8_AddMemberFunction(_exports_DrawableTextDecoration_class, "copy", _wrap_DrawableTextDecoration_copy);
SWIGV8_AddMemberFunction(_exports_DrawableTextDecoration_class, "decoration", _wrap_DrawableTextDecoration__wrap_DrawableTextDecoration_decoration);
SWIGV8_AddMemberFunction(_exports_DrawableTextDirection_class, "call", _wrap_DrawableTextDirection_call);
SWIGV8_AddMemberFunction(_exports_DrawableTextDirection_class, "direction", _wrap_DrawableTextDirection__wrap_DrawableTextDirection_direction);
SWIGV8_AddMemberFunction(_exports_DrawableTextDirection_class, "copy", _wrap_DrawableTextDirection_copy);
SWIGV8_AddMemberFunction(_exports_DrawableTextInterlineSpacing_class, "call", _wrap_DrawableTextInterlineSpacing_call);
SWIGV8_AddMemberFunction(_exports_DrawableTextInterlineSpacing_class, "spacing", _wrap_DrawableTextInterlineSpacing__wrap_DrawableTextInterlineSpacing_spacing);
SWIGV8_AddMemberFunction(_exports_DrawableTextInterlineSpacing_class, "copy", _wrap_DrawableTextInterlineSpacing_copy);
SWIGV8_AddMemberFunction(_exports_DrawableTextInterwordSpacing_class, "call", _wrap_DrawableTextInterwordSpacing_call);
SWIGV8_AddMemberFunction(_exports_DrawableTextInterwordSpacing_class, "spacing", _wrap_DrawableTextInterwordSpacing__wrap_DrawableTextInterwordSpacing_spacing);
SWIGV8_AddMemberFunction(_exports_DrawableTextInterwordSpacing_class, "copy", _wrap_DrawableTextInterwordSpacing_copy);
SWIGV8_AddMemberFunction(_exports_DrawableTextKerning_class, "call", _wrap_DrawableTextKerning_call);
SWIGV8_AddMemberFunction(_exports_DrawableTextKerning_class, "kerning", _wrap_DrawableTextKerning__wrap_DrawableTextKerning_kerning);
SWIGV8_AddMemberFunction(_exports_DrawableTextKerning_class, "copy", _wrap_DrawableTextKerning_copy);
SWIGV8_AddMemberFunction(_exports_DrawableTextUnderColor_class, "call", _wrap_DrawableTextUnderColor_call);
SWIGV8_AddMemberFunction(_exports_DrawableTextUnderColor_class, "copy", _wrap_DrawableTextUnderColor_copy);
SWIGV8_AddMemberFunction(_exports_DrawableTextUnderColor_class, "color", _wrap_DrawableTextUnderColor__wrap_DrawableTextUnderColor_color);
SWIGV8_AddMemberFunction(_exports_DrawableTranslation_class, "call", _wrap_DrawableTranslation_call);
SWIGV8_AddMemberFunction(_exports_DrawableTranslation_class, "copy", _wrap_DrawableTranslation_copy);
SWIGV8_AddMemberFunction(_exports_DrawableTranslation_class, "x", _wrap_DrawableTranslation__wrap_DrawableTranslation_x);
SWIGV8_AddMemberFunction(_exports_DrawableTranslation_class, "y", _wrap_DrawableTranslation__wrap_DrawableTranslation_y);
SWIGV8_AddMemberFunction(_exports_DrawableViewbox_class, "call", _wrap_DrawableViewbox_call);
SWIGV8_AddMemberFunction(_exports_DrawableViewbox_class, "copy", _wrap_DrawableViewbox_copy);
SWIGV8_AddMemberFunction(_exports_DrawableViewbox_class, "x1", _wrap_DrawableViewbox__wrap_DrawableViewbox_x1);
SWIGV8_AddMemberFunction(_exports_DrawableViewbox_class, "y1", _wrap_DrawableViewbox__wrap_DrawableViewbox_y1);
SWIGV8_AddMemberFunction(_exports_DrawableViewbox_class, "x2", _wrap_DrawableViewbox__wrap_DrawableViewbox_x2);
SWIGV8_AddMemberFunction(_exports_DrawableViewbox_class, "y2", _wrap_DrawableViewbox__wrap_DrawableViewbox_y2);
SWIGV8_AddMemberFunction(_exports_PathArcArgs_class, "radiusX", _wrap_PathArcArgs__wrap_PathArcArgs_radiusX);
SWIGV8_AddMemberFunction(_exports_PathArcArgs_class, "radiusY", _wrap_PathArcArgs__wrap_PathArcArgs_radiusY);
SWIGV8_AddMemberFunction(_exports_PathArcArgs_class, "xAxisRotation", _wrap_PathArcArgs__wrap_PathArcArgs_xAxisRotation);
SWIGV8_AddMemberFunction(_exports_PathArcArgs_class, "largeArcFlag", _wrap_PathArcArgs__wrap_PathArcArgs_largeArcFlag);
SWIGV8_AddMemberFunction(_exports_PathArcArgs_class, "sweepFlag", _wrap_PathArcArgs__wrap_PathArcArgs_sweepFlag);
SWIGV8_AddMemberFunction(_exports_PathArcArgs_class, "x", _wrap_PathArcArgs__wrap_PathArcArgs_x);
SWIGV8_AddMemberFunction(_exports_PathArcArgs_class, "y", _wrap_PathArcArgs__wrap_PathArcArgs_y);
SWIGV8_AddMemberFunction(_exports_PathArcAbs_class, "call", _wrap_PathArcAbs_call);
SWIGV8_AddMemberFunction(_exports_PathArcAbs_class, "copy", _wrap_PathArcAbs_copy);
SWIGV8_AddMemberFunction(_exports_PathArcRel_class, "call", _wrap_PathArcRel_call);
SWIGV8_AddMemberFunction(_exports_PathArcRel_class, "copy", _wrap_PathArcRel_copy);
SWIGV8_AddMemberFunction(_exports_PathClosePath_class, "call", _wrap_PathClosePath_call);
SWIGV8_AddMemberFunction(_exports_PathClosePath_class, "copy", _wrap_PathClosePath_copy);
SWIGV8_AddMemberFunction(_exports_PathCurvetoArgs_class, "x1", _wrap_PathCurvetoArgs__wrap_PathCurvetoArgs_x1);
SWIGV8_AddMemberFunction(_exports_PathCurvetoArgs_class, "y1", _wrap_PathCurvetoArgs__wrap_PathCurvetoArgs_y1);
SWIGV8_AddMemberFunction(_exports_PathCurvetoArgs_class, "x2", _wrap_PathCurvetoArgs__wrap_PathCurvetoArgs_x2);
SWIGV8_AddMemberFunction(_exports_PathCurvetoArgs_class, "y2", _wrap_PathCurvetoArgs__wrap_PathCurvetoArgs_y2);
SWIGV8_AddMemberFunction(_exports_PathCurvetoArgs_class, "x", _wrap_PathCurvetoArgs__wrap_PathCurvetoArgs_x);
SWIGV8_AddMemberFunction(_exports_PathCurvetoArgs_class, "y", _wrap_PathCurvetoArgs__wrap_PathCurvetoArgs_y);
SWIGV8_AddMemberFunction(_exports_PathCurvetoAbs_class, "call", _wrap_PathCurvetoAbs_call);
SWIGV8_AddMemberFunction(_exports_PathCurvetoAbs_class, "copy", _wrap_PathCurvetoAbs_copy);
SWIGV8_AddMemberFunction(_exports_PathCurvetoRel_class, "call", _wrap_PathCurvetoRel_call);
SWIGV8_AddMemberFunction(_exports_PathCurvetoRel_class, "copy", _wrap_PathCurvetoRel_copy);
SWIGV8_AddMemberFunction(_exports_PathSmoothCurvetoAbs_class, "call", _wrap_PathSmoothCurvetoAbs_call);
SWIGV8_AddMemberFunction(_exports_PathSmoothCurvetoAbs_class, "copy", _wrap_PathSmoothCurvetoAbs_copy);
SWIGV8_AddMemberFunction(_exports_PathSmoothCurvetoRel_class, "call", _wrap_PathSmoothCurvetoRel_call);
SWIGV8_AddMemberFunction(_exports_PathSmoothCurvetoRel_class, "copy", _wrap_PathSmoothCurvetoRel_copy);
SWIGV8_AddMemberFunction(_exports_PathQuadraticCurvetoArgs_class, "x1", _wrap_PathQuadraticCurvetoArgs__wrap_PathQuadraticCurvetoArgs_x1);
SWIGV8_AddMemberFunction(_exports_PathQuadraticCurvetoArgs_class, "y1", _wrap_PathQuadraticCurvetoArgs__wrap_PathQuadraticCurvetoArgs_y1);
SWIGV8_AddMemberFunction(_exports_PathQuadraticCurvetoArgs_class, "x", _wrap_PathQuadraticCurvetoArgs__wrap_PathQuadraticCurvetoArgs_x);
SWIGV8_AddMemberFunction(_exports_PathQuadraticCurvetoArgs_class, "y", _wrap_PathQuadraticCurvetoArgs__wrap_PathQuadraticCurvetoArgs_y);
SWIGV8_AddMemberFunction(_exports_PathQuadraticCurvetoAbs_class, "call", _wrap_PathQuadraticCurvetoAbs_call);
SWIGV8_AddMemberFunction(_exports_PathQuadraticCurvetoAbs_class, "copy", _wrap_PathQuadraticCurvetoAbs_copy);
SWIGV8_AddMemberFunction(_exports_PathQuadraticCurvetoRel_class, "call", _wrap_PathQuadraticCurvetoRel_call);
SWIGV8_AddMemberFunction(_exports_PathQuadraticCurvetoRel_class, "copy", _wrap_PathQuadraticCurvetoRel_copy);
SWIGV8_AddMemberFunction(_exports_PathSmoothQuadraticCurvetoAbs_class, "call", _wrap_PathSmoothQuadraticCurvetoAbs_call);
SWIGV8_AddMemberFunction(_exports_PathSmoothQuadraticCurvetoAbs_class, "copy", _wrap_PathSmoothQuadraticCurvetoAbs_copy);
SWIGV8_AddMemberFunction(_exports_PathSmoothQuadraticCurvetoRel_class, "call", _wrap_PathSmoothQuadraticCurvetoRel_call);
SWIGV8_AddMemberFunction(_exports_PathSmoothQuadraticCurvetoRel_class, "copy", _wrap_PathSmoothQuadraticCurvetoRel_copy);
SWIGV8_AddMemberFunction(_exports_PathLinetoAbs_class, "call", _wrap_PathLinetoAbs_call);
SWIGV8_AddMemberFunction(_exports_PathLinetoAbs_class, "copy", _wrap_PathLinetoAbs_copy);
SWIGV8_AddMemberFunction(_exports_PathLinetoRel_class, "call", _wrap_PathLinetoRel_call);
SWIGV8_AddMemberFunction(_exports_PathLinetoRel_class, "copy", _wrap_PathLinetoRel_copy);
SWIGV8_AddMemberFunction(_exports_PathLinetoHorizontalAbs_class, "call", _wrap_PathLinetoHorizontalAbs_call);
SWIGV8_AddMemberFunction(_exports_PathLinetoHorizontalAbs_class, "copy", _wrap_PathLinetoHorizontalAbs_copy);
SWIGV8_AddMemberFunction(_exports_PathLinetoHorizontalAbs_class, "x", _wrap_PathLinetoHorizontalAbs__wrap_PathLinetoHorizontalAbs_x);
SWIGV8_AddMemberFunction(_exports_PathLinetoHorizontalRel_class, "call", _wrap_PathLinetoHorizontalRel_call);
SWIGV8_AddMemberFunction(_exports_PathLinetoHorizontalRel_class, "copy", _wrap_PathLinetoHorizontalRel_copy);
SWIGV8_AddMemberFunction(_exports_PathLinetoHorizontalRel_class, "x", _wrap_PathLinetoHorizontalRel__wrap_PathLinetoHorizontalRel_x);
SWIGV8_AddMemberFunction(_exports_PathLinetoVerticalAbs_class, "call", _wrap_PathLinetoVerticalAbs_call);
SWIGV8_AddMemberFunction(_exports_PathLinetoVerticalAbs_class, "copy", _wrap_PathLinetoVerticalAbs_copy);
SWIGV8_AddMemberFunction(_exports_PathLinetoVerticalAbs_class, "y", _wrap_PathLinetoVerticalAbs__wrap_PathLinetoVerticalAbs_y);
SWIGV8_AddMemberFunction(_exports_PathLinetoVerticalRel_class, "call", _wrap_PathLinetoVerticalRel_call);
SWIGV8_AddMemberFunction(_exports_PathLinetoVerticalRel_class, "copy", _wrap_PathLinetoVerticalRel_copy);
SWIGV8_AddMemberFunction(_exports_PathLinetoVerticalRel_class, "y", _wrap_PathLinetoVerticalRel__wrap_PathLinetoVerticalRel_y);
SWIGV8_AddMemberFunction(_exports_PathMovetoAbs_class, "call", _wrap_PathMovetoAbs_call);
SWIGV8_AddMemberFunction(_exports_PathMovetoAbs_class, "copy", _wrap_PathMovetoAbs_copy);
SWIGV8_AddMemberFunction(_exports_PathMovetoRel_class, "call", _wrap_PathMovetoRel_call);
SWIGV8_AddMemberFunction(_exports_PathMovetoRel_class, "copy", _wrap_PathMovetoRel_copy);
SWIGV8_AddMemberFunction(_exports_Exception_class, "clone", _wrap_Exception_clone);
SWIGV8_AddMemberFunction(_exports_Exception_class, "what", _wrap_Exception_what);
SWIGV8_AddMemberFunction(_exports_Exception_class, "nested", _wrap_Exception__wrap_Exception_nested);
SWIGV8_AddMemberFunction(_exports_Montage_class, "backgroundColor", _wrap_Montage__wrap_Montage_backgroundColor);
SWIGV8_AddMemberFunction(_exports_Montage_class, "compose", _wrap_Montage__wrap_Montage_compose);
SWIGV8_AddMemberFunction(_exports_Montage_class, "fileName", _wrap_Montage__wrap_Montage_fileName);
SWIGV8_AddMemberFunction(_exports_Montage_class, "fillColor", _wrap_Montage__wrap_Montage_fillColor);
SWIGV8_AddMemberFunction(_exports_Montage_class, "font", _wrap_Montage__wrap_Montage_font);
SWIGV8_AddMemberFunction(_exports_Montage_class, "geometry", _wrap_Montage__wrap_Montage_geometry);
SWIGV8_AddMemberFunction(_exports_Montage_class, "gravity", _wrap_Montage__wrap_Montage_gravity);
SWIGV8_AddMemberFunction(_exports_Montage_class, "label", _wrap_Montage__wrap_Montage_label);
SWIGV8_AddMemberFunction(_exports_Montage_class, "penColor", _wrap_Montage__wrap_Montage_penColor);
SWIGV8_AddMemberFunction(_exports_Montage_class, "pointSize", _wrap_Montage__wrap_Montage_pointSize);
SWIGV8_AddMemberFunction(_exports_Montage_class, "shadow", _wrap_Montage__wrap_Montage_shadow);
SWIGV8_AddMemberFunction(_exports_Montage_class, "strokeColor", _wrap_Montage__wrap_Montage_strokeColor);
SWIGV8_AddMemberFunction(_exports_Montage_class, "texture", _wrap_Montage__wrap_Montage_texture);
SWIGV8_AddMemberFunction(_exports_Montage_class, "tile", _wrap_Montage__wrap_Montage_tile);
SWIGV8_AddMemberFunction(_exports_Montage_class, "title", _wrap_Montage__wrap_Montage_title);
SWIGV8_AddMemberFunction(_exports_Montage_class, "transparentColor", _wrap_Montage__wrap_Montage_transparentColor);
SWIGV8_AddMemberFunction(_exports_Montage_class, "updateMontageInfo", _wrap_Montage_updateMontageInfo);
SWIGV8_AddMemberFunction(_exports_MontageFramed_class, "borderColor", _wrap_MontageFramed__wrap_MontageFramed_borderColor);
SWIGV8_AddMemberFunction(_exports_MontageFramed_class, "borderWidth", _wrap_MontageFramed__wrap_MontageFramed_borderWidth);
SWIGV8_AddMemberFunction(_exports_MontageFramed_class, "frameGeometry", _wrap_MontageFramed__wrap_MontageFramed_frameGeometry);
SWIGV8_AddMemberFunction(_exports_MontageFramed_class, "matteColor", _wrap_MontageFramed__wrap_MontageFramed_matteColor);
SWIGV8_AddMemberFunction(_exports_MontageFramed_class, "updateMontageInfo", _wrap_MontageFramed_updateMontageInfo);
SWIGV8_AddStaticVariable(exports_obj, "borderGeometryDefault", _wrap_borderGeometryDefault_get, _wrap_borderGeometryDefault_set, context);
SWIGV8_AddStaticVariable(exports_obj, "frameGeometryDefault", _wrap_frameGeometryDefault_get, _wrap_frameGeometryDefault_set, context);
SWIGV8_AddStaticVariable(exports_obj, "raiseGeometryDefault", _wrap_raiseGeometryDefault_get, _wrap_raiseGeometryDefault_set, context);
SWIGV8_AddMemberFunction(_exports_Image_class, "clone", _wrap_Image_clone);
SWIGV8_AddMemberFunction(_exports_Image_class, "adjoin", _wrap_Image__wrap_Image_adjoin);
SWIGV8_AddMemberFunction(_exports_Image_class, "antiAlias", _wrap_Image__wrap_Image_antiAlias);
SWIGV8_AddMemberFunction(_exports_Image_class, "animationDelay", _wrap_Image__wrap_Image_animationDelay);
SWIGV8_AddMemberFunction(_exports_Image_class, "animationIterations", _wrap_Image__wrap_Image_animationIterations);
SWIGV8_AddMemberFunction(_exports_Image_class, "attenuate", _wrap_Image_attenuate);
SWIGV8_AddMemberFunction(_exports_Image_class, "backgroundColor", _wrap_Image__wrap_Image_backgroundColor);
SWIGV8_AddMemberFunction(_exports_Image_class, "backgroundTexture", _wrap_Image__wrap_Image_backgroundTexture);
SWIGV8_AddMemberFunction(_exports_Image_class, "baseColumns", _wrap_Image_baseColumns);
SWIGV8_AddMemberFunction(_exports_Image_class, "baseFilename", _wrap_Image_baseFilename);
SWIGV8_AddMemberFunction(_exports_Image_class, "baseRows", _wrap_Image_baseRows);
SWIGV8_AddMemberFunction(_exports_Image_class, "blackPointCompensation", _wrap_Image__wrap_Image_blackPointCompensation);
SWIGV8_AddMemberFunction(_exports_Image_class, "borderColor", _wrap_Image__wrap_Image_borderColor);
SWIGV8_AddMemberFunction(_exports_Image_class, "boundingBox", _wrap_Image_boundingBox);
SWIGV8_AddMemberFunction(_exports_Image_class, "boxColor", _wrap_Image__wrap_Image_boxColor);
SWIGV8_AddMemberFunction(_exports_Image_class, "classType", _wrap_Image__wrap_Image_classType);
SWIGV8_AddMemberFunction(_exports_Image_class, "clipMask", _wrap_Image__wrap_Image_clipMask);
SWIGV8_AddMemberFunction(_exports_Image_class, "colorFuzz", _wrap_Image__wrap_Image_colorFuzz);
SWIGV8_AddMemberFunction(_exports_Image_class, "colorMapSize", _wrap_Image__wrap_Image_colorMapSize);
SWIGV8_AddMemberFunction(_exports_Image_class, "colorSpace", _wrap_Image__wrap_Image_colorSpace);
SWIGV8_AddMemberFunction(_exports_Image_class, "colorspaceType", _wrap_Image__wrap_Image_colorspaceType);
SWIGV8_AddMemberFunction(_exports_Image_class, "columns", _wrap_Image_columns);
SWIGV8_AddMemberFunction(_exports_Image_class, "comment", _wrap_Image__wrap_Image_comment);
SWIGV8_AddMemberFunction(_exports_Image_class, "compose", _wrap_Image__wrap_Image_compose);
SWIGV8_AddMemberFunction(_exports_Image_class, "compressType", _wrap_Image__wrap_Image_compressType);
SWIGV8_AddMemberFunction(_exports_Image_class, "debug", _wrap_Image__wrap_Image_debug);
SWIGV8_AddMemberFunction(_exports_Image_class, "density", _wrap_Image__wrap_Image_density);
SWIGV8_AddMemberFunction(_exports_Image_class, "depth", _wrap_Image__wrap_Image_depth);
SWIGV8_AddMemberFunction(_exports_Image_class, "directory", _wrap_Image_directory);
SWIGV8_AddMemberFunction(_exports_Image_class, "endian", _wrap_Image__wrap_Image_endian);
SWIGV8_AddMemberFunction(_exports_Image_class, "exifProfile", _wrap_Image__wrap_Image_exifProfile);
SWIGV8_AddMemberFunction(_exports_Image_class, "fileName", _wrap_Image__wrap_Image_fileName);
SWIGV8_AddMemberFunction(_exports_Image_class, "fileSize", _wrap_Image_fileSize);
SWIGV8_AddMemberFunction(_exports_Image_class, "fillColor", _wrap_Image__wrap_Image_fillColor);
SWIGV8_AddMemberFunction(_exports_Image_class, "fillRule", _wrap_Image__wrap_Image_fillRule);
SWIGV8_AddMemberFunction(_exports_Image_class, "fillPattern", _wrap_Image__wrap_Image_fillPattern);
SWIGV8_AddMemberFunction(_exports_Image_class, "filterType", _wrap_Image__wrap_Image_filterType);
SWIGV8_AddMemberFunction(_exports_Image_class, "font", _wrap_Image__wrap_Image_font);
SWIGV8_AddMemberFunction(_exports_Image_class, "fontFamily", _wrap_Image__wrap_Image_fontFamily);
SWIGV8_AddMemberFunction(_exports_Image_class, "fontPointsize", _wrap_Image__wrap_Image_fontPointsize);
SWIGV8_AddMemberFunction(_exports_Image_class, "fontStyle", _wrap_Image__wrap_Image_fontStyle);
SWIGV8_AddMemberFunction(_exports_Image_class, "fontWeight", _wrap_Image__wrap_Image_fontWeight);
SWIGV8_AddMemberFunction(_exports_Image_class, "format", _wrap_Image_format);
SWIGV8_AddMemberFunction(_exports_Image_class, "formatExpression", _wrap_Image_formatExpression);
SWIGV8_AddMemberFunction(_exports_Image_class, "geometry", _wrap_Image_geometry);
SWIGV8_AddMemberFunction(_exports_Image_class, "gifDisposeMethod", _wrap_Image__wrap_Image_gifDisposeMethod);
SWIGV8_AddMemberFunction(_exports_Image_class, "highlightColor", _wrap_Image_highlightColor);
SWIGV8_AddMemberFunction(_exports_Image_class, "iccColorProfile", _wrap_Image__wrap_Image_iccColorProfile);
SWIGV8_AddMemberFunction(_exports_Image_class, "interlaceType", _wrap_Image__wrap_Image_interlaceType);
SWIGV8_AddMemberFunction(_exports_Image_class, "interpolate", _wrap_Image__wrap_Image_interpolate);
SWIGV8_AddMemberFunction(_exports_Image_class, "iptcProfile", _wrap_Image__wrap_Image_iptcProfile);
SWIGV8_AddMemberFunction(_exports_Image_class, "isOpaque", _wrap_Image_isOpaque);
SWIGV8_AddMemberFunction(_exports_Image_class, "isValid", _wrap_Image__wrap_Image_isValid);
SWIGV8_AddMemberFunction(_exports_Image_class, "label", _wrap_Image__wrap_Image_label);
SWIGV8_AddMemberFunction(_exports_Image_class, "lineWidth", _wrap_Image__wrap_Image_lineWidth);
SWIGV8_AddMemberFunction(_exports_Image_class, "lowlightColor", _wrap_Image_lowlightColor);
SWIGV8_AddMemberFunction(_exports_Image_class, "magick", _wrap_Image__wrap_Image_magick);
SWIGV8_AddMemberFunction(_exports_Image_class, "mask", _wrap_Image__wrap_Image_mask);
SWIGV8_AddMemberFunction(_exports_Image_class, "matte", _wrap_Image__wrap_Image_matte);
SWIGV8_AddMemberFunction(_exports_Image_class, "matteColor", _wrap_Image__wrap_Image_matteColor);
SWIGV8_AddMemberFunction(_exports_Image_class, "meanErrorPerPixel", _wrap_Image_meanErrorPerPixel);
SWIGV8_AddMemberFunction(_exports_Image_class, "modulusDepth", _wrap_Image__wrap_Image_modulusDepth);
SWIGV8_AddMemberFunction(_exports_Image_class, "monochrome", _wrap_Image__wrap_Image_monochrome);
SWIGV8_AddMemberFunction(_exports_Image_class, "montageGeometry", _wrap_Image_montageGeometry);
SWIGV8_AddMemberFunction(_exports_Image_class, "normalizedMaxError", _wrap_Image_normalizedMaxError);
SWIGV8_AddMemberFunction(_exports_Image_class, "normalizedMeanError", _wrap_Image_normalizedMeanError);
SWIGV8_AddMemberFunction(_exports_Image_class, "orientation", _wrap_Image__wrap_Image_orientation);
SWIGV8_AddMemberFunction(_exports_Image_class, "page", _wrap_Image__wrap_Image_page);
SWIGV8_AddMemberFunction(_exports_Image_class, "penColor", _wrap_Image__wrap_Image_penColor);
SWIGV8_AddMemberFunction(_exports_Image_class, "penTexture", _wrap_Image__wrap_Image_penTexture);
SWIGV8_AddMemberFunction(_exports_Image_class, "quality", _wrap_Image__wrap_Image_quality);
SWIGV8_AddMemberFunction(_exports_Image_class, "quantizeColors", _wrap_Image__wrap_Image_quantizeColors);
SWIGV8_AddMemberFunction(_exports_Image_class, "quantizeColorSpace", _wrap_Image__wrap_Image_quantizeColorSpace);
SWIGV8_AddMemberFunction(_exports_Image_class, "quantizeDither", _wrap_Image__wrap_Image_quantizeDither);
SWIGV8_AddMemberFunction(_exports_Image_class, "quantizeDitherMethod", _wrap_Image__wrap_Image_quantizeDitherMethod);
SWIGV8_AddMemberFunction(_exports_Image_class, "quantizeTreeDepth", _wrap_Image__wrap_Image_quantizeTreeDepth);
SWIGV8_AddMemberFunction(_exports_Image_class, "quiet", _wrap_Image__wrap_Image_quiet);
SWIGV8_AddMemberFunction(_exports_Image_class, "renderingIntent", _wrap_Image__wrap_Image_renderingIntent);
SWIGV8_AddMemberFunction(_exports_Image_class, "resolutionUnits", _wrap_Image__wrap_Image_resolutionUnits);
SWIGV8_AddMemberFunction(_exports_Image_class, "rows", _wrap_Image_rows);
SWIGV8_AddMemberFunction(_exports_Image_class, "scene", _wrap_Image__wrap_Image_scene);
SWIGV8_AddMemberFunction(_exports_Image_class, "size", _wrap_Image__wrap_Image_size);
SWIGV8_AddMemberFunction(_exports_Image_class, "strokeAntiAlias", _wrap_Image__wrap_Image_strokeAntiAlias);
SWIGV8_AddMemberFunction(_exports_Image_class, "strokeColor", _wrap_Image__wrap_Image_strokeColor);
SWIGV8_AddMemberFunction(_exports_Image_class, "strokeDashArray", _wrap_Image__wrap_Image_strokeDashArray);
SWIGV8_AddMemberFunction(_exports_Image_class, "strokeDashOffset", _wrap_Image__wrap_Image_strokeDashOffset);
SWIGV8_AddMemberFunction(_exports_Image_class, "strokeLineCap", _wrap_Image__wrap_Image_strokeLineCap);
SWIGV8_AddMemberFunction(_exports_Image_class, "strokeLineJoin", _wrap_Image__wrap_Image_strokeLineJoin);
SWIGV8_AddMemberFunction(_exports_Image_class, "strokeMiterLimit", _wrap_Image__wrap_Image_strokeMiterLimit);
SWIGV8_AddMemberFunction(_exports_Image_class, "strokePattern", _wrap_Image__wrap_Image_strokePattern);
SWIGV8_AddMemberFunction(_exports_Image_class, "strokeWidth", _wrap_Image__wrap_Image_strokeWidth);
SWIGV8_AddMemberFunction(_exports_Image_class, "subImage", _wrap_Image__wrap_Image_subImage);
SWIGV8_AddMemberFunction(_exports_Image_class, "subRange", _wrap_Image__wrap_Image_subRange);
SWIGV8_AddMemberFunction(_exports_Image_class, "textDirection", _wrap_Image__wrap_Image_textDirection);
SWIGV8_AddMemberFunction(_exports_Image_class, "textEncoding", _wrap_Image__wrap_Image_textEncoding);
SWIGV8_AddMemberFunction(_exports_Image_class, "textGravity", _wrap_Image__wrap_Image_textGravity);
SWIGV8_AddMemberFunction(_exports_Image_class, "textInterlineSpacing", _wrap_Image__wrap_Image_textInterlineSpacing);
SWIGV8_AddMemberFunction(_exports_Image_class, "textInterwordSpacing", _wrap_Image__wrap_Image_textInterwordSpacing);
SWIGV8_AddMemberFunction(_exports_Image_class, "textKerning", _wrap_Image__wrap_Image_textKerning);
SWIGV8_AddMemberFunction(_exports_Image_class, "textUnderColor", _wrap_Image__wrap_Image_textUnderColor);
SWIGV8_AddMemberFunction(_exports_Image_class, "tileName", _wrap_Image__wrap_Image_tileName);
SWIGV8_AddMemberFunction(_exports_Image_class, "totalColors", _wrap_Image_totalColors);
SWIGV8_AddMemberFunction(_exports_Image_class, "transformRotation", _wrap_Image_transformRotation);
SWIGV8_AddMemberFunction(_exports_Image_class, "transformSkewX", _wrap_Image_transformSkewX);
SWIGV8_AddMemberFunction(_exports_Image_class, "transformSkewY", _wrap_Image_transformSkewY);
SWIGV8_AddMemberFunction(_exports_Image_class, "type", _wrap_Image__wrap_Image_type);
SWIGV8_AddMemberFunction(_exports_Image_class, "verbose", _wrap_Image__wrap_Image_verbose);
SWIGV8_AddMemberFunction(_exports_Image_class, "view", _wrap_Image__wrap_Image_view);
SWIGV8_AddMemberFunction(_exports_Image_class, "virtualPixelMethod", _wrap_Image__wrap_Image_virtualPixelMethod);
SWIGV8_AddMemberFunction(_exports_Image_class, "x11Display", _wrap_Image__wrap_Image_x11Display);
SWIGV8_AddMemberFunction(_exports_Image_class, "xResolution", _wrap_Image_xResolution);
SWIGV8_AddMemberFunction(_exports_Image_class, "yResolution", _wrap_Image_yResolution);
SWIGV8_AddMemberFunction(_exports_Image_class, "adaptiveBlur", _wrap_Image__wrap_Image_adaptiveBlur);
SWIGV8_AddMemberFunction(_exports_Image_class, "adaptiveResize", _wrap_Image_adaptiveResize);
SWIGV8_AddMemberFunction(_exports_Image_class, "adaptiveSharpen", _wrap_Image__wrap_Image_adaptiveSharpen);
SWIGV8_AddMemberFunction(_exports_Image_class, "adaptiveSharpenChannel", _wrap_Image__wrap_Image_adaptiveSharpenChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "adaptiveThreshold", _wrap_Image__wrap_Image_adaptiveThreshold);
SWIGV8_AddMemberFunction(_exports_Image_class, "addNoise", _wrap_Image_addNoise);
SWIGV8_AddMemberFunction(_exports_Image_class, "addNoiseChannel", _wrap_Image_addNoiseChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "affineTransform", _wrap_Image_affineTransform);
SWIGV8_AddMemberFunction(_exports_Image_class, "alphaChannel", _wrap_Image_alphaChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "annotate", _wrap_Image__wrap_Image_annotate);
SWIGV8_AddMemberFunction(_exports_Image_class, "artifact", _wrap_Image__wrap_Image_artifact);
SWIGV8_AddMemberFunction(_exports_Image_class, "attribute", _wrap_Image__wrap_Image_attribute);
SWIGV8_AddMemberFunction(_exports_Image_class, "autoGamma", _wrap_Image_autoGamma);
SWIGV8_AddMemberFunction(_exports_Image_class, "autoGammaChannel", _wrap_Image_autoGammaChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "autoLevel", _wrap_Image_autoLevel);
SWIGV8_AddMemberFunction(_exports_Image_class, "autoLevelChannel", _wrap_Image_autoLevelChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "autoOrient", _wrap_Image_autoOrient);
SWIGV8_AddMemberFunction(_exports_Image_class, "blackThreshold", _wrap_Image_blackThreshold);
SWIGV8_AddMemberFunction(_exports_Image_class, "blackThresholdChannel", _wrap_Image_blackThresholdChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "blueShift", _wrap_Image__wrap_Image_blueShift);
SWIGV8_AddMemberFunction(_exports_Image_class, "blur", _wrap_Image__wrap_Image_blur);
SWIGV8_AddMemberFunction(_exports_Image_class, "blurChannel", _wrap_Image__wrap_Image_blurChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "border", _wrap_Image__wrap_Image_border);
SWIGV8_AddMemberFunction(_exports_Image_class, "brightnessContrast", _wrap_Image__wrap_Image_brightnessContrast);
SWIGV8_AddMemberFunction(_exports_Image_class, "brightnessContrastChannel", _wrap_Image__wrap_Image_brightnessContrastChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "cannyEdge", _wrap_Image__wrap_Image_cannyEdge);
SWIGV8_AddMemberFunction(_exports_Image_class, "cdl", _wrap_Image_cdl);
SWIGV8_AddMemberFunction(_exports_Image_class, "channel", _wrap_Image_channel);
SWIGV8_AddMemberFunction(_exports_Image_class, "channelDepth", _wrap_Image__wrap_Image_channelDepth);
SWIGV8_AddMemberFunction(_exports_Image_class, "charcoal", _wrap_Image__wrap_Image_charcoal);
SWIGV8_AddMemberFunction(_exports_Image_class, "chop", _wrap_Image_chop);
SWIGV8_AddMemberFunction(_exports_Image_class, "chromaBluePrimary", _wrap_Image__wrap_Image_chromaBluePrimary);
SWIGV8_AddMemberFunction(_exports_Image_class, "chromaGreenPrimary", _wrap_Image__wrap_Image_chromaGreenPrimary);
SWIGV8_AddMemberFunction(_exports_Image_class, "chromaRedPrimary", _wrap_Image__wrap_Image_chromaRedPrimary);
SWIGV8_AddMemberFunction(_exports_Image_class, "chromaWhitePoint", _wrap_Image__wrap_Image_chromaWhitePoint);
SWIGV8_AddMemberFunction(_exports_Image_class, "clamp", _wrap_Image_clamp);
SWIGV8_AddMemberFunction(_exports_Image_class, "clampChannel", _wrap_Image_clampChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "clip", _wrap_Image_clip);
SWIGV8_AddMemberFunction(_exports_Image_class, "clipPath", _wrap_Image_clipPath);
SWIGV8_AddMemberFunction(_exports_Image_class, "clut", _wrap_Image_clut);
SWIGV8_AddMemberFunction(_exports_Image_class, "clutChannel", _wrap_Image_clutChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "colorize", _wrap_Image__wrap_Image_colorize);
SWIGV8_AddMemberFunction(_exports_Image_class, "colorMap", _wrap_Image__wrap_Image_colorMap);
SWIGV8_AddMemberFunction(_exports_Image_class, "colorMatrix", _wrap_Image_colorMatrix);
SWIGV8_AddMemberFunction(_exports_Image_class, "compare", _wrap_Image__wrap_Image_compare);
SWIGV8_AddMemberFunction(_exports_Image_class, "compareChannel", _wrap_Image__wrap_Image_compareChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "composite", _wrap_Image__wrap_Image_composite);
SWIGV8_AddMemberFunction(_exports_Image_class, "connectedComponents", _wrap_Image_connectedComponents);
SWIGV8_AddMemberFunction(_exports_Image_class, "contrast", _wrap_Image_contrast);
SWIGV8_AddMemberFunction(_exports_Image_class, "contrastStretch", _wrap_Image_contrastStretch);
SWIGV8_AddMemberFunction(_exports_Image_class, "contrastStretchChannel", _wrap_Image_contrastStretchChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "convolve", _wrap_Image_convolve);
SWIGV8_AddMemberFunction(_exports_Image_class, "copyPixels", _wrap_Image_copyPixels);
SWIGV8_AddMemberFunction(_exports_Image_class, "crop", _wrap_Image_crop);
SWIGV8_AddMemberFunction(_exports_Image_class, "cycleColormap", _wrap_Image_cycleColormap);
SWIGV8_AddMemberFunction(_exports_Image_class, "decipher", _wrap_Image_decipher);
SWIGV8_AddMemberFunction(_exports_Image_class, "defineSet", _wrap_Image__wrap_Image_defineSet);
SWIGV8_AddMemberFunction(_exports_Image_class, "defineValue", _wrap_Image__wrap_Image_defineValue);
SWIGV8_AddMemberFunction(_exports_Image_class, "deskew", _wrap_Image_deskew);
SWIGV8_AddMemberFunction(_exports_Image_class, "despeckle", _wrap_Image_despeckle);
SWIGV8_AddMemberFunction(_exports_Image_class, "determineType", _wrap_Image_determineType);
SWIGV8_AddMemberFunction(_exports_Image_class, "display", _wrap_Image_display);
SWIGV8_AddMemberFunction(_exports_Image_class, "distort", _wrap_Image__wrap_Image_distort);
SWIGV8_AddMemberFunction(_exports_Image_class, "draw", _wrap_Image__wrap_Image_draw);
SWIGV8_AddMemberFunction(_exports_Image_class, "edge", _wrap_Image__wrap_Image_edge);
SWIGV8_AddMemberFunction(_exports_Image_class, "emboss", _wrap_Image__wrap_Image_emboss);
SWIGV8_AddMemberFunction(_exports_Image_class, "encipher", _wrap_Image_encipher);
SWIGV8_AddMemberFunction(_exports_Image_class, "enhance", _wrap_Image_enhance);
SWIGV8_AddMemberFunction(_exports_Image_class, "equalize", _wrap_Image_equalize);
SWIGV8_AddMemberFunction(_exports_Image_class, "erase", _wrap_Image_erase);
SWIGV8_AddMemberFunction(_exports_Image_class, "extent", _wrap_Image__wrap_Image_extent);
SWIGV8_AddMemberFunction(_exports_Image_class, "flip", _wrap_Image_flip);
SWIGV8_AddMemberFunction(_exports_Image_class, "floodFillColor", _wrap_Image__wrap_Image_floodFillColor);
SWIGV8_AddMemberFunction(_exports_Image_class, "floodFillOpacity", _wrap_Image__wrap_Image_floodFillOpacity);
SWIGV8_AddMemberFunction(_exports_Image_class, "floodFillTexture", _wrap_Image__wrap_Image_floodFillTexture);
SWIGV8_AddMemberFunction(_exports_Image_class, "flop", _wrap_Image_flop);
SWIGV8_AddMemberFunction(_exports_Image_class, "fontTypeMetrics", _wrap_Image_fontTypeMetrics);
SWIGV8_AddMemberFunction(_exports_Image_class, "fontTypeMetricsMultiline", _wrap_Image_fontTypeMetricsMultiline);
SWIGV8_AddMemberFunction(_exports_Image_class, "frame", _wrap_Image__wrap_Image_frame);
SWIGV8_AddMemberFunction(_exports_Image_class, "fx", _wrap_Image__wrap_Image_fx);
SWIGV8_AddMemberFunction(_exports_Image_class, "gamma", _wrap_Image__wrap_Image_gamma);
SWIGV8_AddMemberFunction(_exports_Image_class, "gaussianBlur", _wrap_Image_gaussianBlur);
SWIGV8_AddMemberFunction(_exports_Image_class, "gaussianBlurChannel", _wrap_Image_gaussianBlurChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "getConstIndexes", _wrap_Image_getConstIndexes);
SWIGV8_AddMemberFunction(_exports_Image_class, "getConstPixels", _wrap_Image_getConstPixels);
SWIGV8_AddMemberFunction(_exports_Image_class, "getIndexes", _wrap_Image_getIndexes);
SWIGV8_AddMemberFunction(_exports_Image_class, "getPixels", _wrap_Image_getPixels);
SWIGV8_AddMemberFunction(_exports_Image_class, "grayscale", _wrap_Image_grayscale);
SWIGV8_AddMemberFunction(_exports_Image_class, "haldClut", _wrap_Image_haldClut);
SWIGV8_AddMemberFunction(_exports_Image_class, "houghLine", _wrap_Image__wrap_Image_houghLine);
SWIGV8_AddMemberFunction(_exports_Image_class, "implode", _wrap_Image_implode);
SWIGV8_AddMemberFunction(_exports_Image_class, "inverseFourierTransform", _wrap_Image__wrap_Image_inverseFourierTransform);
SWIGV8_AddMemberFunction(_exports_Image_class, "kuwahara", _wrap_Image__wrap_Image_kuwahara);
SWIGV8_AddMemberFunction(_exports_Image_class, "kuwaharaChannel", _wrap_Image__wrap_Image_kuwaharaChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "level", _wrap_Image__wrap_Image_level);
SWIGV8_AddMemberFunction(_exports_Image_class, "levelChannel", _wrap_Image__wrap_Image_levelChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "levelColors", _wrap_Image__wrap_Image_levelColors);
SWIGV8_AddMemberFunction(_exports_Image_class, "levelColorsChannel", _wrap_Image__wrap_Image_levelColorsChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "levelize", _wrap_Image__wrap_Image_levelize);
SWIGV8_AddMemberFunction(_exports_Image_class, "levelizeChannel", _wrap_Image__wrap_Image_levelizeChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "linearStretch", _wrap_Image_linearStretch);
SWIGV8_AddMemberFunction(_exports_Image_class, "liquidRescale", _wrap_Image_liquidRescale);
SWIGV8_AddMemberFunction(_exports_Image_class, "localContrast", _wrap_Image_localContrast);
SWIGV8_AddMemberFunction(_exports_Image_class, "magnify", _wrap_Image_magnify);
SWIGV8_AddMemberFunction(_exports_Image_class, "map", _wrap_Image__wrap_Image_map);
SWIGV8_AddMemberFunction(_exports_Image_class, "matteFloodfill", _wrap_Image_matteFloodfill);
SWIGV8_AddMemberFunction(_exports_Image_class, "medianFilter", _wrap_Image__wrap_Image_medianFilter);
SWIGV8_AddMemberFunction(_exports_Image_class, "mergeLayers", _wrap_Image_mergeLayers);
SWIGV8_AddMemberFunction(_exports_Image_class, "minify", _wrap_Image_minify);
SWIGV8_AddMemberFunction(_exports_Image_class, "modulate", _wrap_Image_modulate);
SWIGV8_AddMemberFunction(_exports_Image_class, "moments", _wrap_Image_moments);
SWIGV8_AddMemberFunction(_exports_Image_class, "morphology", _wrap_Image__wrap_Image_morphology);
SWIGV8_AddMemberFunction(_exports_Image_class, "morphologyChannel", _wrap_Image__wrap_Image_morphologyChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "motionBlur", _wrap_Image_motionBlur);
SWIGV8_AddMemberFunction(_exports_Image_class, "negate", _wrap_Image__wrap_Image_negate);
SWIGV8_AddMemberFunction(_exports_Image_class, "negateChannel", _wrap_Image__wrap_Image_negateChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "normalize", _wrap_Image_normalize);
SWIGV8_AddMemberFunction(_exports_Image_class, "oilPaint", _wrap_Image__wrap_Image_oilPaint);
SWIGV8_AddMemberFunction(_exports_Image_class, "opacity", _wrap_Image_opacity);
SWIGV8_AddMemberFunction(_exports_Image_class, "opaque", _wrap_Image__wrap_Image_opaque);
SWIGV8_AddMemberFunction(_exports_Image_class, "orderedDither", _wrap_Image_orderedDither);
SWIGV8_AddMemberFunction(_exports_Image_class, "orderedDitherChannel", _wrap_Image_orderedDitherChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "perceptible", _wrap_Image_perceptible);
SWIGV8_AddMemberFunction(_exports_Image_class, "perceptibleChannel", _wrap_Image_perceptibleChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "ping", _wrap_Image__wrap_Image_ping);
SWIGV8_AddMemberFunction(_exports_Image_class, "pixelColor", _wrap_Image__wrap_Image_pixelColor);
SWIGV8_AddMemberFunction(_exports_Image_class, "polaroid", _wrap_Image_polaroid);
SWIGV8_AddMemberFunction(_exports_Image_class, "posterize", _wrap_Image__wrap_Image_posterize);
SWIGV8_AddMemberFunction(_exports_Image_class, "posterizeChannel", _wrap_Image__wrap_Image_posterizeChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "process", _wrap_Image_process);
SWIGV8_AddMemberFunction(_exports_Image_class, "profile", _wrap_Image__wrap_Image_profile);
SWIGV8_AddMemberFunction(_exports_Image_class, "quantize", _wrap_Image__wrap_Image_quantize);
SWIGV8_AddMemberFunction(_exports_Image_class, "quantumOperator", _wrap_Image__wrap_Image_quantumOperator);
SWIGV8_AddMemberFunction(_exports_Image_class, "raise", _wrap_Image__wrap_Image_raise);
SWIGV8_AddMemberFunction(_exports_Image_class, "randomThreshold", _wrap_Image_randomThreshold);
SWIGV8_AddMemberFunction(_exports_Image_class, "randomThresholdChannel", _wrap_Image_randomThresholdChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "read", _wrap_Image__wrap_Image_read);
SWIGV8_AddMemberFunction(_exports_Image_class, "readPixels", _wrap_Image_readPixels);
SWIGV8_AddMemberFunction(_exports_Image_class, "reduceNoise", _wrap_Image__wrap_Image_reduceNoise);
SWIGV8_AddMemberFunction(_exports_Image_class, "repage", _wrap_Image_repage);
SWIGV8_AddMemberFunction(_exports_Image_class, "resample", _wrap_Image_resample);
SWIGV8_AddMemberFunction(_exports_Image_class, "resize", _wrap_Image_resize);
SWIGV8_AddMemberFunction(_exports_Image_class, "roll", _wrap_Image__wrap_Image_roll);
SWIGV8_AddMemberFunction(_exports_Image_class, "rotate", _wrap_Image_rotate);
SWIGV8_AddMemberFunction(_exports_Image_class, "rotationalBlur", _wrap_Image_rotationalBlur);
SWIGV8_AddMemberFunction(_exports_Image_class, "rotationalBlurChannel", _wrap_Image_rotationalBlurChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "sample", _wrap_Image_sample);
SWIGV8_AddMemberFunction(_exports_Image_class, "scale", _wrap_Image_scale);
SWIGV8_AddMemberFunction(_exports_Image_class, "segment", _wrap_Image__wrap_Image_segment);
SWIGV8_AddMemberFunction(_exports_Image_class, "selectiveBlur", _wrap_Image_selectiveBlur);
SWIGV8_AddMemberFunction(_exports_Image_class, "selectiveBlurChannel", _wrap_Image_selectiveBlurChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "separate", _wrap_Image_separate);
SWIGV8_AddMemberFunction(_exports_Image_class, "sepiaTone", _wrap_Image_sepiaTone);
SWIGV8_AddMemberFunction(_exports_Image_class, "setPixels", _wrap_Image_setPixels);
SWIGV8_AddMemberFunction(_exports_Image_class, "shade", _wrap_Image__wrap_Image_shade);
SWIGV8_AddMemberFunction(_exports_Image_class, "shadow", _wrap_Image__wrap_Image_shadow);
SWIGV8_AddMemberFunction(_exports_Image_class, "sharpen", _wrap_Image__wrap_Image_sharpen);
SWIGV8_AddMemberFunction(_exports_Image_class, "sharpenChannel", _wrap_Image__wrap_Image_sharpenChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "shave", _wrap_Image_shave);
SWIGV8_AddMemberFunction(_exports_Image_class, "shear", _wrap_Image_shear);
SWIGV8_AddMemberFunction(_exports_Image_class, "sigmoidalContrast", _wrap_Image__wrap_Image_sigmoidalContrast);
SWIGV8_AddMemberFunction(_exports_Image_class, "signature", _wrap_Image__wrap_Image_signature);
SWIGV8_AddMemberFunction(_exports_Image_class, "sketch", _wrap_Image__wrap_Image_sketch);
SWIGV8_AddMemberFunction(_exports_Image_class, "solarize", _wrap_Image__wrap_Image_solarize);
SWIGV8_AddMemberFunction(_exports_Image_class, "sparseColor", _wrap_Image_sparseColor);
SWIGV8_AddMemberFunction(_exports_Image_class, "splice", _wrap_Image__wrap_Image_splice);
SWIGV8_AddMemberFunction(_exports_Image_class, "spread", _wrap_Image__wrap_Image_spread);
SWIGV8_AddMemberFunction(_exports_Image_class, "statistics", _wrap_Image_statistics);
SWIGV8_AddMemberFunction(_exports_Image_class, "stegano", _wrap_Image_stegano);
SWIGV8_AddMemberFunction(_exports_Image_class, "stereo", _wrap_Image_stereo);
SWIGV8_AddMemberFunction(_exports_Image_class, "strip", _wrap_Image_strip);
SWIGV8_AddMemberFunction(_exports_Image_class, "subImageSearch", _wrap_Image__wrap_Image_subImageSearch);
SWIGV8_AddMemberFunction(_exports_Image_class, "swirl", _wrap_Image_swirl);
SWIGV8_AddMemberFunction(_exports_Image_class, "syncPixels", _wrap_Image_syncPixels);
SWIGV8_AddMemberFunction(_exports_Image_class, "texture", _wrap_Image_texture);
SWIGV8_AddMemberFunction(_exports_Image_class, "threshold", _wrap_Image_threshold);
SWIGV8_AddMemberFunction(_exports_Image_class, "thumbnail", _wrap_Image_thumbnail);
SWIGV8_AddMemberFunction(_exports_Image_class, "tint", _wrap_Image_tint);
SWIGV8_AddMemberFunction(_exports_Image_class, "transform", _wrap_Image__wrap_Image_transform);
SWIGV8_AddMemberFunction(_exports_Image_class, "transformOrigin", _wrap_Image_transformOrigin);
SWIGV8_AddMemberFunction(_exports_Image_class, "transformReset", _wrap_Image_transformReset);
SWIGV8_AddMemberFunction(_exports_Image_class, "transformScale", _wrap_Image_transformScale);
SWIGV8_AddMemberFunction(_exports_Image_class, "transparent", _wrap_Image_transparent);
SWIGV8_AddMemberFunction(_exports_Image_class, "transparentChroma", _wrap_Image_transparentChroma);
SWIGV8_AddMemberFunction(_exports_Image_class, "transpose", _wrap_Image_transpose);
SWIGV8_AddMemberFunction(_exports_Image_class, "transverse", _wrap_Image_transverse);
SWIGV8_AddMemberFunction(_exports_Image_class, "trim", _wrap_Image_trim);
SWIGV8_AddMemberFunction(_exports_Image_class, "uniqueColors", _wrap_Image_uniqueColors);
SWIGV8_AddMemberFunction(_exports_Image_class, "unsharpmask", _wrap_Image_unsharpmask);
SWIGV8_AddMemberFunction(_exports_Image_class, "unsharpmaskChannel", _wrap_Image_unsharpmaskChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "vignette", _wrap_Image__wrap_Image_vignette);
SWIGV8_AddMemberFunction(_exports_Image_class, "wave", _wrap_Image__wrap_Image_wave);
SWIGV8_AddMemberFunction(_exports_Image_class, "waveletDenoise", _wrap_Image_waveletDenoise);
SWIGV8_AddMemberFunction(_exports_Image_class, "whiteThreshold", _wrap_Image_whiteThreshold);
SWIGV8_AddMemberFunction(_exports_Image_class, "whiteThresholdChannel", _wrap_Image_whiteThresholdChannel);
SWIGV8_AddMemberFunction(_exports_Image_class, "write", _wrap_Image__wrap_Image_write);
SWIGV8_AddMemberFunction(_exports_Image_class, "writePixels", _wrap_Image_writePixels);
SWIGV8_AddMemberFunction(_exports_Image_class, "zoom", _wrap_Image_zoom);
SWIGV8_AddMemberFunction(_exports_Image_class, "image", _wrap_Image_image);
SWIGV8_AddMemberFunction(_exports_Image_class, "constImage", _wrap_Image_constImage);
SWIGV8_AddMemberFunction(_exports_Image_class, "imageInfo", _wrap_Image_imageInfo);
SWIGV8_AddMemberFunction(_exports_Image_class, "constImageInfo", _wrap_Image_constImageInfo);
SWIGV8_AddMemberFunction(_exports_Image_class, "options", _wrap_Image_options);
SWIGV8_AddMemberFunction(_exports_Image_class, "constOptions", _wrap_Image_constOptions);
SWIGV8_AddMemberFunction(_exports_Image_class, "quantizeInfo", _wrap_Image_quantizeInfo);
SWIGV8_AddMemberFunction(_exports_Image_class, "constQuantizeInfo", _wrap_Image_constQuantizeInfo);
SWIGV8_AddMemberFunction(_exports_Image_class, "modifyImage", _wrap_Image_modifyImage);
SWIGV8_AddMemberFunction(_exports_Image_class, "replaceImage", _wrap_Image_replaceImage);
SWIGV8_AddMemberFunction(_exports_Image_class, "throwImageException", _wrap_Image_throwImageException);


  /* setup inheritances */
  if (SWIGTYPE_p_Magick__Color->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Color->clientdata)->class_templ.IsEmpty()))
{
  _exports_ColorGray_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Color->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_ColorGray _Magick__Color\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_ColorGray _Magick__Color\n");
#endif
}
if (SWIGTYPE_p_Magick__Color->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Color->clientdata)->class_templ.IsEmpty()))
{
  _exports_ColorHSL_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Color->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_ColorHSL _Magick__Color\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_ColorHSL _Magick__Color\n");
#endif
}
if (SWIGTYPE_p_Magick__Color->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Color->clientdata)->class_templ.IsEmpty()))
{
  _exports_ColorMono_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Color->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_ColorMono _Magick__Color\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_ColorMono _Magick__Color\n");
#endif
}
if (SWIGTYPE_p_Magick__Color->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Color->clientdata)->class_templ.IsEmpty()))
{
  _exports_ColorRGB_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Color->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_ColorRGB _Magick__Color\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_ColorRGB _Magick__Color\n");
#endif
}
if (SWIGTYPE_p_Magick__Color->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Color->clientdata)->class_templ.IsEmpty()))
{
  _exports_ColorYUV_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Color->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_ColorYUV _Magick__Color\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_ColorYUV _Magick__Color\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableAffine_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableAffine _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableAffine _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableArc_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableArc _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableArc _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableBezier_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableBezier _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableBezier _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawablePopClipPath_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawablePopClipPath _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawablePopClipPath _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawablePushClipPath_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawablePushClipPath _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawablePushClipPath _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableClipPath_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableClipPath _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableClipPath _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableCircle_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableCircle _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableCircle _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableColor_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableColor _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableColor _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableCompositeImage_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableCompositeImage _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableCompositeImage _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableDensity_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableDensity _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableDensity _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableEllipse_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableEllipse _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableEllipse _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableFillColor_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableFillColor _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableFillColor _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableFillRule_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableFillRule _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableFillRule _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableFillOpacity_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableFillOpacity _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableFillOpacity _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableFont_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableFont _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableFont _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableGravity_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableGravity _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableGravity _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableLine_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableLine _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableLine _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableMatte_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableMatte _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableMatte _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawablePath_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawablePath _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawablePath _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawablePoint_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawablePoint _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawablePoint _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawablePointSize_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawablePointSize _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawablePointSize _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawablePolygon_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawablePolygon _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawablePolygon _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawablePolyline_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawablePolyline _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawablePolyline _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawablePopGraphicContext_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawablePopGraphicContext _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawablePopGraphicContext _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawablePushGraphicContext_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawablePushGraphicContext _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawablePushGraphicContext _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawablePopPattern_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawablePopPattern _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawablePopPattern _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawablePushPattern_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawablePushPattern _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawablePushPattern _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableRectangle_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableRectangle _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableRectangle _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableRotation_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableRotation _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableRotation _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableRoundRectangle_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableRoundRectangle _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableRoundRectangle _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableScaling_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableScaling _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableScaling _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableSkewX_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableSkewX _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableSkewX _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableSkewY_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableSkewY _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableSkewY _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableDashArray_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableDashArray _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableDashArray _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableDashOffset_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableDashOffset _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableDashOffset _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableStrokeLineCap_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableStrokeLineCap _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableStrokeLineCap _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableStrokeLineJoin_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableStrokeLineJoin _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableStrokeLineJoin _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableMiterLimit_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableMiterLimit _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableMiterLimit _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableStrokeAntialias_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableStrokeAntialias _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableStrokeAntialias _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableStrokeColor_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableStrokeColor _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableStrokeColor _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableStrokeOpacity_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableStrokeOpacity _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableStrokeOpacity _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableStrokeWidth_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableStrokeWidth _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableStrokeWidth _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableText_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableText _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableText _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableTextAntialias_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableTextAntialias _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableTextAntialias _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableTextDecoration_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableTextDecoration _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableTextDecoration _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableTextDirection_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableTextDirection _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableTextDirection _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableTextInterlineSpacing_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableTextInterlineSpacing _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableTextInterlineSpacing _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableTextInterwordSpacing_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableTextInterwordSpacing _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableTextInterwordSpacing _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableTextKerning_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableTextKerning _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableTextKerning _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableTextUnderColor_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableTextUnderColor _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableTextUnderColor _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableTranslation_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableTranslation _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableTranslation _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__DrawableBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_DrawableViewbox_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__DrawableBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_DrawableViewbox _Magick__DrawableBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_DrawableViewbox _Magick__DrawableBase\n");
#endif
}
if (SWIGTYPE_p_Magick__VPathBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_PathArcAbs_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_PathArcAbs _Magick__VPathBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_PathArcAbs _Magick__VPathBase\n");
#endif
}
if (SWIGTYPE_p_Magick__VPathBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_PathArcRel_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_PathArcRel _Magick__VPathBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_PathArcRel _Magick__VPathBase\n");
#endif
}
if (SWIGTYPE_p_Magick__VPathBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_PathClosePath_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_PathClosePath _Magick__VPathBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_PathClosePath _Magick__VPathBase\n");
#endif
}
if (SWIGTYPE_p_Magick__VPathBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_PathCurvetoAbs_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_PathCurvetoAbs _Magick__VPathBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_PathCurvetoAbs _Magick__VPathBase\n");
#endif
}
if (SWIGTYPE_p_Magick__VPathBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_PathCurvetoRel_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_PathCurvetoRel _Magick__VPathBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_PathCurvetoRel _Magick__VPathBase\n");
#endif
}
if (SWIGTYPE_p_Magick__VPathBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_PathSmoothCurvetoAbs_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_PathSmoothCurvetoAbs _Magick__VPathBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_PathSmoothCurvetoAbs _Magick__VPathBase\n");
#endif
}
if (SWIGTYPE_p_Magick__VPathBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_PathSmoothCurvetoRel_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_PathSmoothCurvetoRel _Magick__VPathBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_PathSmoothCurvetoRel _Magick__VPathBase\n");
#endif
}
if (SWIGTYPE_p_Magick__VPathBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_PathQuadraticCurvetoAbs_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_PathQuadraticCurvetoAbs _Magick__VPathBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_PathQuadraticCurvetoAbs _Magick__VPathBase\n");
#endif
}
if (SWIGTYPE_p_Magick__VPathBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_PathQuadraticCurvetoRel_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_PathQuadraticCurvetoRel _Magick__VPathBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_PathQuadraticCurvetoRel _Magick__VPathBase\n");
#endif
}
if (SWIGTYPE_p_Magick__VPathBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_PathSmoothQuadraticCurvetoAbs_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_PathSmoothQuadraticCurvetoAbs _Magick__VPathBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_PathSmoothQuadraticCurvetoAbs _Magick__VPathBase\n");
#endif
}
if (SWIGTYPE_p_Magick__VPathBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_PathSmoothQuadraticCurvetoRel_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_PathSmoothQuadraticCurvetoRel _Magick__VPathBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_PathSmoothQuadraticCurvetoRel _Magick__VPathBase\n");
#endif
}
if (SWIGTYPE_p_Magick__VPathBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_PathLinetoAbs_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_PathLinetoAbs _Magick__VPathBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_PathLinetoAbs _Magick__VPathBase\n");
#endif
}
if (SWIGTYPE_p_Magick__VPathBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_PathLinetoRel_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_PathLinetoRel _Magick__VPathBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_PathLinetoRel _Magick__VPathBase\n");
#endif
}
if (SWIGTYPE_p_Magick__VPathBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_PathLinetoHorizontalAbs_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_PathLinetoHorizontalAbs _Magick__VPathBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_PathLinetoHorizontalAbs _Magick__VPathBase\n");
#endif
}
if (SWIGTYPE_p_Magick__VPathBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_PathLinetoHorizontalRel_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_PathLinetoHorizontalRel _Magick__VPathBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_PathLinetoHorizontalRel _Magick__VPathBase\n");
#endif
}
if (SWIGTYPE_p_Magick__VPathBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_PathLinetoVerticalAbs_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_PathLinetoVerticalAbs _Magick__VPathBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_PathLinetoVerticalAbs _Magick__VPathBase\n");
#endif
}
if (SWIGTYPE_p_Magick__VPathBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_PathLinetoVerticalRel_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_PathLinetoVerticalRel _Magick__VPathBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_PathLinetoVerticalRel _Magick__VPathBase\n");
#endif
}
if (SWIGTYPE_p_Magick__VPathBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_PathMovetoAbs_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_PathMovetoAbs _Magick__VPathBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_PathMovetoAbs _Magick__VPathBase\n");
#endif
}
if (SWIGTYPE_p_Magick__VPathBase->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ.IsEmpty()))
{
  _exports_PathMovetoRel_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__VPathBase->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_PathMovetoRel _Magick__VPathBase\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_PathMovetoRel _Magick__VPathBase\n");
#endif
}
if (SWIGTYPE_p_Magick__Exception->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Exception->clientdata)->class_templ.IsEmpty()))
{
  _exports_Error_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Exception->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_Error _Magick__Exception\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_Error _Magick__Exception\n");
#endif
}
if (SWIGTYPE_p_Magick__Error->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ.IsEmpty()))
{
  _exports_ErrorBlob_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_ErrorBlob _Magick__Error\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_ErrorBlob _Magick__Error\n");
#endif
}
if (SWIGTYPE_p_Magick__Error->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ.IsEmpty()))
{
  _exports_ErrorCache_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_ErrorCache _Magick__Error\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_ErrorCache _Magick__Error\n");
#endif
}
if (SWIGTYPE_p_Magick__Error->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ.IsEmpty()))
{
  _exports_ErrorCoder_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_ErrorCoder _Magick__Error\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_ErrorCoder _Magick__Error\n");
#endif
}
if (SWIGTYPE_p_Magick__Error->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ.IsEmpty()))
{
  _exports_ErrorConfigure_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_ErrorConfigure _Magick__Error\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_ErrorConfigure _Magick__Error\n");
#endif
}
if (SWIGTYPE_p_Magick__Error->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ.IsEmpty()))
{
  _exports_ErrorCorruptImage_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_ErrorCorruptImage _Magick__Error\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_ErrorCorruptImage _Magick__Error\n");
#endif
}
if (SWIGTYPE_p_Magick__Error->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ.IsEmpty()))
{
  _exports_ErrorDelegate_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_ErrorDelegate _Magick__Error\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_ErrorDelegate _Magick__Error\n");
#endif
}
if (SWIGTYPE_p_Magick__Error->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ.IsEmpty()))
{
  _exports_ErrorDraw_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_ErrorDraw _Magick__Error\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_ErrorDraw _Magick__Error\n");
#endif
}
if (SWIGTYPE_p_Magick__Error->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ.IsEmpty()))
{
  _exports_ErrorFileOpen_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_ErrorFileOpen _Magick__Error\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_ErrorFileOpen _Magick__Error\n");
#endif
}
if (SWIGTYPE_p_Magick__Error->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ.IsEmpty()))
{
  _exports_ErrorImage_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_ErrorImage _Magick__Error\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_ErrorImage _Magick__Error\n");
#endif
}
if (SWIGTYPE_p_Magick__Error->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ.IsEmpty()))
{
  _exports_ErrorMissingDelegate_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_ErrorMissingDelegate _Magick__Error\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_ErrorMissingDelegate _Magick__Error\n");
#endif
}
if (SWIGTYPE_p_Magick__Error->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ.IsEmpty()))
{
  _exports_ErrorModule_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_ErrorModule _Magick__Error\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_ErrorModule _Magick__Error\n");
#endif
}
if (SWIGTYPE_p_Magick__Error->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ.IsEmpty()))
{
  _exports_ErrorMonitor_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_ErrorMonitor _Magick__Error\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_ErrorMonitor _Magick__Error\n");
#endif
}
if (SWIGTYPE_p_Magick__Error->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ.IsEmpty()))
{
  _exports_ErrorOption_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_ErrorOption _Magick__Error\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_ErrorOption _Magick__Error\n");
#endif
}
if (SWIGTYPE_p_Magick__Error->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ.IsEmpty()))
{
  _exports_ErrorPolicy_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_ErrorPolicy _Magick__Error\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_ErrorPolicy _Magick__Error\n");
#endif
}
if (SWIGTYPE_p_Magick__Error->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ.IsEmpty()))
{
  _exports_ErrorRegistry_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_ErrorRegistry _Magick__Error\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_ErrorRegistry _Magick__Error\n");
#endif
}
if (SWIGTYPE_p_Magick__Error->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ.IsEmpty()))
{
  _exports_ErrorResourceLimit_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_ErrorResourceLimit _Magick__Error\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_ErrorResourceLimit _Magick__Error\n");
#endif
}
if (SWIGTYPE_p_Magick__Error->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ.IsEmpty()))
{
  _exports_ErrorStream_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_ErrorStream _Magick__Error\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_ErrorStream _Magick__Error\n");
#endif
}
if (SWIGTYPE_p_Magick__Error->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ.IsEmpty()))
{
  _exports_ErrorType_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_ErrorType _Magick__Error\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_ErrorType _Magick__Error\n");
#endif
}
if (SWIGTYPE_p_Magick__Error->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ.IsEmpty()))
{
  _exports_ErrorUndefined_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_ErrorUndefined _Magick__Error\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_ErrorUndefined _Magick__Error\n");
#endif
}
if (SWIGTYPE_p_Magick__Error->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ.IsEmpty()))
{
  _exports_ErrorXServer_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Error->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_ErrorXServer _Magick__Error\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_ErrorXServer _Magick__Error\n");
#endif
}
if (SWIGTYPE_p_Magick__Exception->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Exception->clientdata)->class_templ.IsEmpty()))
{
  _exports_Warning_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Exception->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_Warning _Magick__Exception\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_Warning _Magick__Exception\n");
#endif
}
if (SWIGTYPE_p_Magick__Warning->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ.IsEmpty()))
{
  _exports_WarningBlob_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_WarningBlob _Magick__Warning\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_WarningBlob _Magick__Warning\n");
#endif
}
if (SWIGTYPE_p_Magick__Warning->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ.IsEmpty()))
{
  _exports_WarningCache_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_WarningCache _Magick__Warning\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_WarningCache _Magick__Warning\n");
#endif
}
if (SWIGTYPE_p_Magick__Warning->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ.IsEmpty()))
{
  _exports_WarningCoder_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_WarningCoder _Magick__Warning\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_WarningCoder _Magick__Warning\n");
#endif
}
if (SWIGTYPE_p_Magick__Warning->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ.IsEmpty()))
{
  _exports_WarningConfigure_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_WarningConfigure _Magick__Warning\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_WarningConfigure _Magick__Warning\n");
#endif
}
if (SWIGTYPE_p_Magick__Warning->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ.IsEmpty()))
{
  _exports_WarningCorruptImage_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_WarningCorruptImage _Magick__Warning\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_WarningCorruptImage _Magick__Warning\n");
#endif
}
if (SWIGTYPE_p_Magick__Warning->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ.IsEmpty()))
{
  _exports_WarningDelegate_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_WarningDelegate _Magick__Warning\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_WarningDelegate _Magick__Warning\n");
#endif
}
if (SWIGTYPE_p_Magick__Warning->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ.IsEmpty()))
{
  _exports_WarningDraw_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_WarningDraw _Magick__Warning\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_WarningDraw _Magick__Warning\n");
#endif
}
if (SWIGTYPE_p_Magick__Warning->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ.IsEmpty()))
{
  _exports_WarningFileOpen_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_WarningFileOpen _Magick__Warning\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_WarningFileOpen _Magick__Warning\n");
#endif
}
if (SWIGTYPE_p_Magick__Warning->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ.IsEmpty()))
{
  _exports_WarningImage_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_WarningImage _Magick__Warning\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_WarningImage _Magick__Warning\n");
#endif
}
if (SWIGTYPE_p_Magick__Warning->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ.IsEmpty()))
{
  _exports_WarningMissingDelegate_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_WarningMissingDelegate _Magick__Warning\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_WarningMissingDelegate _Magick__Warning\n");
#endif
}
if (SWIGTYPE_p_Magick__Warning->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ.IsEmpty()))
{
  _exports_WarningModule_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_WarningModule _Magick__Warning\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_WarningModule _Magick__Warning\n");
#endif
}
if (SWIGTYPE_p_Magick__Warning->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ.IsEmpty()))
{
  _exports_WarningMonitor_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_WarningMonitor _Magick__Warning\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_WarningMonitor _Magick__Warning\n");
#endif
}
if (SWIGTYPE_p_Magick__Warning->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ.IsEmpty()))
{
  _exports_WarningOption_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_WarningOption _Magick__Warning\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_WarningOption _Magick__Warning\n");
#endif
}
if (SWIGTYPE_p_Magick__Warning->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ.IsEmpty()))
{
  _exports_WarningPolicy_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_WarningPolicy _Magick__Warning\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_WarningPolicy _Magick__Warning\n");
#endif
}
if (SWIGTYPE_p_Magick__Warning->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ.IsEmpty()))
{
  _exports_WarningRegistry_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_WarningRegistry _Magick__Warning\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_WarningRegistry _Magick__Warning\n");
#endif
}
if (SWIGTYPE_p_Magick__Warning->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ.IsEmpty()))
{
  _exports_WarningResourceLimit_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_WarningResourceLimit _Magick__Warning\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_WarningResourceLimit _Magick__Warning\n");
#endif
}
if (SWIGTYPE_p_Magick__Warning->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ.IsEmpty()))
{
  _exports_WarningStream_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_WarningStream _Magick__Warning\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_WarningStream _Magick__Warning\n");
#endif
}
if (SWIGTYPE_p_Magick__Warning->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ.IsEmpty()))
{
  _exports_WarningType_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_WarningType _Magick__Warning\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_WarningType _Magick__Warning\n");
#endif
}
if (SWIGTYPE_p_Magick__Warning->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ.IsEmpty()))
{
  _exports_WarningUndefined_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_WarningUndefined _Magick__Warning\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_WarningUndefined _Magick__Warning\n");
#endif
}
if (SWIGTYPE_p_Magick__Warning->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ.IsEmpty()))
{
  _exports_WarningXServer_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Warning->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_WarningXServer _Magick__Warning\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_WarningXServer _Magick__Warning\n");
#endif
}
if (SWIGTYPE_p_Magick__Montage->clientdata && !(static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Montage->clientdata)->class_templ.IsEmpty()))
{
  _exports_MontageFramed_class->Inherit(
    v8::Local<v8::FunctionTemplate>::New(
      v8::Isolate::GetCurrent(),
      static_cast<SWIGV8_ClientData *>(SWIGTYPE_p_Magick__Montage->clientdata)->class_templ)
    );
  
#ifdef SWIGRUNTIME_DEBUG
  printf("Inheritance successful _exports_MontageFramed _Magick__Montage\n");
#endif
} else {
#ifdef SWIGRUNTIME_DEBUG
  printf("Unable to inherit baseclass, it didn't exist _exports_MontageFramed _Magick__Montage\n");
#endif
}


  /* class instances */
  /* Class: TypeMetric (_exports_TypeMetric) */
SWIGV8_FUNCTION_TEMPLATE _exports_TypeMetric_class_0 = SWIGV8_CreateClassTemplate("TypeMetric");
_exports_TypeMetric_class_0->SetCallHandler(_wrap_new_TypeMetric);
_exports_TypeMetric_class_0->Inherit(_exports_TypeMetric_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_TypeMetric_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_TypeMetric_obj = _exports_TypeMetric_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_TypeMetric_obj = _exports_TypeMetric_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: Geometry (_exports_Geometry) */
SWIGV8_FUNCTION_TEMPLATE _exports_Geometry_class_0 = SWIGV8_CreateClassTemplate("Geometry");
_exports_Geometry_class_0->SetCallHandler(_wrap_new_Geometry);
_exports_Geometry_class_0->Inherit(_exports_Geometry_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_Geometry_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_Geometry_obj = _exports_Geometry_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_Geometry_obj = _exports_Geometry_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: Offset (_exports_Offset) */
SWIGV8_FUNCTION_TEMPLATE _exports_Offset_class_0 = SWIGV8_CreateClassTemplate("Offset");
_exports_Offset_class_0->SetCallHandler(_wrap_new_Offset);
_exports_Offset_class_0->Inherit(_exports_Offset_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_Offset_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_Offset_obj = _exports_Offset_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_Offset_obj = _exports_Offset_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: Pixels (_exports_Pixels) */
SWIGV8_FUNCTION_TEMPLATE _exports_Pixels_class_0 = SWIGV8_CreateClassTemplate("Pixels");
_exports_Pixels_class_0->SetCallHandler(_wrap_new_Pixels);
_exports_Pixels_class_0->Inherit(_exports_Pixels_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_Pixels_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_Pixels_obj = _exports_Pixels_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_Pixels_obj = _exports_Pixels_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: PixelData (_exports_PixelData) */
SWIGV8_FUNCTION_TEMPLATE _exports_PixelData_class_0 = SWIGV8_CreateClassTemplate("PixelData");
_exports_PixelData_class_0->SetCallHandler(_wrap_new_PixelData);
_exports_PixelData_class_0->Inherit(_exports_PixelData_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_PixelData_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_PixelData_obj = _exports_PixelData_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_PixelData_obj = _exports_PixelData_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ResourceLimits (_exports_ResourceLimits) */
SWIGV8_FUNCTION_TEMPLATE _exports_ResourceLimits_class_0 = SWIGV8_CreateClassTemplate("ResourceLimits");
_exports_ResourceLimits_class_0->SetCallHandler(_wrap_new_veto_ResourceLimits);
_exports_ResourceLimits_class_0->Inherit(_exports_ResourceLimits_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ResourceLimits_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ResourceLimits_obj = _exports_ResourceLimits_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ResourceLimits_obj = _exports_ResourceLimits_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: adaptiveBlurImage (_exports_adaptiveBlurImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_adaptiveBlurImage_class_0 = SWIGV8_CreateClassTemplate("adaptiveBlurImage");
_exports_adaptiveBlurImage_class_0->SetCallHandler(_wrap_new_adaptiveBlurImage);
_exports_adaptiveBlurImage_class_0->Inherit(_exports_adaptiveBlurImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_adaptiveBlurImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_adaptiveBlurImage_obj = _exports_adaptiveBlurImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_adaptiveBlurImage_obj = _exports_adaptiveBlurImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: adaptiveThresholdImage (_exports_adaptiveThresholdImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_adaptiveThresholdImage_class_0 = SWIGV8_CreateClassTemplate("adaptiveThresholdImage");
_exports_adaptiveThresholdImage_class_0->SetCallHandler(_wrap_new_adaptiveThresholdImage);
_exports_adaptiveThresholdImage_class_0->Inherit(_exports_adaptiveThresholdImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_adaptiveThresholdImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_adaptiveThresholdImage_obj = _exports_adaptiveThresholdImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_adaptiveThresholdImage_obj = _exports_adaptiveThresholdImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: addNoiseImage (_exports_addNoiseImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_addNoiseImage_class_0 = SWIGV8_CreateClassTemplate("addNoiseImage");
_exports_addNoiseImage_class_0->SetCallHandler(_wrap_new_addNoiseImage);
_exports_addNoiseImage_class_0->Inherit(_exports_addNoiseImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_addNoiseImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_addNoiseImage_obj = _exports_addNoiseImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_addNoiseImage_obj = _exports_addNoiseImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: affineTransformImage (_exports_affineTransformImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_affineTransformImage_class_0 = SWIGV8_CreateClassTemplate("affineTransformImage");
_exports_affineTransformImage_class_0->SetCallHandler(_wrap_new_affineTransformImage);
_exports_affineTransformImage_class_0->Inherit(_exports_affineTransformImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_affineTransformImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_affineTransformImage_obj = _exports_affineTransformImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_affineTransformImage_obj = _exports_affineTransformImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: annotateImage (_exports_annotateImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_annotateImage_class_0 = SWIGV8_CreateClassTemplate("annotateImage");
_exports_annotateImage_class_0->SetCallHandler(_wrap_new_annotateImage);
_exports_annotateImage_class_0->Inherit(_exports_annotateImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_annotateImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_annotateImage_obj = _exports_annotateImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_annotateImage_obj = _exports_annotateImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: blurImage (_exports_blurImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_blurImage_class_0 = SWIGV8_CreateClassTemplate("blurImage");
_exports_blurImage_class_0->SetCallHandler(_wrap_new_blurImage);
_exports_blurImage_class_0->Inherit(_exports_blurImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_blurImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_blurImage_obj = _exports_blurImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_blurImage_obj = _exports_blurImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: borderImage (_exports_borderImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_borderImage_class_0 = SWIGV8_CreateClassTemplate("borderImage");
_exports_borderImage_class_0->SetCallHandler(_wrap_new_borderImage);
_exports_borderImage_class_0->Inherit(_exports_borderImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_borderImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_borderImage_obj = _exports_borderImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_borderImage_obj = _exports_borderImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: channelImage (_exports_channelImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_channelImage_class_0 = SWIGV8_CreateClassTemplate("channelImage");
_exports_channelImage_class_0->SetCallHandler(_wrap_new_channelImage);
_exports_channelImage_class_0->Inherit(_exports_channelImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_channelImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_channelImage_obj = _exports_channelImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_channelImage_obj = _exports_channelImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: charcoalImage (_exports_charcoalImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_charcoalImage_class_0 = SWIGV8_CreateClassTemplate("charcoalImage");
_exports_charcoalImage_class_0->SetCallHandler(_wrap_new_charcoalImage);
_exports_charcoalImage_class_0->Inherit(_exports_charcoalImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_charcoalImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_charcoalImage_obj = _exports_charcoalImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_charcoalImage_obj = _exports_charcoalImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: chopImage (_exports_chopImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_chopImage_class_0 = SWIGV8_CreateClassTemplate("chopImage");
_exports_chopImage_class_0->SetCallHandler(_wrap_new_chopImage);
_exports_chopImage_class_0->Inherit(_exports_chopImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_chopImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_chopImage_obj = _exports_chopImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_chopImage_obj = _exports_chopImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: cdlImage (_exports_cdlImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_cdlImage_class_0 = SWIGV8_CreateClassTemplate("cdlImage");
_exports_cdlImage_class_0->SetCallHandler(_wrap_new_cdlImage);
_exports_cdlImage_class_0->Inherit(_exports_cdlImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_cdlImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_cdlImage_obj = _exports_cdlImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_cdlImage_obj = _exports_cdlImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: colorizeImage (_exports_colorizeImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_colorizeImage_class_0 = SWIGV8_CreateClassTemplate("colorizeImage");
_exports_colorizeImage_class_0->SetCallHandler(_wrap_new_colorizeImage);
_exports_colorizeImage_class_0->Inherit(_exports_colorizeImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_colorizeImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_colorizeImage_obj = _exports_colorizeImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_colorizeImage_obj = _exports_colorizeImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: colorMatrixImage (_exports_colorMatrixImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_colorMatrixImage_class_0 = SWIGV8_CreateClassTemplate("colorMatrixImage");
_exports_colorMatrixImage_class_0->SetCallHandler(_wrap_new_colorMatrixImage);
_exports_colorMatrixImage_class_0->Inherit(_exports_colorMatrixImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_colorMatrixImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_colorMatrixImage_obj = _exports_colorMatrixImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_colorMatrixImage_obj = _exports_colorMatrixImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: colorSpaceImage (_exports_colorSpaceImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_colorSpaceImage_class_0 = SWIGV8_CreateClassTemplate("colorSpaceImage");
_exports_colorSpaceImage_class_0->SetCallHandler(_wrap_new_colorSpaceImage);
_exports_colorSpaceImage_class_0->Inherit(_exports_colorSpaceImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_colorSpaceImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_colorSpaceImage_obj = _exports_colorSpaceImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_colorSpaceImage_obj = _exports_colorSpaceImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: commentImage (_exports_commentImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_commentImage_class_0 = SWIGV8_CreateClassTemplate("commentImage");
_exports_commentImage_class_0->SetCallHandler(_wrap_new_commentImage);
_exports_commentImage_class_0->Inherit(_exports_commentImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_commentImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_commentImage_obj = _exports_commentImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_commentImage_obj = _exports_commentImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: compositeImage (_exports_compositeImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_compositeImage_class_0 = SWIGV8_CreateClassTemplate("compositeImage");
_exports_compositeImage_class_0->SetCallHandler(_wrap_new_compositeImage);
_exports_compositeImage_class_0->Inherit(_exports_compositeImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_compositeImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_compositeImage_obj = _exports_compositeImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_compositeImage_obj = _exports_compositeImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: contrastImage (_exports_contrastImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_contrastImage_class_0 = SWIGV8_CreateClassTemplate("contrastImage");
_exports_contrastImage_class_0->SetCallHandler(_wrap_new_contrastImage);
_exports_contrastImage_class_0->Inherit(_exports_contrastImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_contrastImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_contrastImage_obj = _exports_contrastImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_contrastImage_obj = _exports_contrastImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: cropImage (_exports_cropImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_cropImage_class_0 = SWIGV8_CreateClassTemplate("cropImage");
_exports_cropImage_class_0->SetCallHandler(_wrap_new_cropImage);
_exports_cropImage_class_0->Inherit(_exports_cropImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_cropImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_cropImage_obj = _exports_cropImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_cropImage_obj = _exports_cropImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: cycleColormapImage (_exports_cycleColormapImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_cycleColormapImage_class_0 = SWIGV8_CreateClassTemplate("cycleColormapImage");
_exports_cycleColormapImage_class_0->SetCallHandler(_wrap_new_cycleColormapImage);
_exports_cycleColormapImage_class_0->Inherit(_exports_cycleColormapImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_cycleColormapImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_cycleColormapImage_obj = _exports_cycleColormapImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_cycleColormapImage_obj = _exports_cycleColormapImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: despeckleImage (_exports_despeckleImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_despeckleImage_class_0 = SWIGV8_CreateClassTemplate("despeckleImage");
_exports_despeckleImage_class_0->SetCallHandler(_wrap_new_despeckleImage);
_exports_despeckleImage_class_0->Inherit(_exports_despeckleImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_despeckleImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_despeckleImage_obj = _exports_despeckleImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_despeckleImage_obj = _exports_despeckleImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: distortImage (_exports_distortImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_distortImage_class_0 = SWIGV8_CreateClassTemplate("distortImage");
_exports_distortImage_class_0->SetCallHandler(_wrap_new_distortImage);
_exports_distortImage_class_0->Inherit(_exports_distortImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_distortImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_distortImage_obj = _exports_distortImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_distortImage_obj = _exports_distortImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: drawImage (_exports_drawImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_drawImage_class_0 = SWIGV8_CreateClassTemplate("drawImage");
_exports_drawImage_class_0->SetCallHandler(_wrap_new_drawImage);
_exports_drawImage_class_0->Inherit(_exports_drawImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_drawImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_drawImage_obj = _exports_drawImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_drawImage_obj = _exports_drawImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: edgeImage (_exports_edgeImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_edgeImage_class_0 = SWIGV8_CreateClassTemplate("edgeImage");
_exports_edgeImage_class_0->SetCallHandler(_wrap_new_edgeImage);
_exports_edgeImage_class_0->Inherit(_exports_edgeImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_edgeImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_edgeImage_obj = _exports_edgeImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_edgeImage_obj = _exports_edgeImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: embossImage (_exports_embossImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_embossImage_class_0 = SWIGV8_CreateClassTemplate("embossImage");
_exports_embossImage_class_0->SetCallHandler(_wrap_new_embossImage);
_exports_embossImage_class_0->Inherit(_exports_embossImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_embossImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_embossImage_obj = _exports_embossImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_embossImage_obj = _exports_embossImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: enhanceImage (_exports_enhanceImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_enhanceImage_class_0 = SWIGV8_CreateClassTemplate("enhanceImage");
_exports_enhanceImage_class_0->SetCallHandler(_wrap_new_enhanceImage);
_exports_enhanceImage_class_0->Inherit(_exports_enhanceImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_enhanceImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_enhanceImage_obj = _exports_enhanceImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_enhanceImage_obj = _exports_enhanceImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: equalizeImage (_exports_equalizeImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_equalizeImage_class_0 = SWIGV8_CreateClassTemplate("equalizeImage");
_exports_equalizeImage_class_0->SetCallHandler(_wrap_new_equalizeImage);
_exports_equalizeImage_class_0->Inherit(_exports_equalizeImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_equalizeImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_equalizeImage_obj = _exports_equalizeImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_equalizeImage_obj = _exports_equalizeImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: fillColorImage (_exports_fillColorImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_fillColorImage_class_0 = SWIGV8_CreateClassTemplate("fillColorImage");
_exports_fillColorImage_class_0->SetCallHandler(_wrap_new_fillColorImage);
_exports_fillColorImage_class_0->Inherit(_exports_fillColorImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_fillColorImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_fillColorImage_obj = _exports_fillColorImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_fillColorImage_obj = _exports_fillColorImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: flipImage (_exports_flipImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_flipImage_class_0 = SWIGV8_CreateClassTemplate("flipImage");
_exports_flipImage_class_0->SetCallHandler(_wrap_new_flipImage);
_exports_flipImage_class_0->Inherit(_exports_flipImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_flipImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_flipImage_obj = _exports_flipImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_flipImage_obj = _exports_flipImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: floodFillColorImage (_exports_floodFillColorImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_floodFillColorImage_class_0 = SWIGV8_CreateClassTemplate("floodFillColorImage");
_exports_floodFillColorImage_class_0->SetCallHandler(_wrap_new_floodFillColorImage);
_exports_floodFillColorImage_class_0->Inherit(_exports_floodFillColorImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_floodFillColorImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_floodFillColorImage_obj = _exports_floodFillColorImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_floodFillColorImage_obj = _exports_floodFillColorImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: floodFillTextureImage (_exports_floodFillTextureImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_floodFillTextureImage_class_0 = SWIGV8_CreateClassTemplate("floodFillTextureImage");
_exports_floodFillTextureImage_class_0->SetCallHandler(_wrap_new_floodFillTextureImage);
_exports_floodFillTextureImage_class_0->Inherit(_exports_floodFillTextureImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_floodFillTextureImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_floodFillTextureImage_obj = _exports_floodFillTextureImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_floodFillTextureImage_obj = _exports_floodFillTextureImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: flopImage (_exports_flopImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_flopImage_class_0 = SWIGV8_CreateClassTemplate("flopImage");
_exports_flopImage_class_0->SetCallHandler(_wrap_new_flopImage);
_exports_flopImage_class_0->Inherit(_exports_flopImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_flopImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_flopImage_obj = _exports_flopImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_flopImage_obj = _exports_flopImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: frameImage (_exports_frameImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_frameImage_class_0 = SWIGV8_CreateClassTemplate("frameImage");
_exports_frameImage_class_0->SetCallHandler(_wrap_new_frameImage);
_exports_frameImage_class_0->Inherit(_exports_frameImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_frameImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_frameImage_obj = _exports_frameImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_frameImage_obj = _exports_frameImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: gammaImage (_exports_gammaImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_gammaImage_class_0 = SWIGV8_CreateClassTemplate("gammaImage");
_exports_gammaImage_class_0->SetCallHandler(_wrap_new_gammaImage);
_exports_gammaImage_class_0->Inherit(_exports_gammaImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_gammaImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_gammaImage_obj = _exports_gammaImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_gammaImage_obj = _exports_gammaImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: gaussianBlurImage (_exports_gaussianBlurImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_gaussianBlurImage_class_0 = SWIGV8_CreateClassTemplate("gaussianBlurImage");
_exports_gaussianBlurImage_class_0->SetCallHandler(_wrap_new_gaussianBlurImage);
_exports_gaussianBlurImage_class_0->Inherit(_exports_gaussianBlurImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_gaussianBlurImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_gaussianBlurImage_obj = _exports_gaussianBlurImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_gaussianBlurImage_obj = _exports_gaussianBlurImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: haldClutImage (_exports_haldClutImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_haldClutImage_class_0 = SWIGV8_CreateClassTemplate("haldClutImage");
_exports_haldClutImage_class_0->SetCallHandler(_wrap_new_haldClutImage);
_exports_haldClutImage_class_0->Inherit(_exports_haldClutImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_haldClutImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_haldClutImage_obj = _exports_haldClutImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_haldClutImage_obj = _exports_haldClutImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: implodeImage (_exports_implodeImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_implodeImage_class_0 = SWIGV8_CreateClassTemplate("implodeImage");
_exports_implodeImage_class_0->SetCallHandler(_wrap_new_implodeImage);
_exports_implodeImage_class_0->Inherit(_exports_implodeImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_implodeImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_implodeImage_obj = _exports_implodeImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_implodeImage_obj = _exports_implodeImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: inverseFourierTransformImage (_exports_inverseFourierTransformImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_inverseFourierTransformImage_class_0 = SWIGV8_CreateClassTemplate("inverseFourierTransformImage");
_exports_inverseFourierTransformImage_class_0->SetCallHandler(_wrap_new_inverseFourierTransformImage);
_exports_inverseFourierTransformImage_class_0->Inherit(_exports_inverseFourierTransformImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_inverseFourierTransformImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_inverseFourierTransformImage_obj = _exports_inverseFourierTransformImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_inverseFourierTransformImage_obj = _exports_inverseFourierTransformImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: isValidImage (_exports_isValidImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_isValidImage_class_0 = SWIGV8_CreateClassTemplate("isValidImage");
_exports_isValidImage_class_0->SetCallHandler(_wrap_new_isValidImage);
_exports_isValidImage_class_0->Inherit(_exports_isValidImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_isValidImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_isValidImage_obj = _exports_isValidImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_isValidImage_obj = _exports_isValidImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: labelImage (_exports_labelImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_labelImage_class_0 = SWIGV8_CreateClassTemplate("labelImage");
_exports_labelImage_class_0->SetCallHandler(_wrap_new_labelImage);
_exports_labelImage_class_0->Inherit(_exports_labelImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_labelImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_labelImage_obj = _exports_labelImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_labelImage_obj = _exports_labelImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: levelImage (_exports_levelImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_levelImage_class_0 = SWIGV8_CreateClassTemplate("levelImage");
_exports_levelImage_class_0->SetCallHandler(_wrap_new_levelImage);
_exports_levelImage_class_0->Inherit(_exports_levelImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_levelImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_levelImage_obj = _exports_levelImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_levelImage_obj = _exports_levelImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: levelChannelImage (_exports_levelChannelImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_levelChannelImage_class_0 = SWIGV8_CreateClassTemplate("levelChannelImage");
_exports_levelChannelImage_class_0->SetCallHandler(_wrap_new_levelChannelImage);
_exports_levelChannelImage_class_0->Inherit(_exports_levelChannelImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_levelChannelImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_levelChannelImage_obj = _exports_levelChannelImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_levelChannelImage_obj = _exports_levelChannelImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: magnifyImage (_exports_magnifyImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_magnifyImage_class_0 = SWIGV8_CreateClassTemplate("magnifyImage");
_exports_magnifyImage_class_0->SetCallHandler(_wrap_new_magnifyImage);
_exports_magnifyImage_class_0->Inherit(_exports_magnifyImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_magnifyImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_magnifyImage_obj = _exports_magnifyImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_magnifyImage_obj = _exports_magnifyImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: mapImage (_exports_mapImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_mapImage_class_0 = SWIGV8_CreateClassTemplate("mapImage");
_exports_mapImage_class_0->SetCallHandler(_wrap_new_mapImage);
_exports_mapImage_class_0->Inherit(_exports_mapImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_mapImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_mapImage_obj = _exports_mapImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_mapImage_obj = _exports_mapImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: matteFloodfillImage (_exports_matteFloodfillImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_matteFloodfillImage_class_0 = SWIGV8_CreateClassTemplate("matteFloodfillImage");
_exports_matteFloodfillImage_class_0->SetCallHandler(_wrap_new_matteFloodfillImage);
_exports_matteFloodfillImage_class_0->Inherit(_exports_matteFloodfillImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_matteFloodfillImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_matteFloodfillImage_obj = _exports_matteFloodfillImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_matteFloodfillImage_obj = _exports_matteFloodfillImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: medianFilterImage (_exports_medianFilterImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_medianFilterImage_class_0 = SWIGV8_CreateClassTemplate("medianFilterImage");
_exports_medianFilterImage_class_0->SetCallHandler(_wrap_new_medianFilterImage);
_exports_medianFilterImage_class_0->Inherit(_exports_medianFilterImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_medianFilterImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_medianFilterImage_obj = _exports_medianFilterImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_medianFilterImage_obj = _exports_medianFilterImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: mergeLayersImage (_exports_mergeLayersImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_mergeLayersImage_class_0 = SWIGV8_CreateClassTemplate("mergeLayersImage");
_exports_mergeLayersImage_class_0->SetCallHandler(_wrap_new_mergeLayersImage);
_exports_mergeLayersImage_class_0->Inherit(_exports_mergeLayersImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_mergeLayersImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_mergeLayersImage_obj = _exports_mergeLayersImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_mergeLayersImage_obj = _exports_mergeLayersImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: minifyImage (_exports_minifyImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_minifyImage_class_0 = SWIGV8_CreateClassTemplate("minifyImage");
_exports_minifyImage_class_0->SetCallHandler(_wrap_new_minifyImage);
_exports_minifyImage_class_0->Inherit(_exports_minifyImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_minifyImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_minifyImage_obj = _exports_minifyImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_minifyImage_obj = _exports_minifyImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: modulateImage (_exports_modulateImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_modulateImage_class_0 = SWIGV8_CreateClassTemplate("modulateImage");
_exports_modulateImage_class_0->SetCallHandler(_wrap_new_modulateImage);
_exports_modulateImage_class_0->Inherit(_exports_modulateImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_modulateImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_modulateImage_obj = _exports_modulateImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_modulateImage_obj = _exports_modulateImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: negateImage (_exports_negateImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_negateImage_class_0 = SWIGV8_CreateClassTemplate("negateImage");
_exports_negateImage_class_0->SetCallHandler(_wrap_new_negateImage);
_exports_negateImage_class_0->Inherit(_exports_negateImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_negateImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_negateImage_obj = _exports_negateImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_negateImage_obj = _exports_negateImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: normalizeImage (_exports_normalizeImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_normalizeImage_class_0 = SWIGV8_CreateClassTemplate("normalizeImage");
_exports_normalizeImage_class_0->SetCallHandler(_wrap_new_normalizeImage);
_exports_normalizeImage_class_0->Inherit(_exports_normalizeImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_normalizeImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_normalizeImage_obj = _exports_normalizeImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_normalizeImage_obj = _exports_normalizeImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: oilPaintImage (_exports_oilPaintImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_oilPaintImage_class_0 = SWIGV8_CreateClassTemplate("oilPaintImage");
_exports_oilPaintImage_class_0->SetCallHandler(_wrap_new_oilPaintImage);
_exports_oilPaintImage_class_0->Inherit(_exports_oilPaintImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_oilPaintImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_oilPaintImage_obj = _exports_oilPaintImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_oilPaintImage_obj = _exports_oilPaintImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: opacityImage (_exports_opacityImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_opacityImage_class_0 = SWIGV8_CreateClassTemplate("opacityImage");
_exports_opacityImage_class_0->SetCallHandler(_wrap_new_opacityImage);
_exports_opacityImage_class_0->Inherit(_exports_opacityImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_opacityImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_opacityImage_obj = _exports_opacityImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_opacityImage_obj = _exports_opacityImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: opaqueImage (_exports_opaqueImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_opaqueImage_class_0 = SWIGV8_CreateClassTemplate("opaqueImage");
_exports_opaqueImage_class_0->SetCallHandler(_wrap_new_opaqueImage);
_exports_opaqueImage_class_0->Inherit(_exports_opaqueImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_opaqueImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_opaqueImage_obj = _exports_opaqueImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_opaqueImage_obj = _exports_opaqueImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: quantizeImage (_exports_quantizeImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_quantizeImage_class_0 = SWIGV8_CreateClassTemplate("quantizeImage");
_exports_quantizeImage_class_0->SetCallHandler(_wrap_new_quantizeImage);
_exports_quantizeImage_class_0->Inherit(_exports_quantizeImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_quantizeImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_quantizeImage_obj = _exports_quantizeImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_quantizeImage_obj = _exports_quantizeImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: raiseImage (_exports_raiseImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_raiseImage_class_0 = SWIGV8_CreateClassTemplate("raiseImage");
_exports_raiseImage_class_0->SetCallHandler(_wrap_new_raiseImage);
_exports_raiseImage_class_0->Inherit(_exports_raiseImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_raiseImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_raiseImage_obj = _exports_raiseImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_raiseImage_obj = _exports_raiseImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ReadOptions (_exports_ReadOptions) */
SWIGV8_FUNCTION_TEMPLATE _exports_ReadOptions_class_0 = SWIGV8_CreateClassTemplate("ReadOptions");
_exports_ReadOptions_class_0->SetCallHandler(_wrap_new_ReadOptions);
_exports_ReadOptions_class_0->Inherit(_exports_ReadOptions_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ReadOptions_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ReadOptions_obj = _exports_ReadOptions_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ReadOptions_obj = _exports_ReadOptions_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: reduceNoiseImage (_exports_reduceNoiseImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_reduceNoiseImage_class_0 = SWIGV8_CreateClassTemplate("reduceNoiseImage");
_exports_reduceNoiseImage_class_0->SetCallHandler(_wrap_new_reduceNoiseImage);
_exports_reduceNoiseImage_class_0->Inherit(_exports_reduceNoiseImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_reduceNoiseImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_reduceNoiseImage_obj = _exports_reduceNoiseImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_reduceNoiseImage_obj = _exports_reduceNoiseImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: resizeImage (_exports_resizeImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_resizeImage_class_0 = SWIGV8_CreateClassTemplate("resizeImage");
_exports_resizeImage_class_0->SetCallHandler(_wrap_new_resizeImage);
_exports_resizeImage_class_0->Inherit(_exports_resizeImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_resizeImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_resizeImage_obj = _exports_resizeImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_resizeImage_obj = _exports_resizeImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: rollImage (_exports_rollImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_rollImage_class_0 = SWIGV8_CreateClassTemplate("rollImage");
_exports_rollImage_class_0->SetCallHandler(_wrap_new_rollImage);
_exports_rollImage_class_0->Inherit(_exports_rollImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_rollImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_rollImage_obj = _exports_rollImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_rollImage_obj = _exports_rollImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: rotateImage (_exports_rotateImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_rotateImage_class_0 = SWIGV8_CreateClassTemplate("rotateImage");
_exports_rotateImage_class_0->SetCallHandler(_wrap_new_rotateImage);
_exports_rotateImage_class_0->Inherit(_exports_rotateImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_rotateImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_rotateImage_obj = _exports_rotateImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_rotateImage_obj = _exports_rotateImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: sampleImage (_exports_sampleImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_sampleImage_class_0 = SWIGV8_CreateClassTemplate("sampleImage");
_exports_sampleImage_class_0->SetCallHandler(_wrap_new_sampleImage);
_exports_sampleImage_class_0->Inherit(_exports_sampleImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_sampleImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_sampleImage_obj = _exports_sampleImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_sampleImage_obj = _exports_sampleImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: scaleImage (_exports_scaleImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_scaleImage_class_0 = SWIGV8_CreateClassTemplate("scaleImage");
_exports_scaleImage_class_0->SetCallHandler(_wrap_new_scaleImage);
_exports_scaleImage_class_0->Inherit(_exports_scaleImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_scaleImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_scaleImage_obj = _exports_scaleImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_scaleImage_obj = _exports_scaleImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: segmentImage (_exports_segmentImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_segmentImage_class_0 = SWIGV8_CreateClassTemplate("segmentImage");
_exports_segmentImage_class_0->SetCallHandler(_wrap_new_segmentImage);
_exports_segmentImage_class_0->Inherit(_exports_segmentImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_segmentImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_segmentImage_obj = _exports_segmentImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_segmentImage_obj = _exports_segmentImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: shadeImage (_exports_shadeImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_shadeImage_class_0 = SWIGV8_CreateClassTemplate("shadeImage");
_exports_shadeImage_class_0->SetCallHandler(_wrap_new_shadeImage);
_exports_shadeImage_class_0->Inherit(_exports_shadeImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_shadeImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_shadeImage_obj = _exports_shadeImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_shadeImage_obj = _exports_shadeImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: shadowImage (_exports_shadowImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_shadowImage_class_0 = SWIGV8_CreateClassTemplate("shadowImage");
_exports_shadowImage_class_0->SetCallHandler(_wrap_new_shadowImage);
_exports_shadowImage_class_0->Inherit(_exports_shadowImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_shadowImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_shadowImage_obj = _exports_shadowImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_shadowImage_obj = _exports_shadowImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: sharpenImage (_exports_sharpenImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_sharpenImage_class_0 = SWIGV8_CreateClassTemplate("sharpenImage");
_exports_sharpenImage_class_0->SetCallHandler(_wrap_new_sharpenImage);
_exports_sharpenImage_class_0->Inherit(_exports_sharpenImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_sharpenImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_sharpenImage_obj = _exports_sharpenImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_sharpenImage_obj = _exports_sharpenImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: shaveImage (_exports_shaveImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_shaveImage_class_0 = SWIGV8_CreateClassTemplate("shaveImage");
_exports_shaveImage_class_0->SetCallHandler(_wrap_new_shaveImage);
_exports_shaveImage_class_0->Inherit(_exports_shaveImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_shaveImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_shaveImage_obj = _exports_shaveImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_shaveImage_obj = _exports_shaveImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: shearImage (_exports_shearImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_shearImage_class_0 = SWIGV8_CreateClassTemplate("shearImage");
_exports_shearImage_class_0->SetCallHandler(_wrap_new_shearImage);
_exports_shearImage_class_0->Inherit(_exports_shearImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_shearImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_shearImage_obj = _exports_shearImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_shearImage_obj = _exports_shearImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: solarizeImage (_exports_solarizeImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_solarizeImage_class_0 = SWIGV8_CreateClassTemplate("solarizeImage");
_exports_solarizeImage_class_0->SetCallHandler(_wrap_new_solarizeImage);
_exports_solarizeImage_class_0->Inherit(_exports_solarizeImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_solarizeImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_solarizeImage_obj = _exports_solarizeImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_solarizeImage_obj = _exports_solarizeImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: spliceImage (_exports_spliceImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_spliceImage_class_0 = SWIGV8_CreateClassTemplate("spliceImage");
_exports_spliceImage_class_0->SetCallHandler(_wrap_new_spliceImage);
_exports_spliceImage_class_0->Inherit(_exports_spliceImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_spliceImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_spliceImage_obj = _exports_spliceImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_spliceImage_obj = _exports_spliceImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: spreadImage (_exports_spreadImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_spreadImage_class_0 = SWIGV8_CreateClassTemplate("spreadImage");
_exports_spreadImage_class_0->SetCallHandler(_wrap_new_spreadImage);
_exports_spreadImage_class_0->Inherit(_exports_spreadImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_spreadImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_spreadImage_obj = _exports_spreadImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_spreadImage_obj = _exports_spreadImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: steganoImage (_exports_steganoImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_steganoImage_class_0 = SWIGV8_CreateClassTemplate("steganoImage");
_exports_steganoImage_class_0->SetCallHandler(_wrap_new_steganoImage);
_exports_steganoImage_class_0->Inherit(_exports_steganoImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_steganoImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_steganoImage_obj = _exports_steganoImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_steganoImage_obj = _exports_steganoImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: stereoImage (_exports_stereoImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_stereoImage_class_0 = SWIGV8_CreateClassTemplate("stereoImage");
_exports_stereoImage_class_0->SetCallHandler(_wrap_new_stereoImage);
_exports_stereoImage_class_0->Inherit(_exports_stereoImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_stereoImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_stereoImage_obj = _exports_stereoImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_stereoImage_obj = _exports_stereoImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: strokeColorImage (_exports_strokeColorImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_strokeColorImage_class_0 = SWIGV8_CreateClassTemplate("strokeColorImage");
_exports_strokeColorImage_class_0->SetCallHandler(_wrap_new_strokeColorImage);
_exports_strokeColorImage_class_0->Inherit(_exports_strokeColorImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_strokeColorImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_strokeColorImage_obj = _exports_strokeColorImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_strokeColorImage_obj = _exports_strokeColorImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: swirlImage (_exports_swirlImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_swirlImage_class_0 = SWIGV8_CreateClassTemplate("swirlImage");
_exports_swirlImage_class_0->SetCallHandler(_wrap_new_swirlImage);
_exports_swirlImage_class_0->Inherit(_exports_swirlImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_swirlImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_swirlImage_obj = _exports_swirlImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_swirlImage_obj = _exports_swirlImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: textureImage (_exports_textureImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_textureImage_class_0 = SWIGV8_CreateClassTemplate("textureImage");
_exports_textureImage_class_0->SetCallHandler(_wrap_new_textureImage);
_exports_textureImage_class_0->Inherit(_exports_textureImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_textureImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_textureImage_obj = _exports_textureImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_textureImage_obj = _exports_textureImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: thresholdImage (_exports_thresholdImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_thresholdImage_class_0 = SWIGV8_CreateClassTemplate("thresholdImage");
_exports_thresholdImage_class_0->SetCallHandler(_wrap_new_thresholdImage);
_exports_thresholdImage_class_0->Inherit(_exports_thresholdImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_thresholdImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_thresholdImage_obj = _exports_thresholdImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_thresholdImage_obj = _exports_thresholdImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: transformImage (_exports_transformImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_transformImage_class_0 = SWIGV8_CreateClassTemplate("transformImage");
_exports_transformImage_class_0->SetCallHandler(_wrap_new_transformImage);
_exports_transformImage_class_0->Inherit(_exports_transformImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_transformImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_transformImage_obj = _exports_transformImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_transformImage_obj = _exports_transformImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: transparentImage (_exports_transparentImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_transparentImage_class_0 = SWIGV8_CreateClassTemplate("transparentImage");
_exports_transparentImage_class_0->SetCallHandler(_wrap_new_transparentImage);
_exports_transparentImage_class_0->Inherit(_exports_transparentImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_transparentImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_transparentImage_obj = _exports_transparentImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_transparentImage_obj = _exports_transparentImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: trimImage (_exports_trimImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_trimImage_class_0 = SWIGV8_CreateClassTemplate("trimImage");
_exports_trimImage_class_0->SetCallHandler(_wrap_new_trimImage);
_exports_trimImage_class_0->Inherit(_exports_trimImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_trimImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_trimImage_obj = _exports_trimImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_trimImage_obj = _exports_trimImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: waveImage (_exports_waveImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_waveImage_class_0 = SWIGV8_CreateClassTemplate("waveImage");
_exports_waveImage_class_0->SetCallHandler(_wrap_new_waveImage);
_exports_waveImage_class_0->Inherit(_exports_waveImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_waveImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_waveImage_obj = _exports_waveImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_waveImage_obj = _exports_waveImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: zoomImage (_exports_zoomImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_zoomImage_class_0 = SWIGV8_CreateClassTemplate("zoomImage");
_exports_zoomImage_class_0->SetCallHandler(_wrap_new_zoomImage);
_exports_zoomImage_class_0->Inherit(_exports_zoomImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_zoomImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_zoomImage_obj = _exports_zoomImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_zoomImage_obj = _exports_zoomImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: antiAliasImage (_exports_antiAliasImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_antiAliasImage_class_0 = SWIGV8_CreateClassTemplate("antiAliasImage");
_exports_antiAliasImage_class_0->SetCallHandler(_wrap_new_antiAliasImage);
_exports_antiAliasImage_class_0->Inherit(_exports_antiAliasImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_antiAliasImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_antiAliasImage_obj = _exports_antiAliasImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_antiAliasImage_obj = _exports_antiAliasImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: adjoinImage (_exports_adjoinImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_adjoinImage_class_0 = SWIGV8_CreateClassTemplate("adjoinImage");
_exports_adjoinImage_class_0->SetCallHandler(_wrap_new_adjoinImage);
_exports_adjoinImage_class_0->Inherit(_exports_adjoinImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_adjoinImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_adjoinImage_obj = _exports_adjoinImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_adjoinImage_obj = _exports_adjoinImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: animationDelayImage (_exports_animationDelayImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_animationDelayImage_class_0 = SWIGV8_CreateClassTemplate("animationDelayImage");
_exports_animationDelayImage_class_0->SetCallHandler(_wrap_new_animationDelayImage);
_exports_animationDelayImage_class_0->Inherit(_exports_animationDelayImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_animationDelayImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_animationDelayImage_obj = _exports_animationDelayImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_animationDelayImage_obj = _exports_animationDelayImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: animationIterationsImage (_exports_animationIterationsImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_animationIterationsImage_class_0 = SWIGV8_CreateClassTemplate("animationIterationsImage");
_exports_animationIterationsImage_class_0->SetCallHandler(_wrap_new_animationIterationsImage);
_exports_animationIterationsImage_class_0->Inherit(_exports_animationIterationsImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_animationIterationsImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_animationIterationsImage_obj = _exports_animationIterationsImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_animationIterationsImage_obj = _exports_animationIterationsImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: backgroundColorImage (_exports_backgroundColorImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_backgroundColorImage_class_0 = SWIGV8_CreateClassTemplate("backgroundColorImage");
_exports_backgroundColorImage_class_0->SetCallHandler(_wrap_new_backgroundColorImage);
_exports_backgroundColorImage_class_0->Inherit(_exports_backgroundColorImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_backgroundColorImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_backgroundColorImage_obj = _exports_backgroundColorImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_backgroundColorImage_obj = _exports_backgroundColorImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: backgroundTextureImage (_exports_backgroundTextureImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_backgroundTextureImage_class_0 = SWIGV8_CreateClassTemplate("backgroundTextureImage");
_exports_backgroundTextureImage_class_0->SetCallHandler(_wrap_new_backgroundTextureImage);
_exports_backgroundTextureImage_class_0->Inherit(_exports_backgroundTextureImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_backgroundTextureImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_backgroundTextureImage_obj = _exports_backgroundTextureImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_backgroundTextureImage_obj = _exports_backgroundTextureImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: borderColorImage (_exports_borderColorImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_borderColorImage_class_0 = SWIGV8_CreateClassTemplate("borderColorImage");
_exports_borderColorImage_class_0->SetCallHandler(_wrap_new_borderColorImage);
_exports_borderColorImage_class_0->Inherit(_exports_borderColorImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_borderColorImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_borderColorImage_obj = _exports_borderColorImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_borderColorImage_obj = _exports_borderColorImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: boxColorImage (_exports_boxColorImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_boxColorImage_class_0 = SWIGV8_CreateClassTemplate("boxColorImage");
_exports_boxColorImage_class_0->SetCallHandler(_wrap_new_boxColorImage);
_exports_boxColorImage_class_0->Inherit(_exports_boxColorImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_boxColorImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_boxColorImage_obj = _exports_boxColorImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_boxColorImage_obj = _exports_boxColorImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: chromaBluePrimaryImage (_exports_chromaBluePrimaryImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_chromaBluePrimaryImage_class_0 = SWIGV8_CreateClassTemplate("chromaBluePrimaryImage");
_exports_chromaBluePrimaryImage_class_0->SetCallHandler(_wrap_new_chromaBluePrimaryImage);
_exports_chromaBluePrimaryImage_class_0->Inherit(_exports_chromaBluePrimaryImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_chromaBluePrimaryImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_chromaBluePrimaryImage_obj = _exports_chromaBluePrimaryImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_chromaBluePrimaryImage_obj = _exports_chromaBluePrimaryImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: chromaGreenPrimaryImage (_exports_chromaGreenPrimaryImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_chromaGreenPrimaryImage_class_0 = SWIGV8_CreateClassTemplate("chromaGreenPrimaryImage");
_exports_chromaGreenPrimaryImage_class_0->SetCallHandler(_wrap_new_chromaGreenPrimaryImage);
_exports_chromaGreenPrimaryImage_class_0->Inherit(_exports_chromaGreenPrimaryImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_chromaGreenPrimaryImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_chromaGreenPrimaryImage_obj = _exports_chromaGreenPrimaryImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_chromaGreenPrimaryImage_obj = _exports_chromaGreenPrimaryImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: chromaRedPrimaryImage (_exports_chromaRedPrimaryImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_chromaRedPrimaryImage_class_0 = SWIGV8_CreateClassTemplate("chromaRedPrimaryImage");
_exports_chromaRedPrimaryImage_class_0->SetCallHandler(_wrap_new_chromaRedPrimaryImage);
_exports_chromaRedPrimaryImage_class_0->Inherit(_exports_chromaRedPrimaryImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_chromaRedPrimaryImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_chromaRedPrimaryImage_obj = _exports_chromaRedPrimaryImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_chromaRedPrimaryImage_obj = _exports_chromaRedPrimaryImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: chromaWhitePointImage (_exports_chromaWhitePointImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_chromaWhitePointImage_class_0 = SWIGV8_CreateClassTemplate("chromaWhitePointImage");
_exports_chromaWhitePointImage_class_0->SetCallHandler(_wrap_new_chromaWhitePointImage);
_exports_chromaWhitePointImage_class_0->Inherit(_exports_chromaWhitePointImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_chromaWhitePointImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_chromaWhitePointImage_obj = _exports_chromaWhitePointImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_chromaWhitePointImage_obj = _exports_chromaWhitePointImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: colorFuzzImage (_exports_colorFuzzImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_colorFuzzImage_class_0 = SWIGV8_CreateClassTemplate("colorFuzzImage");
_exports_colorFuzzImage_class_0->SetCallHandler(_wrap_new_colorFuzzImage);
_exports_colorFuzzImage_class_0->Inherit(_exports_colorFuzzImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_colorFuzzImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_colorFuzzImage_obj = _exports_colorFuzzImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_colorFuzzImage_obj = _exports_colorFuzzImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: colorMapImage (_exports_colorMapImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_colorMapImage_class_0 = SWIGV8_CreateClassTemplate("colorMapImage");
_exports_colorMapImage_class_0->SetCallHandler(_wrap_new_colorMapImage);
_exports_colorMapImage_class_0->Inherit(_exports_colorMapImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_colorMapImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_colorMapImage_obj = _exports_colorMapImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_colorMapImage_obj = _exports_colorMapImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: composeImage (_exports_composeImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_composeImage_class_0 = SWIGV8_CreateClassTemplate("composeImage");
_exports_composeImage_class_0->SetCallHandler(_wrap_new_composeImage);
_exports_composeImage_class_0->Inherit(_exports_composeImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_composeImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_composeImage_obj = _exports_composeImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_composeImage_obj = _exports_composeImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: compressTypeImage (_exports_compressTypeImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_compressTypeImage_class_0 = SWIGV8_CreateClassTemplate("compressTypeImage");
_exports_compressTypeImage_class_0->SetCallHandler(_wrap_new_compressTypeImage);
_exports_compressTypeImage_class_0->Inherit(_exports_compressTypeImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_compressTypeImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_compressTypeImage_obj = _exports_compressTypeImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_compressTypeImage_obj = _exports_compressTypeImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: densityImage (_exports_densityImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_densityImage_class_0 = SWIGV8_CreateClassTemplate("densityImage");
_exports_densityImage_class_0->SetCallHandler(_wrap_new_densityImage);
_exports_densityImage_class_0->Inherit(_exports_densityImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_densityImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_densityImage_obj = _exports_densityImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_densityImage_obj = _exports_densityImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: depthImage (_exports_depthImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_depthImage_class_0 = SWIGV8_CreateClassTemplate("depthImage");
_exports_depthImage_class_0->SetCallHandler(_wrap_new_depthImage);
_exports_depthImage_class_0->Inherit(_exports_depthImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_depthImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_depthImage_obj = _exports_depthImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_depthImage_obj = _exports_depthImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: endianImage (_exports_endianImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_endianImage_class_0 = SWIGV8_CreateClassTemplate("endianImage");
_exports_endianImage_class_0->SetCallHandler(_wrap_new_endianImage);
_exports_endianImage_class_0->Inherit(_exports_endianImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_endianImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_endianImage_obj = _exports_endianImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_endianImage_obj = _exports_endianImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: fileNameImage (_exports_fileNameImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_fileNameImage_class_0 = SWIGV8_CreateClassTemplate("fileNameImage");
_exports_fileNameImage_class_0->SetCallHandler(_wrap_new_fileNameImage);
_exports_fileNameImage_class_0->Inherit(_exports_fileNameImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_fileNameImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_fileNameImage_obj = _exports_fileNameImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_fileNameImage_obj = _exports_fileNameImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: filterTypeImage (_exports_filterTypeImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_filterTypeImage_class_0 = SWIGV8_CreateClassTemplate("filterTypeImage");
_exports_filterTypeImage_class_0->SetCallHandler(_wrap_new_filterTypeImage);
_exports_filterTypeImage_class_0->Inherit(_exports_filterTypeImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_filterTypeImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_filterTypeImage_obj = _exports_filterTypeImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_filterTypeImage_obj = _exports_filterTypeImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: fontImage (_exports_fontImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_fontImage_class_0 = SWIGV8_CreateClassTemplate("fontImage");
_exports_fontImage_class_0->SetCallHandler(_wrap_new_fontImage);
_exports_fontImage_class_0->Inherit(_exports_fontImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_fontImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_fontImage_obj = _exports_fontImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_fontImage_obj = _exports_fontImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: fontPointsizeImage (_exports_fontPointsizeImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_fontPointsizeImage_class_0 = SWIGV8_CreateClassTemplate("fontPointsizeImage");
_exports_fontPointsizeImage_class_0->SetCallHandler(_wrap_new_fontPointsizeImage);
_exports_fontPointsizeImage_class_0->Inherit(_exports_fontPointsizeImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_fontPointsizeImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_fontPointsizeImage_obj = _exports_fontPointsizeImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_fontPointsizeImage_obj = _exports_fontPointsizeImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: gifDisposeMethodImage (_exports_gifDisposeMethodImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_gifDisposeMethodImage_class_0 = SWIGV8_CreateClassTemplate("gifDisposeMethodImage");
_exports_gifDisposeMethodImage_class_0->SetCallHandler(_wrap_new_gifDisposeMethodImage);
_exports_gifDisposeMethodImage_class_0->Inherit(_exports_gifDisposeMethodImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_gifDisposeMethodImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_gifDisposeMethodImage_obj = _exports_gifDisposeMethodImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_gifDisposeMethodImage_obj = _exports_gifDisposeMethodImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: interlaceTypeImage (_exports_interlaceTypeImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_interlaceTypeImage_class_0 = SWIGV8_CreateClassTemplate("interlaceTypeImage");
_exports_interlaceTypeImage_class_0->SetCallHandler(_wrap_new_interlaceTypeImage);
_exports_interlaceTypeImage_class_0->Inherit(_exports_interlaceTypeImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_interlaceTypeImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_interlaceTypeImage_obj = _exports_interlaceTypeImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_interlaceTypeImage_obj = _exports_interlaceTypeImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: lineWidthImage (_exports_lineWidthImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_lineWidthImage_class_0 = SWIGV8_CreateClassTemplate("lineWidthImage");
_exports_lineWidthImage_class_0->SetCallHandler(_wrap_new_lineWidthImage);
_exports_lineWidthImage_class_0->Inherit(_exports_lineWidthImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_lineWidthImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_lineWidthImage_obj = _exports_lineWidthImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_lineWidthImage_obj = _exports_lineWidthImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: magickImage (_exports_magickImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_magickImage_class_0 = SWIGV8_CreateClassTemplate("magickImage");
_exports_magickImage_class_0->SetCallHandler(_wrap_new_magickImage);
_exports_magickImage_class_0->Inherit(_exports_magickImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_magickImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_magickImage_obj = _exports_magickImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_magickImage_obj = _exports_magickImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: matteImage (_exports_matteImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_matteImage_class_0 = SWIGV8_CreateClassTemplate("matteImage");
_exports_matteImage_class_0->SetCallHandler(_wrap_new_matteImage);
_exports_matteImage_class_0->Inherit(_exports_matteImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_matteImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_matteImage_obj = _exports_matteImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_matteImage_obj = _exports_matteImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: matteColorImage (_exports_matteColorImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_matteColorImage_class_0 = SWIGV8_CreateClassTemplate("matteColorImage");
_exports_matteColorImage_class_0->SetCallHandler(_wrap_new_matteColorImage);
_exports_matteColorImage_class_0->Inherit(_exports_matteColorImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_matteColorImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_matteColorImage_obj = _exports_matteColorImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_matteColorImage_obj = _exports_matteColorImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: monochromeImage (_exports_monochromeImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_monochromeImage_class_0 = SWIGV8_CreateClassTemplate("monochromeImage");
_exports_monochromeImage_class_0->SetCallHandler(_wrap_new_monochromeImage);
_exports_monochromeImage_class_0->Inherit(_exports_monochromeImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_monochromeImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_monochromeImage_obj = _exports_monochromeImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_monochromeImage_obj = _exports_monochromeImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: penColorImage (_exports_penColorImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_penColorImage_class_0 = SWIGV8_CreateClassTemplate("penColorImage");
_exports_penColorImage_class_0->SetCallHandler(_wrap_new_penColorImage);
_exports_penColorImage_class_0->Inherit(_exports_penColorImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_penColorImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_penColorImage_obj = _exports_penColorImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_penColorImage_obj = _exports_penColorImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: penTextureImage (_exports_penTextureImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_penTextureImage_class_0 = SWIGV8_CreateClassTemplate("penTextureImage");
_exports_penTextureImage_class_0->SetCallHandler(_wrap_new_penTextureImage);
_exports_penTextureImage_class_0->Inherit(_exports_penTextureImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_penTextureImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_penTextureImage_obj = _exports_penTextureImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_penTextureImage_obj = _exports_penTextureImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: pixelColorImage (_exports_pixelColorImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_pixelColorImage_class_0 = SWIGV8_CreateClassTemplate("pixelColorImage");
_exports_pixelColorImage_class_0->SetCallHandler(_wrap_new_pixelColorImage);
_exports_pixelColorImage_class_0->Inherit(_exports_pixelColorImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_pixelColorImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_pixelColorImage_obj = _exports_pixelColorImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_pixelColorImage_obj = _exports_pixelColorImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: pageImage (_exports_pageImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_pageImage_class_0 = SWIGV8_CreateClassTemplate("pageImage");
_exports_pageImage_class_0->SetCallHandler(_wrap_new_pageImage);
_exports_pageImage_class_0->Inherit(_exports_pageImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_pageImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_pageImage_obj = _exports_pageImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_pageImage_obj = _exports_pageImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: qualityImage (_exports_qualityImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_qualityImage_class_0 = SWIGV8_CreateClassTemplate("qualityImage");
_exports_qualityImage_class_0->SetCallHandler(_wrap_new_qualityImage);
_exports_qualityImage_class_0->Inherit(_exports_qualityImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_qualityImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_qualityImage_obj = _exports_qualityImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_qualityImage_obj = _exports_qualityImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: quantizeColorsImage (_exports_quantizeColorsImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_quantizeColorsImage_class_0 = SWIGV8_CreateClassTemplate("quantizeColorsImage");
_exports_quantizeColorsImage_class_0->SetCallHandler(_wrap_new_quantizeColorsImage);
_exports_quantizeColorsImage_class_0->Inherit(_exports_quantizeColorsImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_quantizeColorsImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_quantizeColorsImage_obj = _exports_quantizeColorsImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_quantizeColorsImage_obj = _exports_quantizeColorsImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: quantizeColorSpaceImage (_exports_quantizeColorSpaceImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_quantizeColorSpaceImage_class_0 = SWIGV8_CreateClassTemplate("quantizeColorSpaceImage");
_exports_quantizeColorSpaceImage_class_0->SetCallHandler(_wrap_new_quantizeColorSpaceImage);
_exports_quantizeColorSpaceImage_class_0->Inherit(_exports_quantizeColorSpaceImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_quantizeColorSpaceImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_quantizeColorSpaceImage_obj = _exports_quantizeColorSpaceImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_quantizeColorSpaceImage_obj = _exports_quantizeColorSpaceImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: quantizeDitherImage (_exports_quantizeDitherImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_quantizeDitherImage_class_0 = SWIGV8_CreateClassTemplate("quantizeDitherImage");
_exports_quantizeDitherImage_class_0->SetCallHandler(_wrap_new_quantizeDitherImage);
_exports_quantizeDitherImage_class_0->Inherit(_exports_quantizeDitherImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_quantizeDitherImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_quantizeDitherImage_obj = _exports_quantizeDitherImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_quantizeDitherImage_obj = _exports_quantizeDitherImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: quantizeTreeDepthImage (_exports_quantizeTreeDepthImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_quantizeTreeDepthImage_class_0 = SWIGV8_CreateClassTemplate("quantizeTreeDepthImage");
_exports_quantizeTreeDepthImage_class_0->SetCallHandler(_wrap_new_quantizeTreeDepthImage);
_exports_quantizeTreeDepthImage_class_0->Inherit(_exports_quantizeTreeDepthImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_quantizeTreeDepthImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_quantizeTreeDepthImage_obj = _exports_quantizeTreeDepthImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_quantizeTreeDepthImage_obj = _exports_quantizeTreeDepthImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: renderingIntentImage (_exports_renderingIntentImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_renderingIntentImage_class_0 = SWIGV8_CreateClassTemplate("renderingIntentImage");
_exports_renderingIntentImage_class_0->SetCallHandler(_wrap_new_renderingIntentImage);
_exports_renderingIntentImage_class_0->Inherit(_exports_renderingIntentImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_renderingIntentImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_renderingIntentImage_obj = _exports_renderingIntentImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_renderingIntentImage_obj = _exports_renderingIntentImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: resolutionUnitsImage (_exports_resolutionUnitsImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_resolutionUnitsImage_class_0 = SWIGV8_CreateClassTemplate("resolutionUnitsImage");
_exports_resolutionUnitsImage_class_0->SetCallHandler(_wrap_new_resolutionUnitsImage);
_exports_resolutionUnitsImage_class_0->Inherit(_exports_resolutionUnitsImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_resolutionUnitsImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_resolutionUnitsImage_obj = _exports_resolutionUnitsImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_resolutionUnitsImage_obj = _exports_resolutionUnitsImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: sceneImage (_exports_sceneImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_sceneImage_class_0 = SWIGV8_CreateClassTemplate("sceneImage");
_exports_sceneImage_class_0->SetCallHandler(_wrap_new_sceneImage);
_exports_sceneImage_class_0->Inherit(_exports_sceneImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_sceneImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_sceneImage_obj = _exports_sceneImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_sceneImage_obj = _exports_sceneImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: sigmoidalContrastImage (_exports_sigmoidalContrastImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_sigmoidalContrastImage_class_0 = SWIGV8_CreateClassTemplate("sigmoidalContrastImage");
_exports_sigmoidalContrastImage_class_0->SetCallHandler(_wrap_new_sigmoidalContrastImage);
_exports_sigmoidalContrastImage_class_0->Inherit(_exports_sigmoidalContrastImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_sigmoidalContrastImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_sigmoidalContrastImage_obj = _exports_sigmoidalContrastImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_sigmoidalContrastImage_obj = _exports_sigmoidalContrastImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: sizeImage (_exports_sizeImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_sizeImage_class_0 = SWIGV8_CreateClassTemplate("sizeImage");
_exports_sizeImage_class_0->SetCallHandler(_wrap_new_sizeImage);
_exports_sizeImage_class_0->Inherit(_exports_sizeImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_sizeImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_sizeImage_obj = _exports_sizeImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_sizeImage_obj = _exports_sizeImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: stripImage (_exports_stripImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_stripImage_class_0 = SWIGV8_CreateClassTemplate("stripImage");
_exports_stripImage_class_0->SetCallHandler(_wrap_new_stripImage);
_exports_stripImage_class_0->Inherit(_exports_stripImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_stripImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_stripImage_obj = _exports_stripImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_stripImage_obj = _exports_stripImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: subImageImage (_exports_subImageImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_subImageImage_class_0 = SWIGV8_CreateClassTemplate("subImageImage");
_exports_subImageImage_class_0->SetCallHandler(_wrap_new_subImageImage);
_exports_subImageImage_class_0->Inherit(_exports_subImageImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_subImageImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_subImageImage_obj = _exports_subImageImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_subImageImage_obj = _exports_subImageImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: subRangeImage (_exports_subRangeImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_subRangeImage_class_0 = SWIGV8_CreateClassTemplate("subRangeImage");
_exports_subRangeImage_class_0->SetCallHandler(_wrap_new_subRangeImage);
_exports_subRangeImage_class_0->Inherit(_exports_subRangeImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_subRangeImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_subRangeImage_obj = _exports_subRangeImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_subRangeImage_obj = _exports_subRangeImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: tileNameImage (_exports_tileNameImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_tileNameImage_class_0 = SWIGV8_CreateClassTemplate("tileNameImage");
_exports_tileNameImage_class_0->SetCallHandler(_wrap_new_tileNameImage);
_exports_tileNameImage_class_0->Inherit(_exports_tileNameImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_tileNameImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_tileNameImage_obj = _exports_tileNameImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_tileNameImage_obj = _exports_tileNameImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: typeImage (_exports_typeImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_typeImage_class_0 = SWIGV8_CreateClassTemplate("typeImage");
_exports_typeImage_class_0->SetCallHandler(_wrap_new_typeImage);
_exports_typeImage_class_0->Inherit(_exports_typeImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_typeImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_typeImage_obj = _exports_typeImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_typeImage_obj = _exports_typeImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: verboseImage (_exports_verboseImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_verboseImage_class_0 = SWIGV8_CreateClassTemplate("verboseImage");
_exports_verboseImage_class_0->SetCallHandler(_wrap_new_verboseImage);
_exports_verboseImage_class_0->Inherit(_exports_verboseImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_verboseImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_verboseImage_obj = _exports_verboseImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_verboseImage_obj = _exports_verboseImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: viewImage (_exports_viewImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_viewImage_class_0 = SWIGV8_CreateClassTemplate("viewImage");
_exports_viewImage_class_0->SetCallHandler(_wrap_new_viewImage);
_exports_viewImage_class_0->Inherit(_exports_viewImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_viewImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_viewImage_obj = _exports_viewImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_viewImage_obj = _exports_viewImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: x11DisplayImage (_exports_x11DisplayImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_x11DisplayImage_class_0 = SWIGV8_CreateClassTemplate("x11DisplayImage");
_exports_x11DisplayImage_class_0->SetCallHandler(_wrap_new_x11DisplayImage);
_exports_x11DisplayImage_class_0->Inherit(_exports_x11DisplayImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_x11DisplayImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_x11DisplayImage_obj = _exports_x11DisplayImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_x11DisplayImage_obj = _exports_x11DisplayImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: Blob (_exports_Blob) */
SWIGV8_FUNCTION_TEMPLATE _exports_Blob_class_0 = SWIGV8_CreateClassTemplate("Blob");
_exports_Blob_class_0->SetCallHandler(_wrap_new_Blob);
_exports_Blob_class_0->Inherit(_exports_Blob_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_Blob_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_Blob_obj = _exports_Blob_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_Blob_obj = _exports_Blob_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ChannelMoments (_exports_ChannelMoments) */
SWIGV8_FUNCTION_TEMPLATE _exports_ChannelMoments_class_0 = SWIGV8_CreateClassTemplate("ChannelMoments");
_exports_ChannelMoments_class_0->SetCallHandler(_wrap_new_ChannelMoments);
_exports_ChannelMoments_class_0->Inherit(_exports_ChannelMoments_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ChannelMoments_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ChannelMoments_obj = _exports_ChannelMoments_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ChannelMoments_obj = _exports_ChannelMoments_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ImageMoments (_exports_ImageMoments) */
SWIGV8_FUNCTION_TEMPLATE _exports_ImageMoments_class_0 = SWIGV8_CreateClassTemplate("ImageMoments");
_exports_ImageMoments_class_0->SetCallHandler(_wrap_new_ImageMoments);
_exports_ImageMoments_class_0->Inherit(_exports_ImageMoments_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ImageMoments_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ImageMoments_obj = _exports_ImageMoments_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ImageMoments_obj = _exports_ImageMoments_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: CoderInfo (_exports_CoderInfo) */
SWIGV8_FUNCTION_TEMPLATE _exports_CoderInfo_class_0 = SWIGV8_CreateClassTemplate("CoderInfo");
_exports_CoderInfo_class_0->SetCallHandler(_wrap_new_CoderInfo);
_exports_CoderInfo_class_0->Inherit(_exports_CoderInfo_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_CoderInfo_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_CoderInfo_obj = _exports_CoderInfo_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_CoderInfo_obj = _exports_CoderInfo_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: Color (_exports_Color) */
SWIGV8_FUNCTION_TEMPLATE _exports_Color_class_0 = SWIGV8_CreateClassTemplate("Color");
_exports_Color_class_0->SetCallHandler(_wrap_new_Color);
_exports_Color_class_0->Inherit(_exports_Color_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_Color_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_Color_obj = _exports_Color_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_Color_obj = _exports_Color_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ColorGray (_exports_ColorGray) */
SWIGV8_FUNCTION_TEMPLATE _exports_ColorGray_class_0 = SWIGV8_CreateClassTemplate("ColorGray");
_exports_ColorGray_class_0->SetCallHandler(_wrap_new_ColorGray);
_exports_ColorGray_class_0->Inherit(_exports_ColorGray_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ColorGray_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ColorGray_obj = _exports_ColorGray_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ColorGray_obj = _exports_ColorGray_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ColorHSL (_exports_ColorHSL) */
SWIGV8_FUNCTION_TEMPLATE _exports_ColorHSL_class_0 = SWIGV8_CreateClassTemplate("ColorHSL");
_exports_ColorHSL_class_0->SetCallHandler(_wrap_new_ColorHSL);
_exports_ColorHSL_class_0->Inherit(_exports_ColorHSL_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ColorHSL_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ColorHSL_obj = _exports_ColorHSL_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ColorHSL_obj = _exports_ColorHSL_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ColorMono (_exports_ColorMono) */
SWIGV8_FUNCTION_TEMPLATE _exports_ColorMono_class_0 = SWIGV8_CreateClassTemplate("ColorMono");
_exports_ColorMono_class_0->SetCallHandler(_wrap_new_ColorMono);
_exports_ColorMono_class_0->Inherit(_exports_ColorMono_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ColorMono_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ColorMono_obj = _exports_ColorMono_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ColorMono_obj = _exports_ColorMono_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ColorRGB (_exports_ColorRGB) */
SWIGV8_FUNCTION_TEMPLATE _exports_ColorRGB_class_0 = SWIGV8_CreateClassTemplate("ColorRGB");
_exports_ColorRGB_class_0->SetCallHandler(_wrap_new_ColorRGB);
_exports_ColorRGB_class_0->Inherit(_exports_ColorRGB_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ColorRGB_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ColorRGB_obj = _exports_ColorRGB_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ColorRGB_obj = _exports_ColorRGB_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ColorYUV (_exports_ColorYUV) */
SWIGV8_FUNCTION_TEMPLATE _exports_ColorYUV_class_0 = SWIGV8_CreateClassTemplate("ColorYUV");
_exports_ColorYUV_class_0->SetCallHandler(_wrap_new_ColorYUV);
_exports_ColorYUV_class_0->Inherit(_exports_ColorYUV_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ColorYUV_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ColorYUV_obj = _exports_ColorYUV_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ColorYUV_obj = _exports_ColorYUV_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: Coordinate (_exports_Coordinate) */
SWIGV8_FUNCTION_TEMPLATE _exports_Coordinate_class_0 = SWIGV8_CreateClassTemplate("Coordinate");
_exports_Coordinate_class_0->SetCallHandler(_wrap_new_Coordinate);
_exports_Coordinate_class_0->Inherit(_exports_Coordinate_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_Coordinate_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_Coordinate_obj = _exports_Coordinate_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_Coordinate_obj = _exports_Coordinate_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableBase (_exports_DrawableBase) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableBase_class_0 = SWIGV8_CreateClassTemplate("DrawableBase");
_exports_DrawableBase_class_0->SetCallHandler(_wrap_new_veto_DrawableBase);
_exports_DrawableBase_class_0->Inherit(_exports_DrawableBase_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableBase_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableBase_obj = _exports_DrawableBase_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableBase_obj = _exports_DrawableBase_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: Drawable (_exports_Drawable) */
SWIGV8_FUNCTION_TEMPLATE _exports_Drawable_class_0 = SWIGV8_CreateClassTemplate("Drawable");
_exports_Drawable_class_0->SetCallHandler(_wrap_new_Drawable);
_exports_Drawable_class_0->Inherit(_exports_Drawable_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_Drawable_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_Drawable_obj = _exports_Drawable_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_Drawable_obj = _exports_Drawable_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: VPathBase (_exports_VPathBase) */
SWIGV8_FUNCTION_TEMPLATE _exports_VPathBase_class_0 = SWIGV8_CreateClassTemplate("VPathBase");
_exports_VPathBase_class_0->SetCallHandler(_wrap_new_veto_VPathBase);
_exports_VPathBase_class_0->Inherit(_exports_VPathBase_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_VPathBase_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_VPathBase_obj = _exports_VPathBase_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_VPathBase_obj = _exports_VPathBase_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: VPath (_exports_VPath) */
SWIGV8_FUNCTION_TEMPLATE _exports_VPath_class_0 = SWIGV8_CreateClassTemplate("VPath");
_exports_VPath_class_0->SetCallHandler(_wrap_new_VPath);
_exports_VPath_class_0->Inherit(_exports_VPath_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_VPath_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_VPath_obj = _exports_VPath_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_VPath_obj = _exports_VPath_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableAffine (_exports_DrawableAffine) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableAffine_class_0 = SWIGV8_CreateClassTemplate("DrawableAffine");
_exports_DrawableAffine_class_0->SetCallHandler(_wrap_new_DrawableAffine);
_exports_DrawableAffine_class_0->Inherit(_exports_DrawableAffine_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableAffine_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableAffine_obj = _exports_DrawableAffine_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableAffine_obj = _exports_DrawableAffine_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableArc (_exports_DrawableArc) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableArc_class_0 = SWIGV8_CreateClassTemplate("DrawableArc");
_exports_DrawableArc_class_0->SetCallHandler(_wrap_new_DrawableArc);
_exports_DrawableArc_class_0->Inherit(_exports_DrawableArc_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableArc_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableArc_obj = _exports_DrawableArc_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableArc_obj = _exports_DrawableArc_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableBezier (_exports_DrawableBezier) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableBezier_class_0 = SWIGV8_CreateClassTemplate("DrawableBezier");
_exports_DrawableBezier_class_0->SetCallHandler(_wrap_new_DrawableBezier);
_exports_DrawableBezier_class_0->Inherit(_exports_DrawableBezier_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableBezier_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableBezier_obj = _exports_DrawableBezier_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableBezier_obj = _exports_DrawableBezier_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawablePopClipPath (_exports_DrawablePopClipPath) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawablePopClipPath_class_0 = SWIGV8_CreateClassTemplate("DrawablePopClipPath");
_exports_DrawablePopClipPath_class_0->SetCallHandler(_wrap_new_DrawablePopClipPath);
_exports_DrawablePopClipPath_class_0->Inherit(_exports_DrawablePopClipPath_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawablePopClipPath_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawablePopClipPath_obj = _exports_DrawablePopClipPath_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawablePopClipPath_obj = _exports_DrawablePopClipPath_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawablePushClipPath (_exports_DrawablePushClipPath) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawablePushClipPath_class_0 = SWIGV8_CreateClassTemplate("DrawablePushClipPath");
_exports_DrawablePushClipPath_class_0->SetCallHandler(_wrap_new_DrawablePushClipPath);
_exports_DrawablePushClipPath_class_0->Inherit(_exports_DrawablePushClipPath_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawablePushClipPath_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawablePushClipPath_obj = _exports_DrawablePushClipPath_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawablePushClipPath_obj = _exports_DrawablePushClipPath_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableClipPath (_exports_DrawableClipPath) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableClipPath_class_0 = SWIGV8_CreateClassTemplate("DrawableClipPath");
_exports_DrawableClipPath_class_0->SetCallHandler(_wrap_new_DrawableClipPath);
_exports_DrawableClipPath_class_0->Inherit(_exports_DrawableClipPath_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableClipPath_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableClipPath_obj = _exports_DrawableClipPath_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableClipPath_obj = _exports_DrawableClipPath_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableCircle (_exports_DrawableCircle) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableCircle_class_0 = SWIGV8_CreateClassTemplate("DrawableCircle");
_exports_DrawableCircle_class_0->SetCallHandler(_wrap_new_DrawableCircle);
_exports_DrawableCircle_class_0->Inherit(_exports_DrawableCircle_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableCircle_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableCircle_obj = _exports_DrawableCircle_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableCircle_obj = _exports_DrawableCircle_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableColor (_exports_DrawableColor) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableColor_class_0 = SWIGV8_CreateClassTemplate("DrawableColor");
_exports_DrawableColor_class_0->SetCallHandler(_wrap_new_DrawableColor);
_exports_DrawableColor_class_0->Inherit(_exports_DrawableColor_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableColor_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableColor_obj = _exports_DrawableColor_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableColor_obj = _exports_DrawableColor_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableCompositeImage (_exports_DrawableCompositeImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableCompositeImage_class_0 = SWIGV8_CreateClassTemplate("DrawableCompositeImage");
_exports_DrawableCompositeImage_class_0->SetCallHandler(_wrap_new_DrawableCompositeImage);
_exports_DrawableCompositeImage_class_0->Inherit(_exports_DrawableCompositeImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableCompositeImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableCompositeImage_obj = _exports_DrawableCompositeImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableCompositeImage_obj = _exports_DrawableCompositeImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableDensity (_exports_DrawableDensity) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableDensity_class_0 = SWIGV8_CreateClassTemplate("DrawableDensity");
_exports_DrawableDensity_class_0->SetCallHandler(_wrap_new_DrawableDensity);
_exports_DrawableDensity_class_0->Inherit(_exports_DrawableDensity_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableDensity_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableDensity_obj = _exports_DrawableDensity_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableDensity_obj = _exports_DrawableDensity_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableEllipse (_exports_DrawableEllipse) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableEllipse_class_0 = SWIGV8_CreateClassTemplate("DrawableEllipse");
_exports_DrawableEllipse_class_0->SetCallHandler(_wrap_new_DrawableEllipse);
_exports_DrawableEllipse_class_0->Inherit(_exports_DrawableEllipse_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableEllipse_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableEllipse_obj = _exports_DrawableEllipse_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableEllipse_obj = _exports_DrawableEllipse_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableFillColor (_exports_DrawableFillColor) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableFillColor_class_0 = SWIGV8_CreateClassTemplate("DrawableFillColor");
_exports_DrawableFillColor_class_0->SetCallHandler(_wrap_new_DrawableFillColor);
_exports_DrawableFillColor_class_0->Inherit(_exports_DrawableFillColor_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableFillColor_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableFillColor_obj = _exports_DrawableFillColor_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableFillColor_obj = _exports_DrawableFillColor_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableFillRule (_exports_DrawableFillRule) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableFillRule_class_0 = SWIGV8_CreateClassTemplate("DrawableFillRule");
_exports_DrawableFillRule_class_0->SetCallHandler(_wrap_new_DrawableFillRule);
_exports_DrawableFillRule_class_0->Inherit(_exports_DrawableFillRule_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableFillRule_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableFillRule_obj = _exports_DrawableFillRule_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableFillRule_obj = _exports_DrawableFillRule_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableFillOpacity (_exports_DrawableFillOpacity) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableFillOpacity_class_0 = SWIGV8_CreateClassTemplate("DrawableFillOpacity");
_exports_DrawableFillOpacity_class_0->SetCallHandler(_wrap_new_DrawableFillOpacity);
_exports_DrawableFillOpacity_class_0->Inherit(_exports_DrawableFillOpacity_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableFillOpacity_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableFillOpacity_obj = _exports_DrawableFillOpacity_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableFillOpacity_obj = _exports_DrawableFillOpacity_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableFont (_exports_DrawableFont) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableFont_class_0 = SWIGV8_CreateClassTemplate("DrawableFont");
_exports_DrawableFont_class_0->SetCallHandler(_wrap_new_DrawableFont);
_exports_DrawableFont_class_0->Inherit(_exports_DrawableFont_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableFont_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableFont_obj = _exports_DrawableFont_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableFont_obj = _exports_DrawableFont_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableGravity (_exports_DrawableGravity) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableGravity_class_0 = SWIGV8_CreateClassTemplate("DrawableGravity");
_exports_DrawableGravity_class_0->SetCallHandler(_wrap_new_DrawableGravity);
_exports_DrawableGravity_class_0->Inherit(_exports_DrawableGravity_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableGravity_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableGravity_obj = _exports_DrawableGravity_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableGravity_obj = _exports_DrawableGravity_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableLine (_exports_DrawableLine) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableLine_class_0 = SWIGV8_CreateClassTemplate("DrawableLine");
_exports_DrawableLine_class_0->SetCallHandler(_wrap_new_DrawableLine);
_exports_DrawableLine_class_0->Inherit(_exports_DrawableLine_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableLine_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableLine_obj = _exports_DrawableLine_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableLine_obj = _exports_DrawableLine_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableMatte (_exports_DrawableMatte) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableMatte_class_0 = SWIGV8_CreateClassTemplate("DrawableMatte");
_exports_DrawableMatte_class_0->SetCallHandler(_wrap_new_DrawableMatte);
_exports_DrawableMatte_class_0->Inherit(_exports_DrawableMatte_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableMatte_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableMatte_obj = _exports_DrawableMatte_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableMatte_obj = _exports_DrawableMatte_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawablePath (_exports_DrawablePath) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawablePath_class_0 = SWIGV8_CreateClassTemplate("DrawablePath");
_exports_DrawablePath_class_0->SetCallHandler(_wrap_new_DrawablePath);
_exports_DrawablePath_class_0->Inherit(_exports_DrawablePath_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawablePath_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawablePath_obj = _exports_DrawablePath_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawablePath_obj = _exports_DrawablePath_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawablePoint (_exports_DrawablePoint) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawablePoint_class_0 = SWIGV8_CreateClassTemplate("DrawablePoint");
_exports_DrawablePoint_class_0->SetCallHandler(_wrap_new_DrawablePoint);
_exports_DrawablePoint_class_0->Inherit(_exports_DrawablePoint_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawablePoint_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawablePoint_obj = _exports_DrawablePoint_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawablePoint_obj = _exports_DrawablePoint_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawablePointSize (_exports_DrawablePointSize) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawablePointSize_class_0 = SWIGV8_CreateClassTemplate("DrawablePointSize");
_exports_DrawablePointSize_class_0->SetCallHandler(_wrap_new_DrawablePointSize);
_exports_DrawablePointSize_class_0->Inherit(_exports_DrawablePointSize_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawablePointSize_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawablePointSize_obj = _exports_DrawablePointSize_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawablePointSize_obj = _exports_DrawablePointSize_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawablePolygon (_exports_DrawablePolygon) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawablePolygon_class_0 = SWIGV8_CreateClassTemplate("DrawablePolygon");
_exports_DrawablePolygon_class_0->SetCallHandler(_wrap_new_DrawablePolygon);
_exports_DrawablePolygon_class_0->Inherit(_exports_DrawablePolygon_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawablePolygon_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawablePolygon_obj = _exports_DrawablePolygon_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawablePolygon_obj = _exports_DrawablePolygon_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawablePolyline (_exports_DrawablePolyline) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawablePolyline_class_0 = SWIGV8_CreateClassTemplate("DrawablePolyline");
_exports_DrawablePolyline_class_0->SetCallHandler(_wrap_new_DrawablePolyline);
_exports_DrawablePolyline_class_0->Inherit(_exports_DrawablePolyline_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawablePolyline_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawablePolyline_obj = _exports_DrawablePolyline_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawablePolyline_obj = _exports_DrawablePolyline_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawablePopGraphicContext (_exports_DrawablePopGraphicContext) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawablePopGraphicContext_class_0 = SWIGV8_CreateClassTemplate("DrawablePopGraphicContext");
_exports_DrawablePopGraphicContext_class_0->SetCallHandler(_wrap_new_DrawablePopGraphicContext);
_exports_DrawablePopGraphicContext_class_0->Inherit(_exports_DrawablePopGraphicContext_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawablePopGraphicContext_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawablePopGraphicContext_obj = _exports_DrawablePopGraphicContext_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawablePopGraphicContext_obj = _exports_DrawablePopGraphicContext_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawablePushGraphicContext (_exports_DrawablePushGraphicContext) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawablePushGraphicContext_class_0 = SWIGV8_CreateClassTemplate("DrawablePushGraphicContext");
_exports_DrawablePushGraphicContext_class_0->SetCallHandler(_wrap_new_DrawablePushGraphicContext);
_exports_DrawablePushGraphicContext_class_0->Inherit(_exports_DrawablePushGraphicContext_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawablePushGraphicContext_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawablePushGraphicContext_obj = _exports_DrawablePushGraphicContext_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawablePushGraphicContext_obj = _exports_DrawablePushGraphicContext_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawablePopPattern (_exports_DrawablePopPattern) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawablePopPattern_class_0 = SWIGV8_CreateClassTemplate("DrawablePopPattern");
_exports_DrawablePopPattern_class_0->SetCallHandler(_wrap_new_DrawablePopPattern);
_exports_DrawablePopPattern_class_0->Inherit(_exports_DrawablePopPattern_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawablePopPattern_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawablePopPattern_obj = _exports_DrawablePopPattern_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawablePopPattern_obj = _exports_DrawablePopPattern_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawablePushPattern (_exports_DrawablePushPattern) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawablePushPattern_class_0 = SWIGV8_CreateClassTemplate("DrawablePushPattern");
_exports_DrawablePushPattern_class_0->SetCallHandler(_wrap_new_DrawablePushPattern);
_exports_DrawablePushPattern_class_0->Inherit(_exports_DrawablePushPattern_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawablePushPattern_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawablePushPattern_obj = _exports_DrawablePushPattern_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawablePushPattern_obj = _exports_DrawablePushPattern_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableRectangle (_exports_DrawableRectangle) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableRectangle_class_0 = SWIGV8_CreateClassTemplate("DrawableRectangle");
_exports_DrawableRectangle_class_0->SetCallHandler(_wrap_new_DrawableRectangle);
_exports_DrawableRectangle_class_0->Inherit(_exports_DrawableRectangle_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableRectangle_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableRectangle_obj = _exports_DrawableRectangle_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableRectangle_obj = _exports_DrawableRectangle_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableRotation (_exports_DrawableRotation) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableRotation_class_0 = SWIGV8_CreateClassTemplate("DrawableRotation");
_exports_DrawableRotation_class_0->SetCallHandler(_wrap_new_DrawableRotation);
_exports_DrawableRotation_class_0->Inherit(_exports_DrawableRotation_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableRotation_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableRotation_obj = _exports_DrawableRotation_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableRotation_obj = _exports_DrawableRotation_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableRoundRectangle (_exports_DrawableRoundRectangle) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableRoundRectangle_class_0 = SWIGV8_CreateClassTemplate("DrawableRoundRectangle");
_exports_DrawableRoundRectangle_class_0->SetCallHandler(_wrap_new_DrawableRoundRectangle);
_exports_DrawableRoundRectangle_class_0->Inherit(_exports_DrawableRoundRectangle_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableRoundRectangle_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableRoundRectangle_obj = _exports_DrawableRoundRectangle_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableRoundRectangle_obj = _exports_DrawableRoundRectangle_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableScaling (_exports_DrawableScaling) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableScaling_class_0 = SWIGV8_CreateClassTemplate("DrawableScaling");
_exports_DrawableScaling_class_0->SetCallHandler(_wrap_new_DrawableScaling);
_exports_DrawableScaling_class_0->Inherit(_exports_DrawableScaling_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableScaling_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableScaling_obj = _exports_DrawableScaling_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableScaling_obj = _exports_DrawableScaling_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableSkewX (_exports_DrawableSkewX) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableSkewX_class_0 = SWIGV8_CreateClassTemplate("DrawableSkewX");
_exports_DrawableSkewX_class_0->SetCallHandler(_wrap_new_DrawableSkewX);
_exports_DrawableSkewX_class_0->Inherit(_exports_DrawableSkewX_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableSkewX_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableSkewX_obj = _exports_DrawableSkewX_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableSkewX_obj = _exports_DrawableSkewX_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableSkewY (_exports_DrawableSkewY) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableSkewY_class_0 = SWIGV8_CreateClassTemplate("DrawableSkewY");
_exports_DrawableSkewY_class_0->SetCallHandler(_wrap_new_DrawableSkewY);
_exports_DrawableSkewY_class_0->Inherit(_exports_DrawableSkewY_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableSkewY_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableSkewY_obj = _exports_DrawableSkewY_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableSkewY_obj = _exports_DrawableSkewY_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableDashArray (_exports_DrawableDashArray) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableDashArray_class_0 = SWIGV8_CreateClassTemplate("DrawableDashArray");
_exports_DrawableDashArray_class_0->SetCallHandler(_wrap_new_DrawableDashArray);
_exports_DrawableDashArray_class_0->Inherit(_exports_DrawableDashArray_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableDashArray_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableDashArray_obj = _exports_DrawableDashArray_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableDashArray_obj = _exports_DrawableDashArray_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableDashOffset (_exports_DrawableDashOffset) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableDashOffset_class_0 = SWIGV8_CreateClassTemplate("DrawableDashOffset");
_exports_DrawableDashOffset_class_0->SetCallHandler(_wrap_new_DrawableDashOffset);
_exports_DrawableDashOffset_class_0->Inherit(_exports_DrawableDashOffset_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableDashOffset_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableDashOffset_obj = _exports_DrawableDashOffset_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableDashOffset_obj = _exports_DrawableDashOffset_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableStrokeLineCap (_exports_DrawableStrokeLineCap) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableStrokeLineCap_class_0 = SWIGV8_CreateClassTemplate("DrawableStrokeLineCap");
_exports_DrawableStrokeLineCap_class_0->SetCallHandler(_wrap_new_DrawableStrokeLineCap);
_exports_DrawableStrokeLineCap_class_0->Inherit(_exports_DrawableStrokeLineCap_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableStrokeLineCap_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableStrokeLineCap_obj = _exports_DrawableStrokeLineCap_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableStrokeLineCap_obj = _exports_DrawableStrokeLineCap_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableStrokeLineJoin (_exports_DrawableStrokeLineJoin) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableStrokeLineJoin_class_0 = SWIGV8_CreateClassTemplate("DrawableStrokeLineJoin");
_exports_DrawableStrokeLineJoin_class_0->SetCallHandler(_wrap_new_DrawableStrokeLineJoin);
_exports_DrawableStrokeLineJoin_class_0->Inherit(_exports_DrawableStrokeLineJoin_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableStrokeLineJoin_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableStrokeLineJoin_obj = _exports_DrawableStrokeLineJoin_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableStrokeLineJoin_obj = _exports_DrawableStrokeLineJoin_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableMiterLimit (_exports_DrawableMiterLimit) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableMiterLimit_class_0 = SWIGV8_CreateClassTemplate("DrawableMiterLimit");
_exports_DrawableMiterLimit_class_0->SetCallHandler(_wrap_new_DrawableMiterLimit);
_exports_DrawableMiterLimit_class_0->Inherit(_exports_DrawableMiterLimit_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableMiterLimit_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableMiterLimit_obj = _exports_DrawableMiterLimit_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableMiterLimit_obj = _exports_DrawableMiterLimit_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableStrokeAntialias (_exports_DrawableStrokeAntialias) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableStrokeAntialias_class_0 = SWIGV8_CreateClassTemplate("DrawableStrokeAntialias");
_exports_DrawableStrokeAntialias_class_0->SetCallHandler(_wrap_new_DrawableStrokeAntialias);
_exports_DrawableStrokeAntialias_class_0->Inherit(_exports_DrawableStrokeAntialias_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableStrokeAntialias_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableStrokeAntialias_obj = _exports_DrawableStrokeAntialias_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableStrokeAntialias_obj = _exports_DrawableStrokeAntialias_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableStrokeColor (_exports_DrawableStrokeColor) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableStrokeColor_class_0 = SWIGV8_CreateClassTemplate("DrawableStrokeColor");
_exports_DrawableStrokeColor_class_0->SetCallHandler(_wrap_new_DrawableStrokeColor);
_exports_DrawableStrokeColor_class_0->Inherit(_exports_DrawableStrokeColor_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableStrokeColor_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableStrokeColor_obj = _exports_DrawableStrokeColor_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableStrokeColor_obj = _exports_DrawableStrokeColor_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableStrokeOpacity (_exports_DrawableStrokeOpacity) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableStrokeOpacity_class_0 = SWIGV8_CreateClassTemplate("DrawableStrokeOpacity");
_exports_DrawableStrokeOpacity_class_0->SetCallHandler(_wrap_new_DrawableStrokeOpacity);
_exports_DrawableStrokeOpacity_class_0->Inherit(_exports_DrawableStrokeOpacity_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableStrokeOpacity_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableStrokeOpacity_obj = _exports_DrawableStrokeOpacity_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableStrokeOpacity_obj = _exports_DrawableStrokeOpacity_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableStrokeWidth (_exports_DrawableStrokeWidth) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableStrokeWidth_class_0 = SWIGV8_CreateClassTemplate("DrawableStrokeWidth");
_exports_DrawableStrokeWidth_class_0->SetCallHandler(_wrap_new_DrawableStrokeWidth);
_exports_DrawableStrokeWidth_class_0->Inherit(_exports_DrawableStrokeWidth_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableStrokeWidth_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableStrokeWidth_obj = _exports_DrawableStrokeWidth_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableStrokeWidth_obj = _exports_DrawableStrokeWidth_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableText (_exports_DrawableText) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableText_class_0 = SWIGV8_CreateClassTemplate("DrawableText");
_exports_DrawableText_class_0->SetCallHandler(_wrap_new_DrawableText);
_exports_DrawableText_class_0->Inherit(_exports_DrawableText_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableText_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableText_obj = _exports_DrawableText_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableText_obj = _exports_DrawableText_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableTextAntialias (_exports_DrawableTextAntialias) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableTextAntialias_class_0 = SWIGV8_CreateClassTemplate("DrawableTextAntialias");
_exports_DrawableTextAntialias_class_0->SetCallHandler(_wrap_new_DrawableTextAntialias);
_exports_DrawableTextAntialias_class_0->Inherit(_exports_DrawableTextAntialias_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableTextAntialias_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableTextAntialias_obj = _exports_DrawableTextAntialias_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableTextAntialias_obj = _exports_DrawableTextAntialias_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableTextDecoration (_exports_DrawableTextDecoration) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableTextDecoration_class_0 = SWIGV8_CreateClassTemplate("DrawableTextDecoration");
_exports_DrawableTextDecoration_class_0->SetCallHandler(_wrap_new_DrawableTextDecoration);
_exports_DrawableTextDecoration_class_0->Inherit(_exports_DrawableTextDecoration_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableTextDecoration_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableTextDecoration_obj = _exports_DrawableTextDecoration_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableTextDecoration_obj = _exports_DrawableTextDecoration_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableTextDirection (_exports_DrawableTextDirection) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableTextDirection_class_0 = SWIGV8_CreateClassTemplate("DrawableTextDirection");
_exports_DrawableTextDirection_class_0->SetCallHandler(_wrap_new_DrawableTextDirection);
_exports_DrawableTextDirection_class_0->Inherit(_exports_DrawableTextDirection_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableTextDirection_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableTextDirection_obj = _exports_DrawableTextDirection_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableTextDirection_obj = _exports_DrawableTextDirection_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableTextInterlineSpacing (_exports_DrawableTextInterlineSpacing) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableTextInterlineSpacing_class_0 = SWIGV8_CreateClassTemplate("DrawableTextInterlineSpacing");
_exports_DrawableTextInterlineSpacing_class_0->SetCallHandler(_wrap_new_DrawableTextInterlineSpacing);
_exports_DrawableTextInterlineSpacing_class_0->Inherit(_exports_DrawableTextInterlineSpacing_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableTextInterlineSpacing_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableTextInterlineSpacing_obj = _exports_DrawableTextInterlineSpacing_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableTextInterlineSpacing_obj = _exports_DrawableTextInterlineSpacing_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableTextInterwordSpacing (_exports_DrawableTextInterwordSpacing) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableTextInterwordSpacing_class_0 = SWIGV8_CreateClassTemplate("DrawableTextInterwordSpacing");
_exports_DrawableTextInterwordSpacing_class_0->SetCallHandler(_wrap_new_DrawableTextInterwordSpacing);
_exports_DrawableTextInterwordSpacing_class_0->Inherit(_exports_DrawableTextInterwordSpacing_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableTextInterwordSpacing_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableTextInterwordSpacing_obj = _exports_DrawableTextInterwordSpacing_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableTextInterwordSpacing_obj = _exports_DrawableTextInterwordSpacing_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableTextKerning (_exports_DrawableTextKerning) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableTextKerning_class_0 = SWIGV8_CreateClassTemplate("DrawableTextKerning");
_exports_DrawableTextKerning_class_0->SetCallHandler(_wrap_new_DrawableTextKerning);
_exports_DrawableTextKerning_class_0->Inherit(_exports_DrawableTextKerning_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableTextKerning_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableTextKerning_obj = _exports_DrawableTextKerning_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableTextKerning_obj = _exports_DrawableTextKerning_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableTextUnderColor (_exports_DrawableTextUnderColor) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableTextUnderColor_class_0 = SWIGV8_CreateClassTemplate("DrawableTextUnderColor");
_exports_DrawableTextUnderColor_class_0->SetCallHandler(_wrap_new_DrawableTextUnderColor);
_exports_DrawableTextUnderColor_class_0->Inherit(_exports_DrawableTextUnderColor_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableTextUnderColor_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableTextUnderColor_obj = _exports_DrawableTextUnderColor_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableTextUnderColor_obj = _exports_DrawableTextUnderColor_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableTranslation (_exports_DrawableTranslation) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableTranslation_class_0 = SWIGV8_CreateClassTemplate("DrawableTranslation");
_exports_DrawableTranslation_class_0->SetCallHandler(_wrap_new_DrawableTranslation);
_exports_DrawableTranslation_class_0->Inherit(_exports_DrawableTranslation_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableTranslation_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableTranslation_obj = _exports_DrawableTranslation_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableTranslation_obj = _exports_DrawableTranslation_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: DrawableViewbox (_exports_DrawableViewbox) */
SWIGV8_FUNCTION_TEMPLATE _exports_DrawableViewbox_class_0 = SWIGV8_CreateClassTemplate("DrawableViewbox");
_exports_DrawableViewbox_class_0->SetCallHandler(_wrap_new_DrawableViewbox);
_exports_DrawableViewbox_class_0->Inherit(_exports_DrawableViewbox_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_DrawableViewbox_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_DrawableViewbox_obj = _exports_DrawableViewbox_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_DrawableViewbox_obj = _exports_DrawableViewbox_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: PathArcArgs (_exports_PathArcArgs) */
SWIGV8_FUNCTION_TEMPLATE _exports_PathArcArgs_class_0 = SWIGV8_CreateClassTemplate("PathArcArgs");
_exports_PathArcArgs_class_0->SetCallHandler(_wrap_new_PathArcArgs);
_exports_PathArcArgs_class_0->Inherit(_exports_PathArcArgs_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_PathArcArgs_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_PathArcArgs_obj = _exports_PathArcArgs_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_PathArcArgs_obj = _exports_PathArcArgs_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: PathArcAbs (_exports_PathArcAbs) */
SWIGV8_FUNCTION_TEMPLATE _exports_PathArcAbs_class_0 = SWIGV8_CreateClassTemplate("PathArcAbs");
_exports_PathArcAbs_class_0->SetCallHandler(_wrap_new_PathArcAbs);
_exports_PathArcAbs_class_0->Inherit(_exports_PathArcAbs_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_PathArcAbs_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_PathArcAbs_obj = _exports_PathArcAbs_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_PathArcAbs_obj = _exports_PathArcAbs_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: PathArcRel (_exports_PathArcRel) */
SWIGV8_FUNCTION_TEMPLATE _exports_PathArcRel_class_0 = SWIGV8_CreateClassTemplate("PathArcRel");
_exports_PathArcRel_class_0->SetCallHandler(_wrap_new_PathArcRel);
_exports_PathArcRel_class_0->Inherit(_exports_PathArcRel_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_PathArcRel_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_PathArcRel_obj = _exports_PathArcRel_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_PathArcRel_obj = _exports_PathArcRel_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: PathClosePath (_exports_PathClosePath) */
SWIGV8_FUNCTION_TEMPLATE _exports_PathClosePath_class_0 = SWIGV8_CreateClassTemplate("PathClosePath");
_exports_PathClosePath_class_0->SetCallHandler(_wrap_new_PathClosePath);
_exports_PathClosePath_class_0->Inherit(_exports_PathClosePath_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_PathClosePath_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_PathClosePath_obj = _exports_PathClosePath_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_PathClosePath_obj = _exports_PathClosePath_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: PathCurvetoArgs (_exports_PathCurvetoArgs) */
SWIGV8_FUNCTION_TEMPLATE _exports_PathCurvetoArgs_class_0 = SWIGV8_CreateClassTemplate("PathCurvetoArgs");
_exports_PathCurvetoArgs_class_0->SetCallHandler(_wrap_new_PathCurvetoArgs);
_exports_PathCurvetoArgs_class_0->Inherit(_exports_PathCurvetoArgs_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_PathCurvetoArgs_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_PathCurvetoArgs_obj = _exports_PathCurvetoArgs_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_PathCurvetoArgs_obj = _exports_PathCurvetoArgs_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: PathCurvetoAbs (_exports_PathCurvetoAbs) */
SWIGV8_FUNCTION_TEMPLATE _exports_PathCurvetoAbs_class_0 = SWIGV8_CreateClassTemplate("PathCurvetoAbs");
_exports_PathCurvetoAbs_class_0->SetCallHandler(_wrap_new_PathCurvetoAbs);
_exports_PathCurvetoAbs_class_0->Inherit(_exports_PathCurvetoAbs_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_PathCurvetoAbs_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_PathCurvetoAbs_obj = _exports_PathCurvetoAbs_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_PathCurvetoAbs_obj = _exports_PathCurvetoAbs_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: PathCurvetoRel (_exports_PathCurvetoRel) */
SWIGV8_FUNCTION_TEMPLATE _exports_PathCurvetoRel_class_0 = SWIGV8_CreateClassTemplate("PathCurvetoRel");
_exports_PathCurvetoRel_class_0->SetCallHandler(_wrap_new_PathCurvetoRel);
_exports_PathCurvetoRel_class_0->Inherit(_exports_PathCurvetoRel_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_PathCurvetoRel_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_PathCurvetoRel_obj = _exports_PathCurvetoRel_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_PathCurvetoRel_obj = _exports_PathCurvetoRel_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: PathSmoothCurvetoAbs (_exports_PathSmoothCurvetoAbs) */
SWIGV8_FUNCTION_TEMPLATE _exports_PathSmoothCurvetoAbs_class_0 = SWIGV8_CreateClassTemplate("PathSmoothCurvetoAbs");
_exports_PathSmoothCurvetoAbs_class_0->SetCallHandler(_wrap_new_PathSmoothCurvetoAbs);
_exports_PathSmoothCurvetoAbs_class_0->Inherit(_exports_PathSmoothCurvetoAbs_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_PathSmoothCurvetoAbs_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_PathSmoothCurvetoAbs_obj = _exports_PathSmoothCurvetoAbs_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_PathSmoothCurvetoAbs_obj = _exports_PathSmoothCurvetoAbs_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: PathSmoothCurvetoRel (_exports_PathSmoothCurvetoRel) */
SWIGV8_FUNCTION_TEMPLATE _exports_PathSmoothCurvetoRel_class_0 = SWIGV8_CreateClassTemplate("PathSmoothCurvetoRel");
_exports_PathSmoothCurvetoRel_class_0->SetCallHandler(_wrap_new_PathSmoothCurvetoRel);
_exports_PathSmoothCurvetoRel_class_0->Inherit(_exports_PathSmoothCurvetoRel_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_PathSmoothCurvetoRel_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_PathSmoothCurvetoRel_obj = _exports_PathSmoothCurvetoRel_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_PathSmoothCurvetoRel_obj = _exports_PathSmoothCurvetoRel_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: PathQuadraticCurvetoArgs (_exports_PathQuadraticCurvetoArgs) */
SWIGV8_FUNCTION_TEMPLATE _exports_PathQuadraticCurvetoArgs_class_0 = SWIGV8_CreateClassTemplate("PathQuadraticCurvetoArgs");
_exports_PathQuadraticCurvetoArgs_class_0->SetCallHandler(_wrap_new_PathQuadraticCurvetoArgs);
_exports_PathQuadraticCurvetoArgs_class_0->Inherit(_exports_PathQuadraticCurvetoArgs_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_PathQuadraticCurvetoArgs_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_PathQuadraticCurvetoArgs_obj = _exports_PathQuadraticCurvetoArgs_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_PathQuadraticCurvetoArgs_obj = _exports_PathQuadraticCurvetoArgs_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: PathQuadraticCurvetoAbs (_exports_PathQuadraticCurvetoAbs) */
SWIGV8_FUNCTION_TEMPLATE _exports_PathQuadraticCurvetoAbs_class_0 = SWIGV8_CreateClassTemplate("PathQuadraticCurvetoAbs");
_exports_PathQuadraticCurvetoAbs_class_0->SetCallHandler(_wrap_new_PathQuadraticCurvetoAbs);
_exports_PathQuadraticCurvetoAbs_class_0->Inherit(_exports_PathQuadraticCurvetoAbs_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_PathQuadraticCurvetoAbs_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_PathQuadraticCurvetoAbs_obj = _exports_PathQuadraticCurvetoAbs_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_PathQuadraticCurvetoAbs_obj = _exports_PathQuadraticCurvetoAbs_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: PathQuadraticCurvetoRel (_exports_PathQuadraticCurvetoRel) */
SWIGV8_FUNCTION_TEMPLATE _exports_PathQuadraticCurvetoRel_class_0 = SWIGV8_CreateClassTemplate("PathQuadraticCurvetoRel");
_exports_PathQuadraticCurvetoRel_class_0->SetCallHandler(_wrap_new_PathQuadraticCurvetoRel);
_exports_PathQuadraticCurvetoRel_class_0->Inherit(_exports_PathQuadraticCurvetoRel_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_PathQuadraticCurvetoRel_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_PathQuadraticCurvetoRel_obj = _exports_PathQuadraticCurvetoRel_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_PathQuadraticCurvetoRel_obj = _exports_PathQuadraticCurvetoRel_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: PathSmoothQuadraticCurvetoAbs (_exports_PathSmoothQuadraticCurvetoAbs) */
SWIGV8_FUNCTION_TEMPLATE _exports_PathSmoothQuadraticCurvetoAbs_class_0 = SWIGV8_CreateClassTemplate("PathSmoothQuadraticCurvetoAbs");
_exports_PathSmoothQuadraticCurvetoAbs_class_0->SetCallHandler(_wrap_new_PathSmoothQuadraticCurvetoAbs);
_exports_PathSmoothQuadraticCurvetoAbs_class_0->Inherit(_exports_PathSmoothQuadraticCurvetoAbs_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_PathSmoothQuadraticCurvetoAbs_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_PathSmoothQuadraticCurvetoAbs_obj = _exports_PathSmoothQuadraticCurvetoAbs_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_PathSmoothQuadraticCurvetoAbs_obj = _exports_PathSmoothQuadraticCurvetoAbs_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: PathSmoothQuadraticCurvetoRel (_exports_PathSmoothQuadraticCurvetoRel) */
SWIGV8_FUNCTION_TEMPLATE _exports_PathSmoothQuadraticCurvetoRel_class_0 = SWIGV8_CreateClassTemplate("PathSmoothQuadraticCurvetoRel");
_exports_PathSmoothQuadraticCurvetoRel_class_0->SetCallHandler(_wrap_new_PathSmoothQuadraticCurvetoRel);
_exports_PathSmoothQuadraticCurvetoRel_class_0->Inherit(_exports_PathSmoothQuadraticCurvetoRel_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_PathSmoothQuadraticCurvetoRel_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_PathSmoothQuadraticCurvetoRel_obj = _exports_PathSmoothQuadraticCurvetoRel_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_PathSmoothQuadraticCurvetoRel_obj = _exports_PathSmoothQuadraticCurvetoRel_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: PathLinetoAbs (_exports_PathLinetoAbs) */
SWIGV8_FUNCTION_TEMPLATE _exports_PathLinetoAbs_class_0 = SWIGV8_CreateClassTemplate("PathLinetoAbs");
_exports_PathLinetoAbs_class_0->SetCallHandler(_wrap_new_PathLinetoAbs);
_exports_PathLinetoAbs_class_0->Inherit(_exports_PathLinetoAbs_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_PathLinetoAbs_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_PathLinetoAbs_obj = _exports_PathLinetoAbs_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_PathLinetoAbs_obj = _exports_PathLinetoAbs_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: PathLinetoRel (_exports_PathLinetoRel) */
SWIGV8_FUNCTION_TEMPLATE _exports_PathLinetoRel_class_0 = SWIGV8_CreateClassTemplate("PathLinetoRel");
_exports_PathLinetoRel_class_0->SetCallHandler(_wrap_new_PathLinetoRel);
_exports_PathLinetoRel_class_0->Inherit(_exports_PathLinetoRel_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_PathLinetoRel_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_PathLinetoRel_obj = _exports_PathLinetoRel_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_PathLinetoRel_obj = _exports_PathLinetoRel_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: PathLinetoHorizontalAbs (_exports_PathLinetoHorizontalAbs) */
SWIGV8_FUNCTION_TEMPLATE _exports_PathLinetoHorizontalAbs_class_0 = SWIGV8_CreateClassTemplate("PathLinetoHorizontalAbs");
_exports_PathLinetoHorizontalAbs_class_0->SetCallHandler(_wrap_new_PathLinetoHorizontalAbs);
_exports_PathLinetoHorizontalAbs_class_0->Inherit(_exports_PathLinetoHorizontalAbs_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_PathLinetoHorizontalAbs_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_PathLinetoHorizontalAbs_obj = _exports_PathLinetoHorizontalAbs_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_PathLinetoHorizontalAbs_obj = _exports_PathLinetoHorizontalAbs_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: PathLinetoHorizontalRel (_exports_PathLinetoHorizontalRel) */
SWIGV8_FUNCTION_TEMPLATE _exports_PathLinetoHorizontalRel_class_0 = SWIGV8_CreateClassTemplate("PathLinetoHorizontalRel");
_exports_PathLinetoHorizontalRel_class_0->SetCallHandler(_wrap_new_PathLinetoHorizontalRel);
_exports_PathLinetoHorizontalRel_class_0->Inherit(_exports_PathLinetoHorizontalRel_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_PathLinetoHorizontalRel_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_PathLinetoHorizontalRel_obj = _exports_PathLinetoHorizontalRel_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_PathLinetoHorizontalRel_obj = _exports_PathLinetoHorizontalRel_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: PathLinetoVerticalAbs (_exports_PathLinetoVerticalAbs) */
SWIGV8_FUNCTION_TEMPLATE _exports_PathLinetoVerticalAbs_class_0 = SWIGV8_CreateClassTemplate("PathLinetoVerticalAbs");
_exports_PathLinetoVerticalAbs_class_0->SetCallHandler(_wrap_new_PathLinetoVerticalAbs);
_exports_PathLinetoVerticalAbs_class_0->Inherit(_exports_PathLinetoVerticalAbs_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_PathLinetoVerticalAbs_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_PathLinetoVerticalAbs_obj = _exports_PathLinetoVerticalAbs_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_PathLinetoVerticalAbs_obj = _exports_PathLinetoVerticalAbs_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: PathLinetoVerticalRel (_exports_PathLinetoVerticalRel) */
SWIGV8_FUNCTION_TEMPLATE _exports_PathLinetoVerticalRel_class_0 = SWIGV8_CreateClassTemplate("PathLinetoVerticalRel");
_exports_PathLinetoVerticalRel_class_0->SetCallHandler(_wrap_new_PathLinetoVerticalRel);
_exports_PathLinetoVerticalRel_class_0->Inherit(_exports_PathLinetoVerticalRel_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_PathLinetoVerticalRel_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_PathLinetoVerticalRel_obj = _exports_PathLinetoVerticalRel_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_PathLinetoVerticalRel_obj = _exports_PathLinetoVerticalRel_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: PathMovetoAbs (_exports_PathMovetoAbs) */
SWIGV8_FUNCTION_TEMPLATE _exports_PathMovetoAbs_class_0 = SWIGV8_CreateClassTemplate("PathMovetoAbs");
_exports_PathMovetoAbs_class_0->SetCallHandler(_wrap_new_PathMovetoAbs);
_exports_PathMovetoAbs_class_0->Inherit(_exports_PathMovetoAbs_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_PathMovetoAbs_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_PathMovetoAbs_obj = _exports_PathMovetoAbs_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_PathMovetoAbs_obj = _exports_PathMovetoAbs_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: PathMovetoRel (_exports_PathMovetoRel) */
SWIGV8_FUNCTION_TEMPLATE _exports_PathMovetoRel_class_0 = SWIGV8_CreateClassTemplate("PathMovetoRel");
_exports_PathMovetoRel_class_0->SetCallHandler(_wrap_new_PathMovetoRel);
_exports_PathMovetoRel_class_0->Inherit(_exports_PathMovetoRel_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_PathMovetoRel_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_PathMovetoRel_obj = _exports_PathMovetoRel_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_PathMovetoRel_obj = _exports_PathMovetoRel_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: Exception (_exports_Exception) */
SWIGV8_FUNCTION_TEMPLATE _exports_Exception_class_0 = SWIGV8_CreateClassTemplate("Exception");
_exports_Exception_class_0->SetCallHandler(_wrap_new_Exception);
_exports_Exception_class_0->Inherit(_exports_Exception_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_Exception_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_Exception_obj = _exports_Exception_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_Exception_obj = _exports_Exception_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: Error (_exports_Error) */
SWIGV8_FUNCTION_TEMPLATE _exports_Error_class_0 = SWIGV8_CreateClassTemplate("Error");
_exports_Error_class_0->SetCallHandler(_wrap_new_Error);
_exports_Error_class_0->Inherit(_exports_Error_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_Error_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_Error_obj = _exports_Error_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_Error_obj = _exports_Error_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ErrorBlob (_exports_ErrorBlob) */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorBlob_class_0 = SWIGV8_CreateClassTemplate("ErrorBlob");
_exports_ErrorBlob_class_0->SetCallHandler(_wrap_new_ErrorBlob);
_exports_ErrorBlob_class_0->Inherit(_exports_ErrorBlob_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ErrorBlob_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ErrorBlob_obj = _exports_ErrorBlob_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ErrorBlob_obj = _exports_ErrorBlob_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ErrorCache (_exports_ErrorCache) */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorCache_class_0 = SWIGV8_CreateClassTemplate("ErrorCache");
_exports_ErrorCache_class_0->SetCallHandler(_wrap_new_ErrorCache);
_exports_ErrorCache_class_0->Inherit(_exports_ErrorCache_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ErrorCache_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ErrorCache_obj = _exports_ErrorCache_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ErrorCache_obj = _exports_ErrorCache_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ErrorCoder (_exports_ErrorCoder) */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorCoder_class_0 = SWIGV8_CreateClassTemplate("ErrorCoder");
_exports_ErrorCoder_class_0->SetCallHandler(_wrap_new_ErrorCoder);
_exports_ErrorCoder_class_0->Inherit(_exports_ErrorCoder_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ErrorCoder_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ErrorCoder_obj = _exports_ErrorCoder_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ErrorCoder_obj = _exports_ErrorCoder_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ErrorConfigure (_exports_ErrorConfigure) */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorConfigure_class_0 = SWIGV8_CreateClassTemplate("ErrorConfigure");
_exports_ErrorConfigure_class_0->SetCallHandler(_wrap_new_ErrorConfigure);
_exports_ErrorConfigure_class_0->Inherit(_exports_ErrorConfigure_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ErrorConfigure_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ErrorConfigure_obj = _exports_ErrorConfigure_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ErrorConfigure_obj = _exports_ErrorConfigure_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ErrorCorruptImage (_exports_ErrorCorruptImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorCorruptImage_class_0 = SWIGV8_CreateClassTemplate("ErrorCorruptImage");
_exports_ErrorCorruptImage_class_0->SetCallHandler(_wrap_new_ErrorCorruptImage);
_exports_ErrorCorruptImage_class_0->Inherit(_exports_ErrorCorruptImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ErrorCorruptImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ErrorCorruptImage_obj = _exports_ErrorCorruptImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ErrorCorruptImage_obj = _exports_ErrorCorruptImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ErrorDelegate (_exports_ErrorDelegate) */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorDelegate_class_0 = SWIGV8_CreateClassTemplate("ErrorDelegate");
_exports_ErrorDelegate_class_0->SetCallHandler(_wrap_new_ErrorDelegate);
_exports_ErrorDelegate_class_0->Inherit(_exports_ErrorDelegate_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ErrorDelegate_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ErrorDelegate_obj = _exports_ErrorDelegate_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ErrorDelegate_obj = _exports_ErrorDelegate_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ErrorDraw (_exports_ErrorDraw) */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorDraw_class_0 = SWIGV8_CreateClassTemplate("ErrorDraw");
_exports_ErrorDraw_class_0->SetCallHandler(_wrap_new_ErrorDraw);
_exports_ErrorDraw_class_0->Inherit(_exports_ErrorDraw_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ErrorDraw_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ErrorDraw_obj = _exports_ErrorDraw_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ErrorDraw_obj = _exports_ErrorDraw_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ErrorFileOpen (_exports_ErrorFileOpen) */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorFileOpen_class_0 = SWIGV8_CreateClassTemplate("ErrorFileOpen");
_exports_ErrorFileOpen_class_0->SetCallHandler(_wrap_new_ErrorFileOpen);
_exports_ErrorFileOpen_class_0->Inherit(_exports_ErrorFileOpen_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ErrorFileOpen_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ErrorFileOpen_obj = _exports_ErrorFileOpen_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ErrorFileOpen_obj = _exports_ErrorFileOpen_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ErrorImage (_exports_ErrorImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorImage_class_0 = SWIGV8_CreateClassTemplate("ErrorImage");
_exports_ErrorImage_class_0->SetCallHandler(_wrap_new_ErrorImage);
_exports_ErrorImage_class_0->Inherit(_exports_ErrorImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ErrorImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ErrorImage_obj = _exports_ErrorImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ErrorImage_obj = _exports_ErrorImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ErrorMissingDelegate (_exports_ErrorMissingDelegate) */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorMissingDelegate_class_0 = SWIGV8_CreateClassTemplate("ErrorMissingDelegate");
_exports_ErrorMissingDelegate_class_0->SetCallHandler(_wrap_new_ErrorMissingDelegate);
_exports_ErrorMissingDelegate_class_0->Inherit(_exports_ErrorMissingDelegate_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ErrorMissingDelegate_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ErrorMissingDelegate_obj = _exports_ErrorMissingDelegate_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ErrorMissingDelegate_obj = _exports_ErrorMissingDelegate_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ErrorModule (_exports_ErrorModule) */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorModule_class_0 = SWIGV8_CreateClassTemplate("ErrorModule");
_exports_ErrorModule_class_0->SetCallHandler(_wrap_new_ErrorModule);
_exports_ErrorModule_class_0->Inherit(_exports_ErrorModule_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ErrorModule_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ErrorModule_obj = _exports_ErrorModule_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ErrorModule_obj = _exports_ErrorModule_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ErrorMonitor (_exports_ErrorMonitor) */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorMonitor_class_0 = SWIGV8_CreateClassTemplate("ErrorMonitor");
_exports_ErrorMonitor_class_0->SetCallHandler(_wrap_new_ErrorMonitor);
_exports_ErrorMonitor_class_0->Inherit(_exports_ErrorMonitor_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ErrorMonitor_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ErrorMonitor_obj = _exports_ErrorMonitor_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ErrorMonitor_obj = _exports_ErrorMonitor_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ErrorOption (_exports_ErrorOption) */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorOption_class_0 = SWIGV8_CreateClassTemplate("ErrorOption");
_exports_ErrorOption_class_0->SetCallHandler(_wrap_new_ErrorOption);
_exports_ErrorOption_class_0->Inherit(_exports_ErrorOption_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ErrorOption_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ErrorOption_obj = _exports_ErrorOption_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ErrorOption_obj = _exports_ErrorOption_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ErrorPolicy (_exports_ErrorPolicy) */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorPolicy_class_0 = SWIGV8_CreateClassTemplate("ErrorPolicy");
_exports_ErrorPolicy_class_0->SetCallHandler(_wrap_new_ErrorPolicy);
_exports_ErrorPolicy_class_0->Inherit(_exports_ErrorPolicy_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ErrorPolicy_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ErrorPolicy_obj = _exports_ErrorPolicy_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ErrorPolicy_obj = _exports_ErrorPolicy_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ErrorRegistry (_exports_ErrorRegistry) */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorRegistry_class_0 = SWIGV8_CreateClassTemplate("ErrorRegistry");
_exports_ErrorRegistry_class_0->SetCallHandler(_wrap_new_ErrorRegistry);
_exports_ErrorRegistry_class_0->Inherit(_exports_ErrorRegistry_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ErrorRegistry_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ErrorRegistry_obj = _exports_ErrorRegistry_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ErrorRegistry_obj = _exports_ErrorRegistry_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ErrorResourceLimit (_exports_ErrorResourceLimit) */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorResourceLimit_class_0 = SWIGV8_CreateClassTemplate("ErrorResourceLimit");
_exports_ErrorResourceLimit_class_0->SetCallHandler(_wrap_new_ErrorResourceLimit);
_exports_ErrorResourceLimit_class_0->Inherit(_exports_ErrorResourceLimit_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ErrorResourceLimit_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ErrorResourceLimit_obj = _exports_ErrorResourceLimit_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ErrorResourceLimit_obj = _exports_ErrorResourceLimit_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ErrorStream (_exports_ErrorStream) */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorStream_class_0 = SWIGV8_CreateClassTemplate("ErrorStream");
_exports_ErrorStream_class_0->SetCallHandler(_wrap_new_ErrorStream);
_exports_ErrorStream_class_0->Inherit(_exports_ErrorStream_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ErrorStream_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ErrorStream_obj = _exports_ErrorStream_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ErrorStream_obj = _exports_ErrorStream_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ErrorType (_exports_ErrorType) */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorType_class_0 = SWIGV8_CreateClassTemplate("ErrorType");
_exports_ErrorType_class_0->SetCallHandler(_wrap_new_ErrorType);
_exports_ErrorType_class_0->Inherit(_exports_ErrorType_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ErrorType_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ErrorType_obj = _exports_ErrorType_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ErrorType_obj = _exports_ErrorType_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ErrorUndefined (_exports_ErrorUndefined) */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorUndefined_class_0 = SWIGV8_CreateClassTemplate("ErrorUndefined");
_exports_ErrorUndefined_class_0->SetCallHandler(_wrap_new_ErrorUndefined);
_exports_ErrorUndefined_class_0->Inherit(_exports_ErrorUndefined_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ErrorUndefined_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ErrorUndefined_obj = _exports_ErrorUndefined_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ErrorUndefined_obj = _exports_ErrorUndefined_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: ErrorXServer (_exports_ErrorXServer) */
SWIGV8_FUNCTION_TEMPLATE _exports_ErrorXServer_class_0 = SWIGV8_CreateClassTemplate("ErrorXServer");
_exports_ErrorXServer_class_0->SetCallHandler(_wrap_new_ErrorXServer);
_exports_ErrorXServer_class_0->Inherit(_exports_ErrorXServer_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_ErrorXServer_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_ErrorXServer_obj = _exports_ErrorXServer_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_ErrorXServer_obj = _exports_ErrorXServer_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: Warning (_exports_Warning) */
SWIGV8_FUNCTION_TEMPLATE _exports_Warning_class_0 = SWIGV8_CreateClassTemplate("Warning");
_exports_Warning_class_0->SetCallHandler(_wrap_new_Warning);
_exports_Warning_class_0->Inherit(_exports_Warning_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_Warning_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_Warning_obj = _exports_Warning_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_Warning_obj = _exports_Warning_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: WarningBlob (_exports_WarningBlob) */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningBlob_class_0 = SWIGV8_CreateClassTemplate("WarningBlob");
_exports_WarningBlob_class_0->SetCallHandler(_wrap_new_WarningBlob);
_exports_WarningBlob_class_0->Inherit(_exports_WarningBlob_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_WarningBlob_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_WarningBlob_obj = _exports_WarningBlob_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_WarningBlob_obj = _exports_WarningBlob_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: WarningCache (_exports_WarningCache) */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningCache_class_0 = SWIGV8_CreateClassTemplate("WarningCache");
_exports_WarningCache_class_0->SetCallHandler(_wrap_new_WarningCache);
_exports_WarningCache_class_0->Inherit(_exports_WarningCache_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_WarningCache_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_WarningCache_obj = _exports_WarningCache_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_WarningCache_obj = _exports_WarningCache_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: WarningCoder (_exports_WarningCoder) */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningCoder_class_0 = SWIGV8_CreateClassTemplate("WarningCoder");
_exports_WarningCoder_class_0->SetCallHandler(_wrap_new_WarningCoder);
_exports_WarningCoder_class_0->Inherit(_exports_WarningCoder_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_WarningCoder_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_WarningCoder_obj = _exports_WarningCoder_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_WarningCoder_obj = _exports_WarningCoder_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: WarningConfigure (_exports_WarningConfigure) */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningConfigure_class_0 = SWIGV8_CreateClassTemplate("WarningConfigure");
_exports_WarningConfigure_class_0->SetCallHandler(_wrap_new_WarningConfigure);
_exports_WarningConfigure_class_0->Inherit(_exports_WarningConfigure_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_WarningConfigure_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_WarningConfigure_obj = _exports_WarningConfigure_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_WarningConfigure_obj = _exports_WarningConfigure_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: WarningCorruptImage (_exports_WarningCorruptImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningCorruptImage_class_0 = SWIGV8_CreateClassTemplate("WarningCorruptImage");
_exports_WarningCorruptImage_class_0->SetCallHandler(_wrap_new_WarningCorruptImage);
_exports_WarningCorruptImage_class_0->Inherit(_exports_WarningCorruptImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_WarningCorruptImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_WarningCorruptImage_obj = _exports_WarningCorruptImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_WarningCorruptImage_obj = _exports_WarningCorruptImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: WarningDelegate (_exports_WarningDelegate) */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningDelegate_class_0 = SWIGV8_CreateClassTemplate("WarningDelegate");
_exports_WarningDelegate_class_0->SetCallHandler(_wrap_new_WarningDelegate);
_exports_WarningDelegate_class_0->Inherit(_exports_WarningDelegate_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_WarningDelegate_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_WarningDelegate_obj = _exports_WarningDelegate_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_WarningDelegate_obj = _exports_WarningDelegate_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: WarningDraw (_exports_WarningDraw) */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningDraw_class_0 = SWIGV8_CreateClassTemplate("WarningDraw");
_exports_WarningDraw_class_0->SetCallHandler(_wrap_new_WarningDraw);
_exports_WarningDraw_class_0->Inherit(_exports_WarningDraw_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_WarningDraw_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_WarningDraw_obj = _exports_WarningDraw_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_WarningDraw_obj = _exports_WarningDraw_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: WarningFileOpen (_exports_WarningFileOpen) */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningFileOpen_class_0 = SWIGV8_CreateClassTemplate("WarningFileOpen");
_exports_WarningFileOpen_class_0->SetCallHandler(_wrap_new_WarningFileOpen);
_exports_WarningFileOpen_class_0->Inherit(_exports_WarningFileOpen_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_WarningFileOpen_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_WarningFileOpen_obj = _exports_WarningFileOpen_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_WarningFileOpen_obj = _exports_WarningFileOpen_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: WarningImage (_exports_WarningImage) */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningImage_class_0 = SWIGV8_CreateClassTemplate("WarningImage");
_exports_WarningImage_class_0->SetCallHandler(_wrap_new_WarningImage);
_exports_WarningImage_class_0->Inherit(_exports_WarningImage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_WarningImage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_WarningImage_obj = _exports_WarningImage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_WarningImage_obj = _exports_WarningImage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: WarningMissingDelegate (_exports_WarningMissingDelegate) */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningMissingDelegate_class_0 = SWIGV8_CreateClassTemplate("WarningMissingDelegate");
_exports_WarningMissingDelegate_class_0->SetCallHandler(_wrap_new_WarningMissingDelegate);
_exports_WarningMissingDelegate_class_0->Inherit(_exports_WarningMissingDelegate_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_WarningMissingDelegate_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_WarningMissingDelegate_obj = _exports_WarningMissingDelegate_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_WarningMissingDelegate_obj = _exports_WarningMissingDelegate_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: WarningModule (_exports_WarningModule) */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningModule_class_0 = SWIGV8_CreateClassTemplate("WarningModule");
_exports_WarningModule_class_0->SetCallHandler(_wrap_new_WarningModule);
_exports_WarningModule_class_0->Inherit(_exports_WarningModule_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_WarningModule_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_WarningModule_obj = _exports_WarningModule_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_WarningModule_obj = _exports_WarningModule_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: WarningMonitor (_exports_WarningMonitor) */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningMonitor_class_0 = SWIGV8_CreateClassTemplate("WarningMonitor");
_exports_WarningMonitor_class_0->SetCallHandler(_wrap_new_WarningMonitor);
_exports_WarningMonitor_class_0->Inherit(_exports_WarningMonitor_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_WarningMonitor_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_WarningMonitor_obj = _exports_WarningMonitor_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_WarningMonitor_obj = _exports_WarningMonitor_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: WarningOption (_exports_WarningOption) */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningOption_class_0 = SWIGV8_CreateClassTemplate("WarningOption");
_exports_WarningOption_class_0->SetCallHandler(_wrap_new_WarningOption);
_exports_WarningOption_class_0->Inherit(_exports_WarningOption_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_WarningOption_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_WarningOption_obj = _exports_WarningOption_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_WarningOption_obj = _exports_WarningOption_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: WarningPolicy (_exports_WarningPolicy) */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningPolicy_class_0 = SWIGV8_CreateClassTemplate("WarningPolicy");
_exports_WarningPolicy_class_0->SetCallHandler(_wrap_new_WarningPolicy);
_exports_WarningPolicy_class_0->Inherit(_exports_WarningPolicy_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_WarningPolicy_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_WarningPolicy_obj = _exports_WarningPolicy_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_WarningPolicy_obj = _exports_WarningPolicy_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: WarningRegistry (_exports_WarningRegistry) */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningRegistry_class_0 = SWIGV8_CreateClassTemplate("WarningRegistry");
_exports_WarningRegistry_class_0->SetCallHandler(_wrap_new_WarningRegistry);
_exports_WarningRegistry_class_0->Inherit(_exports_WarningRegistry_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_WarningRegistry_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_WarningRegistry_obj = _exports_WarningRegistry_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_WarningRegistry_obj = _exports_WarningRegistry_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: WarningResourceLimit (_exports_WarningResourceLimit) */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningResourceLimit_class_0 = SWIGV8_CreateClassTemplate("WarningResourceLimit");
_exports_WarningResourceLimit_class_0->SetCallHandler(_wrap_new_WarningResourceLimit);
_exports_WarningResourceLimit_class_0->Inherit(_exports_WarningResourceLimit_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_WarningResourceLimit_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_WarningResourceLimit_obj = _exports_WarningResourceLimit_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_WarningResourceLimit_obj = _exports_WarningResourceLimit_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: WarningStream (_exports_WarningStream) */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningStream_class_0 = SWIGV8_CreateClassTemplate("WarningStream");
_exports_WarningStream_class_0->SetCallHandler(_wrap_new_WarningStream);
_exports_WarningStream_class_0->Inherit(_exports_WarningStream_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_WarningStream_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_WarningStream_obj = _exports_WarningStream_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_WarningStream_obj = _exports_WarningStream_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: WarningType (_exports_WarningType) */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningType_class_0 = SWIGV8_CreateClassTemplate("WarningType");
_exports_WarningType_class_0->SetCallHandler(_wrap_new_WarningType);
_exports_WarningType_class_0->Inherit(_exports_WarningType_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_WarningType_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_WarningType_obj = _exports_WarningType_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_WarningType_obj = _exports_WarningType_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: WarningUndefined (_exports_WarningUndefined) */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningUndefined_class_0 = SWIGV8_CreateClassTemplate("WarningUndefined");
_exports_WarningUndefined_class_0->SetCallHandler(_wrap_new_WarningUndefined);
_exports_WarningUndefined_class_0->Inherit(_exports_WarningUndefined_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_WarningUndefined_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_WarningUndefined_obj = _exports_WarningUndefined_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_WarningUndefined_obj = _exports_WarningUndefined_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: WarningXServer (_exports_WarningXServer) */
SWIGV8_FUNCTION_TEMPLATE _exports_WarningXServer_class_0 = SWIGV8_CreateClassTemplate("WarningXServer");
_exports_WarningXServer_class_0->SetCallHandler(_wrap_new_WarningXServer);
_exports_WarningXServer_class_0->Inherit(_exports_WarningXServer_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_WarningXServer_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_WarningXServer_obj = _exports_WarningXServer_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_WarningXServer_obj = _exports_WarningXServer_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: Montage (_exports_Montage) */
SWIGV8_FUNCTION_TEMPLATE _exports_Montage_class_0 = SWIGV8_CreateClassTemplate("Montage");
_exports_Montage_class_0->SetCallHandler(_wrap_new_Montage);
_exports_Montage_class_0->Inherit(_exports_Montage_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_Montage_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_Montage_obj = _exports_Montage_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_Montage_obj = _exports_Montage_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: MontageFramed (_exports_MontageFramed) */
SWIGV8_FUNCTION_TEMPLATE _exports_MontageFramed_class_0 = SWIGV8_CreateClassTemplate("MontageFramed");
_exports_MontageFramed_class_0->SetCallHandler(_wrap_new_MontageFramed);
_exports_MontageFramed_class_0->Inherit(_exports_MontageFramed_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_MontageFramed_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_MontageFramed_obj = _exports_MontageFramed_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_MontageFramed_obj = _exports_MontageFramed_class_0->GetFunction(context).ToLocalChecked();
#endif
/* Class: Image (_exports_Image) */
SWIGV8_FUNCTION_TEMPLATE _exports_Image_class_0 = SWIGV8_CreateClassTemplate("Image");
_exports_Image_class_0->SetCallHandler(_wrap_new_Image);
_exports_Image_class_0->Inherit(_exports_Image_class);
#if (SWIG_V8_VERSION < 0x0704)
_exports_Image_class_0->SetHiddenPrototype(true);
v8::Local<v8::Object> _exports_Image_obj = _exports_Image_class_0->GetFunction();
#else
v8::Local<v8::Object> _exports_Image_obj = _exports_Image_class_0->GetFunction(context).ToLocalChecked();
#endif


  /* add static class functions and variables */
  SWIGV8_AddStaticFunction(exports_obj, "CloneString", _wrap_CloneString, context);
SWIGV8_AddStaticFunction(exports_obj, "DisableOpenCL", _wrap_DisableOpenCL, context);
SWIGV8_AddStaticFunction(exports_obj, "EnableOpenCL", _wrap_Magick__wrap_EnableOpenCL, context);
SWIGV8_AddStaticFunction(exports_obj, "InitializeMagick", _wrap_InitializeMagick, context);
SWIGV8_AddStaticFunction(exports_obj, "SetRandomSeed", _wrap_SetRandomSeed, context);
SWIGV8_AddStaticFunction(exports_obj, "TerminateMagick", _wrap_TerminateMagick, context);
SWIGV8_AddStaticFunction(_exports_ResourceLimits_obj, "area", _wrap_ResourceLimits__wrap_ResourceLimits_area, context);
SWIGV8_AddStaticFunction(_exports_ResourceLimits_obj, "disk", _wrap_ResourceLimits__wrap_ResourceLimits_disk, context);
SWIGV8_AddStaticFunction(_exports_ResourceLimits_obj, "file", _wrap_ResourceLimits__wrap_ResourceLimits_file, context);
SWIGV8_AddStaticFunction(_exports_ResourceLimits_obj, "height", _wrap_ResourceLimits__wrap_ResourceLimits_height, context);
SWIGV8_AddStaticFunction(_exports_ResourceLimits_obj, "listLength", _wrap_ResourceLimits__wrap_ResourceLimits_listLength, context);
SWIGV8_AddStaticFunction(_exports_ResourceLimits_obj, "map", _wrap_ResourceLimits__wrap_ResourceLimits_map, context);
SWIGV8_AddStaticFunction(_exports_ResourceLimits_obj, "memory", _wrap_ResourceLimits__wrap_ResourceLimits_memory, context);
SWIGV8_AddStaticFunction(_exports_ResourceLimits_obj, "thread", _wrap_ResourceLimits__wrap_ResourceLimits_thread, context);
SWIGV8_AddStaticFunction(_exports_ResourceLimits_obj, "throttle", _wrap_ResourceLimits__wrap_ResourceLimits_throttle, context);
SWIGV8_AddStaticFunction(_exports_ResourceLimits_obj, "width", _wrap_ResourceLimits__wrap_ResourceLimits_width, context);
SWIGV8_AddStaticVariable(_exports_Blob_obj, "MallocAllocator", _wrap_Magick_Blob_MallocAllocator, JS_veto_set_variable, context);
SWIGV8_AddStaticVariable(_exports_Blob_obj, "NewAllocator", _wrap_Magick_Blob_NewAllocator, JS_veto_set_variable, context);
SWIGV8_AddStaticVariable(_exports_CoderInfo_obj, "AnyMatch", _wrap_Magick_CoderInfo_AnyMatch, JS_veto_set_variable, context);
SWIGV8_AddStaticVariable(_exports_CoderInfo_obj, "TrueMatch", _wrap_Magick_CoderInfo_TrueMatch, JS_veto_set_variable, context);
SWIGV8_AddStaticVariable(_exports_CoderInfo_obj, "FalseMatch", _wrap_Magick_CoderInfo_FalseMatch, JS_veto_set_variable, context);
SWIGV8_AddStaticFunction(_exports_Color_obj, "scaleDoubleToQuantum", _wrap_Color_scaleDoubleToQuantum, context);
SWIGV8_AddStaticFunction(_exports_Color_obj, "scaleQuantumToDouble", _wrap_Color_scaleQuantumToDouble, context);
SWIGV8_AddStaticFunction(exports_obj, "formatExceptionMessage", _wrap_formatExceptionMessage, context);
SWIGV8_AddStaticFunction(exports_obj, "createException", _wrap_createException, context);
SWIGV8_AddStaticFunction(exports_obj, "throwExceptionExplicit", _wrap_Magick__wrap_throwExceptionExplicit, context);
SWIGV8_AddStaticFunction(exports_obj, "throwException", _wrap_Magick__wrap_throwException, context);
SWIGV8_AddStaticFunction(exports_obj, "equal", _wrap_Magick__wrap_equal, context);
SWIGV8_AddStaticFunction(exports_obj, "notEqual", _wrap_Magick__wrap_notEqual, context);
SWIGV8_AddStaticFunction(exports_obj, "gt", _wrap_Magick__wrap_gt, context);
SWIGV8_AddStaticFunction(exports_obj, "lt", _wrap_Magick__wrap_lt, context);
SWIGV8_AddStaticFunction(exports_obj, "gte", _wrap_Magick__wrap_gte, context);
SWIGV8_AddStaticFunction(exports_obj, "lte", _wrap_Magick__wrap_lte, context);
SWIGV8_AddStaticFunction(_exports_Image_obj, "cacheThreshold", _wrap_Image_cacheThreshold, context);


  /* register classes */
  SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("TypeMetric"), _exports_TypeMetric_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("Geometry"), _exports_Geometry_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("Offset"), _exports_Offset_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("Pixels"), _exports_Pixels_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("PixelData"), _exports_PixelData_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ResourceLimits"), _exports_ResourceLimits_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("adaptiveBlurImage"), _exports_adaptiveBlurImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("adaptiveThresholdImage"), _exports_adaptiveThresholdImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("addNoiseImage"), _exports_addNoiseImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("affineTransformImage"), _exports_affineTransformImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("annotateImage"), _exports_annotateImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("blurImage"), _exports_blurImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("borderImage"), _exports_borderImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("channelImage"), _exports_channelImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("charcoalImage"), _exports_charcoalImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("chopImage"), _exports_chopImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("cdlImage"), _exports_cdlImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("colorizeImage"), _exports_colorizeImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("colorMatrixImage"), _exports_colorMatrixImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("colorSpaceImage"), _exports_colorSpaceImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("commentImage"), _exports_commentImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("compositeImage"), _exports_compositeImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("contrastImage"), _exports_contrastImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("cropImage"), _exports_cropImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("cycleColormapImage"), _exports_cycleColormapImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("despeckleImage"), _exports_despeckleImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("distortImage"), _exports_distortImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("drawImage"), _exports_drawImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("edgeImage"), _exports_edgeImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("embossImage"), _exports_embossImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("enhanceImage"), _exports_enhanceImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("equalizeImage"), _exports_equalizeImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("fillColorImage"), _exports_fillColorImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("flipImage"), _exports_flipImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("floodFillColorImage"), _exports_floodFillColorImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("floodFillTextureImage"), _exports_floodFillTextureImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("flopImage"), _exports_flopImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("frameImage"), _exports_frameImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("gammaImage"), _exports_gammaImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("gaussianBlurImage"), _exports_gaussianBlurImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("haldClutImage"), _exports_haldClutImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("implodeImage"), _exports_implodeImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("inverseFourierTransformImage"), _exports_inverseFourierTransformImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("isValidImage"), _exports_isValidImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("labelImage"), _exports_labelImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("levelImage"), _exports_levelImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("levelChannelImage"), _exports_levelChannelImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("magnifyImage"), _exports_magnifyImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("mapImage"), _exports_mapImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("matteFloodfillImage"), _exports_matteFloodfillImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("medianFilterImage"), _exports_medianFilterImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("mergeLayersImage"), _exports_mergeLayersImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("minifyImage"), _exports_minifyImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("modulateImage"), _exports_modulateImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("negateImage"), _exports_negateImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("normalizeImage"), _exports_normalizeImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("oilPaintImage"), _exports_oilPaintImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("opacityImage"), _exports_opacityImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("opaqueImage"), _exports_opaqueImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("quantizeImage"), _exports_quantizeImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("raiseImage"), _exports_raiseImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ReadOptions"), _exports_ReadOptions_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("reduceNoiseImage"), _exports_reduceNoiseImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("resizeImage"), _exports_resizeImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("rollImage"), _exports_rollImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("rotateImage"), _exports_rotateImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("sampleImage"), _exports_sampleImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("scaleImage"), _exports_scaleImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("segmentImage"), _exports_segmentImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("shadeImage"), _exports_shadeImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("shadowImage"), _exports_shadowImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("sharpenImage"), _exports_sharpenImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("shaveImage"), _exports_shaveImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("shearImage"), _exports_shearImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("solarizeImage"), _exports_solarizeImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("spliceImage"), _exports_spliceImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("spreadImage"), _exports_spreadImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("steganoImage"), _exports_steganoImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("stereoImage"), _exports_stereoImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("strokeColorImage"), _exports_strokeColorImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("swirlImage"), _exports_swirlImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("textureImage"), _exports_textureImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("thresholdImage"), _exports_thresholdImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("transformImage"), _exports_transformImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("transparentImage"), _exports_transparentImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("trimImage"), _exports_trimImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("waveImage"), _exports_waveImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("zoomImage"), _exports_zoomImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("antiAliasImage"), _exports_antiAliasImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("adjoinImage"), _exports_adjoinImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("animationDelayImage"), _exports_animationDelayImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("animationIterationsImage"), _exports_animationIterationsImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("backgroundColorImage"), _exports_backgroundColorImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("backgroundTextureImage"), _exports_backgroundTextureImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("borderColorImage"), _exports_borderColorImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("boxColorImage"), _exports_boxColorImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("chromaBluePrimaryImage"), _exports_chromaBluePrimaryImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("chromaGreenPrimaryImage"), _exports_chromaGreenPrimaryImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("chromaRedPrimaryImage"), _exports_chromaRedPrimaryImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("chromaWhitePointImage"), _exports_chromaWhitePointImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("colorFuzzImage"), _exports_colorFuzzImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("colorMapImage"), _exports_colorMapImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("composeImage"), _exports_composeImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("compressTypeImage"), _exports_compressTypeImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("densityImage"), _exports_densityImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("depthImage"), _exports_depthImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("endianImage"), _exports_endianImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("fileNameImage"), _exports_fileNameImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("filterTypeImage"), _exports_filterTypeImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("fontImage"), _exports_fontImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("fontPointsizeImage"), _exports_fontPointsizeImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("gifDisposeMethodImage"), _exports_gifDisposeMethodImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("interlaceTypeImage"), _exports_interlaceTypeImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("lineWidthImage"), _exports_lineWidthImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("magickImage"), _exports_magickImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("matteImage"), _exports_matteImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("matteColorImage"), _exports_matteColorImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("monochromeImage"), _exports_monochromeImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("penColorImage"), _exports_penColorImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("penTextureImage"), _exports_penTextureImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("pixelColorImage"), _exports_pixelColorImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("pageImage"), _exports_pageImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("qualityImage"), _exports_qualityImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("quantizeColorsImage"), _exports_quantizeColorsImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("quantizeColorSpaceImage"), _exports_quantizeColorSpaceImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("quantizeDitherImage"), _exports_quantizeDitherImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("quantizeTreeDepthImage"), _exports_quantizeTreeDepthImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("renderingIntentImage"), _exports_renderingIntentImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("resolutionUnitsImage"), _exports_resolutionUnitsImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("sceneImage"), _exports_sceneImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("sigmoidalContrastImage"), _exports_sigmoidalContrastImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("sizeImage"), _exports_sizeImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("stripImage"), _exports_stripImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("subImageImage"), _exports_subImageImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("subRangeImage"), _exports_subRangeImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("tileNameImage"), _exports_tileNameImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("typeImage"), _exports_typeImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("verboseImage"), _exports_verboseImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("viewImage"), _exports_viewImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("x11DisplayImage"), _exports_x11DisplayImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("Blob"), _exports_Blob_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ChannelMoments"), _exports_ChannelMoments_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ImageMoments"), _exports_ImageMoments_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("CoderInfo"), _exports_CoderInfo_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("Color"), _exports_Color_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ColorGray"), _exports_ColorGray_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ColorHSL"), _exports_ColorHSL_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ColorMono"), _exports_ColorMono_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ColorRGB"), _exports_ColorRGB_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ColorYUV"), _exports_ColorYUV_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("Coordinate"), _exports_Coordinate_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableBase"), _exports_DrawableBase_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("Drawable"), _exports_Drawable_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("VPathBase"), _exports_VPathBase_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("VPath"), _exports_VPath_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableAffine"), _exports_DrawableAffine_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableArc"), _exports_DrawableArc_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableBezier"), _exports_DrawableBezier_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawablePopClipPath"), _exports_DrawablePopClipPath_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawablePushClipPath"), _exports_DrawablePushClipPath_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableClipPath"), _exports_DrawableClipPath_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableCircle"), _exports_DrawableCircle_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableColor"), _exports_DrawableColor_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableCompositeImage"), _exports_DrawableCompositeImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableDensity"), _exports_DrawableDensity_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableEllipse"), _exports_DrawableEllipse_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableFillColor"), _exports_DrawableFillColor_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableFillRule"), _exports_DrawableFillRule_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableFillOpacity"), _exports_DrawableFillOpacity_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableFont"), _exports_DrawableFont_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableGravity"), _exports_DrawableGravity_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableLine"), _exports_DrawableLine_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableMatte"), _exports_DrawableMatte_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawablePath"), _exports_DrawablePath_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawablePoint"), _exports_DrawablePoint_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawablePointSize"), _exports_DrawablePointSize_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawablePolygon"), _exports_DrawablePolygon_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawablePolyline"), _exports_DrawablePolyline_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawablePopGraphicContext"), _exports_DrawablePopGraphicContext_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawablePushGraphicContext"), _exports_DrawablePushGraphicContext_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawablePopPattern"), _exports_DrawablePopPattern_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawablePushPattern"), _exports_DrawablePushPattern_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableRectangle"), _exports_DrawableRectangle_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableRotation"), _exports_DrawableRotation_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableRoundRectangle"), _exports_DrawableRoundRectangle_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableScaling"), _exports_DrawableScaling_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableSkewX"), _exports_DrawableSkewX_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableSkewY"), _exports_DrawableSkewY_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableDashArray"), _exports_DrawableDashArray_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableDashOffset"), _exports_DrawableDashOffset_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableStrokeLineCap"), _exports_DrawableStrokeLineCap_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableStrokeLineJoin"), _exports_DrawableStrokeLineJoin_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableMiterLimit"), _exports_DrawableMiterLimit_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableStrokeAntialias"), _exports_DrawableStrokeAntialias_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableStrokeColor"), _exports_DrawableStrokeColor_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableStrokeOpacity"), _exports_DrawableStrokeOpacity_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableStrokeWidth"), _exports_DrawableStrokeWidth_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableText"), _exports_DrawableText_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableTextAntialias"), _exports_DrawableTextAntialias_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableTextDecoration"), _exports_DrawableTextDecoration_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableTextDirection"), _exports_DrawableTextDirection_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableTextInterlineSpacing"), _exports_DrawableTextInterlineSpacing_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableTextInterwordSpacing"), _exports_DrawableTextInterwordSpacing_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableTextKerning"), _exports_DrawableTextKerning_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableTextUnderColor"), _exports_DrawableTextUnderColor_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableTranslation"), _exports_DrawableTranslation_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("DrawableViewbox"), _exports_DrawableViewbox_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("PathArcArgs"), _exports_PathArcArgs_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("PathArcAbs"), _exports_PathArcAbs_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("PathArcRel"), _exports_PathArcRel_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("PathClosePath"), _exports_PathClosePath_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("PathCurvetoArgs"), _exports_PathCurvetoArgs_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("PathCurvetoAbs"), _exports_PathCurvetoAbs_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("PathCurvetoRel"), _exports_PathCurvetoRel_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("PathSmoothCurvetoAbs"), _exports_PathSmoothCurvetoAbs_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("PathSmoothCurvetoRel"), _exports_PathSmoothCurvetoRel_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("PathQuadraticCurvetoArgs"), _exports_PathQuadraticCurvetoArgs_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("PathQuadraticCurvetoAbs"), _exports_PathQuadraticCurvetoAbs_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("PathQuadraticCurvetoRel"), _exports_PathQuadraticCurvetoRel_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("PathSmoothQuadraticCurvetoAbs"), _exports_PathSmoothQuadraticCurvetoAbs_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("PathSmoothQuadraticCurvetoRel"), _exports_PathSmoothQuadraticCurvetoRel_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("PathLinetoAbs"), _exports_PathLinetoAbs_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("PathLinetoRel"), _exports_PathLinetoRel_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("PathLinetoHorizontalAbs"), _exports_PathLinetoHorizontalAbs_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("PathLinetoHorizontalRel"), _exports_PathLinetoHorizontalRel_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("PathLinetoVerticalAbs"), _exports_PathLinetoVerticalAbs_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("PathLinetoVerticalRel"), _exports_PathLinetoVerticalRel_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("PathMovetoAbs"), _exports_PathMovetoAbs_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("PathMovetoRel"), _exports_PathMovetoRel_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("Exception"), _exports_Exception_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("Error"), _exports_Error_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ErrorBlob"), _exports_ErrorBlob_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ErrorCache"), _exports_ErrorCache_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ErrorCoder"), _exports_ErrorCoder_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ErrorConfigure"), _exports_ErrorConfigure_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ErrorCorruptImage"), _exports_ErrorCorruptImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ErrorDelegate"), _exports_ErrorDelegate_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ErrorDraw"), _exports_ErrorDraw_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ErrorFileOpen"), _exports_ErrorFileOpen_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ErrorImage"), _exports_ErrorImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ErrorMissingDelegate"), _exports_ErrorMissingDelegate_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ErrorModule"), _exports_ErrorModule_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ErrorMonitor"), _exports_ErrorMonitor_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ErrorOption"), _exports_ErrorOption_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ErrorPolicy"), _exports_ErrorPolicy_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ErrorRegistry"), _exports_ErrorRegistry_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ErrorResourceLimit"), _exports_ErrorResourceLimit_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ErrorStream"), _exports_ErrorStream_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ErrorType"), _exports_ErrorType_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ErrorUndefined"), _exports_ErrorUndefined_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("ErrorXServer"), _exports_ErrorXServer_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("Warning"), _exports_Warning_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("WarningBlob"), _exports_WarningBlob_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("WarningCache"), _exports_WarningCache_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("WarningCoder"), _exports_WarningCoder_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("WarningConfigure"), _exports_WarningConfigure_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("WarningCorruptImage"), _exports_WarningCorruptImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("WarningDelegate"), _exports_WarningDelegate_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("WarningDraw"), _exports_WarningDraw_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("WarningFileOpen"), _exports_WarningFileOpen_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("WarningImage"), _exports_WarningImage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("WarningMissingDelegate"), _exports_WarningMissingDelegate_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("WarningModule"), _exports_WarningModule_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("WarningMonitor"), _exports_WarningMonitor_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("WarningOption"), _exports_WarningOption_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("WarningPolicy"), _exports_WarningPolicy_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("WarningRegistry"), _exports_WarningRegistry_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("WarningResourceLimit"), _exports_WarningResourceLimit_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("WarningStream"), _exports_WarningStream_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("WarningType"), _exports_WarningType_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("WarningUndefined"), _exports_WarningUndefined_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("WarningXServer"), _exports_WarningXServer_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("Montage"), _exports_Montage_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("MontageFramed"), _exports_MontageFramed_obj));
SWIGV8_MAYBE_CHECK(exports_obj->Set(context, SWIGV8_SYMBOL_NEW("Image"), _exports_Image_obj));


  /* create and register namespace objects */
  
}

#if defined(BUILDING_NODE_EXTENSION)
#if (NODE_MODULE_VERSION < 64)
NODE_MODULE(magickwand, magickwand_initialize)
#else
NODE_MODULE_CONTEXT_AWARE(magickwand, magickwand_initialize)
#endif
#endif
