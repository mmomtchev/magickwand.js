/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.2.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

declare const _SWIG_enum_tag: unique symbol;

export namespace MagickCore {

export const UndefinedClass: ClassType;

export const DirectClass: ClassType;

export const PseudoClass: ClassType;

export type ClassType = number & { readonly [_SWIG_enum_tag]: 'ClassType'; };

export const MagickFalse: MagickBooleanType;

export const MagickTrue: MagickBooleanType;

export type MagickBooleanType = number & { readonly [_SWIG_enum_tag]: 'MagickBooleanType'; };

export const UndefinedGravity: GravityType;

export const ForgetGravity: GravityType;

export const NorthWestGravity: GravityType;

export const NorthGravity: GravityType;

export const NorthEastGravity: GravityType;

export const WestGravity: GravityType;

export const CenterGravity: GravityType;

export const EastGravity: GravityType;

export const SouthWestGravity: GravityType;

export const SouthGravity: GravityType;

export const SouthEastGravity: GravityType;

export type GravityType = number & { readonly [_SWIG_enum_tag]: 'GravityType'; };

export const UndefinedColorspace: ColorspaceType;

export const CMYColorspace: ColorspaceType;

export const CMYKColorspace: ColorspaceType;

export const GRAYColorspace: ColorspaceType;

export const HCLColorspace: ColorspaceType;

export const HCLpColorspace: ColorspaceType;

export const HSBColorspace: ColorspaceType;

export const HSIColorspace: ColorspaceType;

export const HSLColorspace: ColorspaceType;

export const HSVColorspace: ColorspaceType;

export const HWBColorspace: ColorspaceType;

export const LabColorspace: ColorspaceType;

export const LCHColorspace: ColorspaceType;

export const LCHabColorspace: ColorspaceType;

export const LCHuvColorspace: ColorspaceType;

export const LogColorspace: ColorspaceType;

export const LMSColorspace: ColorspaceType;

export const LuvColorspace: ColorspaceType;

export const OHTAColorspace: ColorspaceType;

export const Rec601YCbCrColorspace: ColorspaceType;

export const Rec709YCbCrColorspace: ColorspaceType;

export const RGBColorspace: ColorspaceType;

export const scRGBColorspace: ColorspaceType;

export const sRGBColorspace: ColorspaceType;

export const TransparentColorspace: ColorspaceType;

export const xyYColorspace: ColorspaceType;

export const XYZColorspace: ColorspaceType;

export const YCbCrColorspace: ColorspaceType;

export const YCCColorspace: ColorspaceType;

export const YDbDrColorspace: ColorspaceType;

export const YIQColorspace: ColorspaceType;

export const YPbPrColorspace: ColorspaceType;

export const YUVColorspace: ColorspaceType;

export const LinearGRAYColorspace: ColorspaceType;

export const JzazbzColorspace: ColorspaceType;

export const DisplayP3Colorspace: ColorspaceType;

export const Adobe98Colorspace: ColorspaceType;

export const ProPhotoColorspace: ColorspaceType;

export const OklabColorspace: ColorspaceType;

export const OklchColorspace: ColorspaceType;

export type ColorspaceType = number & { readonly [_SWIG_enum_tag]: 'ColorspaceType'; };

export const UndefinedChannel: ChannelType;

export const RedChannel: ChannelType;

export const GrayChannel: ChannelType;

export const CyanChannel: ChannelType;

export const LChannel: ChannelType;

export const GreenChannel: ChannelType;

export const MagentaChannel: ChannelType;

export const aChannel: ChannelType;

export const BlueChannel: ChannelType;

export const bChannel: ChannelType;

export const YellowChannel: ChannelType;

export const BlackChannel: ChannelType;

export const AlphaChannel: ChannelType;

export const OpacityChannel: ChannelType;

export const IndexChannel: ChannelType;

export const ReadMaskChannel: ChannelType;

export const WriteMaskChannel: ChannelType;

export const MetaChannel: ChannelType;

export const CompositeMaskChannel: ChannelType;

export const CompositeChannels: ChannelType;

export const AllChannels: ChannelType;

export const TrueAlphaChannel: ChannelType;

export const RGBChannels: ChannelType;

export const GrayChannels: ChannelType;

export const SyncChannels: ChannelType;

export const DefaultChannels: ChannelType;

export type ChannelType = number & { readonly [_SWIG_enum_tag]: 'ChannelType'; };

export const UndefinedPixel: StorageType;

export const CharPixel: StorageType;

export const DoublePixel: StorageType;

export const FloatPixel: StorageType;

export const LongPixel: StorageType;

export const LongLongPixel: StorageType;

export const QuantumPixel: StorageType;

export const ShortPixel: StorageType;

export type StorageType = number & { readonly [_SWIG_enum_tag]: 'StorageType'; };

export const UndefinedException: ExceptionType;

export const WarningException: ExceptionType;

export const ResourceLimitWarning: ExceptionType;

export const TypeWarning: ExceptionType;

export const OptionWarning: ExceptionType;

export const DelegateWarning: ExceptionType;

export const MissingDelegateWarning: ExceptionType;

export const CorruptImageWarning: ExceptionType;

export const FileOpenWarning: ExceptionType;

export const BlobWarning: ExceptionType;

export const StreamWarning: ExceptionType;

export const CacheWarning: ExceptionType;

export const CoderWarning: ExceptionType;

export const FilterWarning: ExceptionType;

export const ModuleWarning: ExceptionType;

export const DrawWarning: ExceptionType;

export const ImageWarning: ExceptionType;

export const WandWarning: ExceptionType;

export const RandomWarning: ExceptionType;

export const XServerWarning: ExceptionType;

export const MonitorWarning: ExceptionType;

export const RegistryWarning: ExceptionType;

export const ConfigureWarning: ExceptionType;

export const PolicyWarning: ExceptionType;

export const ErrorException: ExceptionType;

export const ResourceLimitError: ExceptionType;

export const TypeError: ExceptionType;

export const OptionError: ExceptionType;

export const DelegateError: ExceptionType;

export const MissingDelegateError: ExceptionType;

export const CorruptImageError: ExceptionType;

export const FileOpenError: ExceptionType;

export const BlobError: ExceptionType;

export const StreamError: ExceptionType;

export const CacheError: ExceptionType;

export const CoderError: ExceptionType;

export const FilterError: ExceptionType;

export const ModuleError: ExceptionType;

export const DrawError: ExceptionType;

export const ImageError: ExceptionType;

export const WandError: ExceptionType;

export const RandomError: ExceptionType;

export const XServerError: ExceptionType;

export const MonitorError: ExceptionType;

export const RegistryError: ExceptionType;

export const ConfigureError: ExceptionType;

export const PolicyError: ExceptionType;

export const FatalErrorException: ExceptionType;

export const ResourceLimitFatalError: ExceptionType;

export const TypeFatalError: ExceptionType;

export const OptionFatalError: ExceptionType;

export const DelegateFatalError: ExceptionType;

export const MissingDelegateFatalError: ExceptionType;

export const CorruptImageFatalError: ExceptionType;

export const FileOpenFatalError: ExceptionType;

export const BlobFatalError: ExceptionType;

export const StreamFatalError: ExceptionType;

export const CacheFatalError: ExceptionType;

export const CoderFatalError: ExceptionType;

export const FilterFatalError: ExceptionType;

export const ModuleFatalError: ExceptionType;

export const DrawFatalError: ExceptionType;

export const ImageFatalError: ExceptionType;

export const WandFatalError: ExceptionType;

export const RandomFatalError: ExceptionType;

export const XServerFatalError: ExceptionType;

export const MonitorFatalError: ExceptionType;

export const RegistryFatalError: ExceptionType;

export const ConfigureFatalError: ExceptionType;

export const PolicyFatalError: ExceptionType;

export type ExceptionType = number & { readonly [_SWIG_enum_tag]: 'ExceptionType'; };

export const UndefinedCompliance: ComplianceType;

export const NoCompliance: ComplianceType;

export const CSSCompliance: ComplianceType;

export const SVGCompliance: ComplianceType;

export const X11Compliance: ComplianceType;

export const XPMCompliance: ComplianceType;

export const MVGCompliance: ComplianceType;

export const AllCompliance: ComplianceType;

export type ComplianceType = number & { readonly [_SWIG_enum_tag]: 'ComplianceType'; };

export const UndefinedIlluminant: IlluminantType;

export const AIlluminant: IlluminantType;

export const BIlluminant: IlluminantType;

export const CIlluminant: IlluminantType;

export const D50Illuminant: IlluminantType;

export const D55Illuminant: IlluminantType;

export const D65Illuminant: IlluminantType;

export const D75Illuminant: IlluminantType;

export const EIlluminant: IlluminantType;

export const F2Illuminant: IlluminantType;

export const F7Illuminant: IlluminantType;

export const F11Illuminant: IlluminantType;

export type IlluminantType = number & { readonly [_SWIG_enum_tag]: 'IlluminantType'; };

export const UndefinedCompositeOp: CompositeOperator;

export const AlphaCompositeOp: CompositeOperator;

export const AtopCompositeOp: CompositeOperator;

export const BlendCompositeOp: CompositeOperator;

export const BlurCompositeOp: CompositeOperator;

export const BumpmapCompositeOp: CompositeOperator;

export const ChangeMaskCompositeOp: CompositeOperator;

export const ClearCompositeOp: CompositeOperator;

export const ColorBurnCompositeOp: CompositeOperator;

export const ColorDodgeCompositeOp: CompositeOperator;

export const ColorizeCompositeOp: CompositeOperator;

export const CopyBlackCompositeOp: CompositeOperator;

export const CopyBlueCompositeOp: CompositeOperator;

export const CopyCompositeOp: CompositeOperator;

export const CopyCyanCompositeOp: CompositeOperator;

export const CopyGreenCompositeOp: CompositeOperator;

export const CopyMagentaCompositeOp: CompositeOperator;

export const CopyAlphaCompositeOp: CompositeOperator;

export const CopyRedCompositeOp: CompositeOperator;

export const CopyYellowCompositeOp: CompositeOperator;

export const DarkenCompositeOp: CompositeOperator;

export const DarkenIntensityCompositeOp: CompositeOperator;

export const DifferenceCompositeOp: CompositeOperator;

export const DisplaceCompositeOp: CompositeOperator;

export const DissolveCompositeOp: CompositeOperator;

export const DistortCompositeOp: CompositeOperator;

export const DivideDstCompositeOp: CompositeOperator;

export const DivideSrcCompositeOp: CompositeOperator;

export const DstAtopCompositeOp: CompositeOperator;

export const DstCompositeOp: CompositeOperator;

export const DstInCompositeOp: CompositeOperator;

export const DstOutCompositeOp: CompositeOperator;

export const DstOverCompositeOp: CompositeOperator;

export const ExclusionCompositeOp: CompositeOperator;

export const HardLightCompositeOp: CompositeOperator;

export const HardMixCompositeOp: CompositeOperator;

export const HueCompositeOp: CompositeOperator;

export const InCompositeOp: CompositeOperator;

export const IntensityCompositeOp: CompositeOperator;

export const LightenCompositeOp: CompositeOperator;

export const LightenIntensityCompositeOp: CompositeOperator;

export const LinearBurnCompositeOp: CompositeOperator;

export const LinearDodgeCompositeOp: CompositeOperator;

export const LinearLightCompositeOp: CompositeOperator;

export const LuminizeCompositeOp: CompositeOperator;

export const MathematicsCompositeOp: CompositeOperator;

export const MinusDstCompositeOp: CompositeOperator;

export const MinusSrcCompositeOp: CompositeOperator;

export const ModulateCompositeOp: CompositeOperator;

export const ModulusAddCompositeOp: CompositeOperator;

export const ModulusSubtractCompositeOp: CompositeOperator;

export const MultiplyCompositeOp: CompositeOperator;

export const NoCompositeOp: CompositeOperator;

export const OutCompositeOp: CompositeOperator;

export const OverCompositeOp: CompositeOperator;

export const OverlayCompositeOp: CompositeOperator;

export const PegtopLightCompositeOp: CompositeOperator;

export const PinLightCompositeOp: CompositeOperator;

export const PlusCompositeOp: CompositeOperator;

export const ReplaceCompositeOp: CompositeOperator;

export const SaturateCompositeOp: CompositeOperator;

export const ScreenCompositeOp: CompositeOperator;

export const SoftLightCompositeOp: CompositeOperator;

export const SrcAtopCompositeOp: CompositeOperator;

export const SrcCompositeOp: CompositeOperator;

export const SrcInCompositeOp: CompositeOperator;

export const SrcOutCompositeOp: CompositeOperator;

export const SrcOverCompositeOp: CompositeOperator;

export const ThresholdCompositeOp: CompositeOperator;

export const VividLightCompositeOp: CompositeOperator;

export const XorCompositeOp: CompositeOperator;

export const StereoCompositeOp: CompositeOperator;

export const FreezeCompositeOp: CompositeOperator;

export const InterpolateCompositeOp: CompositeOperator;

export const NegateCompositeOp: CompositeOperator;

export const ReflectCompositeOp: CompositeOperator;

export const SoftBurnCompositeOp: CompositeOperator;

export const SoftDodgeCompositeOp: CompositeOperator;

export const StampCompositeOp: CompositeOperator;

export const RMSECompositeOp: CompositeOperator;

export const SaliencyBlendCompositeOp: CompositeOperator;

export const SeamlessBlendCompositeOp: CompositeOperator;

export type CompositeOperator = number & { readonly [_SWIG_enum_tag]: 'CompositeOperator'; };

export const UndefinedCompression: CompressionType;

export const B44ACompression: CompressionType;

export const B44Compression: CompressionType;

export const BZipCompression: CompressionType;

export const DXT1Compression: CompressionType;

export const DXT3Compression: CompressionType;

export const DXT5Compression: CompressionType;

export const FaxCompression: CompressionType;

export const Group4Compression: CompressionType;

export const JBIG1Compression: CompressionType;

export const JBIG2Compression: CompressionType;

export const JPEG2000Compression: CompressionType;

export const JPEGCompression: CompressionType;

export const LosslessJPEGCompression: CompressionType;

export const LZMACompression: CompressionType;

export const LZWCompression: CompressionType;

export const NoCompression: CompressionType;

export const PizCompression: CompressionType;

export const Pxr24Compression: CompressionType;

export const RLECompression: CompressionType;

export const ZipCompression: CompressionType;

export const ZipSCompression: CompressionType;

export const ZstdCompression: CompressionType;

export const WebPCompression: CompressionType;

export const DWAACompression: CompressionType;

export const DWABCompression: CompressionType;

export const BC7Compression: CompressionType;

export const BC5Compression: CompressionType;

export const LERCCompression: CompressionType;

export type CompressionType = number & { readonly [_SWIG_enum_tag]: 'CompressionType'; };

export const UndefinedKernel: KernelInfoType;

export const UnityKernel: KernelInfoType;

export const GaussianKernel: KernelInfoType;

export const DoGKernel: KernelInfoType;

export const LoGKernel: KernelInfoType;

export const BlurKernel: KernelInfoType;

export const CometKernel: KernelInfoType;

export const BinomialKernel: KernelInfoType;

export const LaplacianKernel: KernelInfoType;

export const SobelKernel: KernelInfoType;

export const FreiChenKernel: KernelInfoType;

export const RobertsKernel: KernelInfoType;

export const PrewittKernel: KernelInfoType;

export const CompassKernel: KernelInfoType;

export const KirschKernel: KernelInfoType;

export const DiamondKernel: KernelInfoType;

export const SquareKernel: KernelInfoType;

export const RectangleKernel: KernelInfoType;

export const OctagonKernel: KernelInfoType;

export const DiskKernel: KernelInfoType;

export const PlusKernel: KernelInfoType;

export const CrossKernel: KernelInfoType;

export const RingKernel: KernelInfoType;

export const PeaksKernel: KernelInfoType;

export const EdgesKernel: KernelInfoType;

export const CornersKernel: KernelInfoType;

export const DiagonalsKernel: KernelInfoType;

export const LineEndsKernel: KernelInfoType;

export const LineJunctionsKernel: KernelInfoType;

export const RidgesKernel: KernelInfoType;

export const ConvexHullKernel: KernelInfoType;

export const ThinSEKernel: KernelInfoType;

export const SkeletonKernel: KernelInfoType;

export const ChebyshevKernel: KernelInfoType;

export const ManhattanKernel: KernelInfoType;

export const OctagonalKernel: KernelInfoType;

export const EuclideanKernel: KernelInfoType;

export const UserDefinedKernel: KernelInfoType;

export type KernelInfoType = number & { readonly [_SWIG_enum_tag]: 'KernelInfoType'; };

export const UndefinedPreview: PreviewType;

export const RotatePreview: PreviewType;

export const ShearPreview: PreviewType;

export const RollPreview: PreviewType;

export const HuePreview: PreviewType;

export const SaturationPreview: PreviewType;

export const BrightnessPreview: PreviewType;

export const GammaPreview: PreviewType;

export const SpiffPreview: PreviewType;

export const DullPreview: PreviewType;

export const GrayscalePreview: PreviewType;

export const QuantizePreview: PreviewType;

export const DespecklePreview: PreviewType;

export const ReduceNoisePreview: PreviewType;

export const AddNoisePreview: PreviewType;

export const SharpenPreview: PreviewType;

export const BlurPreview: PreviewType;

export const ThresholdPreview: PreviewType;

export const EdgeDetectPreview: PreviewType;

export const SpreadPreview: PreviewType;

export const SolarizePreview: PreviewType;

export const ShadePreview: PreviewType;

export const RaisePreview: PreviewType;

export const SegmentPreview: PreviewType;

export const SwirlPreview: PreviewType;

export const ImplodePreview: PreviewType;

export const WavePreview: PreviewType;

export const OilPaintPreview: PreviewType;

export const CharcoalDrawingPreview: PreviewType;

export const JPEGPreview: PreviewType;

export type PreviewType = number & { readonly [_SWIG_enum_tag]: 'PreviewType'; };

export const UnrecognizedDispose: DisposeType;

export const UndefinedDispose: DisposeType;

export const NoneDispose: DisposeType;

export const BackgroundDispose: DisposeType;

export const PreviousDispose: DisposeType;

export type DisposeType = number & { readonly [_SWIG_enum_tag]: 'DisposeType'; };

export const UndefinedEndian: EndianType;

export const LSBEndian: EndianType;

export const MSBEndian: EndianType;

export type EndianType = number & { readonly [_SWIG_enum_tag]: 'EndianType'; };

export const UndefinedQuantumAlpha: QuantumAlphaType;

export const AssociatedQuantumAlpha: QuantumAlphaType;

export const DisassociatedQuantumAlpha: QuantumAlphaType;

export type QuantumAlphaType = number & { readonly [_SWIG_enum_tag]: 'QuantumAlphaType'; };

export const UndefinedQuantumFormat: QuantumFormatType;

export const FloatingPointQuantumFormat: QuantumFormatType;

export const SignedQuantumFormat: QuantumFormatType;

export const UnsignedQuantumFormat: QuantumFormatType;

export type QuantumFormatType = number & { readonly [_SWIG_enum_tag]: 'QuantumFormatType'; };

export const UndefinedQuantum: QuantumType;

export const AlphaQuantum: QuantumType;

export const BGRAQuantum: QuantumType;

export const BGROQuantum: QuantumType;

export const BGRQuantum: QuantumType;

export const BlackQuantum: QuantumType;

export const BlueQuantum: QuantumType;

export const CbYCrAQuantum: QuantumType;

export const CbYCrQuantum: QuantumType;

export const CbYCrYQuantum: QuantumType;

export const CMYKAQuantum: QuantumType;

export const CMYKOQuantum: QuantumType;

export const CMYKQuantum: QuantumType;

export const CyanQuantum: QuantumType;

export const GrayAlphaQuantum: QuantumType;

export const GrayQuantum: QuantumType;

export const GreenQuantum: QuantumType;

export const IndexAlphaQuantum: QuantumType;

export const IndexQuantum: QuantumType;

export const MagentaQuantum: QuantumType;

export const OpacityQuantum: QuantumType;

export const RedQuantum: QuantumType;

export const RGBAQuantum: QuantumType;

export const RGBOQuantum: QuantumType;

export const RGBPadQuantum: QuantumType;

export const RGBQuantum: QuantumType;

export const YellowQuantum: QuantumType;

export const MultispectralQuantum: QuantumType;

export type QuantumType = number & { readonly [_SWIG_enum_tag]: 'QuantumType'; };

export const UndefinedFilter: FilterType;

export const PointFilter: FilterType;

export const BoxFilter: FilterType;

export const TriangleFilter: FilterType;

export const HermiteFilter: FilterType;

export const HannFilter: FilterType;

export const HammingFilter: FilterType;

export const BlackmanFilter: FilterType;

export const GaussianFilter: FilterType;

export const QuadraticFilter: FilterType;

export const CubicFilter: FilterType;

export const CatromFilter: FilterType;

export const MitchellFilter: FilterType;

export const JincFilter: FilterType;

export const SincFilter: FilterType;

export const SincFastFilter: FilterType;

export const KaiserFilter: FilterType;

export const WelchFilter: FilterType;

export const ParzenFilter: FilterType;

export const BohmanFilter: FilterType;

export const BartlettFilter: FilterType;

export const LagrangeFilter: FilterType;

export const LanczosFilter: FilterType;

export const LanczosSharpFilter: FilterType;

export const Lanczos2Filter: FilterType;

export const Lanczos2SharpFilter: FilterType;

export const RobidouxFilter: FilterType;

export const RobidouxSharpFilter: FilterType;

export const CosineFilter: FilterType;

export const SplineFilter: FilterType;

export const LanczosRadiusFilter: FilterType;

export const CubicSplineFilter: FilterType;

export const SentinelFilter: FilterType;

export type FilterType = number & { readonly [_SWIG_enum_tag]: 'FilterType'; };

export const UndefinedType: ImageType;

export const BilevelType: ImageType;

export const GrayscaleType: ImageType;

export const GrayscaleAlphaType: ImageType;

export const PaletteType: ImageType;

export const PaletteAlphaType: ImageType;

export const TrueColorType: ImageType;

export const TrueColorAlphaType: ImageType;

export const ColorSeparationType: ImageType;

export const ColorSeparationAlphaType: ImageType;

export const OptimizeType: ImageType;

export const PaletteBilevelAlphaType: ImageType;

export type ImageType = number & { readonly [_SWIG_enum_tag]: 'ImageType'; };

export const UndefinedInterlace: InterlaceType;

export const NoInterlace: InterlaceType;

export const LineInterlace: InterlaceType;

export const PlaneInterlace: InterlaceType;

export const PartitionInterlace: InterlaceType;

export const GIFInterlace: InterlaceType;

export const JPEGInterlace: InterlaceType;

export const PNGInterlace: InterlaceType;

export type InterlaceType = number & { readonly [_SWIG_enum_tag]: 'InterlaceType'; };

export const UndefinedOrientation: OrientationType;

export const TopLeftOrientation: OrientationType;

export const TopRightOrientation: OrientationType;

export const BottomRightOrientation: OrientationType;

export const BottomLeftOrientation: OrientationType;

export const LeftTopOrientation: OrientationType;

export const RightTopOrientation: OrientationType;

export const RightBottomOrientation: OrientationType;

export const LeftBottomOrientation: OrientationType;

export type OrientationType = number & { readonly [_SWIG_enum_tag]: 'OrientationType'; };

export const UndefinedResolution: ResolutionType;

export const PixelsPerInchResolution: ResolutionType;

export const PixelsPerCentimeterResolution: ResolutionType;

export type ResolutionType = number & { readonly [_SWIG_enum_tag]: 'ResolutionType'; };

export const UndefinedTransmitType: TransmitType;

export const FileTransmitType: TransmitType;

export const BlobTransmitType: TransmitType;

export const StreamTransmitType: TransmitType;

export const ImageTransmitType: TransmitType;

export type TransmitType = number & { readonly [_SWIG_enum_tag]: 'TransmitType'; };

export const UndefinedStretch: StretchType;

export const NormalStretch: StretchType;

export const UltraCondensedStretch: StretchType;

export const ExtraCondensedStretch: StretchType;

export const CondensedStretch: StretchType;

export const SemiCondensedStretch: StretchType;

export const SemiExpandedStretch: StretchType;

export const ExpandedStretch: StretchType;

export const ExtraExpandedStretch: StretchType;

export const UltraExpandedStretch: StretchType;

export const AnyStretch: StretchType;

export type StretchType = number & { readonly [_SWIG_enum_tag]: 'StretchType'; };

export const UndefinedStyle: StyleType;

export const NormalStyle: StyleType;

export const ItalicStyle: StyleType;

export const ObliqueStyle: StyleType;

export const AnyStyle: StyleType;

export const BoldStyle: StyleType;

export type StyleType = number & { readonly [_SWIG_enum_tag]: 'StyleType'; };

export const UndefinedAlign: AlignType;

export const LeftAlign: AlignType;

export const CenterAlign: AlignType;

export const RightAlign: AlignType;

export type AlignType = number & { readonly [_SWIG_enum_tag]: 'AlignType'; };

export const UndefinedDecoration: DecorationType;

export const NoDecoration: DecorationType;

export const UnderlineDecoration: DecorationType;

export const OverlineDecoration: DecorationType;

export const LineThroughDecoration: DecorationType;

export type DecorationType = number & { readonly [_SWIG_enum_tag]: 'DecorationType'; };

export const UndefinedDirection: DirectionType;

export const RightToLeftDirection: DirectionType;

export const LeftToRightDirection: DirectionType;

export const TopToBottomDirection: DirectionType;

export type DirectionType = number & { readonly [_SWIG_enum_tag]: 'DirectionType'; };

export const UndefinedGradient: GradientType;

export const LinearGradient: GradientType;

export const RadialGradient: GradientType;

export type GradientType = number & { readonly [_SWIG_enum_tag]: 'GradientType'; };

export const UndefinedPrimitive: PrimitiveType;

export const AlphaPrimitive: PrimitiveType;

export const ArcPrimitive: PrimitiveType;

export const BezierPrimitive: PrimitiveType;

export const CirclePrimitive: PrimitiveType;

export const ColorPrimitive: PrimitiveType;

export const EllipsePrimitive: PrimitiveType;

export const ImagePrimitive: PrimitiveType;

export const LinePrimitive: PrimitiveType;

export const PathPrimitive: PrimitiveType;

export const PointPrimitive: PrimitiveType;

export const PolygonPrimitive: PrimitiveType;

export const PolylinePrimitive: PrimitiveType;

export const RectanglePrimitive: PrimitiveType;

export const RoundRectanglePrimitive: PrimitiveType;

export const TextPrimitive: PrimitiveType;

export type PrimitiveType = number & { readonly [_SWIG_enum_tag]: 'PrimitiveType'; };

export const UndefinedReference: ReferenceType;

export const GradientReference: ReferenceType;

export type ReferenceType = number & { readonly [_SWIG_enum_tag]: 'ReferenceType'; };

export const UndefinedWordBreakType: WordBreakType;

export const NormalWordBreakType: WordBreakType;

export const BreakWordBreakType: WordBreakType;

export type WordBreakType = number & { readonly [_SWIG_enum_tag]: 'WordBreakType'; };

export const UndefinedCache: CacheType;

export const DiskCache: CacheType;

export const DistributedCache: CacheType;

export const MapCache: CacheType;

export const MemoryCache: CacheType;

export const PingCache: CacheType;

export type CacheType = number & { readonly [_SWIG_enum_tag]: 'CacheType'; };

export const UndefinedErrorMetric: MetricType;

export const AbsoluteErrorMetric: MetricType;

export const FuzzErrorMetric: MetricType;

export const MeanAbsoluteErrorMetric: MetricType;

export const MeanErrorPerPixelErrorMetric: MetricType;

export const MeanSquaredErrorMetric: MetricType;

export const NormalizedCrossCorrelationErrorMetric: MetricType;

export const PeakAbsoluteErrorMetric: MetricType;

export const PeakSignalToNoiseRatioErrorMetric: MetricType;

export const PerceptualHashErrorMetric: MetricType;

export const RootMeanSquaredErrorMetric: MetricType;

export const StructuralSimilarityErrorMetric: MetricType;

export const StructuralDissimilarityErrorMetric: MetricType;

export type MetricType = number & { readonly [_SWIG_enum_tag]: 'MetricType'; };

export const UndefinedFormatType: MagickFormatType;

export const ImplicitFormatType: MagickFormatType;

export const ExplicitFormatType: MagickFormatType;

export type MagickFormatType = number & { readonly [_SWIG_enum_tag]: 'MagickFormatType'; };

export const UndefinedComplexOperator: ComplexOperator;

export const AddComplexOperator: ComplexOperator;

export const ConjugateComplexOperator: ComplexOperator;

export const DivideComplexOperator: ComplexOperator;

export const MagnitudePhaseComplexOperator: ComplexOperator;

export const MultiplyComplexOperator: ComplexOperator;

export const RealImaginaryComplexOperator: ComplexOperator;

export const SubtractComplexOperator: ComplexOperator;

export type ComplexOperator = number & { readonly [_SWIG_enum_tag]: 'ComplexOperator'; };

export const UndefinedEvents: LogEventType;

export const NoEvents: LogEventType;

export const AccelerateEvent: LogEventType;

export const AnnotateEvent: LogEventType;

export const BlobEvent: LogEventType;

export const CacheEvent: LogEventType;

export const CoderEvent: LogEventType;

export const ConfigureEvent: LogEventType;

export const DeprecateEvent: LogEventType;

export const DrawEvent: LogEventType;

export const ExceptionEvent: LogEventType;

export const ImageEvent: LogEventType;

export const LocaleEvent: LogEventType;

export const ModuleEvent: LogEventType;

export const PixelEvent: LogEventType;

export const PolicyEvent: LogEventType;

export const ResourceEvent: LogEventType;

export const TraceEvent: LogEventType;

export const TransformEvent: LogEventType;

export const UserEvent: LogEventType;

export const WandEvent: LogEventType;

export const X11Event: LogEventType;

export const CommandEvent: LogEventType;

export const AllEvents: LogEventType;

export type LogEventType = number & { readonly [_SWIG_enum_tag]: 'LogEventType'; };

export const MagickImageCoderModule: MagickModuleType;

export const MagickImageFilterModule: MagickModuleType;

export type MagickModuleType = number & { readonly [_SWIG_enum_tag]: 'MagickModuleType'; };

export const UndefinedCLDeviceType: MagickCLDeviceType;

export const CpuCLDeviceType: MagickCLDeviceType;

export const GpuCLDeviceType: MagickCLDeviceType;

export type MagickCLDeviceType = number & { readonly [_SWIG_enum_tag]: 'MagickCLDeviceType'; };

export const UndefinedValidate: ValidateType;

export const NoValidate: ValidateType;

export const ColorspaceValidate: ValidateType;

export const CompareValidate: ValidateType;

export const CompositeValidate: ValidateType;

export const ConvertValidate: ValidateType;

export const FormatsDiskValidate: ValidateType;

export const FormatsMapValidate: ValidateType;

export const FormatsMemoryValidate: ValidateType;

export const IdentifyValidate: ValidateType;

export const ImportExportValidate: ValidateType;

export const MontageValidate: ValidateType;

export const StreamValidate: ValidateType;

export const MagickValidate: ValidateType;

export const AllValidate: ValidateType;

export type ValidateType = number & { readonly [_SWIG_enum_tag]: 'ValidateType'; };

export const UndefinedPolicyDomain: PolicyDomain;

export const CoderPolicyDomain: PolicyDomain;

export const DelegatePolicyDomain: PolicyDomain;

export const FilterPolicyDomain: PolicyDomain;

export const PathPolicyDomain: PolicyDomain;

export const ResourcePolicyDomain: PolicyDomain;

export const SystemPolicyDomain: PolicyDomain;

export const CachePolicyDomain: PolicyDomain;

export const ModulePolicyDomain: PolicyDomain;

export type PolicyDomain = number & { readonly [_SWIG_enum_tag]: 'PolicyDomain'; };

export const UndefinedPolicyRights: PolicyRights;

export const NoPolicyRights: PolicyRights;

export const ReadPolicyRights: PolicyRights;

export const WritePolicyRights: PolicyRights;

export const ExecutePolicyRights: PolicyRights;

export const AllPolicyRights: PolicyRights;

export type PolicyRights = number & { readonly [_SWIG_enum_tag]: 'PolicyRights'; };

export function GetPolicyValue(arg0: string): string;

export function GetPolicyList(): string[];

export function IsRightsAuthorized(arg0: MagickCore.PolicyDomain, arg1: MagickCore.PolicyRights, arg2: string): boolean;

export function ListPolicyInfo(): boolean;

export function SetMagickSecurityPolicy(arg0: string): boolean;

export function SetMagickSecurityPolicyValue(arg0: MagickCore.PolicyDomain, arg1: string, arg2: string): boolean;

export const UndefinedRegistryType: RegistryType;

export const ImageRegistryType: RegistryType;

export const ImageInfoRegistryType: RegistryType;

export const StringRegistryType: RegistryType;

export type RegistryType = number & { readonly [_SWIG_enum_tag]: 'RegistryType'; };

export const UndefinedResource: ResourceType;

export const AreaResource: ResourceType;

export const DiskResource: ResourceType;

export const FileResource: ResourceType;

export const HeightResource: ResourceType;

export const MapResource: ResourceType;

export const MemoryResource: ResourceType;

export const ThreadResource: ResourceType;

export const ThrottleResource: ResourceType;

export const TimeResource: ResourceType;

export const WidthResource: ResourceType;

export const ListLengthResource: ResourceType;

export type ResourceType = number & { readonly [_SWIG_enum_tag]: 'ResourceType'; };

export const UndefinedEvaluateOperator: MagickEvaluateOperator;

export const AbsEvaluateOperator: MagickEvaluateOperator;

export const AddEvaluateOperator: MagickEvaluateOperator;

export const AddModulusEvaluateOperator: MagickEvaluateOperator;

export const AndEvaluateOperator: MagickEvaluateOperator;

export const CosineEvaluateOperator: MagickEvaluateOperator;

export const DivideEvaluateOperator: MagickEvaluateOperator;

export const ExponentialEvaluateOperator: MagickEvaluateOperator;

export const GaussianNoiseEvaluateOperator: MagickEvaluateOperator;

export const ImpulseNoiseEvaluateOperator: MagickEvaluateOperator;

export const LaplacianNoiseEvaluateOperator: MagickEvaluateOperator;

export const LeftShiftEvaluateOperator: MagickEvaluateOperator;

export const LogEvaluateOperator: MagickEvaluateOperator;

export const MaxEvaluateOperator: MagickEvaluateOperator;

export const MeanEvaluateOperator: MagickEvaluateOperator;

export const MedianEvaluateOperator: MagickEvaluateOperator;

export const MinEvaluateOperator: MagickEvaluateOperator;

export const MultiplicativeNoiseEvaluateOperator: MagickEvaluateOperator;

export const MultiplyEvaluateOperator: MagickEvaluateOperator;

export const OrEvaluateOperator: MagickEvaluateOperator;

export const PoissonNoiseEvaluateOperator: MagickEvaluateOperator;

export const PowEvaluateOperator: MagickEvaluateOperator;

export const RightShiftEvaluateOperator: MagickEvaluateOperator;

export const RootMeanSquareEvaluateOperator: MagickEvaluateOperator;

export const SetEvaluateOperator: MagickEvaluateOperator;

export const SineEvaluateOperator: MagickEvaluateOperator;

export const SubtractEvaluateOperator: MagickEvaluateOperator;

export const SumEvaluateOperator: MagickEvaluateOperator;

export const ThresholdBlackEvaluateOperator: MagickEvaluateOperator;

export const ThresholdEvaluateOperator: MagickEvaluateOperator;

export const ThresholdWhiteEvaluateOperator: MagickEvaluateOperator;

export const UniformNoiseEvaluateOperator: MagickEvaluateOperator;

export const XorEvaluateOperator: MagickEvaluateOperator;

export const InverseLogEvaluateOperator: MagickEvaluateOperator;

export type MagickEvaluateOperator = number & { readonly [_SWIG_enum_tag]: 'MagickEvaluateOperator'; };

export const UndefinedStatistic: StatisticType;

export const GradientStatistic: StatisticType;

export const MaximumStatistic: StatisticType;

export const MeanStatistic: StatisticType;

export const MedianStatistic: StatisticType;

export const MinimumStatistic: StatisticType;

export const ModeStatistic: StatisticType;

export const NonpeakStatistic: StatisticType;

export const RootMeanSquareStatistic: StatisticType;

export const StandardDeviationStatistic: StatisticType;

export const ContrastStatistic: StatisticType;

export type StatisticType = number & { readonly [_SWIG_enum_tag]: 'StatisticType'; };

export const UndefinedPath: PathType;

export const MagickPath: PathType;

export const RootPath: PathType;

export const HeadPath: PathType;

export const TailPath: PathType;

export const BasePath: PathType;

export const ExtensionPath: PathType;

export const SubimagePath: PathType;

export const CanonicalPath: PathType;

export const SubcanonicalPath: PathType;

export const BasePathSansCompressExtension: PathType;

export type PathType = number & { readonly [_SWIG_enum_tag]: 'PathType'; };

export const UndefinedNoise: NoiseType;

export const UniformNoise: NoiseType;

export const GaussianNoise: NoiseType;

export const MultiplicativeGaussianNoise: NoiseType;

export const ImpulseNoise: NoiseType;

export const LaplacianNoise: NoiseType;

export const PoissonNoise: NoiseType;

export const RandomNoise: NoiseType;

export type NoiseType = number & { readonly [_SWIG_enum_tag]: 'NoiseType'; };

export function MagickSetSecurityPolicy(arg0: any, arg1: string): boolean;


}

export const NAPI_VERSION: number;

export const MagickCoreSignature: number;

export const MagickPathExtent: number;

export const MagickTimeExtent: number;

export const MagickEpsilon: number;

export const MagickMaximumValue: number;

export const MagickMinimumValue: number;

export const MagickOffsetFormat: string;

export const MagickSizeFormat: string;

export const MagickMaxBufferExtent: number;

export const MagickMinBufferExtent: number;

export const MagickLogFilename: string;

export const MagickPackageName: string;

export const MagickCopyright: string;

export const MagickLibVersion: number;

export const MagickLibVersionText: string;

export const MagickLibAddendum: string;

export const MagickLibInterface: number;

export const MagickLibMinInterface: number;

export const MagickPlatform: string;

export const MagickppLibVersionText: string;

export const MagickppLibAddendum: string;

export const MagickppLibInterface: number;

export const MagickppLibMinInterface: number;

export const MagickGitRevision: string;

export const MagickReleaseDate: string;

export const MagickAuthoritativeLicense: string;

export const MagickAuthoritativeURL: string;

export const MagickHomeURL: string;

export const MagickQuantumDepth: string;

export const MagickQuantumRange: string;

export const MagickHDRISupport: string;

export const MagickVersion: string;

export const MagickWandSignature: number;

export const Magick_CoderInfo_header: number;


export namespace Magick {

export function DisableOpenCL(arg0?: void): void;

export function EnableOpenCL(arg0?: void): boolean;

export function SetRandomSeed(seed: number): void;

export function SetSecurityPolicy(policy_: string): boolean;

export  class Blob {

  constructor();

  constructor(data_: Buffer);

  constructor(blob_: Magick.Blob);

  clone(blob_: Magick.Blob): Magick.Blob;

  base64(base64_: string): void;

  base64Async(base64_: string): Promise<void>;

  base64(): string;

  base64Async(): Promise<string>;

  length(): number;

  lengthAsync(): Promise<number>;

  update(data_: Buffer): void;

  updateAsync(data_: Buffer): Promise<void>;

  data(): Buffer;

  dataAsync(): Promise<Buffer>;
}

export function equal(left_: any, right_: any): number;

export function notEqual(left_: any, right_: any): number;

export function gt(left_: any, right_: any): number;

export function lt(left_: any, right_: any): number;

export function gte(left_: any, right_: any): number;

export function lte(left_: any, right_: any): number;

export type Color_PixelType = number & { readonly [_SWIG_enum_tag]: 'Color_PixelType'; };

export  class Color {

 static readonly CMYKPixel: Color_PixelType;

 static readonly CMYKAPixel: Color_PixelType;

 static readonly RGBPixel: Color_PixelType;

 static readonly RGBAPixel: Color_PixelType;

  constructor();

  constructor(red_: number, green_: number, blue_: number);

  constructor(red_: number, green_: number, blue_: number, alpha_: number);

  constructor(cyan_: number, magenta_: number, yellow_: number, black_: number, alpha_: number);

  constructor(color_: string);

  constructor(color_: Magick.Color | string);

  constructor(color_: string);

  clone(color_: Magick.Color | string): Magick.Color;

  clone(color: string): Magick.Color;

  clone(color: string): Magick.Color;

  toString(): string;

  isFuzzyEquivalent(color_: Magick.Color | string, fuzz_: number): boolean;

  isValid(valid_: boolean): void;

  isValid(): boolean;

  pixelType(): Magick.Color_PixelType;

  quantumAlpha(alpha_: number): void;

  quantumAlpha(): number;

  quantumBlack(black_: number): void;

  quantumBlack(): number;

  quantumBlue(blue_: number): void;

  quantumBlue(): number;

  quantumGreen(green_: number): void;

  quantumGreen(): number;

  quantumRed(red_: number): void;

  quantumRed(): number;
}

export  class ColorCMYK extends Magick.Color {

  constructor();

  constructor(color_: Magick.Color | string | Magick.ColorCMYK);

  constructor(cyan_: number, magenta_: number, yellow_: number, black_: number);

  constructor(cyan_: number, magenta_: number, yellow_: number, black_: number, alpha_: number);

  clone(color_: Magick.Color | string | Magick.ColorCMYK): Magick.ColorCMYK;

  alpha(alpha_: number): void;

  alpha(): number;

  black(black_: number): void;

  black(): number;

  cyan(cyan_: number): void;

  cyan(): number;

  magenta(magenta_: number): void;

  magenta(): number;

  yellow(yellow_: number): void;

  yellow(): number;
}

export  class ColorGray extends Magick.Color {

  constructor();

  constructor(color_: Magick.Color | string | Magick.ColorGray | Magick.ColorCMYK);

  constructor(shade_: number);

  shade(shade_: number): void;

  shade(): number;

  clone(color_: Magick.Color | string | Magick.ColorGray | Magick.ColorCMYK): Magick.ColorGray;
}

export  class ColorHSL extends Magick.Color {

  constructor();

  constructor(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorCMYK);

  constructor(hue_: number, saturation_: number, lightness_: number);

  clone(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorCMYK): Magick.ColorHSL;

  hue(hue_: number): void;

  hue(): number;

  lightness(lightness_: number): void;

  lightness(): number;

  saturation(saturation_: number): void;

  saturation(): number;
}

export  class ColorMono extends Magick.Color {

  constructor();

  constructor(mono_: boolean);

  constructor(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorCMYK | Magick.ColorMono);

  clone(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorCMYK | Magick.ColorMono): Magick.ColorMono;

  mono(mono_: boolean): void;

  mono(): boolean;
}

export  class ColorRGB extends Magick.Color {

  constructor();

  constructor(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono);

  constructor(red_: number, green_: number, blue_: number);

  constructor(red_: number, green_: number, blue_: number, alpha_: number);

  clone(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Magick.ColorRGB;

  alpha(alpha_: number): void;

  alpha(): number;

  blue(blue_: number): void;

  blue(): number;

  green(green_: number): void;

  green(): number;

  red(red_: number): void;

  red(): number;
}

export  class ColorYUV extends Magick.Color {

  constructor();

  constructor(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono);

  constructor(y_: number, u_: number, v_: number);

  clone(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Magick.ColorYUV;

  u(u_: number): void;

  u(): number;

  v(v_: number): void;

  v(): number;

  y(y_: number): void;

  y(): number;
}

export function equal(left_: any, right_: any): number;

export function notEqual(left_: any, right_: any): number;

export function gt(left_: any, right_: any): number;

export function lt(left_: any, right_: any): number;

export function gte(left_: any, right_: any): number;

export function lte(left_: any, right_: any): number;

export  class Geometry {

  constructor();

  constructor(geometry_: string);

  constructor(geometry_: Magick.Geometry | string);

  constructor(geometry_: string);

  constructor(width_: number, height_: number, xOff_: number, yOff_: number);

  constructor(width_: number, height_: number, xOff_: number);

  constructor(width_: number, height_: number);

  clone(geometry_: string): Magick.Geometry;

  clone(Geometry_: Magick.Geometry): Magick.Geometry;

  clone(geometry_: string): Magick.Geometry;

  toString(): string;

  aspect(aspect_: boolean): void;

  aspect(): boolean;

  fillArea(fillArea_: boolean): void;

  fillArea(): boolean;

  greater(greater_: boolean): void;

  greater(): boolean;

  height(height_: number): void;

  height(): number;

  isValid(isValid_: boolean): void;

  isValid(): boolean;

  less(less_: boolean): void;

  less(): boolean;

  limitPixels(limitPixels_: boolean): void;

  limitPixels(): boolean;

  percent(percent_: boolean): void;

  percent(): boolean;

  width(width_: number): void;

  width(): number;

  xOff(xOff_: number): void;

  xOff(): number;

  yOff(yOff_: number): void;

  yOff(): number;

  clone(rectangle_: any): Magick.Geometry;
}

export function equal(left_: any, right_: any): number;

export function notEqual(left_: any, right_: any): number;

export  class Offset {

  constructor();

  constructor(offset_: string);

  constructor(offset_: Magick.Offset);

  constructor(offset_: string);

  constructor(x_: number, y_: number);

  clone(offset_: string): Magick.Offset;

  clone(offset_: Magick.Offset): Magick.Offset;

  clone(offset_: string): Magick.Offset;

  x(): number;

  y(): number;
}

export function equal(left_: any, right_: any): number;

export function notEqual(left_: any, right_: any): number;

export  class Point {

  constructor();

  constructor(point_: string);

  constructor(point_: Magick.Point);

  constructor(point_: string);

  constructor(x_: number, y_: number);

  constructor(xy_: number);

  clone(point_: string): Magick.Point;

  clone(xy_: number): Magick.Point;

  clone(point_: Magick.Point): Magick.Point;

  clone(point_: string): Magick.Point;

  toString(): string;

  isValid(): boolean;

  x(): number;

  y(): number;
}

export  class Coordinate {

  constructor();

  constructor(x_: number, y_: number);

  x(x_: number): void;

  x(): number;

  y(y_: number): void;

  y(): number;
}

export function equal(left_: Magick.Coordinate, right_: Magick.Coordinate): number;

export function notEqual(left_: Magick.Coordinate, right_: Magick.Coordinate): number;

export function gt(left_: Magick.Coordinate, right_: Magick.Coordinate): number;

export function lt(left_: Magick.Coordinate, right_: Magick.Coordinate): number;

export function gte(left_: Magick.Coordinate, right_: Magick.Coordinate): number;

export function lte(left_: Magick.Coordinate, right_: Magick.Coordinate): number;

export  class DrawableBase {

  constructor();

  call(arg0: any): void;

  copy(): Magick.DrawableBase;
}

export  class Drawable {

  constructor();

  constructor(original_: Magick.DrawableBase);

  constructor(original_: Magick.DrawableBase);

  clone(original_: Magick.DrawableBase): Magick.DrawableBase;

  call(arg0: any): void;
}

export abstract class VPathBase {

  call(context_: any): void;

  copy(): Magick.VPathBase;
}

export  class VPath {

  constructor();

  constructor(original_: Magick.VPathBase);

  constructor(original_: Magick.VPath);

  clone(original_: Magick.VPath): Magick.VPath;

  call(context_: any): void;
}

export  class DrawableAffine extends Magick.DrawableBase {

  constructor(sx_: number, sy_: number, rx_: number, ry_: number, tx_: number, ty_: number);

  constructor();

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  sx(sx_: number): void;

  sx(): number;

  sy(sy_: number): void;

  sy(): number;

  rx(rx_: number): void;

  rx(): number;

  ry(ry_: number): void;

  ry(): number;

  tx(tx_: number): void;

  tx(): number;

  ty(ty_: number): void;

  ty(): number;
}

export  class DrawableAlpha extends Magick.DrawableBase {

  constructor(x_: number, y_: number, paintMethod_: any);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  x(x_: number): void;

  x(): number;

  y(y_: number): void;

  y(): number;

  paintMethod(paintMethod_: any): void;

  paintMethod(): any;
}

export  class DrawableArc extends Magick.DrawableBase {

  constructor(startX_: number, startY_: number, endX_: number, endY_: number, startDegrees_: number, endDegrees_: number);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  startX(startX_: number): void;

  startX(): number;

  startY(startY_: number): void;

  startY(): number;

  endX(endX_: number): void;

  endX(): number;

  endY(endY_: number): void;

  endY(): number;

  startDegrees(startDegrees_: number): void;

  startDegrees(): number;

  endDegrees(endDegrees_: number): void;

  endDegrees(): number;
}

export  class DrawableBezier extends Magick.DrawableBase {

  constructor(coordinates_: any);

  constructor(original_: Magick.DrawableBezier);

  call(context_: any): void;

  copy(): Magick.DrawableBase;
}

export  class DrawableBorderColor extends Magick.DrawableBase {

  constructor(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono);

  constructor(original_: Magick.DrawableBorderColor);

  call(context_: any): void;

  color(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  color(): Magick.Color;

  copy(): Magick.DrawableBase;
}

export  class DrawableClipRule extends Magick.DrawableBase {

  constructor(fillRule_: any);

  call(context_: any): void;

  fillRule(fillRule_: any): void;

  fillRule(): any;

  copy(): Magick.DrawableBase;
}

export  class DrawableClipUnits extends Magick.DrawableBase {

  constructor(units_: any);

  call(context_: any): void;

  units(units_: any): void;

  units(): any;

  copy(): Magick.DrawableBase;
}

export  class DrawablePopClipPath extends Magick.DrawableBase {

  constructor();

  call(context_: any): void;

  copy(): Magick.DrawableBase;
}

export  class DrawablePushClipPath extends Magick.DrawableBase {

  constructor(id_: string);

  constructor(original_: Magick.DrawablePushClipPath);

  call(context_: any): void;

  copy(): Magick.DrawableBase;
}

export  class DrawableClipPath extends Magick.DrawableBase {

  constructor(id_: string);

  constructor(original_: Magick.DrawableClipPath);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  clip_path(id_: string): void;

  clip_path(): string;
}

export  class DrawableCircle extends Magick.DrawableBase {

  constructor(originX_: number, originY_: number, perimX_: number, perimY_: number);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  originX(originX_: number): void;

  originX(): number;

  originY(originY_: number): void;

  originY(): number;

  perimX(perimX_: number): void;

  perimX(): number;

  perimY(perimY_: number): void;

  perimY(): number;
}

export  class DrawableColor extends Magick.DrawableBase {

  constructor(x_: number, y_: number, paintMethod_: any);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  x(x_: number): void;

  x(): number;

  y(y_: number): void;

  y(): number;

  paintMethod(paintMethod_: any): void;

  paintMethod(): any;
}

export  class DrawableCompositeImage extends Magick.DrawableBase {

  constructor(x_: number, y_: number, filename_: string);

  constructor(x_: number, y_: number, image_: any);

  constructor(x_: number, y_: number, width_: number, height_: number, filename_: string);

  constructor(x_: number, y_: number, width_: number, height_: number, image_: any);

  constructor(x_: number, y_: number, width_: number, height_: number, filename_: string, composition_: MagickCore.CompositeOperator);

  constructor(x_: number, y_: number, width_: number, height_: number, image_: any, composition_: MagickCore.CompositeOperator);

  constructor(original_: Magick.DrawableCompositeImage);

  clone(original_: Magick.DrawableCompositeImage): Magick.DrawableCompositeImage;

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  composition(composition_: MagickCore.CompositeOperator): void;

  composition(): MagickCore.CompositeOperator;

  filename(image_: string): void;

  filename(): string;

  x(x_: number): void;

  x(): number;

  y(y_: number): void;

  y(): number;

  width(width_: number): void;

  width(): number;

  height(height_: number): void;

  height(): number;

  image(image_: any): void;

  image(): any;

  magick(magick_: string): void;

  magick(): string;
}

export  class DrawableDensity extends Magick.DrawableBase {

  constructor(density_: Magick.Point);

  constructor(density_: string);

  call(context_: any): void;

  copy(): Magick.DrawableBase;
}

export  class DrawableEllipse extends Magick.DrawableBase {

  constructor(originX_: number, originY_: number, radiusX_: number, radiusY_: number, arcStart_: number, arcEnd_: number);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  originX(originX_: number): void;

  originX(): number;

  originY(originY_: number): void;

  originY(): number;

  radiusX(radiusX_: number): void;

  radiusX(): number;

  radiusY(radiusY_: number): void;

  radiusY(): number;

  arcStart(arcStart_: number): void;

  arcStart(): number;

  arcEnd(arcEnd_: number): void;

  arcEnd(): number;
}

export  class DrawableFillColor extends Magick.DrawableBase {

  constructor(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono);

  constructor(original_: Magick.DrawableFillColor);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  color(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  color(): Magick.Color;
}

export  class DrawableFillPatternUrl extends Magick.DrawableBase {

  constructor(url_: string);

  constructor(original_: Magick.DrawableFillPatternUrl);

  call(context_: any): void;

  url(url_: string): void;

  url(): string;

  copy(): Magick.DrawableBase;
}

export  class DrawableFillRule extends Magick.DrawableBase {

  constructor(fillRule_: any);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  fillRule(fillRule_: any): void;

  fillRule(): any;
}

export  class DrawableFillOpacity extends Magick.DrawableBase {

  constructor(opacity_: number);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  opacity(opacity_: number): void;

  opacity(): number;
}

export  class DrawableFont extends Magick.DrawableBase {

  constructor(font_: string);

  constructor(family_: string, style_: MagickCore.StyleType, weight_: number, stretch_: MagickCore.StretchType);

  constructor(original_: Magick.DrawableFont);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  font(font_: string): void;

  font(): string;
}

export  class DrawableGravity extends Magick.DrawableBase {

  constructor(gravity_: MagickCore.GravityType);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  gravity(gravity_: MagickCore.GravityType): void;

  gravity(): MagickCore.GravityType;
}

export  class DrawableLine extends Magick.DrawableBase {

  constructor(startX_: number, startY_: number, endX_: number, endY_: number);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  startX(startX_: number): void;

  startX(): number;

  startY(startY_: number): void;

  startY(): number;

  endX(endX_: number): void;

  endX(): number;

  endY(endY_: number): void;

  endY(): number;
}

export  class DrawablePath extends Magick.DrawableBase {

  constructor(path_: Magick.VPathBase[]);

  constructor(original_: Magick.DrawablePath);

  call(context_: any): void;

  copy(): Magick.DrawableBase;
}

export  class DrawablePoint extends Magick.DrawableBase {

  constructor(x_: number, y_: number);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  x(x_: number): void;

  x(): number;

  y(y_: number): void;

  y(): number;
}

export  class DrawablePointSize extends Magick.DrawableBase {

  constructor(pointSize_: number);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  pointSize(pointSize_: number): void;

  pointSize(): number;
}

export  class DrawablePolygon extends Magick.DrawableBase {

  constructor(coordinates_: any);

  constructor(original_: Magick.DrawablePolygon);

  call(context_: any): void;

  copy(): Magick.DrawableBase;
}

export  class DrawablePolyline extends Magick.DrawableBase {

  constructor(coordinates_: any);

  constructor(original_: Magick.DrawablePolyline);

  call(context_: any): void;

  copy(): Magick.DrawableBase;
}

export  class DrawablePopGraphicContext extends Magick.DrawableBase {

  constructor();

  call(context_: any): void;

  copy(): Magick.DrawableBase;
}

export  class DrawablePushGraphicContext extends Magick.DrawableBase {

  constructor();

  call(context_: any): void;

  copy(): Magick.DrawableBase;
}

export  class DrawablePopPattern extends Magick.DrawableBase {

  constructor();

  call(context_: any): void;

  copy(): Magick.DrawableBase;
}

export  class DrawablePushPattern extends Magick.DrawableBase {

  constructor(id_: string, x_: number, y_: number, width_: number, height_: number);

  constructor(original_: Magick.DrawablePushPattern);

  call(context_: any): void;

  copy(): Magick.DrawableBase;
}

export  class DrawableRectangle extends Magick.DrawableBase {

  constructor(upperLeftX_: number, upperLeftY_: number, lowerRightX_: number, lowerRightY_: number);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  upperLeftX(upperLeftX_: number): void;

  upperLeftX(): number;

  upperLeftY(upperLeftY_: number): void;

  upperLeftY(): number;

  lowerRightX(lowerRightX_: number): void;

  lowerRightX(): number;

  lowerRightY(lowerRightY_: number): void;

  lowerRightY(): number;
}

export  class DrawableRotation extends Magick.DrawableBase {

  constructor(angle_: number);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  angle(angle_: number): void;

  angle(): number;
}

export  class DrawableRoundRectangle extends Magick.DrawableBase {

  constructor(upperLeftX_: number, upperLeftY_: number, lowerRightX_: number, lowerRightY_: number, cornerWidth_: number, cornerHeight_: number);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  upperLeftX(upperLeftX_: number): void;

  upperLeftX(): number;

  upperLeftY(upperLeftY_: number): void;

  upperLeftY(): number;

  lowerRightX(lowerRightX_: number): void;

  lowerRightX(): number;

  lowerRightY(lowerRightY_: number): void;

  lowerRightY(): number;

  cornerWidth(cornerWidth_: number): void;

  cornerWidth(): number;

  cornerHeight(cornerHeight_: number): void;

  cornerHeight(): number;
}

export  class DrawableScaling extends Magick.DrawableBase {

  constructor(x_: number, y_: number);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  x(x_: number): void;

  x(): number;

  y(y_: number): void;

  y(): number;
}

export  class DrawableSkewX extends Magick.DrawableBase {

  constructor(angle_: number);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  angle(angle_: number): void;

  angle(): number;
}

export  class DrawableSkewY extends Magick.DrawableBase {

  constructor(angle_: number);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  angle(angle_: number): void;

  angle(): number;
}

export  class DrawableStrokeDashArray extends Magick.DrawableBase {

  constructor(dasharray_: any);

  constructor(original_: Magick.DrawableStrokeDashArray);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  dasharray(dasharray_: any): void;

  dasharray(): any;

  clone(original_: Magick.DrawableStrokeDashArray): Magick.DrawableStrokeDashArray;
}

export  class DrawableStrokeDashOffset extends Magick.DrawableBase {

  constructor(offset_: number);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  offset(offset_: number): void;

  offset(): number;
}

export  class DrawableStrokeLineCap extends Magick.DrawableBase {

  constructor(linecap_: any);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  linecap(linecap_: any): void;

  linecap(): any;
}

export  class DrawableStrokeLineJoin extends Magick.DrawableBase {

  constructor(linejoin_: any);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  linejoin(linejoin_: any): void;

  linejoin(): any;
}

export  class DrawableMiterLimit extends Magick.DrawableBase {

  constructor(miterlimit_: number);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  miterlimit(miterlimit_: number): void;

  miterlimit(): number;
}

export  class DrawableStrokePatternUrl extends Magick.DrawableBase {

  constructor(url_: string);

  constructor(original_: Magick.DrawableStrokePatternUrl);

  call(context_: any): void;

  url(url_: string): void;

  url(): string;

  copy(): Magick.DrawableBase;
}

export  class DrawableStrokeAntialias extends Magick.DrawableBase {

  constructor(flag_: boolean);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  flag(flag_: boolean): void;

  flag(): boolean;
}

export  class DrawableStrokeColor extends Magick.DrawableBase {

  constructor(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono);

  constructor(original_: Magick.DrawableStrokeColor);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  color(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  color(): Magick.Color;
}

export  class DrawableStrokeOpacity extends Magick.DrawableBase {

  constructor(opacity_: number);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  opacity(opacity_: number): void;

  opacity(): number;
}

export  class DrawableStrokeWidth extends Magick.DrawableBase {

  constructor(width_: number);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  width(width_: number): void;

  width(): number;
}

export  class DrawableText extends Magick.DrawableBase {

  constructor(x_: number, y_: number, text_: string);

  constructor(x_: number, y_: number, text_: string, encoding_: string);

  constructor(original_: Magick.DrawableText);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  encoding(encoding_: string): void;

  x(x_: number): void;

  x(): number;

  y(y_: number): void;

  y(): number;

  text(text_: string): void;

  text(): string;
}

export  class DrawableTextAlignment extends Magick.DrawableBase {

  constructor(alignment_: MagickCore.AlignType);

  constructor(original_: Magick.DrawableTextAlignment);

  call(context_: any): void;

  alignment(alignment_: MagickCore.AlignType): void;

  alignment(): MagickCore.AlignType;

  copy(): Magick.DrawableBase;
}

export  class DrawableTextAntialias extends Magick.DrawableBase {

  constructor(flag_: boolean);

  constructor(original_: Magick.DrawableTextAntialias);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  flag(flag_: boolean): void;

  flag(): boolean;
}

export  class DrawableTextDecoration extends Magick.DrawableBase {

  constructor(decoration_: MagickCore.DecorationType);

  constructor(original_: Magick.DrawableTextDecoration);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  decoration(decoration_: MagickCore.DecorationType): void;

  decoration(): MagickCore.DecorationType;
}

export  class DrawableTextDirection extends Magick.DrawableBase {

  constructor(direction_: MagickCore.DirectionType);

  call(context_: any): void;

  direction(direction_: MagickCore.DirectionType): void;

  direction(): MagickCore.DirectionType;

  copy(): Magick.DrawableBase;
}

export  class DrawableTextInterlineSpacing extends Magick.DrawableBase {

  constructor(spacing_: number);

  call(context_: any): void;

  spacing(spacing_: number): void;

  spacing(): number;

  copy(): Magick.DrawableBase;
}

export  class DrawableTextInterwordSpacing extends Magick.DrawableBase {

  constructor(spacing_: number);

  call(context_: any): void;

  spacing(spacing_: number): void;

  spacing(): number;

  copy(): Magick.DrawableBase;
}

export  class DrawableTextKerning extends Magick.DrawableBase {

  constructor(kerning_: number);

  call(context_: any): void;

  kerning(kerning_: number): void;

  kerning(): number;

  copy(): Magick.DrawableBase;
}

export  class DrawableTextUnderColor extends Magick.DrawableBase {

  constructor(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono);

  constructor(original_: Magick.DrawableTextUnderColor);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  color(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  color(): Magick.Color;
}

export  class DrawableTranslation extends Magick.DrawableBase {

  constructor(x_: number, y_: number);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  x(x_: number): void;

  x(): number;

  y(y_: number): void;

  y(): number;
}

export  class DrawableViewbox extends Magick.DrawableBase {

  constructor(x1_: number, y1_: number, x2_: number, y2_: number);

  call(context_: any): void;

  copy(): Magick.DrawableBase;

  x1(x1_: number): void;

  x1(): number;

  y1(y1_: number): void;

  y1(): number;

  x2(x2_: number): void;

  x2(): number;

  y2(y2_: number): void;

  y2(): number;
}

export  class PathArcArgs {

  constructor();

  constructor(radiusX_: number, radiusY_: number, xAxisRotation_: number, largeArcFlag_: boolean, sweepFlag_: boolean, x_: number, y_: number);

  constructor(original_: Magick.PathArcArgs);

  radiusX(radiusX_: number): void;

  radiusX(): number;

  radiusY(radiusY_: number): void;

  radiusY(): number;

  xAxisRotation(xAxisRotation_: number): void;

  xAxisRotation(): number;

  largeArcFlag(largeArcFlag_: boolean): void;

  largeArcFlag(): boolean;

  sweepFlag(sweepFlag_: boolean): void;

  sweepFlag(): boolean;

  x(x_: number): void;

  x(): number;

  y(y_: number): void;

  y(): number;
}

export function equal(left_: Magick.PathArcArgs, right_: Magick.PathArcArgs): number;

export function notEqual(left_: Magick.PathArcArgs, right_: Magick.PathArcArgs): number;

export function gt(left_: Magick.PathArcArgs, right_: Magick.PathArcArgs): number;

export function lt(left_: Magick.PathArcArgs, right_: Magick.PathArcArgs): number;

export function gte(left_: Magick.PathArcArgs, right_: Magick.PathArcArgs): number;

export function lte(left_: Magick.PathArcArgs, right_: Magick.PathArcArgs): number;

export  class PathArcAbs extends Magick.VPathBase {

  constructor(coordinates_: Magick.PathArcArgs);

  constructor(coordinates_: any);

  constructor(original_: Magick.PathArcAbs);

  call(context_: any): void;

  copy(): Magick.VPathBase;
}

export  class PathArcRel extends Magick.VPathBase {

  constructor(coordinates_: Magick.PathArcArgs);

  constructor(coordinates_: any);

  constructor(original_: Magick.PathArcRel);

  call(context_: any): void;

  copy(): Magick.VPathBase;
}

export  class PathClosePath extends Magick.VPathBase {

  constructor();

  call(context_: any): void;

  copy(): Magick.VPathBase;
}

export  class PathCurvetoArgs {

  constructor();

  constructor(x1_: number, y1_: number, x2_: number, y2_: number, x_: number, y_: number);

  constructor(original_: Magick.PathCurvetoArgs);

  x1(x1_: number): void;

  x1(): number;

  y1(y1_: number): void;

  y1(): number;

  x2(x2_: number): void;

  x2(): number;

  y2(y2_: number): void;

  y2(): number;

  x(x_: number): void;

  x(): number;

  y(y_: number): void;

  y(): number;
}

export function equal(left_: Magick.PathCurvetoArgs, right_: Magick.PathCurvetoArgs): number;

export function notEqual(left_: Magick.PathCurvetoArgs, right_: Magick.PathCurvetoArgs): number;

export function gt(left_: Magick.PathCurvetoArgs, right_: Magick.PathCurvetoArgs): number;

export function lt(left_: Magick.PathCurvetoArgs, right_: Magick.PathCurvetoArgs): number;

export function gte(left_: Magick.PathCurvetoArgs, right_: Magick.PathCurvetoArgs): number;

export function lte(left_: Magick.PathCurvetoArgs, right_: Magick.PathCurvetoArgs): number;

export  class PathCurvetoAbs extends Magick.VPathBase {

  constructor(args_: Magick.PathCurvetoArgs);

  constructor(args_: any);

  constructor(original_: Magick.PathCurvetoAbs);

  call(context_: any): void;

  copy(): Magick.VPathBase;
}

export  class PathCurvetoRel extends Magick.VPathBase {

  constructor(args_: Magick.PathCurvetoArgs);

  constructor(args_: any);

  constructor(original_: Magick.PathCurvetoRel);

  call(context_: any): void;

  copy(): Magick.VPathBase;
}

export  class PathSmoothCurvetoAbs extends Magick.VPathBase {

  constructor(coordinates_: Magick.Coordinate);

  constructor(coordinates_: any);

  constructor(original_: Magick.PathSmoothCurvetoAbs);

  call(context_: any): void;

  copy(): Magick.VPathBase;
}

export  class PathSmoothCurvetoRel extends Magick.VPathBase {

  constructor(coordinates_: Magick.Coordinate);

  constructor(coordinates_: any);

  constructor(original_: Magick.PathSmoothCurvetoRel);

  call(context_: any): void;

  copy(): Magick.VPathBase;
}

export  class PathQuadraticCurvetoArgs {

  constructor();

  constructor(x1_: number, y1_: number, x_: number, y_: number);

  constructor(original_: Magick.PathQuadraticCurvetoArgs);

  x1(x1_: number): void;

  x1(): number;

  y1(y1_: number): void;

  y1(): number;

  x(x_: number): void;

  x(): number;

  y(y_: number): void;

  y(): number;
}

export function equal(left_: Magick.PathQuadraticCurvetoArgs, right_: Magick.PathQuadraticCurvetoArgs): number;

export function notEqual(left_: Magick.PathQuadraticCurvetoArgs, right_: Magick.PathQuadraticCurvetoArgs): number;

export function gt(left_: Magick.PathQuadraticCurvetoArgs, right_: Magick.PathQuadraticCurvetoArgs): number;

export function lt(left_: Magick.PathQuadraticCurvetoArgs, right_: Magick.PathQuadraticCurvetoArgs): number;

export function gte(left_: Magick.PathQuadraticCurvetoArgs, right_: Magick.PathQuadraticCurvetoArgs): number;

export function lte(left_: Magick.PathQuadraticCurvetoArgs, right_: Magick.PathQuadraticCurvetoArgs): number;

export  class PathQuadraticCurvetoAbs extends Magick.VPathBase {

  constructor(args_: Magick.PathQuadraticCurvetoArgs);

  constructor(args_: any);

  constructor(original_: Magick.PathQuadraticCurvetoAbs);

  call(context_: any): void;

  copy(): Magick.VPathBase;
}

export  class PathQuadraticCurvetoRel extends Magick.VPathBase {

  constructor(args_: Magick.PathQuadraticCurvetoArgs);

  constructor(args_: any);

  constructor(original_: Magick.PathQuadraticCurvetoRel);

  call(context_: any): void;

  copy(): Magick.VPathBase;
}

export  class PathSmoothQuadraticCurvetoAbs extends Magick.VPathBase {

  constructor(coordinate_: Magick.Coordinate);

  constructor(coordinates_: any);

  constructor(original_: Magick.PathSmoothQuadraticCurvetoAbs);

  call(context_: any): void;

  copy(): Magick.VPathBase;
}

export  class PathSmoothQuadraticCurvetoRel extends Magick.VPathBase {

  constructor(coordinate_: Magick.Coordinate);

  constructor(coordinates_: any);

  constructor(original_: Magick.PathSmoothQuadraticCurvetoRel);

  call(context_: any): void;

  copy(): Magick.VPathBase;
}

export  class PathLinetoAbs extends Magick.VPathBase {

  constructor(coordinate_: Magick.Coordinate);

  constructor(coordinates_: any);

  constructor(original_: Magick.PathLinetoAbs);

  call(context_: any): void;

  copy(): Magick.VPathBase;
}

export  class PathLinetoRel extends Magick.VPathBase {

  constructor(coordinate_: Magick.Coordinate);

  constructor(coordinates_: any);

  constructor(original_: Magick.PathLinetoRel);

  call(context_: any): void;

  copy(): Magick.VPathBase;
}

export  class PathLinetoHorizontalAbs extends Magick.VPathBase {

  constructor(x_: number);

  call(context_: any): void;

  copy(): Magick.VPathBase;

  x(x_: number): void;

  x(): number;
}

export  class PathLinetoHorizontalRel extends Magick.VPathBase {

  constructor(x_: number);

  call(context_: any): void;

  copy(): Magick.VPathBase;

  x(x_: number): void;

  x(): number;
}

export  class PathLinetoVerticalAbs extends Magick.VPathBase {

  constructor(y_: number);

  call(context_: any): void;

  copy(): Magick.VPathBase;

  y(y_: number): void;

  y(): number;
}

export  class PathLinetoVerticalRel extends Magick.VPathBase {

  constructor(y_: number);

  call(context_: any): void;

  copy(): Magick.VPathBase;

  y(y_: number): void;

  y(): number;
}

export  class PathMovetoAbs extends Magick.VPathBase {

  constructor(coordinate_: Magick.Coordinate);

  constructor(coordinates_: any);

  constructor(original_: Magick.PathMovetoAbs);

  call(context_: any): void;

  copy(): Magick.VPathBase;
}

export  class PathMovetoRel extends Magick.VPathBase {

  constructor(coordinate_: Magick.Coordinate);

  constructor(coordinates_: any);

  constructor(original_: Magick.PathMovetoRel);

  call(context_: any): void;

  copy(): Magick.VPathBase;
}

export  class ErrorPolicy {

  constructor(what_: string);

  constructor(what_: string, nested_: any | Magick.ErrorPolicy);
}

export  class ErrorType {

  constructor(what_: string);

  constructor(what_: string, nested_: any | Magick.ErrorPolicy | Magick.ErrorType);
}

export  class WarningPolicy {

  constructor(what_: string);

  constructor(what_: string, nested_: any | Magick.ErrorPolicy | Magick.ErrorType | Magick.WarningPolicy);
}

export  class WarningType {

  constructor(what_: string);

  constructor(what_: string, nested_: any | Magick.ErrorPolicy | Magick.ErrorType | Magick.WarningPolicy | Magick.WarningType);
}

export  class ChannelMoments {

  constructor();

  constructor(channelMoments_: Magick.ChannelMoments);

  centroidX(): number;

  centroidY(): number;

  channel(): any;

  ellipseAxisX(): number;

  ellipseAxisY(): number;

  ellipseAngle(): number;

  ellipseEccentricity(): number;

  ellipseIntensity(): number;

  huInvariants(index_: number): number;

  isValid(): boolean;

  constructor(channel_: any, channelMoments_: any);
}

export  class ChannelPerceptualHash {

  constructor();

  constructor(channelPerceptualHash_: Magick.ChannelPerceptualHash);

  constructor(channel_: any, hash_: string);

  toString(): string;

  channel(): any;

  isValid(): boolean;

  sumSquaredDifferences(channelPerceptualHash_: Magick.ChannelPerceptualHash): number;

  srgbHuPhash(index_: number): number;

  hclpHuPhash(index_: number): number;

  constructor(channel_: any, channelPerceptualHash_: any);
}

export  class ChannelStatistics {

  constructor();

  constructor(channelStatistics_: Magick.ChannelStatistics);

  area(): number;

  channel(): any;

  depth(): number;

  entropy(): number;

  isValid(): boolean;

  kurtosis(): number;

  maxima(): number;

  mean(): number;

  minima(): number;

  skewness(): number;

  standardDeviation(): number;

  sum(): number;

  sumCubed(): number;

  sumFourthPower(): number;

  sumSquared(): number;

  variance(): number;

  constructor(channel_: any, channelStatistics_: any);
}

export  class ImageMoments {

  constructor();

  constructor(imageMoments_: Magick.ImageMoments);

  channel(channel_: any): Magick.ChannelMoments;

  constructor(image_: any);
}

export  class ImagePerceptualHash {

  constructor();

  constructor(imagePerceptualHash_: Magick.ImagePerceptualHash);

  constructor(hash_: string);

  toString(): string;

  channel(channel_: any): Magick.ChannelPerceptualHash;

  isValid(): boolean;

  sumSquaredDifferences(channelPerceptualHash_: Magick.ImagePerceptualHash): number;

  constructor(image_: any);
}

export  class ImageStatistics {

  constructor();

  constructor(imageStatistics_: Magick.ImageStatistics);

  channel(channel_: any): Magick.ChannelStatistics;

  constructor(image_: any);
}

export  class TypeMetric {

  constructor();

  ascent(): number;

  bounds(): Magick.Geometry;

  descent(): number;

  maxHorizontalAdvance(): number;

  origin(): Magick.Coordinate;

  pixelsPerEm(): Magick.Coordinate;

  textHeight(): number;

  textWidth(): number;

  underlinePosition(): number;

  underlineThickness(): number;
}

export let borderGeometryDefault: string;

export let frameGeometryDefault: string;

export let raiseGeometryDefault: string;

export function equal(left_: any, right_: any): number;

export function notEqual(left_: any, right_: any): number;

export function gt(left_: any, right_: any): number;

export function lt(left_: any, right_: any): number;

export function gte(left_: any, right_: any): number;

export function lte(left_: any, right_: any): number;

export  class Image {

  constructor();

  constructor(blob_: Magick.Blob);

  constructor(blob_: Magick.Blob, size_: Magick.Geometry | string);

  constructor(blob_: Magick.Blob, size_: Magick.Geometry | string, depth_: number);

  constructor(blob_: Magick.Blob, size_: Magick.Geometry | string, depth_: number, magick_: string);

  constructor(blob_: Magick.Blob, size_: Magick.Geometry | string, magick_: string);

  constructor(size_: Magick.Geometry | string, color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono);

  constructor(image_: Magick.Image);

  constructor(image_: Magick.Image, geometry_: Magick.Geometry | string);

  constructor(width_: number, height_: number, map_: string, type_: Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array | Float32Array | Float64Array | BigUint64Array);

  constructor(imageSpec_: string);

  clone(image_: Magick.Image): Magick.Image;

  adjoin(flag_: boolean): void;

  adjoinAsync(flag_: boolean): Promise<void>;

  adjoin(): boolean;

  adjoinAsync(): Promise<boolean>;

  alpha(alphaFlag_: boolean): void;

  alphaAsync(alphaFlag_: boolean): Promise<void>;

  alpha(): boolean;

  alphaAsync(): Promise<boolean>;

  matteColor(matteColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  matteColorAsync(matteColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  matteColor(): Magick.Color;

  matteColorAsync(): Promise<Magick.Color>;

  animationDelay(delay_: number): void;

  animationDelayAsync(delay_: number): Promise<void>;

  animationDelay(): number;

  animationDelayAsync(): Promise<number>;

  animationIterations(iterations_: number): void;

  animationIterationsAsync(iterations_: number): Promise<void>;

  animationIterations(): number;

  animationIterationsAsync(): Promise<number>;

  backgroundColor(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  backgroundColorAsync(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  backgroundColor(): Magick.Color;

  backgroundColorAsync(): Promise<Magick.Color>;

  backgroundTexture(backgroundTexture_: string): void;

  backgroundTextureAsync(backgroundTexture_: string): Promise<void>;

  backgroundTexture(): string;

  backgroundTextureAsync(): Promise<string>;

  baseColumns(): number;

  baseColumnsAsync(): Promise<number>;

  baseFilename(): string;

  baseFilenameAsync(): Promise<string>;

  baseRows(): number;

  baseRowsAsync(): Promise<number>;

  blackPointCompensation(flag_: boolean): void;

  blackPointCompensationAsync(flag_: boolean): Promise<void>;

  blackPointCompensation(): boolean;

  blackPointCompensationAsync(): Promise<boolean>;

  borderColor(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  borderColorAsync(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  borderColor(): Magick.Color;

  borderColorAsync(): Promise<Magick.Color>;

  boundingBox(): Magick.Geometry;

  boundingBoxAsync(): Promise<Magick.Geometry>;

  boxColor(boxColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  boxColorAsync(boxColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  boxColor(): Magick.Color;

  boxColorAsync(): Promise<Magick.Color>;

  channelDepth(channel_: MagickCore.ChannelType, depth_: number): void;

  channelDepthAsync(channel_: MagickCore.ChannelType, depth_: number): Promise<void>;

  channelDepth(channel_: MagickCore.ChannelType): number;

  channelDepthAsync(channel_: MagickCore.ChannelType): Promise<number>;

  channels(): number;

  channelsAsync(): Promise<number>;

  classType(class_: MagickCore.ClassType): void;

  classTypeAsync(class_: MagickCore.ClassType): Promise<void>;

  classType(): MagickCore.ClassType;

  classTypeAsync(): Promise<MagickCore.ClassType>;

  colorFuzz(fuzz_: number): void;

  colorFuzzAsync(fuzz_: number): Promise<void>;

  colorFuzz(): number;

  colorFuzzAsync(): Promise<number>;

  colorMapSize(entries_: number): void;

  colorMapSizeAsync(entries_: number): Promise<void>;

  colorMapSize(): number;

  colorMapSizeAsync(): Promise<number>;

  colorSpace(colorSpace_: MagickCore.ColorspaceType): void;

  colorSpaceAsync(colorSpace_: MagickCore.ColorspaceType): Promise<void>;

  colorSpace(): MagickCore.ColorspaceType;

  colorSpaceAsync(): Promise<MagickCore.ColorspaceType>;

  colorSpaceType(colorSpace_: MagickCore.ColorspaceType): void;

  colorSpaceTypeAsync(colorSpace_: MagickCore.ColorspaceType): Promise<void>;

  colorSpaceType(): MagickCore.ColorspaceType;

  colorSpaceTypeAsync(): Promise<MagickCore.ColorspaceType>;

  columns(): number;

  columnsAsync(): Promise<number>;

  comment(comment_: string): void;

  commentAsync(comment_: string): Promise<void>;

  comment(): string;

  commentAsync(): Promise<string>;

  compose(compose_: MagickCore.CompositeOperator): void;

  composeAsync(compose_: MagickCore.CompositeOperator): Promise<void>;

  compose(): MagickCore.CompositeOperator;

  composeAsync(): Promise<MagickCore.CompositeOperator>;

  compressType(compressType_: MagickCore.CompressionType): void;

  compressTypeAsync(compressType_: MagickCore.CompressionType): Promise<void>;

  compressType(): MagickCore.CompressionType;

  compressTypeAsync(): Promise<MagickCore.CompressionType>;

  debug(flag_: boolean): void;

  debugAsync(flag_: boolean): Promise<void>;

  debug(): boolean;

  debugAsync(): Promise<boolean>;

  density(density_: Magick.Point): void;

  densityAsync(density_: Magick.Point): Promise<void>;

  density(): Magick.Point;

  densityAsync(): Promise<Magick.Point>;

  depth(depth_: number): void;

  depthAsync(depth_: number): Promise<void>;

  depth(): number;

  depthAsync(): Promise<number>;

  directory(): string;

  directoryAsync(): Promise<string>;

  endian(endian_: MagickCore.EndianType): void;

  endianAsync(endian_: MagickCore.EndianType): Promise<void>;

  endian(): MagickCore.EndianType;

  endianAsync(): Promise<MagickCore.EndianType>;

  exifProfile(exifProfile_: Magick.Blob): void;

  exifProfileAsync(exifProfile_: Magick.Blob): Promise<void>;

  exifProfile(): Magick.Blob;

  exifProfileAsync(): Promise<Magick.Blob>;

  fileName(fileName_: string): void;

  fileNameAsync(fileName_: string): Promise<void>;

  fileName(): string;

  fileNameAsync(): Promise<string>;

  fileSize(): number;

  fileSizeAsync(): Promise<number>;

  fillColor(fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  fillColorAsync(fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  fillColor(): Magick.Color;

  fillColorAsync(): Promise<Magick.Color>;

  fillRule(fillRule_: any): void;

  fillRuleAsync(fillRule_: any): Promise<void>;

  fillRule(): any;

  fillRuleAsync(): Promise<any>;

  fillPattern(fillPattern_: Magick.Image): void;

  fillPatternAsync(fillPattern_: Magick.Image): Promise<void>;

  fillPattern(): Magick.Image;

  fillPatternAsync(): Promise<Magick.Image>;

  filterType(filterType_: MagickCore.FilterType): void;

  filterTypeAsync(filterType_: MagickCore.FilterType): Promise<void>;

  filterType(): MagickCore.FilterType;

  filterTypeAsync(): Promise<MagickCore.FilterType>;

  font(font_: string): void;

  fontAsync(font_: string): Promise<void>;

  font(): string;

  fontAsync(): Promise<string>;

  fontFamily(family_: string): void;

  fontFamilyAsync(family_: string): Promise<void>;

  fontFamily(): string;

  fontFamilyAsync(): Promise<string>;

  fontPointsize(pointSize_: number): void;

  fontPointsizeAsync(pointSize_: number): Promise<void>;

  fontPointsize(): number;

  fontPointsizeAsync(): Promise<number>;

  fontStyle(style_: MagickCore.StyleType): void;

  fontStyleAsync(style_: MagickCore.StyleType): Promise<void>;

  fontStyle(): MagickCore.StyleType;

  fontStyleAsync(): Promise<MagickCore.StyleType>;

  fontWeight(weight_: number): void;

  fontWeightAsync(weight_: number): Promise<void>;

  fontWeight(): number;

  fontWeightAsync(): Promise<number>;

  format(): string;

  formatAsync(): Promise<string>;

  formatExpression(expression: string): string;

  formatExpressionAsync(expression: string): Promise<string>;

  gamma(): number;

  gammaAsync(): Promise<number>;

  geometry(): Magick.Geometry;

  geometryAsync(): Promise<Magick.Geometry>;

  gifDisposeMethod(disposeMethod_: MagickCore.DisposeType): void;

  gifDisposeMethodAsync(disposeMethod_: MagickCore.DisposeType): Promise<void>;

  gifDisposeMethod(): MagickCore.DisposeType;

  gifDisposeMethodAsync(): Promise<MagickCore.DisposeType>;

  hasChannel(channel: any): boolean;

  hasChannelAsync(channel: any): Promise<boolean>;

  highlightColor(color_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  highlightColorAsync(color_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  iccColorProfile(colorProfile_: Magick.Blob): void;

  iccColorProfileAsync(colorProfile_: Magick.Blob): Promise<void>;

  iccColorProfile(): Magick.Blob;

  iccColorProfileAsync(): Promise<Magick.Blob>;

  interlaceType(interlace_: MagickCore.InterlaceType): void;

  interlaceTypeAsync(interlace_: MagickCore.InterlaceType): Promise<void>;

  interlaceType(): MagickCore.InterlaceType;

  interlaceTypeAsync(): Promise<MagickCore.InterlaceType>;

  interpolate(interpolate_: any): void;

  interpolateAsync(interpolate_: any): Promise<void>;

  interpolate(): any;

  interpolateAsync(): Promise<any>;

  iptcProfile(iptcProfile_: Magick.Blob): void;

  iptcProfileAsync(iptcProfile_: Magick.Blob): Promise<void>;

  iptcProfile(): Magick.Blob;

  iptcProfileAsync(): Promise<Magick.Blob>;

  isOpaque(): boolean;

  isOpaqueAsync(): Promise<boolean>;

  isValid(isValid_: boolean): void;

  isValidAsync(isValid_: boolean): Promise<void>;

  isValid(): boolean;

  isValidAsync(): Promise<boolean>;

  label(label_: string): void;

  labelAsync(label_: string): Promise<void>;

  label(): string;

  labelAsync(): Promise<string>;

  lowlightColor(color_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  lowlightColorAsync(color_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  magick(magick_: string): void;

  magickAsync(magick_: string): Promise<void>;

  magick(): string;

  magickAsync(): Promise<string>;

  masklightColor(color_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  masklightColorAsync(color_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  meanErrorPerPixel(): number;

  meanErrorPerPixelAsync(): Promise<number>;

  modulusDepth(modulusDepth_: number): void;

  modulusDepthAsync(modulusDepth_: number): Promise<void>;

  modulusDepth(): number;

  modulusDepthAsync(): Promise<number>;

  monochrome(monochromeFlag_: boolean): void;

  monochromeAsync(monochromeFlag_: boolean): Promise<void>;

  monochrome(): boolean;

  monochromeAsync(): Promise<boolean>;

  montageGeometry(): Magick.Geometry;

  montageGeometryAsync(): Promise<Magick.Geometry>;

  normalizedMaxError(): number;

  normalizedMaxErrorAsync(): Promise<number>;

  normalizedMeanError(): number;

  normalizedMeanErrorAsync(): Promise<number>;

  orientation(orientation_: MagickCore.OrientationType): void;

  orientationAsync(orientation_: MagickCore.OrientationType): Promise<void>;

  orientation(): MagickCore.OrientationType;

  orientationAsync(): Promise<MagickCore.OrientationType>;

  page(pageSize_: Magick.Geometry): void;

  pageAsync(pageSize_: Magick.Geometry): Promise<void>;

  page(): Magick.Geometry;

  pageAsync(): Promise<Magick.Geometry>;

  quality(quality_: number): void;

  qualityAsync(quality_: number): Promise<void>;

  quality(): number;

  qualityAsync(): Promise<number>;

  quantizeColors(colors_: number): void;

  quantizeColorsAsync(colors_: number): Promise<void>;

  quantizeColors(): number;

  quantizeColorsAsync(): Promise<number>;

  quantizeColorSpace(colorSpace_: MagickCore.ColorspaceType): void;

  quantizeColorSpaceAsync(colorSpace_: MagickCore.ColorspaceType): Promise<void>;

  quantizeColorSpace(): MagickCore.ColorspaceType;

  quantizeColorSpaceAsync(): Promise<MagickCore.ColorspaceType>;

  quantizeDither(ditherFlag_: boolean): void;

  quantizeDitherAsync(ditherFlag_: boolean): Promise<void>;

  quantizeDither(): boolean;

  quantizeDitherAsync(): Promise<boolean>;

  quantizeDitherMethod(ditherMethod_: any): void;

  quantizeDitherMethodAsync(ditherMethod_: any): Promise<void>;

  quantizeDitherMethod(): any;

  quantizeDitherMethodAsync(): Promise<any>;

  quantizeTreeDepth(treeDepth_: number): void;

  quantizeTreeDepthAsync(treeDepth_: number): Promise<void>;

  quantizeTreeDepth(): number;

  quantizeTreeDepthAsync(): Promise<number>;

  quiet(quiet_: boolean): void;

  quietAsync(quiet_: boolean): Promise<void>;

  quiet(): boolean;

  quietAsync(): Promise<boolean>;

  renderingIntent(renderingIntent_: any): void;

  renderingIntentAsync(renderingIntent_: any): Promise<void>;

  renderingIntent(): any;

  renderingIntentAsync(): Promise<any>;

  resolutionUnits(resolutionUnits_: MagickCore.ResolutionType): void;

  resolutionUnitsAsync(resolutionUnits_: MagickCore.ResolutionType): Promise<void>;

  resolutionUnits(): MagickCore.ResolutionType;

  resolutionUnitsAsync(): Promise<MagickCore.ResolutionType>;

  rows(): number;

  rowsAsync(): Promise<number>;

  samplingFactor(samplingFactor_: string): void;

  samplingFactorAsync(samplingFactor_: string): Promise<void>;

  samplingFactor(): string;

  samplingFactorAsync(): Promise<string>;

  scene(scene_: number): void;

  sceneAsync(scene_: number): Promise<void>;

  scene(): number;

  sceneAsync(): Promise<number>;

  size(geometry_: Magick.Geometry | string): void;

  sizeAsync(geometry_: Magick.Geometry | string): Promise<void>;

  size(): Magick.Geometry;

  sizeAsync(): Promise<Magick.Geometry>;

  strokeAntiAlias(flag_: boolean): void;

  strokeAntiAliasAsync(flag_: boolean): Promise<void>;

  strokeAntiAlias(): boolean;

  strokeAntiAliasAsync(): Promise<boolean>;

  strokeColor(strokeColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  strokeColorAsync(strokeColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  strokeColor(): Magick.Color;

  strokeColorAsync(): Promise<Magick.Color>;

  strokeDashArray(strokeDashArray_: any): void;

  strokeDashArrayAsync(strokeDashArray_: any): Promise<void>;

  strokeDashArray(): any;

  strokeDashArrayAsync(): Promise<any>;

  strokeDashOffset(strokeDashOffset_: number): void;

  strokeDashOffsetAsync(strokeDashOffset_: number): Promise<void>;

  strokeDashOffset(): number;

  strokeDashOffsetAsync(): Promise<number>;

  strokeLineCap(lineCap_: any): void;

  strokeLineCapAsync(lineCap_: any): Promise<void>;

  strokeLineCap(): any;

  strokeLineCapAsync(): Promise<any>;

  strokeLineJoin(lineJoin_: any): void;

  strokeLineJoinAsync(lineJoin_: any): Promise<void>;

  strokeLineJoin(): any;

  strokeLineJoinAsync(): Promise<any>;

  strokeMiterLimit(miterLimit_: number): void;

  strokeMiterLimitAsync(miterLimit_: number): Promise<void>;

  strokeMiterLimit(): number;

  strokeMiterLimitAsync(): Promise<number>;

  strokePattern(strokePattern_: Magick.Image): void;

  strokePatternAsync(strokePattern_: Magick.Image): Promise<void>;

  strokePattern(): Magick.Image;

  strokePatternAsync(): Promise<Magick.Image>;

  strokeWidth(strokeWidth_: number): void;

  strokeWidthAsync(strokeWidth_: number): Promise<void>;

  strokeWidth(): number;

  strokeWidthAsync(): Promise<number>;

  subImage(subImage_: number): void;

  subImageAsync(subImage_: number): Promise<void>;

  subImage(): number;

  subImageAsync(): Promise<number>;

  subRange(subRange_: number): void;

  subRangeAsync(subRange_: number): Promise<void>;

  subRange(): number;

  subRangeAsync(): Promise<number>;

  textAntiAlias(flag_: boolean): void;

  textAntiAliasAsync(flag_: boolean): Promise<void>;

  textAntiAlias(): boolean;

  textAntiAliasAsync(): Promise<boolean>;

  textDirection(direction_: MagickCore.DirectionType): void;

  textDirectionAsync(direction_: MagickCore.DirectionType): Promise<void>;

  textDirection(): MagickCore.DirectionType;

  textDirectionAsync(): Promise<MagickCore.DirectionType>;

  textEncoding(encoding_: string): void;

  textEncodingAsync(encoding_: string): Promise<void>;

  textEncoding(): string;

  textEncodingAsync(): Promise<string>;

  textGravity(gravity_: MagickCore.GravityType): void;

  textGravityAsync(gravity_: MagickCore.GravityType): Promise<void>;

  textGravity(): MagickCore.GravityType;

  textGravityAsync(): Promise<MagickCore.GravityType>;

  textInterlineSpacing(spacing_: number): void;

  textInterlineSpacingAsync(spacing_: number): Promise<void>;

  textInterlineSpacing(): number;

  textInterlineSpacingAsync(): Promise<number>;

  textInterwordSpacing(spacing_: number): void;

  textInterwordSpacingAsync(spacing_: number): Promise<void>;

  textInterwordSpacing(): number;

  textInterwordSpacingAsync(): Promise<number>;

  textKerning(kerning_: number): void;

  textKerningAsync(kerning_: number): Promise<void>;

  textKerning(): number;

  textKerningAsync(): Promise<number>;

  textUnderColor(underColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  textUnderColorAsync(underColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  textUnderColor(): Magick.Color;

  textUnderColorAsync(): Promise<Magick.Color>;

  totalColors(): number;

  totalColorsAsync(): Promise<number>;

  transformRotation(angle_: number): void;

  transformRotationAsync(angle_: number): Promise<void>;

  transformSkewX(skewx_: number): void;

  transformSkewXAsync(skewx_: number): Promise<void>;

  transformSkewY(skewy_: number): void;

  transformSkewYAsync(skewy_: number): Promise<void>;

  type(type_: MagickCore.ImageType): void;

  typeAsync(type_: MagickCore.ImageType): Promise<void>;

  type(): MagickCore.ImageType;

  typeAsync(): Promise<MagickCore.ImageType>;

  verbose(verboseFlag_: boolean): void;

  verboseAsync(verboseFlag_: boolean): Promise<void>;

  verbose(): boolean;

  verboseAsync(): Promise<boolean>;

  virtualPixelMethod(virtualPixelMethod_: any): void;

  virtualPixelMethodAsync(virtualPixelMethod_: any): Promise<void>;

  virtualPixelMethod(): any;

  virtualPixelMethodAsync(): Promise<any>;

  x11Display(display_: string): void;

  x11DisplayAsync(display_: string): Promise<void>;

  x11Display(): string;

  x11DisplayAsync(): Promise<string>;

  xResolution(): number;

  xResolutionAsync(): Promise<number>;

  yResolution(): number;

  yResolutionAsync(): Promise<number>;

  adaptiveBlur(radius_: number, sigma_: number): void;

  adaptiveBlurAsync(radius_: number, sigma_: number): Promise<void>;

  adaptiveBlur(radius_: number): void;

  adaptiveBlurAsync(radius_: number): Promise<void>;

  adaptiveBlur(): void;

  adaptiveBlurAsync(): Promise<void>;

  adaptiveResize(geometry_: Magick.Geometry | string): void;

  adaptiveResizeAsync(geometry_: Magick.Geometry | string): Promise<void>;

  adaptiveSharpen(radius_: number, sigma_: number): void;

  adaptiveSharpenAsync(radius_: number, sigma_: number): Promise<void>;

  adaptiveSharpen(radius_: number): void;

  adaptiveSharpenAsync(radius_: number): Promise<void>;

  adaptiveSharpen(): void;

  adaptiveSharpenAsync(): Promise<void>;

  adaptiveSharpenChannel(channel_: MagickCore.ChannelType, radius_: number, sigma_: number): void;

  adaptiveSharpenChannelAsync(channel_: MagickCore.ChannelType, radius_: number, sigma_: number): Promise<void>;

  adaptiveSharpenChannel(channel_: MagickCore.ChannelType, radius_: number): void;

  adaptiveSharpenChannelAsync(channel_: MagickCore.ChannelType, radius_: number): Promise<void>;

  adaptiveSharpenChannel(channel_: MagickCore.ChannelType): void;

  adaptiveSharpenChannelAsync(channel_: MagickCore.ChannelType): Promise<void>;

  adaptiveThreshold(width_: number, height_: number, bias_: number): void;

  adaptiveThresholdAsync(width_: number, height_: number, bias_: number): Promise<void>;

  adaptiveThreshold(width_: number, height_: number): void;

  adaptiveThresholdAsync(width_: number, height_: number): Promise<void>;

  addNoise(noiseType_: MagickCore.NoiseType, attenuate_: number): void;

  addNoiseAsync(noiseType_: MagickCore.NoiseType, attenuate_: number): Promise<void>;

  addNoise(noiseType_: MagickCore.NoiseType): void;

  addNoiseAsync(noiseType_: MagickCore.NoiseType): Promise<void>;

  addNoiseChannel(channel_: MagickCore.ChannelType, noiseType_: MagickCore.NoiseType, attenuate_: number): void;

  addNoiseChannelAsync(channel_: MagickCore.ChannelType, noiseType_: MagickCore.NoiseType, attenuate_: number): Promise<void>;

  addNoiseChannel(channel_: MagickCore.ChannelType, noiseType_: MagickCore.NoiseType): void;

  addNoiseChannelAsync(channel_: MagickCore.ChannelType, noiseType_: MagickCore.NoiseType): Promise<void>;

  affineTransform(affine: Magick.DrawableAffine): void;

  affineTransformAsync(affine: Magick.DrawableAffine): Promise<void>;

  alpha(alpha_: number): void;

  alphaAsync(alpha_: number): Promise<void>;

  alphaChannel(alphaOption_: any): void;

  alphaChannelAsync(alphaOption_: any): Promise<void>;

  annotate(text_: string, location_: Magick.Geometry): void;

  annotateAsync(text_: string, location_: Magick.Geometry): Promise<void>;

  annotate(text_: string, boundingArea_: Magick.Geometry, gravity_: MagickCore.GravityType): void;

  annotateAsync(text_: string, boundingArea_: Magick.Geometry, gravity_: MagickCore.GravityType): Promise<void>;

  annotate(text_: string, boundingArea_: Magick.Geometry, gravity_: MagickCore.GravityType, degrees_: number): void;

  annotateAsync(text_: string, boundingArea_: Magick.Geometry, gravity_: MagickCore.GravityType, degrees_: number): Promise<void>;

  annotate(text_: string, gravity_: MagickCore.GravityType): void;

  annotateAsync(text_: string, gravity_: MagickCore.GravityType): Promise<void>;

  artifact(name_: string, value_: string): void;

  artifactAsync(name_: string, value_: string): Promise<void>;

  artifact(name_: string): string;

  artifactAsync(name_: string): Promise<string>;

  attribute(name_: string, value_: string): void;

  attributeAsync(name_: string, value_: string): Promise<void>;

  attribute(name_: string, value_: string): void;

  attributeAsync(name_: string, value_: string): Promise<void>;

  attribute(name_: string): string;

  attributeAsync(name_: string): Promise<string>;

  autoGamma(): void;

  autoGammaAsync(): Promise<void>;

  autoGammaChannel(channel_: MagickCore.ChannelType): void;

  autoGammaChannelAsync(channel_: MagickCore.ChannelType): Promise<void>;

  autoLevel(): void;

  autoLevelAsync(): Promise<void>;

  autoLevelChannel(channel_: MagickCore.ChannelType): void;

  autoLevelChannelAsync(channel_: MagickCore.ChannelType): Promise<void>;

  autoOrient(): void;

  autoOrientAsync(): Promise<void>;

  autoThreshold(method_: any): void;

  autoThresholdAsync(method_: any): Promise<void>;

  blackThreshold(threshold_: string): void;

  blackThresholdAsync(threshold_: string): Promise<void>;

  blackThresholdChannel(channel_: MagickCore.ChannelType, threshold_: string): void;

  blackThresholdChannelAsync(channel_: MagickCore.ChannelType, threshold_: string): Promise<void>;

  blueShift(factor_: number): void;

  blueShiftAsync(factor_: number): Promise<void>;

  blueShift(): void;

  blueShiftAsync(): Promise<void>;

  blur(radius_: number, sigma_: number): void;

  blurAsync(radius_: number, sigma_: number): Promise<void>;

  blur(radius_: number): void;

  blurAsync(radius_: number): Promise<void>;

  blur(): void;

  blurAsync(): Promise<void>;

  blurChannel(channel_: MagickCore.ChannelType, radius_: number, sigma_: number): void;

  blurChannelAsync(channel_: MagickCore.ChannelType, radius_: number, sigma_: number): Promise<void>;

  blurChannel(channel_: MagickCore.ChannelType, radius_: number): void;

  blurChannelAsync(channel_: MagickCore.ChannelType, radius_: number): Promise<void>;

  blurChannel(channel_: MagickCore.ChannelType): void;

  blurChannelAsync(channel_: MagickCore.ChannelType): Promise<void>;

  border(geometry_: Magick.Geometry | string): void;

  borderAsync(geometry_: Magick.Geometry | string): Promise<void>;

  border(): void;

  borderAsync(): Promise<void>;

  brightnessContrast(brightness_: number, contrast_: number): void;

  brightnessContrastAsync(brightness_: number, contrast_: number): Promise<void>;

  brightnessContrast(brightness_: number): void;

  brightnessContrastAsync(brightness_: number): Promise<void>;

  brightnessContrast(): void;

  brightnessContrastAsync(): Promise<void>;

  brightnessContrastChannel(channel_: MagickCore.ChannelType, brightness_: number, contrast_: number): void;

  brightnessContrastChannelAsync(channel_: MagickCore.ChannelType, brightness_: number, contrast_: number): Promise<void>;

  brightnessContrastChannel(channel_: MagickCore.ChannelType, brightness_: number): void;

  brightnessContrastChannelAsync(channel_: MagickCore.ChannelType, brightness_: number): Promise<void>;

  brightnessContrastChannel(channel_: MagickCore.ChannelType): void;

  brightnessContrastChannelAsync(channel_: MagickCore.ChannelType): Promise<void>;

  cannyEdge(radius_: number, sigma_: number, lowerPercent_: number, upperPercent_: number): void;

  cannyEdgeAsync(radius_: number, sigma_: number, lowerPercent_: number, upperPercent_: number): Promise<void>;

  cannyEdge(radius_: number, sigma_: number, lowerPercent_: number): void;

  cannyEdgeAsync(radius_: number, sigma_: number, lowerPercent_: number): Promise<void>;

  cannyEdge(radius_: number, sigma_: number): void;

  cannyEdgeAsync(radius_: number, sigma_: number): Promise<void>;

  cannyEdge(radius_: number): void;

  cannyEdgeAsync(radius_: number): Promise<void>;

  cannyEdge(): void;

  cannyEdgeAsync(): Promise<void>;

  cdl(cdl_: string): void;

  cdlAsync(cdl_: string): Promise<void>;

  channel(channel_: MagickCore.ChannelType): void;

  channelAsync(channel_: MagickCore.ChannelType): Promise<void>;

  charcoal(radius_: number, sigma_: number): void;

  charcoalAsync(radius_: number, sigma_: number): Promise<void>;

  charcoal(radius_: number): void;

  charcoalAsync(radius_: number): Promise<void>;

  charcoal(): void;

  charcoalAsync(): Promise<void>;

  charcoalChannel(channel_: MagickCore.ChannelType, radius_: number, sigma_: number): void;

  charcoalChannelAsync(channel_: MagickCore.ChannelType, radius_: number, sigma_: number): Promise<void>;

  charcoalChannel(channel_: MagickCore.ChannelType, radius_: number): void;

  charcoalChannelAsync(channel_: MagickCore.ChannelType, radius_: number): Promise<void>;

  charcoalChannel(channel_: MagickCore.ChannelType): void;

  charcoalChannelAsync(channel_: MagickCore.ChannelType): Promise<void>;

  chop(geometry_: Magick.Geometry | string): void;

  chopAsync(geometry_: Magick.Geometry | string): Promise<void>;

  chromaBluePrimary(x_: number, y_: number, z_: number): void;

  chromaBluePrimaryAsync(x_: number, y_: number, z_: number): Promise<void>;

  chromaBluePrimary(x_: any, y_: any, z_: any): void;

  chromaBluePrimaryAsync(x_: any, y_: any, z_: any): Promise<void>;

  chromaGreenPrimary(x_: number, y_: number, z_: number): void;

  chromaGreenPrimaryAsync(x_: number, y_: number, z_: number): Promise<void>;

  chromaGreenPrimary(x_: any, y_: any, z_: any): void;

  chromaGreenPrimaryAsync(x_: any, y_: any, z_: any): Promise<void>;

  chromaRedPrimary(x_: number, y_: number, z_: number): void;

  chromaRedPrimaryAsync(x_: number, y_: number, z_: number): Promise<void>;

  chromaRedPrimary(x_: any, y_: any, z_: any): void;

  chromaRedPrimaryAsync(x_: any, y_: any, z_: any): Promise<void>;

  chromaWhitePoint(x_: number, y_: number, z_: number): void;

  chromaWhitePointAsync(x_: number, y_: number, z_: number): Promise<void>;

  chromaWhitePoint(x_: any, y_: any, z_: any): void;

  chromaWhitePointAsync(x_: any, y_: any, z_: any): Promise<void>;

  clamp(): void;

  clampAsync(): Promise<void>;

  clampChannel(channel_: MagickCore.ChannelType): void;

  clampChannelAsync(channel_: MagickCore.ChannelType): Promise<void>;

  clip(): void;

  clipAsync(): Promise<void>;

  clipPath(pathname_: string, inside_: boolean): void;

  clipPathAsync(pathname_: string, inside_: boolean): Promise<void>;

  clut(clutImage_: Magick.Image, method: any): void;

  clutAsync(clutImage_: Magick.Image, method: any): Promise<void>;

  clutChannel(channel_: MagickCore.ChannelType, clutImage_: Magick.Image, method: any): void;

  clutChannelAsync(channel_: MagickCore.ChannelType, clutImage_: Magick.Image, method: any): Promise<void>;

  colorize(alpha_: number, penColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  colorizeAsync(alpha_: number, penColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  colorize(alphaRed_: number, alphaGreen_: number, alphaBlue_: number, penColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  colorizeAsync(alphaRed_: number, alphaGreen_: number, alphaBlue_: number, penColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  colorMap(index_: number, color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  colorMapAsync(index_: number, color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  colorMap(index_: number): Magick.Color;

  colorMapAsync(index_: number): Promise<Magick.Color>;

  colorMatrix(order_: number, color_matrix_: any): void;

  colorMatrixAsync(order_: number, color_matrix_: any): Promise<void>;

  compare(reference_: Magick.Image): boolean;

  compareAsync(reference_: Magick.Image): Promise<boolean>;

  compare(reference_: Magick.Image, metric_: MagickCore.MetricType): number;

  compareAsync(reference_: Magick.Image, metric_: MagickCore.MetricType): Promise<number>;

  compareChannel(channel_: MagickCore.ChannelType, reference_: Magick.Image, metric_: MagickCore.MetricType): number;

  compareChannelAsync(channel_: MagickCore.ChannelType, reference_: Magick.Image, metric_: MagickCore.MetricType): Promise<number>;

  compare(reference_: Magick.Image, metric_: MagickCore.MetricType, distortion: any): Magick.Image;

  compareAsync(reference_: Magick.Image, metric_: MagickCore.MetricType, distortion: any): Promise<Magick.Image>;

  compareChannel(channel_: MagickCore.ChannelType, reference_: Magick.Image, metric_: MagickCore.MetricType, distortion: any): Magick.Image;

  compareChannelAsync(channel_: MagickCore.ChannelType, reference_: Magick.Image, metric_: MagickCore.MetricType, distortion: any): Promise<Magick.Image>;

  composite(compositeImage_: Magick.Image, offset_: Magick.Geometry | string, compose_: MagickCore.CompositeOperator): void;

  compositeAsync(compositeImage_: Magick.Image, offset_: Magick.Geometry | string, compose_: MagickCore.CompositeOperator): Promise<void>;

  composite(compositeImage_: Magick.Image, offset_: Magick.Geometry | string): void;

  compositeAsync(compositeImage_: Magick.Image, offset_: Magick.Geometry | string): Promise<void>;

  composite(compositeImage_: Magick.Image, gravity_: MagickCore.GravityType, compose_: MagickCore.CompositeOperator): void;

  compositeAsync(compositeImage_: Magick.Image, gravity_: MagickCore.GravityType, compose_: MagickCore.CompositeOperator): Promise<void>;

  composite(compositeImage_: Magick.Image, gravity_: MagickCore.GravityType): void;

  compositeAsync(compositeImage_: Magick.Image, gravity_: MagickCore.GravityType): Promise<void>;

  composite(compositeImage_: Magick.Image, xOffset_: number, yOffset_: number, compose_: MagickCore.CompositeOperator): void;

  compositeAsync(compositeImage_: Magick.Image, xOffset_: number, yOffset_: number, compose_: MagickCore.CompositeOperator): Promise<void>;

  composite(compositeImage_: Magick.Image, xOffset_: number, yOffset_: number): void;

  compositeAsync(compositeImage_: Magick.Image, xOffset_: number, yOffset_: number): Promise<void>;

  connectedComponents(connectivity_: number): void;

  connectedComponentsAsync(connectivity_: number): Promise<void>;

  contrast(sharpen_: boolean): void;

  contrastAsync(sharpen_: boolean): Promise<void>;

  contrastStretch(blackPoint_: number, whitePoint_: number): void;

  contrastStretchAsync(blackPoint_: number, whitePoint_: number): Promise<void>;

  contrastStretchChannel(channel_: MagickCore.ChannelType, blackPoint_: number, whitePoint_: number): void;

  contrastStretchChannelAsync(channel_: MagickCore.ChannelType, blackPoint_: number, whitePoint_: number): Promise<void>;

  convolve(order_: number, kernel_: any): void;

  convolveAsync(order_: number, kernel_: any): Promise<void>;

  copyPixels(source_: Magick.Image, geometry_: Magick.Geometry | string, offset_: Magick.Offset): void;

  copyPixelsAsync(source_: Magick.Image, geometry_: Magick.Geometry | string, offset_: Magick.Offset): Promise<void>;

  crop(geometry_: Magick.Geometry | string): void;

  cropAsync(geometry_: Magick.Geometry | string): Promise<void>;

  cycleColormap(amount_: number): void;

  cycleColormapAsync(amount_: number): Promise<void>;

  decipher(passphrase_: string): void;

  decipherAsync(passphrase_: string): Promise<void>;

  defineSet(magick_: string, key_: string, flag_: boolean): void;

  defineSetAsync(magick_: string, key_: string, flag_: boolean): Promise<void>;

  defineSet(magick_: string, key_: string): boolean;

  defineSetAsync(magick_: string, key_: string): Promise<boolean>;

  defineValue(magick_: string, key_: string, value_: string): void;

  defineValueAsync(magick_: string, key_: string, value_: string): Promise<void>;

  defineValue(magick_: string, key_: string): string;

  defineValueAsync(magick_: string, key_: string): Promise<string>;

  deskew(threshold_: number): void;

  deskewAsync(threshold_: number): Promise<void>;

  despeckle(): void;

  despeckleAsync(): Promise<void>;

  display(): void;

  displayAsync(): Promise<void>;

  distort(method_: any, numberArguments_: number, arguments_: any, bestfit_: boolean): void;

  distortAsync(method_: any, numberArguments_: number, arguments_: any, bestfit_: boolean): Promise<void>;

  distort(method_: any, numberArguments_: number, arguments_: any): void;

  distortAsync(method_: any, numberArguments_: number, arguments_: any): Promise<void>;

  draw(drawable_: Magick.DrawableBase): void;

  drawAsync(drawable_: Magick.DrawableBase): Promise<void>;

  draw(drawable_: Magick.DrawableBase[]): void;

  drawAsync(drawable_: Magick.DrawableBase[]): Promise<void>;

  edge(radius_: number): void;

  edgeAsync(radius_: number): Promise<void>;

  edge(): void;

  edgeAsync(): Promise<void>;

  emboss(radius_: number, sigma_: number): void;

  embossAsync(radius_: number, sigma_: number): Promise<void>;

  emboss(radius_: number): void;

  embossAsync(radius_: number): Promise<void>;

  emboss(): void;

  embossAsync(): Promise<void>;

  encipher(passphrase_: string): void;

  encipherAsync(passphrase_: string): Promise<void>;

  enhance(): void;

  enhanceAsync(): Promise<void>;

  equalize(): void;

  equalizeAsync(): Promise<void>;

  erase(): void;

  eraseAsync(): Promise<void>;

  evaluate(channel_: MagickCore.ChannelType, operator_: MagickCore.MagickEvaluateOperator, rvalue_: number): void;

  evaluateAsync(channel_: MagickCore.ChannelType, operator_: MagickCore.MagickEvaluateOperator, rvalue_: number): Promise<void>;

  evaluate(channel_: MagickCore.ChannelType, function_: any, number_parameters_: number, parameters_: any): void;

  evaluateAsync(channel_: MagickCore.ChannelType, function_: any, number_parameters_: number, parameters_: any): Promise<void>;

  evaluate(channel_: MagickCore.ChannelType, x_: number, y_: number, columns_: number, rows_: number, operator_: MagickCore.MagickEvaluateOperator, rvalue_: number): void;

  evaluateAsync(channel_: MagickCore.ChannelType, x_: number, y_: number, columns_: number, rows_: number, operator_: MagickCore.MagickEvaluateOperator, rvalue_: number): Promise<void>;

  extent(geometry_: Magick.Geometry | string): void;

  extentAsync(geometry_: Magick.Geometry | string): Promise<void>;

  extent(geometry_: Magick.Geometry | string, backgroundColor: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  extentAsync(geometry_: Magick.Geometry | string, backgroundColor: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  extent(geometry_: Magick.Geometry | string, backgroundColor: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, gravity_: MagickCore.GravityType): void;

  extentAsync(geometry_: Magick.Geometry | string, backgroundColor: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, gravity_: MagickCore.GravityType): Promise<void>;

  extent(geometry_: Magick.Geometry | string, gravity_: MagickCore.GravityType): void;

  extentAsync(geometry_: Magick.Geometry | string, gravity_: MagickCore.GravityType): Promise<void>;

  flip(): void;

  flipAsync(): Promise<void>;

  floodFillAlpha(x_: number, y_: number, alpha_: number, invert_: boolean): void;

  floodFillAlphaAsync(x_: number, y_: number, alpha_: number, invert_: boolean): Promise<void>;

  floodFillAlpha(x_: number, y_: number, alpha_: number): void;

  floodFillAlphaAsync(x_: number, y_: number, alpha_: number): Promise<void>;

  floodFillAlpha(x_: number, y_: number, alpha_: number, target_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean): void;

  floodFillAlphaAsync(x_: number, y_: number, alpha_: number, target_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean): Promise<void>;

  floodFillAlpha(x_: number, y_: number, alpha_: number, target_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  floodFillAlphaAsync(x_: number, y_: number, alpha_: number, target_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  floodFillColor(point_: Magick.Geometry, fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean): void;

  floodFillColorAsync(point_: Magick.Geometry, fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean): Promise<void>;

  floodFillColor(point_: Magick.Geometry, fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  floodFillColorAsync(point_: Magick.Geometry, fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  floodFillColor(x_: number, y_: number, fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean): void;

  floodFillColorAsync(x_: number, y_: number, fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean): Promise<void>;

  floodFillColor(x_: number, y_: number, fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  floodFillColorAsync(x_: number, y_: number, fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  floodFillColor(point_: Magick.Geometry, fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, borderColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean): void;

  floodFillColorAsync(point_: Magick.Geometry, fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, borderColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean): Promise<void>;

  floodFillColor(point_: Magick.Geometry, fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, borderColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  floodFillColorAsync(point_: Magick.Geometry, fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, borderColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  floodFillColor(x_: number, y_: number, fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, borderColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean): void;

  floodFillColorAsync(x_: number, y_: number, fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, borderColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean): Promise<void>;

  floodFillColor(x_: number, y_: number, fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, borderColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  floodFillColorAsync(x_: number, y_: number, fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, borderColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  floodFillTexture(point_: Magick.Geometry, texture_: Magick.Image, invert_: boolean): void;

  floodFillTextureAsync(point_: Magick.Geometry, texture_: Magick.Image, invert_: boolean): Promise<void>;

  floodFillTexture(point_: Magick.Geometry, texture_: Magick.Image): void;

  floodFillTextureAsync(point_: Magick.Geometry, texture_: Magick.Image): Promise<void>;

  floodFillTexture(x_: number, y_: number, texture_: Magick.Image, invert_: boolean): void;

  floodFillTextureAsync(x_: number, y_: number, texture_: Magick.Image, invert_: boolean): Promise<void>;

  floodFillTexture(x_: number, y_: number, texture_: Magick.Image): void;

  floodFillTextureAsync(x_: number, y_: number, texture_: Magick.Image): Promise<void>;

  floodFillTexture(point_: Magick.Geometry, texture_: Magick.Image, borderColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean): void;

  floodFillTextureAsync(point_: Magick.Geometry, texture_: Magick.Image, borderColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean): Promise<void>;

  floodFillTexture(point_: Magick.Geometry, texture_: Magick.Image, borderColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  floodFillTextureAsync(point_: Magick.Geometry, texture_: Magick.Image, borderColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  floodFillTexture(x_: number, y_: number, texture_: Magick.Image, borderColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean): void;

  floodFillTextureAsync(x_: number, y_: number, texture_: Magick.Image, borderColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean): Promise<void>;

  floodFillTexture(x_: number, y_: number, texture_: Magick.Image, borderColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  floodFillTextureAsync(x_: number, y_: number, texture_: Magick.Image, borderColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  flop(): void;

  flopAsync(): Promise<void>;

  fontTypeMetrics(text_: string, metrics: Magick.TypeMetric): void;

  fontTypeMetricsAsync(text_: string, metrics: Magick.TypeMetric): Promise<void>;

  fontTypeMetricsMultiline(text_: string, metrics: Magick.TypeMetric): void;

  fontTypeMetricsMultilineAsync(text_: string, metrics: Magick.TypeMetric): Promise<void>;

  frame(geometry_: Magick.Geometry | string): void;

  frameAsync(geometry_: Magick.Geometry | string): Promise<void>;

  frame(): void;

  frameAsync(): Promise<void>;

  frame(width_: number, height_: number, innerBevel_: number, outerBevel_: number): void;

  frameAsync(width_: number, height_: number, innerBevel_: number, outerBevel_: number): Promise<void>;

  frame(width_: number, height_: number, innerBevel_: number): void;

  frameAsync(width_: number, height_: number, innerBevel_: number): Promise<void>;

  frame(width_: number, height_: number): void;

  frameAsync(width_: number, height_: number): Promise<void>;

  fx(expression_: string): void;

  fxAsync(expression_: string): Promise<void>;

  fx(expression_: string, channel_: MagickCore.ChannelType): void;

  fxAsync(expression_: string, channel_: MagickCore.ChannelType): Promise<void>;

  gamma(gamma_: number): void;

  gammaAsync(gamma_: number): Promise<void>;

  gamma(gammaRed_: number, gammaGreen_: number, gammaBlue_: number): void;

  gammaAsync(gammaRed_: number, gammaGreen_: number, gammaBlue_: number): Promise<void>;

  gaussianBlur(radius_: number, sigma_: number): void;

  gaussianBlurAsync(radius_: number, sigma_: number): Promise<void>;

  gaussianBlurChannel(channel_: MagickCore.ChannelType, radius_: number, sigma_: number): void;

  gaussianBlurChannelAsync(channel_: MagickCore.ChannelType, radius_: number, sigma_: number): Promise<void>;

  getConstPixels(x_: number, y_: number, columns_: number, rows_: number): any;

  getConstPixelsAsync(x_: number, y_: number, columns_: number, rows_: number): Promise<any>;

  getConstMetacontent(): any;

  getConstMetacontentAsync(): Promise<any>;

  getMetacontent(): any;

  getMetacontentAsync(): Promise<any>;

  getPixels(x_: number, y_: number, columns_: number, rows_: number): any;

  getPixelsAsync(x_: number, y_: number, columns_: number, rows_: number): Promise<any>;

  grayscale(method_: any): void;

  grayscaleAsync(method_: any): Promise<void>;

  haldClut(clutImage_: Magick.Image): void;

  haldClutAsync(clutImage_: Magick.Image): Promise<void>;

  houghLine(width_: number, height_: number, threshold_: number): void;

  houghLineAsync(width_: number, height_: number, threshold_: number): Promise<void>;

  houghLine(width_: number, height_: number): void;

  houghLineAsync(width_: number, height_: number): Promise<void>;

  identifyType(): MagickCore.ImageType;

  identifyTypeAsync(): Promise<MagickCore.ImageType>;

  implode(factor_: number): void;

  implodeAsync(factor_: number): Promise<void>;

  inverseFourierTransform(phase_: Magick.Image): void;

  inverseFourierTransformAsync(phase_: Magick.Image): Promise<void>;

  inverseFourierTransform(phase_: Magick.Image, magnitude_: boolean): void;

  inverseFourierTransformAsync(phase_: Magick.Image, magnitude_: boolean): Promise<void>;

  kuwahara(radius_: number, sigma_: number): void;

  kuwaharaAsync(radius_: number, sigma_: number): Promise<void>;

  kuwahara(radius_: number): void;

  kuwaharaAsync(radius_: number): Promise<void>;

  kuwahara(): void;

  kuwaharaAsync(): Promise<void>;

  kuwaharaChannel(channel_: MagickCore.ChannelType, radius_: number, sigma_: number): void;

  kuwaharaChannelAsync(channel_: MagickCore.ChannelType, radius_: number, sigma_: number): Promise<void>;

  kuwaharaChannel(channel_: MagickCore.ChannelType, radius_: number): void;

  kuwaharaChannelAsync(channel_: MagickCore.ChannelType, radius_: number): Promise<void>;

  kuwaharaChannel(channel_: MagickCore.ChannelType): void;

  kuwaharaChannelAsync(channel_: MagickCore.ChannelType): Promise<void>;

  level(blackPoint_: number, whitePoint_: number, gamma_: number): void;

  levelAsync(blackPoint_: number, whitePoint_: number, gamma_: number): Promise<void>;

  level(blackPoint_: number, whitePoint_: number): void;

  levelAsync(blackPoint_: number, whitePoint_: number): Promise<void>;

  levelChannel(channel_: MagickCore.ChannelType, blackPoint_: number, whitePoint_: number, gamma_: number): void;

  levelChannelAsync(channel_: MagickCore.ChannelType, blackPoint_: number, whitePoint_: number, gamma_: number): Promise<void>;

  levelChannel(channel_: MagickCore.ChannelType, blackPoint_: number, whitePoint_: number): void;

  levelChannelAsync(channel_: MagickCore.ChannelType, blackPoint_: number, whitePoint_: number): Promise<void>;

  levelColors(blackColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, whiteColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean): void;

  levelColorsAsync(blackColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, whiteColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean): Promise<void>;

  levelColors(blackColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, whiteColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  levelColorsAsync(blackColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, whiteColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  levelColorsChannel(channel_: MagickCore.ChannelType, blackColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, whiteColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean): void;

  levelColorsChannelAsync(channel_: MagickCore.ChannelType, blackColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, whiteColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean): Promise<void>;

  levelColorsChannel(channel_: MagickCore.ChannelType, blackColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, whiteColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  levelColorsChannelAsync(channel_: MagickCore.ChannelType, blackColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, whiteColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  levelize(blackPoint_: number, whitePoint_: number, gamma_: number): void;

  levelizeAsync(blackPoint_: number, whitePoint_: number, gamma_: number): Promise<void>;

  levelize(blackPoint_: number, whitePoint_: number): void;

  levelizeAsync(blackPoint_: number, whitePoint_: number): Promise<void>;

  levelizeChannel(channel_: MagickCore.ChannelType, blackPoint_: number, whitePoint_: number, gamma_: number): void;

  levelizeChannelAsync(channel_: MagickCore.ChannelType, blackPoint_: number, whitePoint_: number, gamma_: number): Promise<void>;

  levelizeChannel(channel_: MagickCore.ChannelType, blackPoint_: number, whitePoint_: number): void;

  levelizeChannelAsync(channel_: MagickCore.ChannelType, blackPoint_: number, whitePoint_: number): Promise<void>;

  linearStretch(blackPoint_: number, whitePoint_: number): void;

  linearStretchAsync(blackPoint_: number, whitePoint_: number): Promise<void>;

  liquidRescale(geometry_: Magick.Geometry | string): void;

  liquidRescaleAsync(geometry_: Magick.Geometry | string): Promise<void>;

  localContrast(radius_: number, strength_: number): void;

  localContrastAsync(radius_: number, strength_: number): Promise<void>;

  localContrastChannel(channel_: MagickCore.ChannelType, radius_: number, strength_: number): void;

  localContrastChannelAsync(channel_: MagickCore.ChannelType, radius_: number, strength_: number): Promise<void>;

  magnify(): void;

  magnifyAsync(): Promise<void>;

  map(mapImage_: Magick.Image, dither_: boolean): void;

  mapAsync(mapImage_: Magick.Image, dither_: boolean): Promise<void>;

  map(mapImage_: Magick.Image): void;

  mapAsync(mapImage_: Magick.Image): Promise<void>;

  meanShift(width_: number, height_: number, color_distance_: number): void;

  meanShiftAsync(width_: number, height_: number, color_distance_: number): Promise<void>;

  medianFilter(radius_: number): void;

  medianFilterAsync(radius_: number): Promise<void>;

  medianFilter(): void;

  medianFilterAsync(): Promise<void>;

  minify(): void;

  minifyAsync(): Promise<void>;

  modulate(brightness_: number, saturation_: number, hue_: number): void;

  modulateAsync(brightness_: number, saturation_: number, hue_: number): Promise<void>;

  moments(): Magick.ImageMoments;

  momentsAsync(): Promise<Magick.ImageMoments>;

  morphology(method_: any, kernel_: string, iterations_: number): void;

  morphologyAsync(method_: any, kernel_: string, iterations_: number): Promise<void>;

  morphology(method_: any, kernel_: string): void;

  morphologyAsync(method_: any, kernel_: string): Promise<void>;

  morphology(method_: any, kernel_: MagickCore.KernelInfoType, arguments_: string, iterations_: number): void;

  morphologyAsync(method_: any, kernel_: MagickCore.KernelInfoType, arguments_: string, iterations_: number): Promise<void>;

  morphology(method_: any, kernel_: MagickCore.KernelInfoType, arguments_: string): void;

  morphologyAsync(method_: any, kernel_: MagickCore.KernelInfoType, arguments_: string): Promise<void>;

  morphologyChannel(channel_: MagickCore.ChannelType, method_: any, kernel_: string, iterations_: number): void;

  morphologyChannelAsync(channel_: MagickCore.ChannelType, method_: any, kernel_: string, iterations_: number): Promise<void>;

  morphologyChannel(channel_: MagickCore.ChannelType, method_: any, kernel_: string): void;

  morphologyChannelAsync(channel_: MagickCore.ChannelType, method_: any, kernel_: string): Promise<void>;

  morphologyChannel(channel_: MagickCore.ChannelType, method_: any, kernel_: MagickCore.KernelInfoType, arguments_: string, iterations_: number): void;

  morphologyChannelAsync(channel_: MagickCore.ChannelType, method_: any, kernel_: MagickCore.KernelInfoType, arguments_: string, iterations_: number): Promise<void>;

  morphologyChannel(channel_: MagickCore.ChannelType, method_: any, kernel_: MagickCore.KernelInfoType, arguments_: string): void;

  morphologyChannelAsync(channel_: MagickCore.ChannelType, method_: any, kernel_: MagickCore.KernelInfoType, arguments_: string): Promise<void>;

  motionBlur(radius_: number, sigma_: number, angle_: number): void;

  motionBlurAsync(radius_: number, sigma_: number, angle_: number): Promise<void>;

  negate(grayscale_: boolean): void;

  negateAsync(grayscale_: boolean): Promise<void>;

  negate(): void;

  negateAsync(): Promise<void>;

  negateChannel(channel_: MagickCore.ChannelType, grayscale_: boolean): void;

  negateChannelAsync(channel_: MagickCore.ChannelType, grayscale_: boolean): Promise<void>;

  negateChannel(channel_: MagickCore.ChannelType): void;

  negateChannelAsync(channel_: MagickCore.ChannelType): Promise<void>;

  normalize(): void;

  normalizeAsync(): Promise<void>;

  oilPaint(radius_: number, sigma: number): void;

  oilPaintAsync(radius_: number, sigma: number): Promise<void>;

  oilPaint(radius_: number): void;

  oilPaintAsync(radius_: number): Promise<void>;

  oilPaint(): void;

  oilPaintAsync(): Promise<void>;

  opaque(opaqueColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, penColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean): void;

  opaqueAsync(opaqueColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, penColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean): Promise<void>;

  opaque(opaqueColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, penColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  opaqueAsync(opaqueColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, penColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  orderedDither(thresholdMap_: string): void;

  orderedDitherAsync(thresholdMap_: string): Promise<void>;

  orderedDitherChannel(channel_: MagickCore.ChannelType, thresholdMap_: string): void;

  orderedDitherChannelAsync(channel_: MagickCore.ChannelType, thresholdMap_: string): Promise<void>;

  perceptible(epsilon_: number): void;

  perceptibleAsync(epsilon_: number): Promise<void>;

  perceptibleChannel(channel_: MagickCore.ChannelType, epsilon_: number): void;

  perceptibleChannelAsync(channel_: MagickCore.ChannelType, epsilon_: number): Promise<void>;

  perceptualHash(): Magick.ImagePerceptualHash;

  perceptualHashAsync(): Promise<Magick.ImagePerceptualHash>;

  ping(imageSpec_: string): void;

  pingAsync(imageSpec_: string): Promise<void>;

  ping(blob_: Magick.Blob): void;

  pingAsync(blob_: Magick.Blob): Promise<void>;

  pixelColor(x_: number, y_: number, color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  pixelColorAsync(x_: number, y_: number, color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  pixelColor(x_: number, y_: number): Magick.Color;

  pixelColorAsync(x_: number, y_: number): Promise<Magick.Color>;

  polaroid(caption_: string, angle_: number, method_: any): void;

  polaroidAsync(caption_: string, angle_: number, method_: any): Promise<void>;

  posterize(levels_: number, method_: any): void;

  posterizeAsync(levels_: number, method_: any): Promise<void>;

  posterizeChannel(channel_: MagickCore.ChannelType, levels_: number, method_: any): void;

  posterizeChannelAsync(channel_: MagickCore.ChannelType, levels_: number, method_: any): Promise<void>;

  process(name_: string, argc_: number, argv_: any): void;

  processAsync(name_: string, argc_: number, argv_: any): Promise<void>;

  profile(name_: string, colorProfile_: Magick.Blob): void;

  profileAsync(name_: string, colorProfile_: Magick.Blob): Promise<void>;

  profile(name_: string): Magick.Blob;

  profileAsync(name_: string): Promise<Magick.Blob>;

  quantize(measureError_: boolean): void;

  quantizeAsync(measureError_: boolean): Promise<void>;

  quantize(): void;

  quantizeAsync(): Promise<void>;

  raise(geometry_: Magick.Geometry | string, raisedFlag_: boolean): void;

  raiseAsync(geometry_: Magick.Geometry | string, raisedFlag_: boolean): Promise<void>;

  raise(geometry_: Magick.Geometry | string): void;

  raiseAsync(geometry_: Magick.Geometry | string): Promise<void>;

  raise(): void;

  raiseAsync(): Promise<void>;

  randomThreshold(low_: number, high_: number): void;

  randomThresholdAsync(low_: number, high_: number): Promise<void>;

  randomThresholdChannel(channel_: MagickCore.ChannelType, low_: number, high_: number): void;

  randomThresholdChannelAsync(channel_: MagickCore.ChannelType, low_: number, high_: number): Promise<void>;

  read(blob_: Magick.Blob): void;

  readAsync(blob_: Magick.Blob): Promise<void>;

  read(blob_: Magick.Blob, size_: Magick.Geometry | string): void;

  readAsync(blob_: Magick.Blob, size_: Magick.Geometry | string): Promise<void>;

  read(blob_: Magick.Blob, size_: Magick.Geometry | string, depth_: number): void;

  readAsync(blob_: Magick.Blob, size_: Magick.Geometry | string, depth_: number): Promise<void>;

  read(blob_: Magick.Blob, size_: Magick.Geometry | string, depth_: number, magick_: string): void;

  readAsync(blob_: Magick.Blob, size_: Magick.Geometry | string, depth_: number, magick_: string): Promise<void>;

  read(blob_: Magick.Blob, size_: Magick.Geometry | string, magick_: string): void;

  readAsync(blob_: Magick.Blob, size_: Magick.Geometry | string, magick_: string): Promise<void>;

  read(size_: Magick.Geometry | string, imageSpec_: string): void;

  readAsync(size_: Magick.Geometry | string, imageSpec_: string): Promise<void>;

  read(width_: number, height_: number, map_: string, type_: Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array | Float32Array | Float64Array | BigUint64Array): void;

  readAsync(width_: number, height_: number, map_: string, type_: Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array | Float32Array | Float64Array | BigUint64Array): Promise<void>;

  read(imageSpec_: string): void;

  readAsync(imageSpec_: string): Promise<void>;

  readMask(mask_: Magick.Image): void;

  readMaskAsync(mask_: Magick.Image): Promise<void>;

  readMask(): Magick.Image;

  readMaskAsync(): Promise<Magick.Image>;

  readPixels(quantum_: MagickCore.QuantumType, source_: any): void;

  readPixelsAsync(quantum_: MagickCore.QuantumType, source_: any): Promise<void>;

  reduceNoise(): void;

  reduceNoiseAsync(): Promise<void>;

  reduceNoise(order_: number): void;

  reduceNoiseAsync(order_: number): Promise<void>;

  repage(): void;

  repageAsync(): Promise<void>;

  resample(density_: Magick.Point): void;

  resampleAsync(density_: Magick.Point): Promise<void>;

  resize(geometry_: Magick.Geometry | string): void;

  resizeAsync(geometry_: Magick.Geometry | string): Promise<void>;

  roll(roll_: Magick.Geometry): void;

  rollAsync(roll_: Magick.Geometry): Promise<void>;

  roll(columns_: number, rows_: number): void;

  rollAsync(columns_: number, rows_: number): Promise<void>;

  rotate(degrees_: number): void;

  rotateAsync(degrees_: number): Promise<void>;

  rotationalBlur(angle_: number): void;

  rotationalBlurAsync(angle_: number): Promise<void>;

  rotationalBlurChannel(channel_: MagickCore.ChannelType, angle_: number): void;

  rotationalBlurChannelAsync(channel_: MagickCore.ChannelType, angle_: number): Promise<void>;

  sample(geometry_: Magick.Geometry | string): void;

  sampleAsync(geometry_: Magick.Geometry | string): Promise<void>;

  scale(geometry_: Magick.Geometry | string): void;

  scaleAsync(geometry_: Magick.Geometry | string): Promise<void>;

  segment(clusterThreshold_: number, smoothingThreshold_: number): void;

  segmentAsync(clusterThreshold_: number, smoothingThreshold_: number): Promise<void>;

  segment(clusterThreshold_: number): void;

  segmentAsync(clusterThreshold_: number): Promise<void>;

  segment(): void;

  segmentAsync(): Promise<void>;

  selectiveBlur(radius_: number, sigma_: number, threshold_: number): void;

  selectiveBlurAsync(radius_: number, sigma_: number, threshold_: number): Promise<void>;

  selectiveBlurChannel(channel_: MagickCore.ChannelType, radius_: number, sigma_: number, threshold_: number): void;

  selectiveBlurChannelAsync(channel_: MagickCore.ChannelType, radius_: number, sigma_: number, threshold_: number): Promise<void>;

  separate(channel_: MagickCore.ChannelType): Magick.Image;

  separateAsync(channel_: MagickCore.ChannelType): Promise<Magick.Image>;

  sepiaTone(threshold_: number): void;

  sepiaToneAsync(threshold_: number): Promise<void>;

  setColorMetric(reference_: Magick.Image): boolean;

  setColorMetricAsync(reference_: Magick.Image): Promise<boolean>;

  setPixels(x_: number, y_: number, columns_: number, rows_: number): any;

  setPixelsAsync(x_: number, y_: number, columns_: number, rows_: number): Promise<any>;

  shade(azimuth_: number, elevation_: number, colorShading_: boolean): void;

  shadeAsync(azimuth_: number, elevation_: number, colorShading_: boolean): Promise<void>;

  shade(azimuth_: number, elevation_: number): void;

  shadeAsync(azimuth_: number, elevation_: number): Promise<void>;

  shade(azimuth_: number): void;

  shadeAsync(azimuth_: number): Promise<void>;

  shade(): void;

  shadeAsync(): Promise<void>;

  shadow(percentAlpha_: number, sigma_: number, x_: number, y_: number): void;

  shadowAsync(percentAlpha_: number, sigma_: number, x_: number, y_: number): Promise<void>;

  shadow(percentAlpha_: number, sigma_: number, x_: number): void;

  shadowAsync(percentAlpha_: number, sigma_: number, x_: number): Promise<void>;

  shadow(percentAlpha_: number, sigma_: number): void;

  shadowAsync(percentAlpha_: number, sigma_: number): Promise<void>;

  shadow(percentAlpha_: number): void;

  shadowAsync(percentAlpha_: number): Promise<void>;

  shadow(): void;

  shadowAsync(): Promise<void>;

  sharpen(radius_: number, sigma_: number): void;

  sharpenAsync(radius_: number, sigma_: number): Promise<void>;

  sharpen(radius_: number): void;

  sharpenAsync(radius_: number): Promise<void>;

  sharpen(): void;

  sharpenAsync(): Promise<void>;

  sharpenChannel(channel_: MagickCore.ChannelType, radius_: number, sigma_: number): void;

  sharpenChannelAsync(channel_: MagickCore.ChannelType, radius_: number, sigma_: number): Promise<void>;

  sharpenChannel(channel_: MagickCore.ChannelType, radius_: number): void;

  sharpenChannelAsync(channel_: MagickCore.ChannelType, radius_: number): Promise<void>;

  sharpenChannel(channel_: MagickCore.ChannelType): void;

  sharpenChannelAsync(channel_: MagickCore.ChannelType): Promise<void>;

  shave(geometry_: Magick.Geometry | string): void;

  shaveAsync(geometry_: Magick.Geometry | string): Promise<void>;

  shear(xShearAngle_: number, yShearAngle_: number): void;

  shearAsync(xShearAngle_: number, yShearAngle_: number): Promise<void>;

  sigmoidalContrast(sharpen_: boolean, contrast: number, midpoint: number): void;

  sigmoidalContrastAsync(sharpen_: boolean, contrast: number, midpoint: number): Promise<void>;

  sigmoidalContrast(sharpen_: boolean, contrast: number): void;

  sigmoidalContrastAsync(sharpen_: boolean, contrast: number): Promise<void>;

  signature(force_: boolean): string;

  signatureAsync(force_: boolean): Promise<string>;

  signature(): string;

  signatureAsync(): Promise<string>;

  sketch(radius_: number, sigma_: number, angle_: number): void;

  sketchAsync(radius_: number, sigma_: number, angle_: number): Promise<void>;

  sketch(radius_: number, sigma_: number): void;

  sketchAsync(radius_: number, sigma_: number): Promise<void>;

  sketch(radius_: number): void;

  sketchAsync(radius_: number): Promise<void>;

  sketch(): void;

  sketchAsync(): Promise<void>;

  solarize(factor_: number): void;

  solarizeAsync(factor_: number): Promise<void>;

  solarize(): void;

  solarizeAsync(): Promise<void>;

  sparseColor(channel_: MagickCore.ChannelType, method_: any, numberArguments_: number, arguments_: any): void;

  sparseColorAsync(channel_: MagickCore.ChannelType, method_: any, numberArguments_: number, arguments_: any): Promise<void>;

  splice(geometry_: Magick.Geometry | string): void;

  spliceAsync(geometry_: Magick.Geometry | string): Promise<void>;

  splice(geometry_: Magick.Geometry | string, backgroundColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  spliceAsync(geometry_: Magick.Geometry | string, backgroundColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  splice(geometry_: Magick.Geometry | string, backgroundColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, gravity_: MagickCore.GravityType): void;

  spliceAsync(geometry_: Magick.Geometry | string, backgroundColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, gravity_: MagickCore.GravityType): Promise<void>;

  spread(amount_: number): void;

  spreadAsync(amount_: number): Promise<void>;

  spread(): void;

  spreadAsync(): Promise<void>;

  statistics(): Magick.ImageStatistics;

  statisticsAsync(): Promise<Magick.ImageStatistics>;

  stegano(watermark_: Magick.Image): void;

  steganoAsync(watermark_: Magick.Image): Promise<void>;

  stereo(rightImage_: Magick.Image): void;

  stereoAsync(rightImage_: Magick.Image): Promise<void>;

  strip(): void;

  stripAsync(): Promise<void>;

  subImageSearch(reference_: Magick.Image, metric_: MagickCore.MetricType, offset_: Magick.Geometry, similarityMetric_: any, similarityThreshold: number): Magick.Image;

  subImageSearchAsync(reference_: Magick.Image, metric_: MagickCore.MetricType, offset_: Magick.Geometry, similarityMetric_: any, similarityThreshold: number): Promise<Magick.Image>;

  subImageSearch(reference_: Magick.Image, metric_: MagickCore.MetricType, offset_: Magick.Geometry, similarityMetric_: any): Magick.Image;

  subImageSearchAsync(reference_: Magick.Image, metric_: MagickCore.MetricType, offset_: Magick.Geometry, similarityMetric_: any): Promise<Magick.Image>;

  swirl(degrees_: number): void;

  swirlAsync(degrees_: number): Promise<void>;

  syncPixels(): void;

  syncPixelsAsync(): Promise<void>;

  texture(texture_: Magick.Image): void;

  textureAsync(texture_: Magick.Image): Promise<void>;

  threshold(threshold_: number): void;

  thresholdAsync(threshold_: number): Promise<void>;

  thumbnail(geometry_: Magick.Geometry | string): void;

  thumbnailAsync(geometry_: Magick.Geometry | string): Promise<void>;

  tint(opacity_: string): void;

  tintAsync(opacity_: string): Promise<void>;

  transformOrigin(x_: number, y_: number): void;

  transformOriginAsync(x_: number, y_: number): Promise<void>;

  transformReset(): void;

  transformResetAsync(): Promise<void>;

  transformScale(sx_: number, sy_: number): void;

  transformScaleAsync(sx_: number, sy_: number): Promise<void>;

  transparent(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, inverse_: boolean): void;

  transparentAsync(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, inverse_: boolean): Promise<void>;

  transparent(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  transparentAsync(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  transparentChroma(colorLow_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, colorHigh_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  transparentChromaAsync(colorLow_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, colorHigh_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  transpose(): void;

  transposeAsync(): Promise<void>;

  transverse(): void;

  transverseAsync(): Promise<void>;

  trim(): void;

  trimAsync(): Promise<void>;

  uniqueColors(): Magick.Image;

  uniqueColorsAsync(): Promise<Magick.Image>;

  unsharpmask(radius_: number, sigma_: number, amount_: number, threshold_: number): void;

  unsharpmaskAsync(radius_: number, sigma_: number, amount_: number, threshold_: number): Promise<void>;

  unsharpmaskChannel(channel_: MagickCore.ChannelType, radius_: number, sigma_: number, amount_: number, threshold_: number): void;

  unsharpmaskChannelAsync(channel_: MagickCore.ChannelType, radius_: number, sigma_: number, amount_: number, threshold_: number): Promise<void>;

  vignette(radius_: number, sigma_: number, x_: number, y_: number): void;

  vignetteAsync(radius_: number, sigma_: number, x_: number, y_: number): Promise<void>;

  vignette(radius_: number, sigma_: number, x_: number): void;

  vignetteAsync(radius_: number, sigma_: number, x_: number): Promise<void>;

  vignette(radius_: number, sigma_: number): void;

  vignetteAsync(radius_: number, sigma_: number): Promise<void>;

  vignette(radius_: number): void;

  vignetteAsync(radius_: number): Promise<void>;

  vignette(): void;

  vignetteAsync(): Promise<void>;

  wave(amplitude_: number, wavelength_: number): void;

  waveAsync(amplitude_: number, wavelength_: number): Promise<void>;

  wave(amplitude_: number): void;

  waveAsync(amplitude_: number): Promise<void>;

  wave(): void;

  waveAsync(): Promise<void>;

  waveletDenoise(threshold_: number, softness_: number): void;

  waveletDenoiseAsync(threshold_: number, softness_: number): Promise<void>;

  whiteThreshold(threshold_: string): void;

  whiteThresholdAsync(threshold_: string): Promise<void>;

  whiteThresholdChannel(channel_: MagickCore.ChannelType, threshold_: string): void;

  whiteThresholdChannelAsync(channel_: MagickCore.ChannelType, threshold_: string): Promise<void>;

  write(blob_: Magick.Blob): void;

  writeAsync(blob_: Magick.Blob): Promise<void>;

  write(blob_: Magick.Blob, magick_: string): void;

  writeAsync(blob_: Magick.Blob, magick_: string): Promise<void>;

  write(blob_: Magick.Blob, magick_: string, depth_: number): void;

  writeAsync(blob_: Magick.Blob, magick_: string, depth_: number): Promise<void>;

  write(x_: number, y_: number, columns_: number, rows_: number, map_: string, type_: Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array | Float32Array | Float64Array | BigUint64Array): void;

  writeAsync(x_: number, y_: number, columns_: number, rows_: number, map_: string, type_: Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array | Float32Array | Float64Array | BigUint64Array): Promise<void>;

  write(imageSpec_: string): void;

  writeAsync(imageSpec_: string): Promise<void>;

  writeMask(mask_: Magick.Image): void;

  writeMaskAsync(mask_: Magick.Image): Promise<void>;

  writeMask(): Magick.Image;

  writeMaskAsync(): Promise<Magick.Image>;

  writePixels(quantum_: MagickCore.QuantumType, destination_: any): void;

  writePixelsAsync(quantum_: MagickCore.QuantumType, destination_: any): Promise<void>;

  zoom(geometry_: Magick.Geometry | string): void;

  zoomAsync(geometry_: Magick.Geometry | string): Promise<void>;

  image(): any;

  imageAsync(): Promise<any>;

  constImage(): any;

  constImageAsync(): Promise<any>;

  imageInfo(): any;

  imageInfoAsync(): Promise<any>;

  constImageInfo(): any;

  constImageInfoAsync(): Promise<any>;

  options(): any;

  optionsAsync(): Promise<any>;

  constOptions(): any;

  constOptionsAsync(): Promise<any>;

  quantizeInfo(): any;

  quantizeInfoAsync(): Promise<any>;

  constQuantizeInfo(): any;

  constQuantizeInfoAsync(): Promise<any>;

  modifyImage(): void;

  modifyImageAsync(): Promise<void>;

  replaceImage(replacement_: any): any;

  replaceImageAsync(replacement_: any): Promise<any>;
}

export  class ResourceLimits {

 static area(limit_: number): void;

 static area(): number;

 static disk(limit_: number): void;

 static disk(): number;

 static file(limit_: number): void;

 static file(): number;

 static height(limit_: number): void;

 static height(): number;

 static listLength(limit_: number): void;

 static listLength(): number;

 static map(limit_: number): void;

 static map(): number;

 static memory(limit_: number): void;

 static memory(): number;

 static thread(limit_: number): void;

 static thread(): number;

 static throttle(limit_: number): void;

 static throttle(): number;

 static width(limit_: number): void;

 static width(): number;
}

export type CoderInfo_MatchType = number & { readonly [_SWIG_enum_tag]: 'CoderInfo_MatchType'; };

export  class CoderInfo {

 static readonly AnyMatch: CoderInfo_MatchType;

 static readonly TrueMatch: CoderInfo_MatchType;

 static readonly FalseMatch: CoderInfo_MatchType;

  constructor();

  constructor(coder_: Magick.CoderInfo);

  constructor(name_: string);

  clone(coder_: Magick.CoderInfo): Magick.CoderInfo;

  canReadMultithreaded(): boolean;

  canWriteMultithreaded(): boolean;

  description(): string;

  isMultiFrame(): boolean;

  isReadable(): boolean;

  isWritable(): boolean;

  mimeType(): string;

  module(): string;

  name(): string;

  unregister(): boolean;
}

export  class Montage {

  constructor();

  backgroundColor(backgroundColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  backgroundColorAsync(backgroundColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  backgroundColor(): Magick.Color;

  backgroundColorAsync(): Promise<Magick.Color>;

  fileName(fileName_: string): void;

  fileNameAsync(fileName_: string): Promise<void>;

  fileName(): string;

  fileNameAsync(): Promise<string>;

  fillColor(fill_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  fillColorAsync(fill_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  fillColor(): Magick.Color;

  fillColorAsync(): Promise<Magick.Color>;

  font(font_: string): void;

  fontAsync(font_: string): Promise<void>;

  font(): string;

  fontAsync(): Promise<string>;

  geometry(geometry_: Magick.Geometry | string): void;

  geometryAsync(geometry_: Magick.Geometry | string): Promise<void>;

  geometry(): Magick.Geometry;

  geometryAsync(): Promise<Magick.Geometry>;

  gravity(gravity_: MagickCore.GravityType): void;

  gravityAsync(gravity_: MagickCore.GravityType): Promise<void>;

  gravity(): MagickCore.GravityType;

  gravityAsync(): Promise<MagickCore.GravityType>;

  label(label_: string): void;

  labelAsync(label_: string): Promise<void>;

  label(): string;

  labelAsync(): Promise<string>;

  pointSize(pointSize_: number): void;

  pointSizeAsync(pointSize_: number): Promise<void>;

  pointSize(): number;

  pointSizeAsync(): Promise<number>;

  shadow(shadow_: boolean): void;

  shadowAsync(shadow_: boolean): Promise<void>;

  shadow(): boolean;

  shadowAsync(): Promise<boolean>;

  strokeColor(stroke_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  strokeColorAsync(stroke_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  strokeColor(): Magick.Color;

  strokeColorAsync(): Promise<Magick.Color>;

  texture(texture_: string): void;

  textureAsync(texture_: string): Promise<void>;

  texture(): string;

  textureAsync(): Promise<string>;

  tile(tile_: Magick.Geometry): void;

  tileAsync(tile_: Magick.Geometry): Promise<void>;

  tile(): Magick.Geometry;

  tileAsync(): Promise<Magick.Geometry>;

  title(title_: string): void;

  titleAsync(title_: string): Promise<void>;

  title(): string;

  titleAsync(): Promise<string>;

  transparentColor(transparentColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  transparentColorAsync(transparentColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  transparentColor(): Magick.Color;

  transparentColorAsync(): Promise<Magick.Color>;

  updateMontageInfo(montageInfo_: any): void;

  updateMontageInfoAsync(montageInfo_: any): Promise<void>;
}

export  class MontageFramed extends Magick.Montage {

  constructor();

  matteColor(matteColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  matteColorAsync(matteColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  matteColor(): Magick.Color;

  matteColorAsync(): Promise<Magick.Color>;

  borderColor(borderColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): void;

  borderColorAsync(borderColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono): Promise<void>;

  borderColor(): Magick.Color;

  borderColorAsync(): Promise<Magick.Color>;

  borderWidth(borderWidth_: number): void;

  borderWidthAsync(borderWidth_: number): Promise<void>;

  borderWidth(): number;

  borderWidthAsync(): Promise<number>;

  frameGeometry(frame_: Magick.Geometry): void;

  frameGeometryAsync(frame_: Magick.Geometry): Promise<void>;

  frameGeometry(): Magick.Geometry;

  frameGeometryAsync(): Promise<Magick.Geometry>;

  updateMontageInfo(montageInfo_: any): void;

  updateMontageInfoAsync(montageInfo_: any): Promise<void>;
}

export  class adaptiveBlurImage {

  constructor(radius_: number, sigma_: number);

  constructor(radius_: number);

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class adaptiveThresholdImage {

  constructor(width_: number, height_: number, offset_: number);

  constructor(width_: number, height_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class addNoiseImage {

  constructor(noiseType_: MagickCore.NoiseType, attenuate_: number);

  constructor(noiseType_: MagickCore.NoiseType);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class affineTransformImage {

  constructor(affine_: Magick.DrawableAffine);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class annotateImage {

  constructor(text_: string, geometry_: Magick.Geometry | string);

  constructor(text_: string, geometry_: Magick.Geometry | string, gravity_: MagickCore.GravityType);

  constructor(text_: string, geometry_: Magick.Geometry | string, gravity_: MagickCore.GravityType, degrees_: number);

  constructor(text_: string, gravity_: MagickCore.GravityType);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class blurImage {

  constructor(radius_: number, sigma_: number);

  constructor(radius_: number);

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class borderImage {

  constructor(geometry_: Magick.Geometry | string);

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class channelImage {

  constructor(channel_: MagickCore.ChannelType);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class charcoalImage {

  constructor(radius_: number, sigma_: number);

  constructor(radius_: number);

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class chopImage {

  constructor(geometry_: Magick.Geometry | string);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class cdlImage {

  constructor(cdl_: string);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class colorizeImage {

  constructor(alphaRed_: number, alphaGreen_: number, alphaBlue_: number, penColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono);

  constructor(alpha_: number, penColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class colorMatrixImage {

  constructor(order_: number, color_matrix_: any);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class colorSpaceImage {

  constructor(colorSpace_: MagickCore.ColorspaceType);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class commentImage {

  constructor(comment_: string);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class compositeImage {

  constructor(compositeImage_: Magick.Image, xOffset_: number, yOffset_: number, compose_: MagickCore.CompositeOperator);

  constructor(compositeImage_: Magick.Image, xOffset_: number, yOffset_: number);

  constructor(compositeImage_: Magick.Image, offset_: Magick.Geometry | string, compose_: MagickCore.CompositeOperator);

  constructor(compositeImage_: Magick.Image, offset_: Magick.Geometry | string);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class contrastImage {

  constructor(sharpen_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class cropImage {

  constructor(geometry_: Magick.Geometry | string);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class cycleColormapImage {

  constructor(amount_: number);

  call(image_: Magick.Image): void;
}

export  class despeckleImage {

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class distortImage {

  constructor(method_: any, number_arguments_: number, arguments_: any, bestfit_: boolean);

  constructor(method_: any, number_arguments_: number, arguments_: any);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class drawImage {

  constructor(drawable_: Magick.DrawableBase);

  constructor(drawable_: Magick.DrawableBase[]);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class edgeImage {

  constructor(radius_: number);

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class embossImage {

  constructor();

  constructor(radius_: number, sigma_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class enhanceImage {

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class equalizeImage {

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class fillColorImage {

  constructor(fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono);

  call(image_: Magick.Image): void;
}

export  class flipImage {

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class floodFillAlphaImage {

  constructor(x_: number, y_: number, alpha_: number, target_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean);

  constructor(x_: number, y_: number, alpha_: number, target_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class floodFillColorImage {

  constructor(point_: Magick.Geometry, fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean);

  constructor(point_: Magick.Geometry, fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono);

  constructor(x_: number, y_: number, fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean);

  constructor(x_: number, y_: number, fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono);

  constructor(point_: Magick.Geometry, fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, borderColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean);

  constructor(point_: Magick.Geometry, fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, borderColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono);

  constructor(x_: number, y_: number, fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, borderColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean);

  constructor(x_: number, y_: number, fillColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, borderColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono);

  call(image_: Magick.Image): void;
}

export  class floodFillTextureImage {

  constructor(x_: number, y_: number, texture_: Magick.Image, invert_: boolean);

  constructor(x_: number, y_: number, texture_: Magick.Image);

  constructor(point_: Magick.Geometry, texture_: Magick.Image, invert_: boolean);

  constructor(point_: Magick.Geometry, texture_: Magick.Image);

  constructor(x_: number, y_: number, texture_: Magick.Image, borderColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean);

  constructor(x_: number, y_: number, texture_: Magick.Image, borderColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono);

  constructor(point_: Magick.Geometry, texture_: Magick.Image, borderColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, invert_: boolean);

  constructor(point_: Magick.Geometry, texture_: Magick.Image, borderColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class flopImage {

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class frameImage {

  constructor(geometry_: Magick.Geometry | string);

  constructor();

  constructor(width_: number, height_: number, innerBevel_: number, outerBevel_: number);

  constructor(width_: number, height_: number, innerBevel_: number);

  constructor(width_: number, height_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class gammaImage {

  constructor(gamma_: number);

  constructor(gammaRed_: number, gammaGreen_: number, gammaBlue_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class gaussianBlurImage {

  constructor(width_: number, sigma_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class haldClutImage {

  constructor(haldClutImage_: Magick.Image);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class implodeImage {

  constructor(factor_: number);

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class inverseFourierTransformImage {

  constructor(phaseImage_: Magick.Image);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class isValidImage {

  constructor(isValid_: boolean);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class labelImage {

  constructor(label_: string);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class levelImage {

  constructor(black_point: number, white_point: number, mid_point: number);

  constructor(black_point: number, white_point: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class magnifyImage {

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class mapImage {

  constructor(mapImage_: Magick.Image, dither_: boolean);

  constructor(mapImage_: Magick.Image);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class medianConvolveImage {

  constructor(radius_: number);

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class minifyImage {

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class modulateImage {

  constructor(brightness_: number, saturation_: number, hue_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class negateImage {

  constructor(grayscale_: boolean);

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class normalizeImage {

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class oilPaintImage {

  constructor(radius_: number);

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class alphaImage {

  constructor(alpha_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class opaqueImage {

  constructor(opaqueColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono, penColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class quantizeImage {

  constructor(measureError_: boolean);

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class raiseImage {

  constructor(geometry_: Magick.Geometry | string, raisedFlag_: boolean);

  constructor(geometry_: Magick.Geometry | string);

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class ReadOptions {

  constructor();

  constructor(options_: Magick.ReadOptions);

  density(geometry_: Magick.Geometry | string): void;

  density(): Magick.Geometry;

  depth(depth_: number): void;

  depth(): number;

  ping(flag_: boolean): void;

  ping(): boolean;

  quiet(quiet_: boolean): void;

  quiet(): boolean;

  size(geometry_: Magick.Geometry | string): void;

  size(): Magick.Geometry;

  imageInfo(): any;
}

export  class reduceNoiseImage {

  constructor();

  constructor(order_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class resizeImage {

  constructor(geometry_: Magick.Geometry | string);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class rollImage {

  constructor(roll_: Magick.Geometry);

  constructor(columns_: number, rows_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class rotateImage {

  constructor(degrees_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class sampleImage {

  constructor(geometry_: Magick.Geometry | string);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class scaleImage {

  constructor(geometry_: Magick.Geometry | string);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class segmentImage {

  constructor(clusterThreshold_: number, smoothingThreshold_: number);

  constructor(clusterThreshold_: number);

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class shadeImage {

  constructor(azimuth_: number, elevation_: number, colorShading_: boolean);

  constructor(azimuth_: number, elevation_: number);

  constructor(azimuth_: number);

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class shadowImage {

  constructor(percent_opacity_: number, sigma_: number, x_: number, y_: number);

  constructor(percent_opacity_: number, sigma_: number, x_: number);

  constructor(percent_opacity_: number, sigma_: number);

  constructor(percent_opacity_: number);

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class sharpenImage {

  constructor(radius_: number, sigma_: number);

  constructor(radius_: number);

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class shaveImage {

  constructor(geometry_: Magick.Geometry | string);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class shearImage {

  constructor(xShearAngle_: number, yShearAngle_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class solarizeImage {

  constructor(factor_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class spliceImage {

  constructor(geometry_: Magick.Geometry | string);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class spreadImage {

  constructor(amount_: number);

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class steganoImage {

  constructor(waterMark_: Magick.Image);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class stereoImage {

  constructor(rightImage_: Magick.Image);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class strokeColorImage {

  constructor(strokeColor_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono);

  call(image_: Magick.Image): void;
}

export  class swirlImage {

  constructor(degrees_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class textureImage {

  constructor(texture_: Magick.Image);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class thresholdImage {

  constructor(threshold_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class transparentImage {

  constructor(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class trimImage {

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class waveImage {

  constructor(amplitude_: number, wavelength_: number);

  constructor(amplitude_: number);

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class zoomImage {

  constructor(geometry_: Magick.Geometry | string);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class adjoinImage {

  constructor(flag_: boolean);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class animationDelayImage {

  constructor(delay_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class animationIterationsImage {

  constructor(iterations_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class backgroundColorImage {

  constructor(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono);

  call(image_: Magick.Image): void;
}

export  class backgroundTextureImage {

  constructor(backgroundTexture_: string);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class borderColorImage {

  constructor(color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono);

  call(image_: Magick.Image): void;
}

export  class boxColorImage {

  constructor(boxColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono);

  call(image_: Magick.Image): void;
}

export  class chromaBluePrimaryImage {

  constructor(x_: number, y_: number, z_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class chromaGreenPrimaryImage {

  constructor(x_: number, y_: number, z_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class chromaRedPrimaryImage {

  constructor(x_: number, y_: number, z_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class chromaWhitePointImage {

  constructor(x_: number, y_: number, z_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class colorFuzzImage {

  constructor(fuzz_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class colorMapImage {

  constructor(index_: number, color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class composeImage {

  constructor(compose_: MagickCore.CompositeOperator);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class compressTypeImage {

  constructor(compressType_: MagickCore.CompressionType);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class densityImage {

  constructor(point_: Magick.Point);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class depthImage {

  constructor(depth_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class endianImage {

  constructor(endian_: MagickCore.EndianType);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class fileNameImage {

  constructor(fileName_: string);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class filterTypeImage {

  constructor(filterType_: MagickCore.FilterType);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class fontImage {

  constructor(font_: string);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class fontPointsizeImage {

  constructor(pointsize_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class gifDisposeMethodImage {

  constructor(disposeMethod_: MagickCore.DisposeType);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class interlaceTypeImage {

  constructor(interlace_: MagickCore.InterlaceType);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class magickImage {

  constructor(magick_: string);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class alphaFlagImage {

  constructor(alphaFlag_: boolean);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class matteColorImage {

  constructor(matteColor_: Magick.Color | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono);

  call(image_: Magick.Image): void;
}

export  class monochromeImage {

  constructor(monochromeFlag_: boolean);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class pixelColorImage {

  constructor(x_: number, y_: number, color_: Magick.Color | string | Magick.ColorHSL | Magick.ColorGray | Magick.ColorYUV | Magick.ColorCMYK | Magick.ColorRGB | Magick.ColorMono);

  call(image_: Magick.Image): void;
}

export  class pageImage {

  constructor(pageSize_: Magick.Geometry);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class qualityImage {

  constructor(quality_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class quantizeColorsImage {

  constructor(colors_: number);

  call(image_: Magick.Image): void;
}

export  class quantizeColorSpaceImage {

  constructor(colorSpace_: MagickCore.ColorspaceType);

  call(image_: Magick.Image): void;
}

export  class quantizeDitherImage {

  constructor(ditherFlag_: boolean);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class quantizeTreeDepthImage {

  constructor(treeDepth_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class renderingIntentImage {

  constructor(renderingIntent_: any);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class resolutionUnitsImage {

  constructor(resolutionUnits_: MagickCore.ResolutionType);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class sceneImage {

  constructor(scene_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class sizeImage {

  constructor(geometry_: Magick.Geometry | string);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class stripImage {

  constructor();

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class subImageImage {

  constructor(subImage_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class subRangeImage {

  constructor(subRange_: number);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class textAntiAliasImage {

  constructor(flag_: boolean);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class typeImage {

  constructor(type_: MagickCore.ImageType);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class verboseImage {

  constructor(verbose_: boolean);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export  class x11DisplayImage {

  constructor(display_: string);

  call(image_: Magick.Image): void;

  callAsync(image_: Magick.Image): Promise<void>;
}

export function coderInfoList(isReadable_: Magick.CoderInfo_MatchType, isWritable_: Magick.CoderInfo_MatchType, isMultiFrame_: Magick.CoderInfo_MatchType): std.coderInfoArray;

export function coderInfoList(isReadable_: Magick.CoderInfo_MatchType, isWritable_: Magick.CoderInfo_MatchType): std.coderInfoArray;

export function coderInfoList(isReadable_: Magick.CoderInfo_MatchType): std.coderInfoArray;

export function coderInfoList(): std.coderInfoArray;

export function appendImages(first_: any, stack_: boolean): Magick.Image;

export function appendImagesAsync(first_: any, stack_: boolean): Promise<Magick.Image>;

export function appendImages(first_: any): Magick.Image;

export function appendImagesAsync(first_: any): Promise<Magick.Image>;

export function averageImages(first_: any): Magick.Image;

export function flattenImages(flattenedImage_: Magick.Image, first_: any): void;

export function mosaicImages(first_: any): Magick.Image;

export function coalesceImages(first_: any): Magick.Image[];

export function deconstructImages(first_: any): Magick.Image[];

export function forwardFourierTransformImage(image_: Magick.Image): Magick.Image[];

export function forwardFourierTransformImageAsync(image_: Magick.Image): Promise<Magick.Image[]>;

export function forwardFourierTransformImage(image_: Magick.Image, magnitude_: boolean): Magick.Image[];

export function forwardFourierTransformImageAsync(image_: Magick.Image, magnitude_: boolean): Promise<Magick.Image[]>;

export function montageImages(first_: any, options_: Magick.Montage | Magick.MontageFramed): Magick.Image[];

export function morphImages(first_: any, frames_: number): Magick.Image[];

export function readImages(imageSpec_: string, options: Magick.ReadOptions): Magick.Image[];

export function readImagesAsync(imageSpec_: string, options: Magick.ReadOptions): Promise<Magick.Image[]>;

export function readImages(imageSpec_: string): Magick.Image[];

export function readImagesAsync(imageSpec_: string): Promise<Magick.Image[]>;

export function readImages(blob_: Magick.Blob, options: Magick.ReadOptions): Magick.Image[];

export function readImagesAsync(blob_: Magick.Blob, options: Magick.ReadOptions): Promise<Magick.Image[]>;

export function readImages(blob_: Magick.Blob): Magick.Image[];

export function readImagesAsync(blob_: Magick.Blob): Promise<Magick.Image[]>;

export function writeImages(first_: any, imageSpec_: string, adjoin_: boolean): void;

export function writeImagesAsync(first_: any, imageSpec_: string, adjoin_: boolean): Promise<void>;

export function writeImages(first_: any, imageSpec_: string): void;

export function writeImagesAsync(first_: any, imageSpec_: string): Promise<void>;

export function writeImages(first_: any, blob_: Magick.Blob, adjoin_: boolean): void;

export function writeImagesAsync(first_: any, blob_: Magick.Blob, adjoin_: boolean): Promise<void>;

export function writeImages(first_: any, blob_: Magick.Blob): void;

export function writeImagesAsync(first_: any, blob_: Magick.Blob): Promise<void>;


}

export namespace std {

export  class coderInfoArray {

  constructor();

  constructor(n: number);

  constructor(other: any);

  size(): number;

  capacity(): number;

  reserve(n: number): void;

  isEmpty(): boolean;

  clear(): void;

  add(x: Magick.CoderInfo): void;

  get(i: number): any;

  set(i: number, val: Magick.CoderInfo): void;
}


}

