/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG JSE (https://www.swig.org).
 * Version 5.0.3
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

#include "swig/magickwand-js.h"


// js_global_function
Napi::Value _wrap_GetMagickCopyright(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  char *result = 0 ;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    if(static_cast<int>(info.Length()) < 0 || static_cast<int>(info.Length()) > 0) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_GetMagickCopyright.");
    }
    
    
    
    
    
    
    {
      try {
        result = (char *)MagickCore::GetMagickCopyright();
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_FromCharPtr((const char *)result);
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function
Napi::Value _wrap_GetMagickDelegates(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  char *result = 0 ;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    if(static_cast<int>(info.Length()) < 0 || static_cast<int>(info.Length()) > 0) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_GetMagickDelegates.");
    }
    
    
    
    
    
    
    {
      try {
        result = (char *)MagickCore::GetMagickDelegates();
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_FromCharPtr((const char *)result);
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function
Napi::Value _wrap_GetMagickFeatures(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  char *result = 0 ;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    if(static_cast<int>(info.Length()) < 0 || static_cast<int>(info.Length()) > 0) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_GetMagickFeatures.");
    }
    
    
    
    
    
    
    {
      try {
        result = (char *)MagickCore::GetMagickFeatures();
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_FromCharPtr((const char *)result);
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function
Napi::Value _wrap_GetMagickLicense(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  char *result = 0 ;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    if(static_cast<int>(info.Length()) < 0 || static_cast<int>(info.Length()) > 0) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_GetMagickLicense.");
    }
    
    
    
    
    
    
    {
      try {
        result = (char *)MagickCore::GetMagickLicense();
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_FromCharPtr((const char *)result);
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function
Napi::Value _wrap_GetMagickPackageName(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  char *result = 0 ;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    if(static_cast<int>(info.Length()) < 0 || static_cast<int>(info.Length()) > 0) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_GetMagickPackageName.");
    }
    
    
    
    
    
    
    {
      try {
        result = (char *)MagickCore::GetMagickPackageName();
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_FromCharPtr((const char *)result);
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function
Napi::Value _wrap_GetMagickReleaseDate(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  char *result = 0 ;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    if(static_cast<int>(info.Length()) < 0 || static_cast<int>(info.Length()) > 0) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_GetMagickReleaseDate.");
    }
    
    
    
    
    
    
    {
      try {
        result = (char *)MagickCore::GetMagickReleaseDate();
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_FromCharPtr((const char *)result);
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function
Napi::Value _wrap_GetPolicyValue(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  char *result = 0 ;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    if(static_cast<int>(info.Length()) < 1 || static_cast<int>(info.Length()) > 1) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_GetPolicyValue.");
    }
    
    res1 = SWIG_AsCharPtrAndSize(info[0], &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetPolicyValue" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = reinterpret_cast< char * >(buf1);
    
    
    
    
    {
      try {
        result = (char *)MagickCore::GetPolicyValue((char const *)arg1);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_FromCharPtr((const char *)result);
    
    if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
    
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  
#endif
  return Napi::Value();
}


// js_global_function
Napi::Value _wrap_GetPolicyList(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  char *arg1 = (char *) 0 ;
  size_t *arg2 = (size_t *) 0 ;
  MagickCore::ExceptionInfo *arg3 = (MagickCore::ExceptionInfo *) 0 ;
  MagickCore::ExceptionInfo _global_error ;
  size_t _global_number_policies ;
  char **result = 0 ;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    if(static_cast<int>(info.Length()) < 0 || static_cast<int>(info.Length()) > 0) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_GetPolicyList.");
    }
    
    arg1 = const_cast<char*>("");
    arg2 = &_global_number_policies;
    arg3 = &_global_error;
    _global_error.severity = MagickCore::ExceptionType::UndefinedException;
    
    
    
    
    
    {
      try {
        result = (char **)MagickCore::GetPolicyList((char const *)arg1,arg2,arg3);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    {
      Napi::Array array = Napi::Array::New(env, _global_number_policies);
      if (result) {
        char **policies = reinterpret_cast<char**>(result);
        for (size_t i = 0; i < _global_number_policies; i++) {
          Napi::String s = Napi::String::New(env, policies[i]);
          array.Set(i, s);
        }
      }
      jsresult = array;
    }
    if (_global_error.severity != MagickCore::ExceptionType::UndefinedException) {
      do {
        SWIG_NAPI_Raise(env, MagickCore::GetExceptionMessage(_global_error.error_number)); SWIG_fail; 
      } while (0);
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function
Napi::Value _wrap_IsRightsAuthorized(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  MagickCore::PolicyDomain arg1 ;
  MagickCore::PolicyRights arg2 ;
  char *arg3 = (char *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  MagickCore::MagickBooleanType result;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    if(static_cast<int>(info.Length()) < 3 || static_cast<int>(info.Length()) > 3) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_IsRightsAuthorized.");
    }
    
    ecode1 = SWIG_AsVal_int(info[0], &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "IsRightsAuthorized" "', argument " "1"" of type '" "MagickCore::PolicyDomain""'");
    } 
    arg1 = static_cast< MagickCore::PolicyDomain >(val1);ecode2 = SWIG_AsVal_int(info[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IsRightsAuthorized" "', argument " "2"" of type '" "MagickCore::PolicyRights""'");
    } 
    arg2 = static_cast< MagickCore::PolicyRights >(val2);res3 = SWIG_AsCharPtrAndSize(info[2], &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "IsRightsAuthorized" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = reinterpret_cast< char * >(buf3);
    
    
    
    
    {
      try {
        result = (MagickCore::MagickBooleanType)MagickCore::IsRightsAuthorized(arg1,arg2,(char const *)arg3);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    {
      jsresult = Napi::Boolean::New(env, result);
    }
    
    if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
    
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  
#endif
  return Napi::Value();
}


// js_global_function
Napi::Value _wrap_ListPolicyInfo(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  FILE *arg1 = (FILE *) 0 ;
  MagickCore::ExceptionInfo *arg2 = (MagickCore::ExceptionInfo *) 0 ;
  MagickCore::ExceptionInfo _global_error ;
  MagickCore::MagickBooleanType result;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    if(static_cast<int>(info.Length()) < 0 || static_cast<int>(info.Length()) > 0) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_ListPolicyInfo.");
    }
    
    arg1 = SWIG_NULLPTR;
    arg2 = &_global_error;
    _global_error.severity = MagickCore::ExceptionType::UndefinedException;
    
    
    
    
    
    {
      try {
        result = (MagickCore::MagickBooleanType)MagickCore::ListPolicyInfo(arg1,arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    {
      jsresult = Napi::Boolean::New(env, result);
    }
    if (_global_error.severity != MagickCore::ExceptionType::UndefinedException) {
      do {
        SWIG_NAPI_Raise(env, MagickCore::GetExceptionMessage(_global_error.error_number)); SWIG_fail; 
      } while (0);
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function
Napi::Value _wrap_SetMagickSecurityPolicy(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  char *arg1 = (char *) 0 ;
  MagickCore::ExceptionInfo *arg2 = (MagickCore::ExceptionInfo *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  MagickCore::ExceptionInfo _global_error ;
  MagickCore::MagickBooleanType result;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    if(static_cast<int>(info.Length()) < 1 || static_cast<int>(info.Length()) > 1) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_SetMagickSecurityPolicy.");
    }
    
    arg2 = &_global_error;
    _global_error.severity = MagickCore::ExceptionType::UndefinedException;
    res1 = SWIG_AsCharPtrAndSize(info[0], &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetMagickSecurityPolicy" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = reinterpret_cast< char * >(buf1);
    
    
    
    
    {
      try {
        result = (MagickCore::MagickBooleanType)MagickCore::SetMagickSecurityPolicy((char const *)arg1,arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    {
      jsresult = Napi::Boolean::New(env, result);
    }
    if (_global_error.severity != MagickCore::ExceptionType::UndefinedException) {
      do {
        SWIG_NAPI_Raise(env, MagickCore::GetExceptionMessage(_global_error.error_number)); SWIG_fail; 
      } while (0);
    }
    
    if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
    
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  
#endif
  return Napi::Value();
}


// js_global_function
Napi::Value _wrap_SetMagickSecurityPolicyValue(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  MagickCore::PolicyDomain arg1 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  MagickCore::ExceptionInfo *arg4 = (MagickCore::ExceptionInfo *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  MagickCore::ExceptionInfo _global_error ;
  MagickCore::MagickBooleanType result;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    if(static_cast<int>(info.Length()) < 3 || static_cast<int>(info.Length()) > 3) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_SetMagickSecurityPolicyValue.");
    }
    
    arg4 = &_global_error;
    _global_error.severity = MagickCore::ExceptionType::UndefinedException;
    ecode1 = SWIG_AsVal_int(info[0], &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SetMagickSecurityPolicyValue" "', argument " "1"" of type '" "MagickCore::PolicyDomain""'");
    } 
    arg1 = static_cast< MagickCore::PolicyDomain >(val1);res2 = SWIG_AsCharPtrAndSize(info[1], &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetMagickSecurityPolicyValue" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = reinterpret_cast< char * >(buf2);res3 = SWIG_AsCharPtrAndSize(info[2], &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SetMagickSecurityPolicyValue" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = reinterpret_cast< char * >(buf3);
    
    
    
    
    {
      try {
        result = (MagickCore::MagickBooleanType)MagickCore::SetMagickSecurityPolicyValue(arg1,(char const *)arg2,(char const *)arg3,arg4);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    {
      jsresult = Napi::Boolean::New(env, result);
    }
    if (_global_error.severity != MagickCore::ExceptionType::UndefinedException) {
      do {
        SWIG_NAPI_Raise(env, MagickCore::GetExceptionMessage(_global_error.error_number)); SWIG_fail; 
      } while (0);
    }
    
    if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
    if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
    if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
    
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  
#endif
  return Napi::Value();
}


// js_global_function
Napi::Value _wrap_MagickSetSecurityPolicy(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  MagickWand *arg1 = (MagickWand *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  MagickCore::MagickBooleanType result;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    if(static_cast<int>(info.Length()) < 2 || static_cast<int>(info.Length()) > 2) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_MagickSetSecurityPolicy.");
    }
    
    res1 = SWIG_ConvertPtr(info[0], &argp1,SWIGTYPE_p_MagickWand, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MagickSetSecurityPolicy" "', argument " "1"" of type '" "MagickWand *""'"); 
    }
    arg1 = reinterpret_cast< MagickWand * >(argp1);res2 = SWIG_AsCharPtrAndSize(info[1], &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MagickSetSecurityPolicy" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = reinterpret_cast< char * >(buf2);
    
    
    
    
    {
      try {
        result = (MagickCore::MagickBooleanType)MagickCore::MagickSetSecurityPolicy(arg1,(char const *)arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    {
      jsresult = Napi::Boolean::New(env, result);
    }
    
    if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
    
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  
#endif
  return Napi::Value();
}


// js_global_function
Napi::Value _wrap_DisableOpenCL(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    if(static_cast<int>(info.Length()) < 0 || static_cast<int>(info.Length()) > 0) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_DisableOpenCL.");
    }
    
    
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::DisableOpenCL();
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function
Napi::Value _wrap_EnableOpenCL(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  bool result;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    if(static_cast<int>(info.Length()) < 0 || static_cast<int>(info.Length()) > 0) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_EnableOpenCL.");
    }
    
    
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (bool)Magick::EnableOpenCL();
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_bool  SWIG_NAPI_FROM_CALL_ARGS(static_cast< bool >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function
Napi::Value _wrap_SetRandomSeed(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  unsigned long arg1 ;
  unsigned long val1 ;
  int ecode1 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    if(static_cast<int>(info.Length()) < 1 || static_cast<int>(info.Length()) > 1) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_SetRandomSeed.");
    }
    
    ecode1 = SWIG_AsVal_unsigned_SS_long(info[0], &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SetRandomSeed" "', argument " "1"" of type '" "unsigned long""'");
    } 
    arg1 = static_cast< unsigned long >(val1);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SetRandomSeed(arg1);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function
Napi::Value _wrap_SetSecurityPolicy(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  bool result;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    if(static_cast<int>(info.Length()) < 1 || static_cast<int>(info.Length()) > 1) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_SetSecurityPolicy.");
    }
    
    {
      {
        std::string *ptr = (std::string *)0;
        res1 = SWIG_AsPtr_std_string(info[0], &ptr);
        if (!SWIG_IsOK(res1)) {
          SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSecurityPolicy" "', argument " "1"" of type '" "std::string const &""'"); 
        }
        if (!ptr) {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetSecurityPolicy" "', argument " "1"" of type '" "std::string const &""'"); 
        }
        arg1 = ptr;
      }
    }
    
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (bool)Magick::SetSecurityPolicy((std::string const &)*arg1);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_bool  SWIG_NAPI_FROM_CALL_ARGS(static_cast< bool >(result));
    
    if (SWIG_IsNewObj(res1)) delete arg1;
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    if (SWIG_IsNewObj(res1)) delete arg1;
    
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_equal__SWIG_0(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Color *arg1 = 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equal" "', argument " "1"" of type '" "Magick::Color const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "1"" of type '" "Magick::Color const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Color * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Color,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equal" "', argument " "2"" of type '" "Magick::Color const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "2"" of type '" "Magick::Color const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Color * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator ==((Magick::Color const &)*arg1,(Magick::Color const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_notEqual__SWIG_0(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Color *arg1 = 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Color const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Color const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Color * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Color,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Color const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Color const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Color * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator !=((Magick::Color const &)*arg1,(Magick::Color const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_gt__SWIG_0(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Color *arg1 = 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gt" "', argument " "1"" of type '" "Magick::Color const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "1"" of type '" "Magick::Color const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Color * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Color,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gt" "', argument " "2"" of type '" "Magick::Color const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "2"" of type '" "Magick::Color const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Color * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator >((Magick::Color const &)*arg1,(Magick::Color const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_lt__SWIG_0(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Color *arg1 = 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lt" "', argument " "1"" of type '" "Magick::Color const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "1"" of type '" "Magick::Color const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Color * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Color,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lt" "', argument " "2"" of type '" "Magick::Color const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "2"" of type '" "Magick::Color const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Color * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator <((Magick::Color const &)*arg1,(Magick::Color const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_gte__SWIG_0(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Color *arg1 = 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gte" "', argument " "1"" of type '" "Magick::Color const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "1"" of type '" "Magick::Color const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Color * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Color,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gte" "', argument " "2"" of type '" "Magick::Color const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "2"" of type '" "Magick::Color const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Color * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator >=((Magick::Color const &)*arg1,(Magick::Color const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_lte__SWIG_0(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Color *arg1 = 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lte" "', argument " "1"" of type '" "Magick::Color const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "1"" of type '" "Magick::Color const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Color * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Color,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lte" "', argument " "2"" of type '" "Magick::Color const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "2"" of type '" "Magick::Color const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Color * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator <=((Magick::Color const &)*arg1,(Magick::Color const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_equal__SWIG_1(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Geometry *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equal" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Geometry * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equal" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator ==((Magick::Geometry const &)*arg1,(Magick::Geometry const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_notEqual__SWIG_1(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Geometry *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Geometry * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator !=((Magick::Geometry const &)*arg1,(Magick::Geometry const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_gt__SWIG_1(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Geometry *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gt" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Geometry * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gt" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator >((Magick::Geometry const &)*arg1,(Magick::Geometry const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_lt__SWIG_1(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Geometry *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lt" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Geometry * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lt" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator <((Magick::Geometry const &)*arg1,(Magick::Geometry const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_gte__SWIG_1(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Geometry *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gte" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Geometry * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gte" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator >=((Magick::Geometry const &)*arg1,(Magick::Geometry const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_lte__SWIG_1(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Geometry *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lte" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Geometry * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lte" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator <=((Magick::Geometry const &)*arg1,(Magick::Geometry const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_equal__SWIG_2(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Offset *arg1 = 0 ;
  Magick::Offset *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Offset,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equal" "', argument " "1"" of type '" "Magick::Offset const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "1"" of type '" "Magick::Offset const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Offset * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Offset,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equal" "', argument " "2"" of type '" "Magick::Offset const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "2"" of type '" "Magick::Offset const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Offset * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator ==((Magick::Offset const &)*arg1,(Magick::Offset const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_notEqual__SWIG_2(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Offset *arg1 = 0 ;
  Magick::Offset *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Offset,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Offset const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Offset const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Offset * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Offset,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Offset const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Offset const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Offset * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator !=((Magick::Offset const &)*arg1,(Magick::Offset const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_equal__SWIG_3(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Point *arg1 = 0 ;
  Magick::Point *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Point,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equal" "', argument " "1"" of type '" "Magick::Point const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "1"" of type '" "Magick::Point const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Point * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Point,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equal" "', argument " "2"" of type '" "Magick::Point const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "2"" of type '" "Magick::Point const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Point * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator ==((Magick::Point const &)*arg1,(Magick::Point const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_notEqual__SWIG_3(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Point *arg1 = 0 ;
  Magick::Point *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Point,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Point const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Point const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Point * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Point,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Point const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Point const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Point * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator !=((Magick::Point const &)*arg1,(Magick::Point const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_equal__SWIG_4(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Coordinate *arg1 = 0 ;
  Magick::Coordinate *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Coordinate,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equal" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Coordinate * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Coordinate,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equal" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Coordinate * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator ==((Magick::Coordinate const &)*arg1,(Magick::Coordinate const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_notEqual__SWIG_4(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Coordinate *arg1 = 0 ;
  Magick::Coordinate *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Coordinate,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Coordinate * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Coordinate,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Coordinate * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator !=((Magick::Coordinate const &)*arg1,(Magick::Coordinate const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_gt__SWIG_2(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Coordinate *arg1 = 0 ;
  Magick::Coordinate *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Coordinate,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gt" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Coordinate * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Coordinate,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gt" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Coordinate * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator >((Magick::Coordinate const &)*arg1,(Magick::Coordinate const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_lt__SWIG_2(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Coordinate *arg1 = 0 ;
  Magick::Coordinate *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Coordinate,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lt" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Coordinate * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Coordinate,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lt" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Coordinate * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator <((Magick::Coordinate const &)*arg1,(Magick::Coordinate const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_gte__SWIG_2(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Coordinate *arg1 = 0 ;
  Magick::Coordinate *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Coordinate,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gte" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Coordinate * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Coordinate,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gte" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Coordinate * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator >=((Magick::Coordinate const &)*arg1,(Magick::Coordinate const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_lte__SWIG_2(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Coordinate *arg1 = 0 ;
  Magick::Coordinate *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Coordinate,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lte" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Coordinate * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Coordinate,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lte" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Coordinate * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator <=((Magick::Coordinate const &)*arg1,(Magick::Coordinate const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_equal__SWIG_5(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathArcArgs *arg1 = 0 ;
  Magick::PathArcArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathArcArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equal" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathArcArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equal" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathArcArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator ==((Magick::PathArcArgs const &)*arg1,(Magick::PathArcArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_notEqual__SWIG_5(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathArcArgs *arg1 = 0 ;
  Magick::PathArcArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathArcArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "notEqual" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathArcArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "notEqual" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathArcArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator !=((Magick::PathArcArgs const &)*arg1,(Magick::PathArcArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_gt__SWIG_3(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathArcArgs *arg1 = 0 ;
  Magick::PathArcArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathArcArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gt" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathArcArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gt" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathArcArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator >((Magick::PathArcArgs const &)*arg1,(Magick::PathArcArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_lt__SWIG_3(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathArcArgs *arg1 = 0 ;
  Magick::PathArcArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathArcArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lt" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathArcArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lt" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathArcArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator <((Magick::PathArcArgs const &)*arg1,(Magick::PathArcArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_gte__SWIG_3(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathArcArgs *arg1 = 0 ;
  Magick::PathArcArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathArcArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gte" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathArcArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gte" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathArcArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator >=((Magick::PathArcArgs const &)*arg1,(Magick::PathArcArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_lte__SWIG_3(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathArcArgs *arg1 = 0 ;
  Magick::PathArcArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathArcArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lte" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathArcArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lte" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathArcArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator <=((Magick::PathArcArgs const &)*arg1,(Magick::PathArcArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_equal__SWIG_6(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathCurvetoArgs *arg1 = 0 ;
  Magick::PathCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equal" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equal" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator ==((Magick::PathCurvetoArgs const &)*arg1,(Magick::PathCurvetoArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_notEqual__SWIG_6(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathCurvetoArgs *arg1 = 0 ;
  Magick::PathCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "notEqual" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "notEqual" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator !=((Magick::PathCurvetoArgs const &)*arg1,(Magick::PathCurvetoArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_gt__SWIG_4(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathCurvetoArgs *arg1 = 0 ;
  Magick::PathCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gt" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gt" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator >((Magick::PathCurvetoArgs const &)*arg1,(Magick::PathCurvetoArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_lt__SWIG_4(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathCurvetoArgs *arg1 = 0 ;
  Magick::PathCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lt" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lt" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator <((Magick::PathCurvetoArgs const &)*arg1,(Magick::PathCurvetoArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_gte__SWIG_4(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathCurvetoArgs *arg1 = 0 ;
  Magick::PathCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gte" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gte" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator >=((Magick::PathCurvetoArgs const &)*arg1,(Magick::PathCurvetoArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_lte__SWIG_4(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathCurvetoArgs *arg1 = 0 ;
  Magick::PathCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lte" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lte" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator <=((Magick::PathCurvetoArgs const &)*arg1,(Magick::PathCurvetoArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_equal__SWIG_7(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathQuadraticCurvetoArgs *arg1 = 0 ;
  Magick::PathQuadraticCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equal" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equal" "', argument " "2"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "2"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator ==((Magick::PathQuadraticCurvetoArgs const &)*arg1,(Magick::PathQuadraticCurvetoArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_notEqual__SWIG_7(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathQuadraticCurvetoArgs *arg1 = 0 ;
  Magick::PathQuadraticCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "notEqual" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "notEqual" "', argument " "2"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "2"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator !=((Magick::PathQuadraticCurvetoArgs const &)*arg1,(Magick::PathQuadraticCurvetoArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_gt__SWIG_5(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathQuadraticCurvetoArgs *arg1 = 0 ;
  Magick::PathQuadraticCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gt" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gt" "', argument " "2"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "2"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator >((Magick::PathQuadraticCurvetoArgs const &)*arg1,(Magick::PathQuadraticCurvetoArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_lt__SWIG_5(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathQuadraticCurvetoArgs *arg1 = 0 ;
  Magick::PathQuadraticCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lt" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lt" "', argument " "2"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "2"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator <((Magick::PathQuadraticCurvetoArgs const &)*arg1,(Magick::PathQuadraticCurvetoArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_gte__SWIG_5(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathQuadraticCurvetoArgs *arg1 = 0 ;
  Magick::PathQuadraticCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gte" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gte" "', argument " "2"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "2"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator >=((Magick::PathQuadraticCurvetoArgs const &)*arg1,(Magick::PathQuadraticCurvetoArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_lte__SWIG_5(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathQuadraticCurvetoArgs *arg1 = 0 ;
  Magick::PathQuadraticCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lte" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "1"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathQuadraticCurvetoArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lte" "', argument " "2"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "2"" of type '" "Magick::PathQuadraticCurvetoArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathQuadraticCurvetoArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator <=((Magick::PathQuadraticCurvetoArgs const &)*arg1,(Magick::PathQuadraticCurvetoArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_setter
void _wrap_borderGeometryDefault_set(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value value = info.Length() > 0 ? info[0] : Napi::Value();
  Napi::Value jsresult;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_AsCharPtrAndSize(value, &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "borderGeometryDefault_set" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = reinterpret_cast< char * >(buf1);
    
    // js_lock
    SWIG_guard.lock();
    
    if (arg1) {
      size_t size = strlen(arg1) + 1;
      Magick::borderGeometryDefault = (char const *)reinterpret_cast< char* >(memcpy(new char[size], arg1, sizeof(char)*(size)));
    } else {
      Magick::borderGeometryDefault = 0;
    }
    
    if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
    
    return;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
    
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  
#endif
  return;
}


// js_global_getter
Napi::Value _wrap_borderGeometryDefault_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  char *result = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    
    
    // js_lock
    SWIG_guard.lock();
    
    result = (char *)Magick::borderGeometryDefault;
    
    jsresult = SWIG_FromCharPtr((const char *)result);
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_setter
void _wrap_frameGeometryDefault_set(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value value = info.Length() > 0 ? info[0] : Napi::Value();
  Napi::Value jsresult;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_AsCharPtrAndSize(value, &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "frameGeometryDefault_set" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = reinterpret_cast< char * >(buf1);
    
    // js_lock
    SWIG_guard.lock();
    
    if (arg1) {
      size_t size = strlen(arg1) + 1;
      Magick::frameGeometryDefault = (char const *)reinterpret_cast< char* >(memcpy(new char[size], arg1, sizeof(char)*(size)));
    } else {
      Magick::frameGeometryDefault = 0;
    }
    
    if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
    
    return;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
    
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  
#endif
  return;
}


// js_global_getter
Napi::Value _wrap_frameGeometryDefault_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  char *result = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    
    
    // js_lock
    SWIG_guard.lock();
    
    result = (char *)Magick::frameGeometryDefault;
    
    jsresult = SWIG_FromCharPtr((const char *)result);
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_setter
void _wrap_raiseGeometryDefault_set(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value value = info.Length() > 0 ? info[0] : Napi::Value();
  Napi::Value jsresult;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_AsCharPtrAndSize(value, &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "raiseGeometryDefault_set" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = reinterpret_cast< char * >(buf1);
    
    // js_lock
    SWIG_guard.lock();
    
    if (arg1) {
      size_t size = strlen(arg1) + 1;
      Magick::raiseGeometryDefault = (char const *)reinterpret_cast< char* >(memcpy(new char[size], arg1, sizeof(char)*(size)));
    } else {
      Magick::raiseGeometryDefault = 0;
    }
    
    if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
    
    return;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
    
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  
#endif
  return;
}


// js_global_getter
Napi::Value _wrap_raiseGeometryDefault_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  char *result = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    
    
    // js_lock
    SWIG_guard.lock();
    
    result = (char *)Magick::raiseGeometryDefault;
    
    jsresult = SWIG_FromCharPtr((const char *)result);
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_overloaded_function
Napi::Value _wrap_equal__SWIG_8(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Image *arg1 = 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Image,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equal" "', argument " "1"" of type '" "Magick::Image const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "1"" of type '" "Magick::Image const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Image * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Image,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equal" "', argument " "2"" of type '" "Magick::Image const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "2"" of type '" "Magick::Image const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Image * >(argp2);
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[0].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[0].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[1].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[1].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator ==((Magick::Image const &)*arg1,(Magick::Image const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function_dispatcher
Napi::Value _wrap_Magick__wrap_equal(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_equal__SWIG_0(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_equal__SWIG_0(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_equal__SWIG_1(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_equal__SWIG_1(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_equal__SWIG_2(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_equal__SWIG_2(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_equal__SWIG_3(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_equal__SWIG_3(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_equal__SWIG_4(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_equal__SWIG_4(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_equal__SWIG_5(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_equal__SWIG_5(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_equal__SWIG_6(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_equal__SWIG_6(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_equal__SWIG_7(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_equal__SWIG_7(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_equal__SWIG_8(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_equal__SWIG_8(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  
  SWIG_Error(SWIG_ERROR, "Illegal arguments for function equal.");
  
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_notEqual__SWIG_8(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Image *arg1 = 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Image,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Image const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Image const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Image * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Image,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Image const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Image const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Image * >(argp2);
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[0].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[0].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[1].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[1].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator !=((Magick::Image const &)*arg1,(Magick::Image const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function_dispatcher
Napi::Value _wrap_Magick__wrap_notEqual(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_notEqual__SWIG_0(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_notEqual__SWIG_0(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_notEqual__SWIG_1(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_notEqual__SWIG_1(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_notEqual__SWIG_2(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_notEqual__SWIG_2(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_notEqual__SWIG_3(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_notEqual__SWIG_3(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_notEqual__SWIG_4(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_notEqual__SWIG_4(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_notEqual__SWIG_5(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_notEqual__SWIG_5(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_notEqual__SWIG_6(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_notEqual__SWIG_6(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_notEqual__SWIG_7(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_notEqual__SWIG_7(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_notEqual__SWIG_8(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_notEqual__SWIG_8(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  
  SWIG_Error(SWIG_ERROR, "Illegal arguments for function notEqual.");
  
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_gt__SWIG_6(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Image *arg1 = 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Image,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gt" "', argument " "1"" of type '" "Magick::Image const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "1"" of type '" "Magick::Image const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Image * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Image,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gt" "', argument " "2"" of type '" "Magick::Image const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "2"" of type '" "Magick::Image const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Image * >(argp2);
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[0].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[0].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[1].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[1].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator >((Magick::Image const &)*arg1,(Magick::Image const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function_dispatcher
Napi::Value _wrap_Magick__wrap_gt(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_gt__SWIG_0(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_gt__SWIG_0(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_gt__SWIG_1(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_gt__SWIG_1(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_gt__SWIG_2(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_gt__SWIG_2(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_gt__SWIG_3(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_gt__SWIG_3(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_gt__SWIG_4(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_gt__SWIG_4(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_gt__SWIG_5(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_gt__SWIG_5(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_gt__SWIG_6(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_gt__SWIG_6(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  
  SWIG_Error(SWIG_ERROR, "Illegal arguments for function gt.");
  
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_lt__SWIG_6(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Image *arg1 = 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Image,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lt" "', argument " "1"" of type '" "Magick::Image const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "1"" of type '" "Magick::Image const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Image * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Image,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lt" "', argument " "2"" of type '" "Magick::Image const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "2"" of type '" "Magick::Image const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Image * >(argp2);
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[0].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[0].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[1].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[1].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator <((Magick::Image const &)*arg1,(Magick::Image const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function_dispatcher
Napi::Value _wrap_Magick__wrap_lt(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_lt__SWIG_0(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_lt__SWIG_0(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_lt__SWIG_1(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_lt__SWIG_1(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_lt__SWIG_2(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_lt__SWIG_2(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_lt__SWIG_3(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_lt__SWIG_3(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_lt__SWIG_4(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_lt__SWIG_4(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_lt__SWIG_5(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_lt__SWIG_5(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_lt__SWIG_6(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_lt__SWIG_6(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  
  SWIG_Error(SWIG_ERROR, "Illegal arguments for function lt.");
  
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_gte__SWIG_6(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Image *arg1 = 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Image,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gte" "', argument " "1"" of type '" "Magick::Image const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "1"" of type '" "Magick::Image const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Image * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Image,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gte" "', argument " "2"" of type '" "Magick::Image const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "2"" of type '" "Magick::Image const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Image * >(argp2);
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[0].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[0].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[1].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[1].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator >=((Magick::Image const &)*arg1,(Magick::Image const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function_dispatcher
Napi::Value _wrap_Magick__wrap_gte(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_gte__SWIG_0(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_gte__SWIG_0(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_gte__SWIG_1(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_gte__SWIG_1(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_gte__SWIG_2(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_gte__SWIG_2(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_gte__SWIG_3(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_gte__SWIG_3(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_gte__SWIG_4(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_gte__SWIG_4(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_gte__SWIG_5(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_gte__SWIG_5(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_gte__SWIG_6(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_gte__SWIG_6(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  
  SWIG_Error(SWIG_ERROR, "Illegal arguments for function gte.");
  
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_lte__SWIG_6(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Image *arg1 = 0 ;
  Magick::Image *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Image,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lte" "', argument " "1"" of type '" "Magick::Image const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "1"" of type '" "Magick::Image const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Image * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Image,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lte" "', argument " "2"" of type '" "Magick::Image const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "2"" of type '" "Magick::Image const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Image * >(argp2);
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[0].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[0].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[1].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[1].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator <=((Magick::Image const &)*arg1,(Magick::Image const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function_dispatcher
Napi::Value _wrap_Magick__wrap_lte(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_lte__SWIG_0(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_lte__SWIG_0(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_lte__SWIG_1(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_lte__SWIG_1(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_lte__SWIG_2(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_lte__SWIG_2(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_lte__SWIG_3(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_lte__SWIG_3(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_lte__SWIG_4(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_lte__SWIG_4(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_lte__SWIG_5(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_lte__SWIG_5(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_lte__SWIG_6(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_lte__SWIG_6(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  
  SWIG_Error(SWIG_ERROR, "Illegal arguments for function lte.");
  
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_coderInfoList__SWIG_0(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  std::vector< Magick::CoderInfo > *arg1 = (std::vector< Magick::CoderInfo > *) 0 ;
  Magick::CoderInfo::MatchType arg2 ;
  Magick::CoderInfo::MatchType arg3 ;
  Magick::CoderInfo::MatchType arg4 ;
  std::vector< Magick::CoderInfo > temp1 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    {
      arg1 = new std::vector<Magick::CoderInfo>;
    }
    ecode2 = SWIG_AsVal_int(info[0], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "coderInfoList" "', argument " "2"" of type '" "Magick::CoderInfo::MatchType""'");
    } 
    arg2 = static_cast< Magick::CoderInfo::MatchType >(val2);ecode3 = SWIG_AsVal_int(info[1], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "coderInfoList" "', argument " "3"" of type '" "Magick::CoderInfo::MatchType""'");
    } 
    arg3 = static_cast< Magick::CoderInfo::MatchType >(val3);ecode4 = SWIG_AsVal_int(info[2], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "coderInfoList" "', argument " "4"" of type '" "Magick::CoderInfo::MatchType""'");
    } 
    arg4 = static_cast< Magick::CoderInfo::MatchType >(val4);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR coderInfoList< std::vector< Magick::CoderInfo > >(arg1,arg2,arg3,arg4);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      jsresult = SWIG_NAPI_NewPointerObj(env, arg1, SWIGTYPE_p_std__vectorT_Magick__CoderInfo_t, SWIG_POINTER_OWN);
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_coderInfoList__SWIG_1(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  std::vector< Magick::CoderInfo > *arg1 = (std::vector< Magick::CoderInfo > *) 0 ;
  Magick::CoderInfo::MatchType arg2 ;
  Magick::CoderInfo::MatchType arg3 ;
  std::vector< Magick::CoderInfo > temp1 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    {
      arg1 = new std::vector<Magick::CoderInfo>;
    }
    ecode2 = SWIG_AsVal_int(info[0], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "coderInfoList" "', argument " "2"" of type '" "Magick::CoderInfo::MatchType""'");
    } 
    arg2 = static_cast< Magick::CoderInfo::MatchType >(val2);ecode3 = SWIG_AsVal_int(info[1], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "coderInfoList" "', argument " "3"" of type '" "Magick::CoderInfo::MatchType""'");
    } 
    arg3 = static_cast< Magick::CoderInfo::MatchType >(val3);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR coderInfoList< std::vector< Magick::CoderInfo > >(arg1,arg2,arg3);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      jsresult = SWIG_NAPI_NewPointerObj(env, arg1, SWIGTYPE_p_std__vectorT_Magick__CoderInfo_t, SWIG_POINTER_OWN);
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_coderInfoList__SWIG_2(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  std::vector< Magick::CoderInfo > *arg1 = (std::vector< Magick::CoderInfo > *) 0 ;
  Magick::CoderInfo::MatchType arg2 ;
  std::vector< Magick::CoderInfo > temp1 ;
  int val2 ;
  int ecode2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    {
      arg1 = new std::vector<Magick::CoderInfo>;
    }
    ecode2 = SWIG_AsVal_int(info[0], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "coderInfoList" "', argument " "2"" of type '" "Magick::CoderInfo::MatchType""'");
    } 
    arg2 = static_cast< Magick::CoderInfo::MatchType >(val2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR coderInfoList< std::vector< Magick::CoderInfo > >(arg1,arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      jsresult = SWIG_NAPI_NewPointerObj(env, arg1, SWIGTYPE_p_std__vectorT_Magick__CoderInfo_t, SWIG_POINTER_OWN);
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_coderInfoList__SWIG_3(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  std::vector< Magick::CoderInfo > *arg1 = (std::vector< Magick::CoderInfo > *) 0 ;
  std::vector< Magick::CoderInfo > temp1 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    {
      arg1 = new std::vector<Magick::CoderInfo>;
    }
    
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR coderInfoList< std::vector< Magick::CoderInfo > >(arg1);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      jsresult = SWIG_NAPI_NewPointerObj(env, arg1, SWIGTYPE_p_std__vectorT_Magick__CoderInfo_t, SWIG_POINTER_OWN);
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function_dispatcher
Napi::Value _wrap_Magick__wrap_coderInfoList(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 3 && static_cast<int>(info.Length()) <= 3) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_coderInfoList__SWIG_0(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_coderInfoList__SWIG_0(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_coderInfoList__SWIG_1(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_coderInfoList__SWIG_1(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 1 && static_cast<int>(info.Length()) <= 1) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_coderInfoList__SWIG_2(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_coderInfoList__SWIG_2(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 0 && static_cast<int>(info.Length()) <= 0) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_coderInfoList__SWIG_3(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_coderInfoList__SWIG_3(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  
  SWIG_Error(SWIG_ERROR, "Illegal arguments for function coderInfoList.");
  
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


// js_global_overloaded_function_async
Napi::Value _wrap_appendImagesAsync__SWIG_0(const Napi::CallbackInfo &info) {
  // js_async_worker_local_class
  class _std_coderInfoArray__wrap_appendImagesAsync__SWIG_0_Tasklet : public SWIG_NAPI_AsyncContext {
    Napi::Env env;
    Magick::Image *arg1 = (Magick::Image *) 0 ;
    ImageListIterator arg2 ;
    ImageListIterator arg3 ;
    bool arg4 ;
    ImageListContainer temp_list2 ;
    bool val4 ;
    int ecode4 = 0 ;
    
    // js_locks_list
    SWIG_Locks_List SWIG_locks;
    
  public:
    _std_coderInfoArray__wrap_appendImagesAsync__SWIG_0_Tasklet(Napi::Env _env)
    :SWIG_NAPI_AsyncContext(_env), env(_env) {
      
    }
    
    virtual void SWIG_NAPI_Execute() override {
      // This runs the action code in a worker thread and V8 is not accessible
      Napi::Env env(SWIG_NULLPTR);
      
      // js_guard
      SWIG_Guard SWIG_guard(SWIG_locks);
      
      
      // js_lock
      SWIG_guard.lock();
      
      
      Magick::SWIGTEMPLATEDISAMBIGUATOR appendImages< ImageListIterator >(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3),arg4);
      
      goto fail;
    fail:
      return;
    }
    
#ifdef NAPI_CPP_EXCEPTIONS
    virtual void SWIG_NAPI_Rethrow(const std::exception_ptr &saved) override {
      // Back in the main thread with V8 access, caller has HandleScope
      
      {
        try {
          if (saved) std::rethrow_exception(saved);
        } catch (const Magick::Exception &e) {
          do {
            SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
          } while (0);
          SWIG_fail;
        }
      }
      
      
    }
#endif
    
    virtual void SWIG_NAPI_Resolve() override {
      // Back in the main thread with V8 access, caller has HandleScope
      Napi::Value jsresult;
      jsresult = env.Undefined();
      {
        if (arg1 != nullptr) {
          jsresult = SWIG_NAPI_NewPointerObj(env, arg1, SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
        } else {
          jsresult = env.Null();
        }
      }
      
      if (!SWIG_NAPI_Cleanup()) goto fail;
      SWIG_NAPI_deferred_finalized = true;
      SWIG_NAPI_deferred.Resolve(jsresult);
      goto fail;
    fail:
      return;
    }
    
    virtual bool SWIG_NAPI_Cleanup() override {
      return true;
      goto fail;
    fail:
      return false;
    }
    
    virtual SWIG_NAPI_Status SWIG_NAPI_Init(const Napi::CallbackInfo &info) override {
#ifdef NAPI_CPP_EXCEPTIONS
      try {
#endif
        {
          arg1 = new Magick::Image();
        }
        {
          {
            if (info[0].IsArray()) {
              Napi::Array array = info[0].As<Napi::Array>();
              for (size_t i = 0; i < array.Length(); i++) {
                Magick::Image *im = nullptr;
                if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
                  SWIG_exception_fail(SWIG_TypeError, "in method 'appendImages', array element is not an Image");
                }
                // Emplace the newly constructed copies in the std::container
                temp_list2.emplace_back(Magick::Image(*im));
              }
              arg2 = temp_list2.begin();
              arg3 = temp_list2.end();
            } else {
              SWIG_exception_fail(SWIG_TypeError, "in method 'appendImages', argument 2 is not an array");
            }
          }
        }
        ecode4 = SWIG_AsVal_bool(info[1], &val4);
        if (!SWIG_IsOK(ecode4)) {
          SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "appendImages" "', argument " "4"" of type '" "bool""'");
        } 
        arg4 = static_cast< bool >(val4);
#define SWIG_NAPI_Raise SWIG_NAPI_Reject
        {
          SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
          if (info[0].IsObject()) {
            Napi::Object obj;
            NAPI_CHECK_RESULT(info[0].ToObject(), obj);
            if (SWIG_NAPI_IsWrappedObject(env, obj)) {
              ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
              if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
                SWIG_locks.insert({
                  reinterpret_cast<void*>(ow), {
                    [ow](){
                      ow->lock();
                    }, [ow](){
                      ow->unlock();
                    }
                    }
                });
              }
            }
          }
        }
        
#undef SWIG_NAPI_Raise
        return SWIG_NAPI_Status::OK;
#ifdef NAPI_CPP_EXCEPTIONS
      } catch (...) {
        SWIG_NAPI_Cleanup();
        std::rethrow_exception(std::current_exception());
      }
#endif
      goto fail;
    fail:
      SWIG_NAPI_Cleanup();
      return SWIG_NAPI_Status::THROW;
    }
  };
  
  Napi::Env env = info.Env();
  _std_coderInfoArray__wrap_appendImagesAsync__SWIG_0_Tasklet *context = SWIG_NULLPTR;
  SWIG_NAPI_AsyncWorker *worker = SWIG_NULLPTR;
  if(static_cast<int>(info.Length()) < 2 || static_cast<int>(info.Length()) > 2) {
    SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_appendImagesAsync__SWIG_0.");
  }
  context = new _std_coderInfoArray__wrap_appendImagesAsync__SWIG_0_Tasklet(env);
  worker = new SWIG_NAPI_AsyncWorker(
    env, "SWIG__wrap_appendImagesAsync__SWIG_0_Async_Worker", context);
  return worker->Run(info);
#ifdef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_appendImages__SWIG_0(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ImageListIterator arg2 ;
  ImageListIterator arg3 ;
  bool arg4 ;
  ImageListContainer temp_list2 ;
  bool val4 ;
  int ecode4 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    {
      arg1 = new Magick::Image();
    }
    {
      {
        if (info[0].IsArray()) {
          Napi::Array array = info[0].As<Napi::Array>();
          for (size_t i = 0; i < array.Length(); i++) {
            Magick::Image *im = nullptr;
            if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
              SWIG_exception_fail(SWIG_TypeError, "in method 'appendImages', array element is not an Image");
            }
            // Emplace the newly constructed copies in the std::container
            temp_list2.emplace_back(Magick::Image(*im));
          }
          arg2 = temp_list2.begin();
          arg3 = temp_list2.end();
        } else {
          SWIG_exception_fail(SWIG_TypeError, "in method 'appendImages', argument 2 is not an array");
        }
      }
    }
    ecode4 = SWIG_AsVal_bool(info[1], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "appendImages" "', argument " "4"" of type '" "bool""'");
    } 
    arg4 = static_cast< bool >(val4);
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[0].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[0].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR appendImages< ImageListIterator >(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3),arg4);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      if (arg1 != nullptr) {
        jsresult = SWIG_NAPI_NewPointerObj(env, arg1, SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
      } else {
        jsresult = env.Null();
      }
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function_async
Napi::Value _wrap_appendImagesAsync__SWIG_1(const Napi::CallbackInfo &info) {
  // js_async_worker_local_class
  class _std_coderInfoArray__wrap_appendImagesAsync__SWIG_1_Tasklet : public SWIG_NAPI_AsyncContext {
    Napi::Env env;
    Magick::Image *arg1 = (Magick::Image *) 0 ;
    ImageListIterator arg2 ;
    ImageListIterator arg3 ;
    ImageListContainer temp_list2 ;
    
    // js_locks_list
    SWIG_Locks_List SWIG_locks;
    
  public:
    _std_coderInfoArray__wrap_appendImagesAsync__SWIG_1_Tasklet(Napi::Env _env)
    :SWIG_NAPI_AsyncContext(_env), env(_env) {
      
    }
    
    virtual void SWIG_NAPI_Execute() override {
      // This runs the action code in a worker thread and V8 is not accessible
      Napi::Env env(SWIG_NULLPTR);
      
      // js_guard
      SWIG_Guard SWIG_guard(SWIG_locks);
      
      
      // js_lock
      SWIG_guard.lock();
      
      
      Magick::SWIGTEMPLATEDISAMBIGUATOR appendImages< ImageListIterator >(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
      
      goto fail;
    fail:
      return;
    }
    
#ifdef NAPI_CPP_EXCEPTIONS
    virtual void SWIG_NAPI_Rethrow(const std::exception_ptr &saved) override {
      // Back in the main thread with V8 access, caller has HandleScope
      
      {
        try {
          if (saved) std::rethrow_exception(saved);
        } catch (const Magick::Exception &e) {
          do {
            SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
          } while (0);
          SWIG_fail;
        }
      }
      
      
    }
#endif
    
    virtual void SWIG_NAPI_Resolve() override {
      // Back in the main thread with V8 access, caller has HandleScope
      Napi::Value jsresult;
      jsresult = env.Undefined();
      {
        if (arg1 != nullptr) {
          jsresult = SWIG_NAPI_NewPointerObj(env, arg1, SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
        } else {
          jsresult = env.Null();
        }
      }
      
      if (!SWIG_NAPI_Cleanup()) goto fail;
      SWIG_NAPI_deferred_finalized = true;
      SWIG_NAPI_deferred.Resolve(jsresult);
      goto fail;
    fail:
      return;
    }
    
    virtual bool SWIG_NAPI_Cleanup() override {
      return true;
      goto fail;
    fail:
      return false;
    }
    
    virtual SWIG_NAPI_Status SWIG_NAPI_Init(const Napi::CallbackInfo &info) override {
#ifdef NAPI_CPP_EXCEPTIONS
      try {
#endif
        {
          arg1 = new Magick::Image();
        }
        {
          {
            if (info[0].IsArray()) {
              Napi::Array array = info[0].As<Napi::Array>();
              for (size_t i = 0; i < array.Length(); i++) {
                Magick::Image *im = nullptr;
                if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
                  SWIG_exception_fail(SWIG_TypeError, "in method 'appendImages', array element is not an Image");
                }
                // Emplace the newly constructed copies in the std::container
                temp_list2.emplace_back(Magick::Image(*im));
              }
              arg2 = temp_list2.begin();
              arg3 = temp_list2.end();
            } else {
              SWIG_exception_fail(SWIG_TypeError, "in method 'appendImages', argument 2 is not an array");
            }
          }
        }
        
#define SWIG_NAPI_Raise SWIG_NAPI_Reject
        {
          SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
          if (info[0].IsObject()) {
            Napi::Object obj;
            NAPI_CHECK_RESULT(info[0].ToObject(), obj);
            if (SWIG_NAPI_IsWrappedObject(env, obj)) {
              ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
              if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
                SWIG_locks.insert({
                  reinterpret_cast<void*>(ow), {
                    [ow](){
                      ow->lock();
                    }, [ow](){
                      ow->unlock();
                    }
                    }
                });
              }
            }
          }
        }
        
#undef SWIG_NAPI_Raise
        return SWIG_NAPI_Status::OK;
#ifdef NAPI_CPP_EXCEPTIONS
      } catch (...) {
        SWIG_NAPI_Cleanup();
        std::rethrow_exception(std::current_exception());
      }
#endif
      goto fail;
    fail:
      SWIG_NAPI_Cleanup();
      return SWIG_NAPI_Status::THROW;
    }
  };
  
  Napi::Env env = info.Env();
  _std_coderInfoArray__wrap_appendImagesAsync__SWIG_1_Tasklet *context = SWIG_NULLPTR;
  SWIG_NAPI_AsyncWorker *worker = SWIG_NULLPTR;
  if(static_cast<int>(info.Length()) < 1 || static_cast<int>(info.Length()) > 1) {
    SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_appendImagesAsync__SWIG_1.");
  }
  context = new _std_coderInfoArray__wrap_appendImagesAsync__SWIG_1_Tasklet(env);
  worker = new SWIG_NAPI_AsyncWorker(
    env, "SWIG__wrap_appendImagesAsync__SWIG_1_Async_Worker", context);
  return worker->Run(info);
#ifdef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


// js_global_function_dispatcher
Napi::Value _wrap_Magick__wrap_appendImagesAsync(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_appendImagesAsync__SWIG_0(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_appendImagesAsync__SWIG_0(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 1 && static_cast<int>(info.Length()) <= 1) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_appendImagesAsync__SWIG_1(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_appendImagesAsync__SWIG_1(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  
  SWIG_Error(SWIG_ERROR, "Illegal arguments for function appendImagesAsync.");
  
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_appendImages__SWIG_1(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ImageListIterator arg2 ;
  ImageListIterator arg3 ;
  ImageListContainer temp_list2 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    {
      arg1 = new Magick::Image();
    }
    {
      {
        if (info[0].IsArray()) {
          Napi::Array array = info[0].As<Napi::Array>();
          for (size_t i = 0; i < array.Length(); i++) {
            Magick::Image *im = nullptr;
            if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
              SWIG_exception_fail(SWIG_TypeError, "in method 'appendImages', array element is not an Image");
            }
            // Emplace the newly constructed copies in the std::container
            temp_list2.emplace_back(Magick::Image(*im));
          }
          arg2 = temp_list2.begin();
          arg3 = temp_list2.end();
        } else {
          SWIG_exception_fail(SWIG_TypeError, "in method 'appendImages', argument 2 is not an array");
        }
      }
    }
    
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[0].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[0].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR appendImages< ImageListIterator >(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      if (arg1 != nullptr) {
        jsresult = SWIG_NAPI_NewPointerObj(env, arg1, SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
      } else {
        jsresult = env.Null();
      }
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function_dispatcher
Napi::Value _wrap_Magick__wrap_appendImages(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_appendImages__SWIG_0(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_appendImages__SWIG_0(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 1 && static_cast<int>(info.Length()) <= 1) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_appendImages__SWIG_1(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_appendImages__SWIG_1(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  
  SWIG_Error(SWIG_ERROR, "Illegal arguments for function appendImages.");
  
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


// js_global_function
Napi::Value _wrap_averageImages(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ImageListIterator arg2 ;
  ImageListIterator arg3 ;
  ImageListContainer temp_list2 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    if(static_cast<int>(info.Length()) < 1 || static_cast<int>(info.Length()) > 1) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_averageImages.");
    }
    
    {
      arg1 = new Magick::Image();
    }
    {
      {
        if (info[0].IsArray()) {
          Napi::Array array = info[0].As<Napi::Array>();
          for (size_t i = 0; i < array.Length(); i++) {
            Magick::Image *im = nullptr;
            if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
              SWIG_exception_fail(SWIG_TypeError, "in method 'averageImages', array element is not an Image");
            }
            // Emplace the newly constructed copies in the std::container
            temp_list2.emplace_back(Magick::Image(*im));
          }
          arg2 = temp_list2.begin();
          arg3 = temp_list2.end();
        } else {
          SWIG_exception_fail(SWIG_TypeError, "in method 'averageImages', argument 2 is not an array");
        }
      }
    }
    
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[0].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[0].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR averageImages< ImageListIterator >(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      if (arg1 != nullptr) {
        jsresult = SWIG_NAPI_NewPointerObj(env, arg1, SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
      } else {
        jsresult = env.Null();
      }
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function
Napi::Value _wrap_flattenImages(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ImageListIterator arg2 ;
  ImageListIterator arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ImageListContainer temp_list2 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    if(static_cast<int>(info.Length()) < 2 || static_cast<int>(info.Length()) > 2) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_flattenImages.");
    }
    
    res1 = SWIG_ConvertPtr(info[0], &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "flattenImages" "', argument " "1"" of type '" "Magick::Image *""'"); 
    }
    arg1 = reinterpret_cast< Magick::Image * >(argp1);{
      {
        if (info[1].IsArray()) {
          Napi::Array array = info[1].As<Napi::Array>();
          for (size_t i = 0; i < array.Length(); i++) {
            Magick::Image *im = nullptr;
            if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
              SWIG_exception_fail(SWIG_TypeError, "in method 'flattenImages', array element is not an Image");
            }
            // Emplace the newly constructed copies in the std::container
            temp_list2.emplace_back(Magick::Image(*im));
          }
          arg2 = temp_list2.begin();
          arg3 = temp_list2.end();
        } else {
          SWIG_exception_fail(SWIG_TypeError, "in method 'flattenImages', argument 2 is not an array");
        }
      }
    }
    
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[0].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[0].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR flattenImages< ImageListIterator >(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function
Napi::Value _wrap_mosaicImages(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ImageListIterator arg2 ;
  ImageListIterator arg3 ;
  ImageListContainer temp_list2 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    if(static_cast<int>(info.Length()) < 1 || static_cast<int>(info.Length()) > 1) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_mosaicImages.");
    }
    
    {
      arg1 = new Magick::Image();
    }
    {
      {
        if (info[0].IsArray()) {
          Napi::Array array = info[0].As<Napi::Array>();
          for (size_t i = 0; i < array.Length(); i++) {
            Magick::Image *im = nullptr;
            if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
              SWIG_exception_fail(SWIG_TypeError, "in method 'mosaicImages', array element is not an Image");
            }
            // Emplace the newly constructed copies in the std::container
            temp_list2.emplace_back(Magick::Image(*im));
          }
          arg2 = temp_list2.begin();
          arg3 = temp_list2.end();
        } else {
          SWIG_exception_fail(SWIG_TypeError, "in method 'mosaicImages', argument 2 is not an array");
        }
      }
    }
    
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[0].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[0].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR mosaicImages< ImageListIterator >(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      if (arg1 != nullptr) {
        jsresult = SWIG_NAPI_NewPointerObj(env, arg1, SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
      } else {
        jsresult = env.Null();
      }
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function
Napi::Value _wrap_coalesceImages(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  ImageListContainer *arg1 = (ImageListContainer *) 0 ;
  ImageListIterator arg2 ;
  ImageListIterator arg3 ;
  ImageListContainer temp_list1 ;
  ImageListContainer temp_list2 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    if(static_cast<int>(info.Length()) < 1 || static_cast<int>(info.Length()) > 1) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_coalesceImages.");
    }
    
    {
      arg1 = &temp_list1;
    }
    {
      {
        if (info[0].IsArray()) {
          Napi::Array array = info[0].As<Napi::Array>();
          for (size_t i = 0; i < array.Length(); i++) {
            Magick::Image *im = nullptr;
            if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
              SWIG_exception_fail(SWIG_TypeError, "in method 'coalesceImages', array element is not an Image");
            }
            // Emplace the newly constructed copies in the std::container
            temp_list2.emplace_back(Magick::Image(*im));
          }
          arg2 = temp_list2.begin();
          arg3 = temp_list2.end();
        } else {
          SWIG_exception_fail(SWIG_TypeError, "in method 'coalesceImages', argument 2 is not an array");
        }
      }
    }
    
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR coalesceImages< ImageListIterator,ImageListContainer >(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      if (arg1 != nullptr) {
        Napi::Array array = Napi::Array::New(env, arg1->size());
        size_t i = 0;
        // Iterate over the std::Container using standard C++ semantics
        for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
          Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
          array.Set(i, element);
        }
        jsresult = array;
      } else {
        jsresult = env.Null();
      }
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function
Napi::Value _wrap_deconstructImages(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  ImageListContainer *arg1 = (ImageListContainer *) 0 ;
  ImageListIterator arg2 ;
  ImageListIterator arg3 ;
  ImageListContainer temp_list1 ;
  ImageListContainer temp_list2 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    if(static_cast<int>(info.Length()) < 1 || static_cast<int>(info.Length()) > 1) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_deconstructImages.");
    }
    
    {
      arg1 = &temp_list1;
    }
    {
      {
        if (info[0].IsArray()) {
          Napi::Array array = info[0].As<Napi::Array>();
          for (size_t i = 0; i < array.Length(); i++) {
            Magick::Image *im = nullptr;
            if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
              SWIG_exception_fail(SWIG_TypeError, "in method 'deconstructImages', array element is not an Image");
            }
            // Emplace the newly constructed copies in the std::container
            temp_list2.emplace_back(Magick::Image(*im));
          }
          arg2 = temp_list2.begin();
          arg3 = temp_list2.end();
        } else {
          SWIG_exception_fail(SWIG_TypeError, "in method 'deconstructImages', argument 2 is not an array");
        }
      }
    }
    
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR deconstructImages< ImageListIterator,ImageListContainer >(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      if (arg1 != nullptr) {
        Napi::Array array = Napi::Array::New(env, arg1->size());
        size_t i = 0;
        // Iterate over the std::Container using standard C++ semantics
        for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
          Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
          array.Set(i, element);
        }
        jsresult = array;
      } else {
        jsresult = env.Null();
      }
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function_async
Napi::Value _wrap_forwardFourierTransformImageAsync__SWIG_0(const Napi::CallbackInfo &info) {
  // js_async_worker_local_class
  class _std_coderInfoArray__wrap_forwardFourierTransformImageAsync__SWIG_0_Tasklet : public SWIG_NAPI_AsyncContext {
    Napi::Env env;
    ImageListContainer *arg1 = (ImageListContainer *) 0 ;
    Magick::Image *arg2 = 0 ;
    ImageListContainer temp_list1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    // js_locks_list
    SWIG_Locks_List SWIG_locks;
    
  public:
    _std_coderInfoArray__wrap_forwardFourierTransformImageAsync__SWIG_0_Tasklet(Napi::Env _env)
    :SWIG_NAPI_AsyncContext(_env), env(_env) {
      
    }
    
    virtual void SWIG_NAPI_Execute() override {
      // This runs the action code in a worker thread and V8 is not accessible
      Napi::Env env(SWIG_NULLPTR);
      
      // js_guard
      SWIG_Guard SWIG_guard(SWIG_locks);
      
      
      // js_lock
      SWIG_guard.lock();
      
      
      Magick::SWIGTEMPLATEDISAMBIGUATOR forwardFourierTransformImage< ImageListContainer >(arg1,(Magick::Image const &)*arg2);
      
      goto fail;
    fail:
      return;
    }
    
#ifdef NAPI_CPP_EXCEPTIONS
    virtual void SWIG_NAPI_Rethrow(const std::exception_ptr &saved) override {
      // Back in the main thread with V8 access, caller has HandleScope
      
      {
        try {
          if (saved) std::rethrow_exception(saved);
        } catch (const Magick::Exception &e) {
          do {
            SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
          } while (0);
          SWIG_fail;
        }
      }
      
      
    }
#endif
    
    virtual void SWIG_NAPI_Resolve() override {
      // Back in the main thread with V8 access, caller has HandleScope
      Napi::Value jsresult;
      jsresult = env.Undefined();
      {
        if (arg1 != nullptr) {
          Napi::Array array = Napi::Array::New(env, arg1->size());
          size_t i = 0;
          // Iterate over the std::Container using standard C++ semantics
          for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
            Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
            array.Set(i, element);
          }
          jsresult = array;
        } else {
          jsresult = env.Null();
        }
      }
      
      if (!SWIG_NAPI_Cleanup()) goto fail;
      SWIG_NAPI_deferred_finalized = true;
      SWIG_NAPI_deferred.Resolve(jsresult);
      goto fail;
    fail:
      return;
    }
    
    virtual bool SWIG_NAPI_Cleanup() override {
      return true;
      goto fail;
    fail:
      return false;
    }
    
    virtual SWIG_NAPI_Status SWIG_NAPI_Init(const Napi::CallbackInfo &info) override {
#ifdef NAPI_CPP_EXCEPTIONS
      try {
#endif
        {
          arg1 = &temp_list1;
        }
        res2 = SWIG_ConvertPtr(info[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
        if (!SWIG_IsOK(res2)) {
          SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "forwardFourierTransformImage" "', argument " "2"" of type '" "Magick::Image const &""'"); 
        }
        if (!argp2) {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "forwardFourierTransformImage" "', argument " "2"" of type '" "Magick::Image const &""'"); 
        }
        arg2 = reinterpret_cast< Magick::Image * >(argp2);
#define SWIG_NAPI_Raise SWIG_NAPI_Reject
        {
          SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
          if (info[0].IsObject()) {
            Napi::Object obj;
            NAPI_CHECK_RESULT(info[0].ToObject(), obj);
            if (SWIG_NAPI_IsWrappedObject(env, obj)) {
              ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
              if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
                SWIG_locks.insert({
                  reinterpret_cast<void*>(ow), {
                    [ow](){
                      ow->lock();
                    }, [ow](){
                      ow->unlock();
                    }
                    }
                });
              }
            }
          }
        }
        
#undef SWIG_NAPI_Raise
        return SWIG_NAPI_Status::OK;
#ifdef NAPI_CPP_EXCEPTIONS
      } catch (...) {
        SWIG_NAPI_Cleanup();
        std::rethrow_exception(std::current_exception());
      }
#endif
      goto fail;
    fail:
      SWIG_NAPI_Cleanup();
      return SWIG_NAPI_Status::THROW;
    }
  };
  
  Napi::Env env = info.Env();
  _std_coderInfoArray__wrap_forwardFourierTransformImageAsync__SWIG_0_Tasklet *context = SWIG_NULLPTR;
  SWIG_NAPI_AsyncWorker *worker = SWIG_NULLPTR;
  if(static_cast<int>(info.Length()) < 1 || static_cast<int>(info.Length()) > 1) {
    SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_forwardFourierTransformImageAsync__SWIG_0.");
  }
  context = new _std_coderInfoArray__wrap_forwardFourierTransformImageAsync__SWIG_0_Tasklet(env);
  worker = new SWIG_NAPI_AsyncWorker(
    env, "SWIG__wrap_forwardFourierTransformImageAsync__SWIG_0_Async_Worker", context);
  return worker->Run(info);
#ifdef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_forwardFourierTransformImage__SWIG_0(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  ImageListContainer *arg1 = (ImageListContainer *) 0 ;
  Magick::Image *arg2 = 0 ;
  ImageListContainer temp_list1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    {
      arg1 = &temp_list1;
    }
    res2 = SWIG_ConvertPtr(info[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "forwardFourierTransformImage" "', argument " "2"" of type '" "Magick::Image const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "forwardFourierTransformImage" "', argument " "2"" of type '" "Magick::Image const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Image * >(argp2);
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[0].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[0].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR forwardFourierTransformImage< ImageListContainer >(arg1,(Magick::Image const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      if (arg1 != nullptr) {
        Napi::Array array = Napi::Array::New(env, arg1->size());
        size_t i = 0;
        // Iterate over the std::Container using standard C++ semantics
        for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
          Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
          array.Set(i, element);
        }
        jsresult = array;
      } else {
        jsresult = env.Null();
      }
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function_async
Napi::Value _wrap_forwardFourierTransformImageAsync__SWIG_1(const Napi::CallbackInfo &info) {
  // js_async_worker_local_class
  class _std_coderInfoArray__wrap_forwardFourierTransformImageAsync__SWIG_1_Tasklet : public SWIG_NAPI_AsyncContext {
    Napi::Env env;
    ImageListContainer *arg1 = (ImageListContainer *) 0 ;
    Magick::Image *arg2 = 0 ;
    bool arg3 ;
    ImageListContainer temp_list1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    bool val3 ;
    int ecode3 = 0 ;
    
    // js_locks_list
    SWIG_Locks_List SWIG_locks;
    
  public:
    _std_coderInfoArray__wrap_forwardFourierTransformImageAsync__SWIG_1_Tasklet(Napi::Env _env)
    :SWIG_NAPI_AsyncContext(_env), env(_env) {
      
    }
    
    virtual void SWIG_NAPI_Execute() override {
      // This runs the action code in a worker thread and V8 is not accessible
      Napi::Env env(SWIG_NULLPTR);
      
      // js_guard
      SWIG_Guard SWIG_guard(SWIG_locks);
      
      
      // js_lock
      SWIG_guard.lock();
      
      
      Magick::SWIGTEMPLATEDISAMBIGUATOR forwardFourierTransformImage< ImageListContainer >(arg1,(Magick::Image const &)*arg2,arg3);
      
      goto fail;
    fail:
      return;
    }
    
#ifdef NAPI_CPP_EXCEPTIONS
    virtual void SWIG_NAPI_Rethrow(const std::exception_ptr &saved) override {
      // Back in the main thread with V8 access, caller has HandleScope
      
      {
        try {
          if (saved) std::rethrow_exception(saved);
        } catch (const Magick::Exception &e) {
          do {
            SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
          } while (0);
          SWIG_fail;
        }
      }
      
      
    }
#endif
    
    virtual void SWIG_NAPI_Resolve() override {
      // Back in the main thread with V8 access, caller has HandleScope
      Napi::Value jsresult;
      jsresult = env.Undefined();
      {
        if (arg1 != nullptr) {
          Napi::Array array = Napi::Array::New(env, arg1->size());
          size_t i = 0;
          // Iterate over the std::Container using standard C++ semantics
          for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
            Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
            array.Set(i, element);
          }
          jsresult = array;
        } else {
          jsresult = env.Null();
        }
      }
      
      if (!SWIG_NAPI_Cleanup()) goto fail;
      SWIG_NAPI_deferred_finalized = true;
      SWIG_NAPI_deferred.Resolve(jsresult);
      goto fail;
    fail:
      return;
    }
    
    virtual bool SWIG_NAPI_Cleanup() override {
      return true;
      goto fail;
    fail:
      return false;
    }
    
    virtual SWIG_NAPI_Status SWIG_NAPI_Init(const Napi::CallbackInfo &info) override {
#ifdef NAPI_CPP_EXCEPTIONS
      try {
#endif
        {
          arg1 = &temp_list1;
        }
        res2 = SWIG_ConvertPtr(info[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
        if (!SWIG_IsOK(res2)) {
          SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "forwardFourierTransformImage" "', argument " "2"" of type '" "Magick::Image const &""'"); 
        }
        if (!argp2) {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "forwardFourierTransformImage" "', argument " "2"" of type '" "Magick::Image const &""'"); 
        }
        arg2 = reinterpret_cast< Magick::Image * >(argp2);ecode3 = SWIG_AsVal_bool(info[1], &val3);
        if (!SWIG_IsOK(ecode3)) {
          SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "forwardFourierTransformImage" "', argument " "3"" of type '" "bool""'");
        } 
        arg3 = static_cast< bool >(val3);
#define SWIG_NAPI_Raise SWIG_NAPI_Reject
        {
          SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
          if (info[0].IsObject()) {
            Napi::Object obj;
            NAPI_CHECK_RESULT(info[0].ToObject(), obj);
            if (SWIG_NAPI_IsWrappedObject(env, obj)) {
              ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
              if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
                SWIG_locks.insert({
                  reinterpret_cast<void*>(ow), {
                    [ow](){
                      ow->lock();
                    }, [ow](){
                      ow->unlock();
                    }
                    }
                });
              }
            }
          }
        }
        
#undef SWIG_NAPI_Raise
        return SWIG_NAPI_Status::OK;
#ifdef NAPI_CPP_EXCEPTIONS
      } catch (...) {
        SWIG_NAPI_Cleanup();
        std::rethrow_exception(std::current_exception());
      }
#endif
      goto fail;
    fail:
      SWIG_NAPI_Cleanup();
      return SWIG_NAPI_Status::THROW;
    }
  };
  
  Napi::Env env = info.Env();
  _std_coderInfoArray__wrap_forwardFourierTransformImageAsync__SWIG_1_Tasklet *context = SWIG_NULLPTR;
  SWIG_NAPI_AsyncWorker *worker = SWIG_NULLPTR;
  if(static_cast<int>(info.Length()) < 2 || static_cast<int>(info.Length()) > 2) {
    SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_forwardFourierTransformImageAsync__SWIG_1.");
  }
  context = new _std_coderInfoArray__wrap_forwardFourierTransformImageAsync__SWIG_1_Tasklet(env);
  worker = new SWIG_NAPI_AsyncWorker(
    env, "SWIG__wrap_forwardFourierTransformImageAsync__SWIG_1_Async_Worker", context);
  return worker->Run(info);
#ifdef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


// js_global_function_dispatcher
Napi::Value _wrap_Magick__wrap_forwardFourierTransformImageAsync(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 1 && static_cast<int>(info.Length()) <= 1) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_forwardFourierTransformImageAsync__SWIG_0(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_forwardFourierTransformImageAsync__SWIG_0(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_forwardFourierTransformImageAsync__SWIG_1(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_forwardFourierTransformImageAsync__SWIG_1(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  
  SWIG_Error(SWIG_ERROR, "Illegal arguments for function forwardFourierTransformImageAsync.");
  
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_forwardFourierTransformImage__SWIG_1(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  ImageListContainer *arg1 = (ImageListContainer *) 0 ;
  Magick::Image *arg2 = 0 ;
  bool arg3 ;
  ImageListContainer temp_list1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    {
      arg1 = &temp_list1;
    }
    res2 = SWIG_ConvertPtr(info[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "forwardFourierTransformImage" "', argument " "2"" of type '" "Magick::Image const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "forwardFourierTransformImage" "', argument " "2"" of type '" "Magick::Image const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Image * >(argp2);ecode3 = SWIG_AsVal_bool(info[1], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "forwardFourierTransformImage" "', argument " "3"" of type '" "bool""'");
    } 
    arg3 = static_cast< bool >(val3);
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[0].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[0].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR forwardFourierTransformImage< ImageListContainer >(arg1,(Magick::Image const &)*arg2,arg3);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      if (arg1 != nullptr) {
        Napi::Array array = Napi::Array::New(env, arg1->size());
        size_t i = 0;
        // Iterate over the std::Container using standard C++ semantics
        for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
          Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
          array.Set(i, element);
        }
        jsresult = array;
      } else {
        jsresult = env.Null();
      }
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function_dispatcher
Napi::Value _wrap_Magick__wrap_forwardFourierTransformImage(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 1 && static_cast<int>(info.Length()) <= 1) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_forwardFourierTransformImage__SWIG_0(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_forwardFourierTransformImage__SWIG_0(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_forwardFourierTransformImage__SWIG_1(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_forwardFourierTransformImage__SWIG_1(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  
  SWIG_Error(SWIG_ERROR, "Illegal arguments for function forwardFourierTransformImage.");
  
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


// js_global_function
Napi::Value _wrap_montageImages(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  ImageListContainer *arg1 = (ImageListContainer *) 0 ;
  ImageListIterator arg2 ;
  ImageListIterator arg3 ;
  Magick::Montage *arg4 = 0 ;
  ImageListContainer temp_list1 ;
  ImageListContainer temp_list2 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    if(static_cast<int>(info.Length()) < 2 || static_cast<int>(info.Length()) > 2) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_montageImages.");
    }
    
    {
      arg1 = &temp_list1;
    }
    {
      {
        if (info[0].IsArray()) {
          Napi::Array array = info[0].As<Napi::Array>();
          for (size_t i = 0; i < array.Length(); i++) {
            Magick::Image *im = nullptr;
            if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
              SWIG_exception_fail(SWIG_TypeError, "in method 'montageImages', array element is not an Image");
            }
            // Emplace the newly constructed copies in the std::container
            temp_list2.emplace_back(Magick::Image(*im));
          }
          arg2 = temp_list2.begin();
          arg3 = temp_list2.end();
        } else {
          SWIG_exception_fail(SWIG_TypeError, "in method 'montageImages', argument 2 is not an array");
        }
      }
    }
    res4 = SWIG_ConvertPtr(info[1], &argp4, SWIGTYPE_p_Magick__Montage,  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "montageImages" "', argument " "4"" of type '" "Magick::Montage const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "montageImages" "', argument " "4"" of type '" "Magick::Montage const &""'"); 
    }
    arg4 = reinterpret_cast< Magick::Montage * >(argp4);
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[1].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[1].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR montageImages< ImageListContainer,ImageListIterator >(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3),(Magick::Montage const &)*arg4);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      if (arg1 != nullptr) {
        Napi::Array array = Napi::Array::New(env, arg1->size());
        size_t i = 0;
        // Iterate over the std::Container using standard C++ semantics
        for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
          Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
          array.Set(i, element);
        }
        jsresult = array;
      } else {
        jsresult = env.Null();
      }
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function
Napi::Value _wrap_morphImages(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  ImageListContainer *arg1 = (ImageListContainer *) 0 ;
  ImageListIterator arg2 ;
  ImageListIterator arg3 ;
  size_t arg4 ;
  ImageListContainer temp_list1 ;
  ImageListContainer temp_list2 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    if(static_cast<int>(info.Length()) < 2 || static_cast<int>(info.Length()) > 2) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_morphImages.");
    }
    
    {
      arg1 = &temp_list1;
    }
    {
      {
        if (info[0].IsArray()) {
          Napi::Array array = info[0].As<Napi::Array>();
          for (size_t i = 0; i < array.Length(); i++) {
            Magick::Image *im = nullptr;
            if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
              SWIG_exception_fail(SWIG_TypeError, "in method 'morphImages', array element is not an Image");
            }
            // Emplace the newly constructed copies in the std::container
            temp_list2.emplace_back(Magick::Image(*im));
          }
          arg2 = temp_list2.begin();
          arg3 = temp_list2.end();
        } else {
          SWIG_exception_fail(SWIG_TypeError, "in method 'morphImages', argument 2 is not an array");
        }
      }
    }
    ecode4 = SWIG_AsVal_unsigned_SS_int(info[1], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "morphImages" "', argument " "4"" of type '" "size_t""'");
    } 
    arg4 = static_cast< size_t >(val4);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR morphImages< ImageListIterator,ImageListContainer >(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3),SWIG_STD_MOVE(arg4));
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      if (arg1 != nullptr) {
        Napi::Array array = Napi::Array::New(env, arg1->size());
        size_t i = 0;
        // Iterate over the std::Container using standard C++ semantics
        for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
          Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
          array.Set(i, element);
        }
        jsresult = array;
      } else {
        jsresult = env.Null();
      }
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function_async
Napi::Value _wrap_readImagesAsync__SWIG_0(const Napi::CallbackInfo &info) {
  // js_async_worker_local_class
  class _std_coderInfoArray__wrap_readImagesAsync__SWIG_0_Tasklet : public SWIG_NAPI_AsyncContext {
    Napi::Env env;
    ImageListContainer *arg1 = (ImageListContainer *) 0 ;
    std::string *arg2 = 0 ;
    Magick::ReadOptions *arg3 = 0 ;
    ImageListContainer temp_list1 ;
    int res2 = SWIG_OLDOBJ ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    
    // js_locks_list
    SWIG_Locks_List SWIG_locks;
    
  public:
    _std_coderInfoArray__wrap_readImagesAsync__SWIG_0_Tasklet(Napi::Env _env)
    :SWIG_NAPI_AsyncContext(_env), env(_env) {
      
    }
    
    virtual void SWIG_NAPI_Execute() override {
      // This runs the action code in a worker thread and V8 is not accessible
      Napi::Env env(SWIG_NULLPTR);
      
      // js_guard
      SWIG_Guard SWIG_guard(SWIG_locks);
      
      
      // js_lock
      SWIG_guard.lock();
      
      
      Magick::SWIGTEMPLATEDISAMBIGUATOR readImages< ImageListContainer >(arg1,(std::string const &)*arg2,*arg3);
      
      goto fail;
    fail:
      return;
    }
    
#ifdef NAPI_CPP_EXCEPTIONS
    virtual void SWIG_NAPI_Rethrow(const std::exception_ptr &saved) override {
      // Back in the main thread with V8 access, caller has HandleScope
      
      {
        try {
          if (saved) std::rethrow_exception(saved);
        } catch (const Magick::Exception &e) {
          do {
            SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
          } while (0);
          SWIG_fail;
        }
      }
      
      
    }
#endif
    
    virtual void SWIG_NAPI_Resolve() override {
      // Back in the main thread with V8 access, caller has HandleScope
      Napi::Value jsresult;
      jsresult = env.Undefined();
      {
        if (arg1 != nullptr) {
          Napi::Array array = Napi::Array::New(env, arg1->size());
          size_t i = 0;
          // Iterate over the std::Container using standard C++ semantics
          for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
            Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
            array.Set(i, element);
          }
          jsresult = array;
        } else {
          jsresult = env.Null();
        }
      }
      
      if (!SWIG_NAPI_Cleanup()) goto fail;
      SWIG_NAPI_deferred_finalized = true;
      SWIG_NAPI_deferred.Resolve(jsresult);
      goto fail;
    fail:
      return;
    }
    
    virtual bool SWIG_NAPI_Cleanup() override {
      if (SWIG_IsNewObj(res2)) delete arg2;
      
      return true;
      goto fail;
    fail:
      return false;
    }
    
    virtual SWIG_NAPI_Status SWIG_NAPI_Init(const Napi::CallbackInfo &info) override {
#ifdef NAPI_CPP_EXCEPTIONS
      try {
#endif
        {
          arg1 = &temp_list1;
        }
        {
          {
            std::string *ptr = (std::string *)0;
            res2 = SWIG_AsPtr_std_string(info[0], &ptr);
            if (!SWIG_IsOK(res2)) {
              SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "readImages" "', argument " "2"" of type '" "std::string const &""'"); 
            }
            if (!ptr) {
              SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "readImages" "', argument " "2"" of type '" "std::string const &""'"); 
            }
            arg2 = ptr;
          }
        }
        res3 = SWIG_ConvertPtr(info[1], &argp3, SWIGTYPE_p_Magick__ReadOptions,  0 );
        if (!SWIG_IsOK(res3)) {
          SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "readImages" "', argument " "3"" of type '" "Magick::ReadOptions &""'"); 
        }
        if (!argp3) {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "readImages" "', argument " "3"" of type '" "Magick::ReadOptions &""'"); 
        }
        arg3 = reinterpret_cast< Magick::ReadOptions * >(argp3);
#define SWIG_NAPI_Raise SWIG_NAPI_Reject
        
#undef SWIG_NAPI_Raise
        return SWIG_NAPI_Status::OK;
#ifdef NAPI_CPP_EXCEPTIONS
      } catch (...) {
        SWIG_NAPI_Cleanup();
        std::rethrow_exception(std::current_exception());
      }
#endif
      goto fail;
    fail:
      SWIG_NAPI_Cleanup();
      return SWIG_NAPI_Status::THROW;
    }
  };
  
  Napi::Env env = info.Env();
  _std_coderInfoArray__wrap_readImagesAsync__SWIG_0_Tasklet *context = SWIG_NULLPTR;
  SWIG_NAPI_AsyncWorker *worker = SWIG_NULLPTR;
  if(static_cast<int>(info.Length()) < 2 || static_cast<int>(info.Length()) > 2) {
    SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_readImagesAsync__SWIG_0.");
  }
  context = new _std_coderInfoArray__wrap_readImagesAsync__SWIG_0_Tasklet(env);
  worker = new SWIG_NAPI_AsyncWorker(
    env, "SWIG__wrap_readImagesAsync__SWIG_0_Async_Worker", context);
  return worker->Run(info);
#ifdef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_readImages__SWIG_0(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  ImageListContainer *arg1 = (ImageListContainer *) 0 ;
  std::string *arg2 = 0 ;
  Magick::ReadOptions *arg3 = 0 ;
  ImageListContainer temp_list1 ;
  int res2 = SWIG_OLDOBJ ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    {
      arg1 = &temp_list1;
    }
    {
      {
        std::string *ptr = (std::string *)0;
        res2 = SWIG_AsPtr_std_string(info[0], &ptr);
        if (!SWIG_IsOK(res2)) {
          SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "readImages" "', argument " "2"" of type '" "std::string const &""'"); 
        }
        if (!ptr) {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "readImages" "', argument " "2"" of type '" "std::string const &""'"); 
        }
        arg2 = ptr;
      }
    }
    res3 = SWIG_ConvertPtr(info[1], &argp3, SWIGTYPE_p_Magick__ReadOptions,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "readImages" "', argument " "3"" of type '" "Magick::ReadOptions &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "readImages" "', argument " "3"" of type '" "Magick::ReadOptions &""'"); 
    }
    arg3 = reinterpret_cast< Magick::ReadOptions * >(argp3);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR readImages< ImageListContainer >(arg1,(std::string const &)*arg2,*arg3);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      if (arg1 != nullptr) {
        Napi::Array array = Napi::Array::New(env, arg1->size());
        size_t i = 0;
        // Iterate over the std::Container using standard C++ semantics
        for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
          Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
          array.Set(i, element);
        }
        jsresult = array;
      } else {
        jsresult = env.Null();
      }
    }
    
    if (SWIG_IsNewObj(res2)) delete arg2;
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    if (SWIG_IsNewObj(res2)) delete arg2;
    
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function_async
Napi::Value _wrap_readImagesAsync__SWIG_1(const Napi::CallbackInfo &info) {
  // js_async_worker_local_class
  class _std_coderInfoArray__wrap_readImagesAsync__SWIG_1_Tasklet : public SWIG_NAPI_AsyncContext {
    Napi::Env env;
    ImageListContainer *arg1 = (ImageListContainer *) 0 ;
    std::string *arg2 = 0 ;
    ImageListContainer temp_list1 ;
    int res2 = SWIG_OLDOBJ ;
    
    // js_locks_list
    SWIG_Locks_List SWIG_locks;
    
  public:
    _std_coderInfoArray__wrap_readImagesAsync__SWIG_1_Tasklet(Napi::Env _env)
    :SWIG_NAPI_AsyncContext(_env), env(_env) {
      
    }
    
    virtual void SWIG_NAPI_Execute() override {
      // This runs the action code in a worker thread and V8 is not accessible
      Napi::Env env(SWIG_NULLPTR);
      
      // js_guard
      SWIG_Guard SWIG_guard(SWIG_locks);
      
      
      // js_lock
      SWIG_guard.lock();
      
      
      Magick::SWIGTEMPLATEDISAMBIGUATOR readImages< ImageListContainer >(arg1,(std::string const &)*arg2);
      
      goto fail;
    fail:
      return;
    }
    
#ifdef NAPI_CPP_EXCEPTIONS
    virtual void SWIG_NAPI_Rethrow(const std::exception_ptr &saved) override {
      // Back in the main thread with V8 access, caller has HandleScope
      
      {
        try {
          if (saved) std::rethrow_exception(saved);
        } catch (const Magick::Exception &e) {
          do {
            SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
          } while (0);
          SWIG_fail;
        }
      }
      
      
    }
#endif
    
    virtual void SWIG_NAPI_Resolve() override {
      // Back in the main thread with V8 access, caller has HandleScope
      Napi::Value jsresult;
      jsresult = env.Undefined();
      {
        if (arg1 != nullptr) {
          Napi::Array array = Napi::Array::New(env, arg1->size());
          size_t i = 0;
          // Iterate over the std::Container using standard C++ semantics
          for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
            Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
            array.Set(i, element);
          }
          jsresult = array;
        } else {
          jsresult = env.Null();
        }
      }
      
      if (!SWIG_NAPI_Cleanup()) goto fail;
      SWIG_NAPI_deferred_finalized = true;
      SWIG_NAPI_deferred.Resolve(jsresult);
      goto fail;
    fail:
      return;
    }
    
    virtual bool SWIG_NAPI_Cleanup() override {
      if (SWIG_IsNewObj(res2)) delete arg2;
      
      return true;
      goto fail;
    fail:
      return false;
    }
    
    virtual SWIG_NAPI_Status SWIG_NAPI_Init(const Napi::CallbackInfo &info) override {
#ifdef NAPI_CPP_EXCEPTIONS
      try {
#endif
        {
          arg1 = &temp_list1;
        }
        {
          {
            std::string *ptr = (std::string *)0;
            res2 = SWIG_AsPtr_std_string(info[0], &ptr);
            if (!SWIG_IsOK(res2)) {
              SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "readImages" "', argument " "2"" of type '" "std::string const &""'"); 
            }
            if (!ptr) {
              SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "readImages" "', argument " "2"" of type '" "std::string const &""'"); 
            }
            arg2 = ptr;
          }
        }
        
#define SWIG_NAPI_Raise SWIG_NAPI_Reject
        
#undef SWIG_NAPI_Raise
        return SWIG_NAPI_Status::OK;
#ifdef NAPI_CPP_EXCEPTIONS
      } catch (...) {
        SWIG_NAPI_Cleanup();
        std::rethrow_exception(std::current_exception());
      }
#endif
      goto fail;
    fail:
      SWIG_NAPI_Cleanup();
      return SWIG_NAPI_Status::THROW;
    }
  };
  
  Napi::Env env = info.Env();
  _std_coderInfoArray__wrap_readImagesAsync__SWIG_1_Tasklet *context = SWIG_NULLPTR;
  SWIG_NAPI_AsyncWorker *worker = SWIG_NULLPTR;
  if(static_cast<int>(info.Length()) < 1 || static_cast<int>(info.Length()) > 1) {
    SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_readImagesAsync__SWIG_1.");
  }
  context = new _std_coderInfoArray__wrap_readImagesAsync__SWIG_1_Tasklet(env);
  worker = new SWIG_NAPI_AsyncWorker(
    env, "SWIG__wrap_readImagesAsync__SWIG_1_Async_Worker", context);
  return worker->Run(info);
#ifdef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_readImages__SWIG_1(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  ImageListContainer *arg1 = (ImageListContainer *) 0 ;
  std::string *arg2 = 0 ;
  ImageListContainer temp_list1 ;
  int res2 = SWIG_OLDOBJ ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    {
      arg1 = &temp_list1;
    }
    {
      {
        std::string *ptr = (std::string *)0;
        res2 = SWIG_AsPtr_std_string(info[0], &ptr);
        if (!SWIG_IsOK(res2)) {
          SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "readImages" "', argument " "2"" of type '" "std::string const &""'"); 
        }
        if (!ptr) {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "readImages" "', argument " "2"" of type '" "std::string const &""'"); 
        }
        arg2 = ptr;
      }
    }
    
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR readImages< ImageListContainer >(arg1,(std::string const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      if (arg1 != nullptr) {
        Napi::Array array = Napi::Array::New(env, arg1->size());
        size_t i = 0;
        // Iterate over the std::Container using standard C++ semantics
        for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
          Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
          array.Set(i, element);
        }
        jsresult = array;
      } else {
        jsresult = env.Null();
      }
    }
    
    if (SWIG_IsNewObj(res2)) delete arg2;
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    if (SWIG_IsNewObj(res2)) delete arg2;
    
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function_async
Napi::Value _wrap_readImagesAsync__SWIG_2(const Napi::CallbackInfo &info) {
  // js_async_worker_local_class
  class _std_coderInfoArray__wrap_readImagesAsync__SWIG_2_Tasklet : public SWIG_NAPI_AsyncContext {
    Napi::Env env;
    ImageListContainer *arg1 = (ImageListContainer *) 0 ;
    Magick::Blob *arg2 = 0 ;
    Magick::ReadOptions *arg3 = 0 ;
    ImageListContainer temp_list1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    
    // js_locks_list
    SWIG_Locks_List SWIG_locks;
    
  public:
    _std_coderInfoArray__wrap_readImagesAsync__SWIG_2_Tasklet(Napi::Env _env)
    :SWIG_NAPI_AsyncContext(_env), env(_env) {
      
    }
    
    virtual void SWIG_NAPI_Execute() override {
      // This runs the action code in a worker thread and V8 is not accessible
      Napi::Env env(SWIG_NULLPTR);
      
      // js_guard
      SWIG_Guard SWIG_guard(SWIG_locks);
      
      
      // js_lock
      SWIG_guard.lock();
      
      
      Magick::SWIGTEMPLATEDISAMBIGUATOR readImages< ImageListContainer >(arg1,(Magick::Blob const &)*arg2,*arg3);
      
      goto fail;
    fail:
      return;
    }
    
#ifdef NAPI_CPP_EXCEPTIONS
    virtual void SWIG_NAPI_Rethrow(const std::exception_ptr &saved) override {
      // Back in the main thread with V8 access, caller has HandleScope
      
      {
        try {
          if (saved) std::rethrow_exception(saved);
        } catch (const Magick::Exception &e) {
          do {
            SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
          } while (0);
          SWIG_fail;
        }
      }
      
      
    }
#endif
    
    virtual void SWIG_NAPI_Resolve() override {
      // Back in the main thread with V8 access, caller has HandleScope
      Napi::Value jsresult;
      jsresult = env.Undefined();
      {
        if (arg1 != nullptr) {
          Napi::Array array = Napi::Array::New(env, arg1->size());
          size_t i = 0;
          // Iterate over the std::Container using standard C++ semantics
          for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
            Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
            array.Set(i, element);
          }
          jsresult = array;
        } else {
          jsresult = env.Null();
        }
      }
      
      if (!SWIG_NAPI_Cleanup()) goto fail;
      SWIG_NAPI_deferred_finalized = true;
      SWIG_NAPI_deferred.Resolve(jsresult);
      goto fail;
    fail:
      return;
    }
    
    virtual bool SWIG_NAPI_Cleanup() override {
      return true;
      goto fail;
    fail:
      return false;
    }
    
    virtual SWIG_NAPI_Status SWIG_NAPI_Init(const Napi::CallbackInfo &info) override {
#ifdef NAPI_CPP_EXCEPTIONS
      try {
#endif
        {
          arg1 = &temp_list1;
        }
        res2 = SWIG_ConvertPtr(info[0], &argp2, SWIGTYPE_p_Magick__Blob,  0 );
        if (!SWIG_IsOK(res2)) {
          SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "readImages" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
        }
        if (!argp2) {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "readImages" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
        }
        arg2 = reinterpret_cast< Magick::Blob * >(argp2);res3 = SWIG_ConvertPtr(info[1], &argp3, SWIGTYPE_p_Magick__ReadOptions,  0 );
        if (!SWIG_IsOK(res3)) {
          SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "readImages" "', argument " "3"" of type '" "Magick::ReadOptions &""'"); 
        }
        if (!argp3) {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "readImages" "', argument " "3"" of type '" "Magick::ReadOptions &""'"); 
        }
        arg3 = reinterpret_cast< Magick::ReadOptions * >(argp3);
#define SWIG_NAPI_Raise SWIG_NAPI_Reject
        {
          SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
          if (info[0].IsObject()) {
            Napi::Object obj;
            NAPI_CHECK_RESULT(info[0].ToObject(), obj);
            if (SWIG_NAPI_IsWrappedObject(env, obj)) {
              ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
              if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
                SWIG_locks.insert({
                  reinterpret_cast<void*>(ow), {
                    [ow](){
                      ow->lock();
                    }, [ow](){
                      ow->unlock();
                    }
                    }
                });
              }
            }
          }
        }
        
#undef SWIG_NAPI_Raise
        return SWIG_NAPI_Status::OK;
#ifdef NAPI_CPP_EXCEPTIONS
      } catch (...) {
        SWIG_NAPI_Cleanup();
        std::rethrow_exception(std::current_exception());
      }
#endif
      goto fail;
    fail:
      SWIG_NAPI_Cleanup();
      return SWIG_NAPI_Status::THROW;
    }
  };
  
  Napi::Env env = info.Env();
  _std_coderInfoArray__wrap_readImagesAsync__SWIG_2_Tasklet *context = SWIG_NULLPTR;
  SWIG_NAPI_AsyncWorker *worker = SWIG_NULLPTR;
  if(static_cast<int>(info.Length()) < 2 || static_cast<int>(info.Length()) > 2) {
    SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_readImagesAsync__SWIG_2.");
  }
  context = new _std_coderInfoArray__wrap_readImagesAsync__SWIG_2_Tasklet(env);
  worker = new SWIG_NAPI_AsyncWorker(
    env, "SWIG__wrap_readImagesAsync__SWIG_2_Async_Worker", context);
  return worker->Run(info);
#ifdef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_readImages__SWIG_2(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  ImageListContainer *arg1 = (ImageListContainer *) 0 ;
  Magick::Blob *arg2 = 0 ;
  Magick::ReadOptions *arg3 = 0 ;
  ImageListContainer temp_list1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    {
      arg1 = &temp_list1;
    }
    res2 = SWIG_ConvertPtr(info[0], &argp2, SWIGTYPE_p_Magick__Blob,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "readImages" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "readImages" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Blob * >(argp2);res3 = SWIG_ConvertPtr(info[1], &argp3, SWIGTYPE_p_Magick__ReadOptions,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "readImages" "', argument " "3"" of type '" "Magick::ReadOptions &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "readImages" "', argument " "3"" of type '" "Magick::ReadOptions &""'"); 
    }
    arg3 = reinterpret_cast< Magick::ReadOptions * >(argp3);
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[0].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[0].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR readImages< ImageListContainer >(arg1,(Magick::Blob const &)*arg2,*arg3);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      if (arg1 != nullptr) {
        Napi::Array array = Napi::Array::New(env, arg1->size());
        size_t i = 0;
        // Iterate over the std::Container using standard C++ semantics
        for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
          Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
          array.Set(i, element);
        }
        jsresult = array;
      } else {
        jsresult = env.Null();
      }
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function_async
Napi::Value _wrap_readImagesAsync__SWIG_3(const Napi::CallbackInfo &info) {
  // js_async_worker_local_class
  class _std_coderInfoArray__wrap_readImagesAsync__SWIG_3_Tasklet : public SWIG_NAPI_AsyncContext {
    Napi::Env env;
    ImageListContainer *arg1 = (ImageListContainer *) 0 ;
    Magick::Blob *arg2 = 0 ;
    ImageListContainer temp_list1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    // js_locks_list
    SWIG_Locks_List SWIG_locks;
    
  public:
    _std_coderInfoArray__wrap_readImagesAsync__SWIG_3_Tasklet(Napi::Env _env)
    :SWIG_NAPI_AsyncContext(_env), env(_env) {
      
    }
    
    virtual void SWIG_NAPI_Execute() override {
      // This runs the action code in a worker thread and V8 is not accessible
      Napi::Env env(SWIG_NULLPTR);
      
      // js_guard
      SWIG_Guard SWIG_guard(SWIG_locks);
      
      
      // js_lock
      SWIG_guard.lock();
      
      
      Magick::SWIGTEMPLATEDISAMBIGUATOR readImages< ImageListContainer >(arg1,(Magick::Blob const &)*arg2);
      
      goto fail;
    fail:
      return;
    }
    
#ifdef NAPI_CPP_EXCEPTIONS
    virtual void SWIG_NAPI_Rethrow(const std::exception_ptr &saved) override {
      // Back in the main thread with V8 access, caller has HandleScope
      
      {
        try {
          if (saved) std::rethrow_exception(saved);
        } catch (const Magick::Exception &e) {
          do {
            SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
          } while (0);
          SWIG_fail;
        }
      }
      
      
    }
#endif
    
    virtual void SWIG_NAPI_Resolve() override {
      // Back in the main thread with V8 access, caller has HandleScope
      Napi::Value jsresult;
      jsresult = env.Undefined();
      {
        if (arg1 != nullptr) {
          Napi::Array array = Napi::Array::New(env, arg1->size());
          size_t i = 0;
          // Iterate over the std::Container using standard C++ semantics
          for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
            Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
            array.Set(i, element);
          }
          jsresult = array;
        } else {
          jsresult = env.Null();
        }
      }
      
      if (!SWIG_NAPI_Cleanup()) goto fail;
      SWIG_NAPI_deferred_finalized = true;
      SWIG_NAPI_deferred.Resolve(jsresult);
      goto fail;
    fail:
      return;
    }
    
    virtual bool SWIG_NAPI_Cleanup() override {
      return true;
      goto fail;
    fail:
      return false;
    }
    
    virtual SWIG_NAPI_Status SWIG_NAPI_Init(const Napi::CallbackInfo &info) override {
#ifdef NAPI_CPP_EXCEPTIONS
      try {
#endif
        {
          arg1 = &temp_list1;
        }
        res2 = SWIG_ConvertPtr(info[0], &argp2, SWIGTYPE_p_Magick__Blob,  0 );
        if (!SWIG_IsOK(res2)) {
          SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "readImages" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
        }
        if (!argp2) {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "readImages" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
        }
        arg2 = reinterpret_cast< Magick::Blob * >(argp2);
#define SWIG_NAPI_Raise SWIG_NAPI_Reject
        {
          SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
          if (info[0].IsObject()) {
            Napi::Object obj;
            NAPI_CHECK_RESULT(info[0].ToObject(), obj);
            if (SWIG_NAPI_IsWrappedObject(env, obj)) {
              ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
              if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
                SWIG_locks.insert({
                  reinterpret_cast<void*>(ow), {
                    [ow](){
                      ow->lock();
                    }, [ow](){
                      ow->unlock();
                    }
                    }
                });
              }
            }
          }
        }
        
#undef SWIG_NAPI_Raise
        return SWIG_NAPI_Status::OK;
#ifdef NAPI_CPP_EXCEPTIONS
      } catch (...) {
        SWIG_NAPI_Cleanup();
        std::rethrow_exception(std::current_exception());
      }
#endif
      goto fail;
    fail:
      SWIG_NAPI_Cleanup();
      return SWIG_NAPI_Status::THROW;
    }
  };
  
  Napi::Env env = info.Env();
  _std_coderInfoArray__wrap_readImagesAsync__SWIG_3_Tasklet *context = SWIG_NULLPTR;
  SWIG_NAPI_AsyncWorker *worker = SWIG_NULLPTR;
  if(static_cast<int>(info.Length()) < 1 || static_cast<int>(info.Length()) > 1) {
    SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_readImagesAsync__SWIG_3.");
  }
  context = new _std_coderInfoArray__wrap_readImagesAsync__SWIG_3_Tasklet(env);
  worker = new SWIG_NAPI_AsyncWorker(
    env, "SWIG__wrap_readImagesAsync__SWIG_3_Async_Worker", context);
  return worker->Run(info);
#ifdef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


// js_global_function_dispatcher
Napi::Value _wrap_Magick__wrap_readImagesAsync(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_readImagesAsync__SWIG_0(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_readImagesAsync__SWIG_0(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 1 && static_cast<int>(info.Length()) <= 1) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_readImagesAsync__SWIG_1(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_readImagesAsync__SWIG_1(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_readImagesAsync__SWIG_2(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_readImagesAsync__SWIG_2(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 1 && static_cast<int>(info.Length()) <= 1) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_readImagesAsync__SWIG_3(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_readImagesAsync__SWIG_3(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  
  SWIG_Error(SWIG_ERROR, "Illegal arguments for function readImagesAsync.");
  
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_readImages__SWIG_3(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  ImageListContainer *arg1 = (ImageListContainer *) 0 ;
  Magick::Blob *arg2 = 0 ;
  ImageListContainer temp_list1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    {
      arg1 = &temp_list1;
    }
    res2 = SWIG_ConvertPtr(info[0], &argp2, SWIGTYPE_p_Magick__Blob,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "readImages" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "readImages" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Blob * >(argp2);
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[0].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[0].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR readImages< ImageListContainer >(arg1,(Magick::Blob const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      if (arg1 != nullptr) {
        Napi::Array array = Napi::Array::New(env, arg1->size());
        size_t i = 0;
        // Iterate over the std::Container using standard C++ semantics
        for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
          Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
          array.Set(i, element);
        }
        jsresult = array;
      } else {
        jsresult = env.Null();
      }
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function_dispatcher
Napi::Value _wrap_Magick__wrap_readImages(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_readImages__SWIG_0(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_readImages__SWIG_0(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 1 && static_cast<int>(info.Length()) <= 1) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_readImages__SWIG_1(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_readImages__SWIG_1(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_readImages__SWIG_2(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_readImages__SWIG_2(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 1 && static_cast<int>(info.Length()) <= 1) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_readImages__SWIG_3(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_readImages__SWIG_3(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  
  SWIG_Error(SWIG_ERROR, "Illegal arguments for function readImages.");
  
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


// js_global_overloaded_function_async
Napi::Value _wrap_writeImagesAsync__SWIG_0(const Napi::CallbackInfo &info) {
  // js_async_worker_local_class
  class _std_coderInfoArray__wrap_writeImagesAsync__SWIG_0_Tasklet : public SWIG_NAPI_AsyncContext {
    Napi::Env env;
    ImageListIterator arg1 ;
    ImageListIterator arg2 ;
    std::string *arg3 = 0 ;
    bool arg4 ;
    ImageListContainer temp_list1 ;
    int res3 = SWIG_OLDOBJ ;
    bool val4 ;
    int ecode4 = 0 ;
    
    // js_locks_list
    SWIG_Locks_List SWIG_locks;
    
  public:
    _std_coderInfoArray__wrap_writeImagesAsync__SWIG_0_Tasklet(Napi::Env _env)
    :SWIG_NAPI_AsyncContext(_env), env(_env) {
      
    }
    
    virtual void SWIG_NAPI_Execute() override {
      // This runs the action code in a worker thread and V8 is not accessible
      Napi::Env env(SWIG_NULLPTR);
      
      // js_guard
      SWIG_Guard SWIG_guard(SWIG_locks);
      
      
      // js_lock
      SWIG_guard.lock();
      
      
      Magick::SWIGTEMPLATEDISAMBIGUATOR writeImages< ImageListIterator >(SWIG_STD_MOVE(arg1),SWIG_STD_MOVE(arg2),(std::string const &)*arg3,arg4);
      
      goto fail;
    fail:
      return;
    }
    
#ifdef NAPI_CPP_EXCEPTIONS
    virtual void SWIG_NAPI_Rethrow(const std::exception_ptr &saved) override {
      // Back in the main thread with V8 access, caller has HandleScope
      
      {
        try {
          if (saved) std::rethrow_exception(saved);
        } catch (const Magick::Exception &e) {
          do {
            SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
          } while (0);
          SWIG_fail;
        }
      }
      
      
    }
#endif
    
    virtual void SWIG_NAPI_Resolve() override {
      // Back in the main thread with V8 access, caller has HandleScope
      Napi::Value jsresult;
      jsresult = env.Undefined();
      
      if (!SWIG_NAPI_Cleanup()) goto fail;
      SWIG_NAPI_deferred_finalized = true;
      SWIG_NAPI_deferred.Resolve(jsresult);
      goto fail;
    fail:
      return;
    }
    
    virtual bool SWIG_NAPI_Cleanup() override {
      if (SWIG_IsNewObj(res3)) delete arg3;
      
      return true;
      goto fail;
    fail:
      return false;
    }
    
    virtual SWIG_NAPI_Status SWIG_NAPI_Init(const Napi::CallbackInfo &info) override {
#ifdef NAPI_CPP_EXCEPTIONS
      try {
#endif
        {
          {
            if (info[0].IsArray()) {
              Napi::Array array = info[0].As<Napi::Array>();
              for (size_t i = 0; i < array.Length(); i++) {
                Magick::Image *im = nullptr;
                if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
                  SWIG_exception_fail(SWIG_TypeError, "in method 'writeImages', array element is not an Image");
                }
                // Emplace the newly constructed copies in the std::container
                temp_list1.emplace_back(Magick::Image(*im));
              }
              arg1 = temp_list1.begin();
              arg2 = temp_list1.end();
            } else {
              SWIG_exception_fail(SWIG_TypeError, "in method 'writeImages', argument 1 is not an array");
            }
          }
        }
        {
          {
            std::string *ptr = (std::string *)0;
            res3 = SWIG_AsPtr_std_string(info[1], &ptr);
            if (!SWIG_IsOK(res3)) {
              SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "writeImages" "', argument " "3"" of type '" "std::string const &""'"); 
            }
            if (!ptr) {
              SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "writeImages" "', argument " "3"" of type '" "std::string const &""'"); 
            }
            arg3 = ptr;
          }
        }
        ecode4 = SWIG_AsVal_bool(info[2], &val4);
        if (!SWIG_IsOK(ecode4)) {
          SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "writeImages" "', argument " "4"" of type '" "bool""'");
        } 
        arg4 = static_cast< bool >(val4);
#define SWIG_NAPI_Raise SWIG_NAPI_Reject
        
#undef SWIG_NAPI_Raise
        return SWIG_NAPI_Status::OK;
#ifdef NAPI_CPP_EXCEPTIONS
      } catch (...) {
        SWIG_NAPI_Cleanup();
        std::rethrow_exception(std::current_exception());
      }
#endif
      goto fail;
    fail:
      SWIG_NAPI_Cleanup();
      return SWIG_NAPI_Status::THROW;
    }
  };
  
  Napi::Env env = info.Env();
  _std_coderInfoArray__wrap_writeImagesAsync__SWIG_0_Tasklet *context = SWIG_NULLPTR;
  SWIG_NAPI_AsyncWorker *worker = SWIG_NULLPTR;
  if(static_cast<int>(info.Length()) < 3 || static_cast<int>(info.Length()) > 3) {
    SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_writeImagesAsync__SWIG_0.");
  }
  context = new _std_coderInfoArray__wrap_writeImagesAsync__SWIG_0_Tasklet(env);
  worker = new SWIG_NAPI_AsyncWorker(
    env, "SWIG__wrap_writeImagesAsync__SWIG_0_Async_Worker", context);
  return worker->Run(info);
#ifdef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_writeImages__SWIG_0(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  ImageListIterator arg1 ;
  ImageListIterator arg2 ;
  std::string *arg3 = 0 ;
  bool arg4 ;
  ImageListContainer temp_list1 ;
  int res3 = SWIG_OLDOBJ ;
  bool val4 ;
  int ecode4 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    {
      {
        if (info[0].IsArray()) {
          Napi::Array array = info[0].As<Napi::Array>();
          for (size_t i = 0; i < array.Length(); i++) {
            Magick::Image *im = nullptr;
            if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
              SWIG_exception_fail(SWIG_TypeError, "in method 'writeImages', array element is not an Image");
            }
            // Emplace the newly constructed copies in the std::container
            temp_list1.emplace_back(Magick::Image(*im));
          }
          arg1 = temp_list1.begin();
          arg2 = temp_list1.end();
        } else {
          SWIG_exception_fail(SWIG_TypeError, "in method 'writeImages', argument 1 is not an array");
        }
      }
    }
    {
      {
        std::string *ptr = (std::string *)0;
        res3 = SWIG_AsPtr_std_string(info[1], &ptr);
        if (!SWIG_IsOK(res3)) {
          SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "writeImages" "', argument " "3"" of type '" "std::string const &""'"); 
        }
        if (!ptr) {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "writeImages" "', argument " "3"" of type '" "std::string const &""'"); 
        }
        arg3 = ptr;
      }
    }
    ecode4 = SWIG_AsVal_bool(info[2], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "writeImages" "', argument " "4"" of type '" "bool""'");
    } 
    arg4 = static_cast< bool >(val4);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR writeImages< ImageListIterator >(SWIG_STD_MOVE(arg1),SWIG_STD_MOVE(arg2),(std::string const &)*arg3,arg4);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    
    if (SWIG_IsNewObj(res3)) delete arg3;
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    if (SWIG_IsNewObj(res3)) delete arg3;
    
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function_async
Napi::Value _wrap_writeImagesAsync__SWIG_1(const Napi::CallbackInfo &info) {
  // js_async_worker_local_class
  class _std_coderInfoArray__wrap_writeImagesAsync__SWIG_1_Tasklet : public SWIG_NAPI_AsyncContext {
    Napi::Env env;
    ImageListIterator arg1 ;
    ImageListIterator arg2 ;
    std::string *arg3 = 0 ;
    ImageListContainer temp_list1 ;
    int res3 = SWIG_OLDOBJ ;
    
    // js_locks_list
    SWIG_Locks_List SWIG_locks;
    
  public:
    _std_coderInfoArray__wrap_writeImagesAsync__SWIG_1_Tasklet(Napi::Env _env)
    :SWIG_NAPI_AsyncContext(_env), env(_env) {
      
    }
    
    virtual void SWIG_NAPI_Execute() override {
      // This runs the action code in a worker thread and V8 is not accessible
      Napi::Env env(SWIG_NULLPTR);
      
      // js_guard
      SWIG_Guard SWIG_guard(SWIG_locks);
      
      
      // js_lock
      SWIG_guard.lock();
      
      
      Magick::SWIGTEMPLATEDISAMBIGUATOR writeImages< ImageListIterator >(SWIG_STD_MOVE(arg1),SWIG_STD_MOVE(arg2),(std::string const &)*arg3);
      
      goto fail;
    fail:
      return;
    }
    
#ifdef NAPI_CPP_EXCEPTIONS
    virtual void SWIG_NAPI_Rethrow(const std::exception_ptr &saved) override {
      // Back in the main thread with V8 access, caller has HandleScope
      
      {
        try {
          if (saved) std::rethrow_exception(saved);
        } catch (const Magick::Exception &e) {
          do {
            SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
          } while (0);
          SWIG_fail;
        }
      }
      
      
    }
#endif
    
    virtual void SWIG_NAPI_Resolve() override {
      // Back in the main thread with V8 access, caller has HandleScope
      Napi::Value jsresult;
      jsresult = env.Undefined();
      
      if (!SWIG_NAPI_Cleanup()) goto fail;
      SWIG_NAPI_deferred_finalized = true;
      SWIG_NAPI_deferred.Resolve(jsresult);
      goto fail;
    fail:
      return;
    }
    
    virtual bool SWIG_NAPI_Cleanup() override {
      if (SWIG_IsNewObj(res3)) delete arg3;
      
      return true;
      goto fail;
    fail:
      return false;
    }
    
    virtual SWIG_NAPI_Status SWIG_NAPI_Init(const Napi::CallbackInfo &info) override {
#ifdef NAPI_CPP_EXCEPTIONS
      try {
#endif
        {
          {
            if (info[0].IsArray()) {
              Napi::Array array = info[0].As<Napi::Array>();
              for (size_t i = 0; i < array.Length(); i++) {
                Magick::Image *im = nullptr;
                if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
                  SWIG_exception_fail(SWIG_TypeError, "in method 'writeImages', array element is not an Image");
                }
                // Emplace the newly constructed copies in the std::container
                temp_list1.emplace_back(Magick::Image(*im));
              }
              arg1 = temp_list1.begin();
              arg2 = temp_list1.end();
            } else {
              SWIG_exception_fail(SWIG_TypeError, "in method 'writeImages', argument 1 is not an array");
            }
          }
        }
        {
          {
            std::string *ptr = (std::string *)0;
            res3 = SWIG_AsPtr_std_string(info[1], &ptr);
            if (!SWIG_IsOK(res3)) {
              SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "writeImages" "', argument " "3"" of type '" "std::string const &""'"); 
            }
            if (!ptr) {
              SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "writeImages" "', argument " "3"" of type '" "std::string const &""'"); 
            }
            arg3 = ptr;
          }
        }
        
#define SWIG_NAPI_Raise SWIG_NAPI_Reject
        
#undef SWIG_NAPI_Raise
        return SWIG_NAPI_Status::OK;
#ifdef NAPI_CPP_EXCEPTIONS
      } catch (...) {
        SWIG_NAPI_Cleanup();
        std::rethrow_exception(std::current_exception());
      }
#endif
      goto fail;
    fail:
      SWIG_NAPI_Cleanup();
      return SWIG_NAPI_Status::THROW;
    }
  };
  
  Napi::Env env = info.Env();
  _std_coderInfoArray__wrap_writeImagesAsync__SWIG_1_Tasklet *context = SWIG_NULLPTR;
  SWIG_NAPI_AsyncWorker *worker = SWIG_NULLPTR;
  if(static_cast<int>(info.Length()) < 2 || static_cast<int>(info.Length()) > 2) {
    SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_writeImagesAsync__SWIG_1.");
  }
  context = new _std_coderInfoArray__wrap_writeImagesAsync__SWIG_1_Tasklet(env);
  worker = new SWIG_NAPI_AsyncWorker(
    env, "SWIG__wrap_writeImagesAsync__SWIG_1_Async_Worker", context);
  return worker->Run(info);
#ifdef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_writeImages__SWIG_1(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  ImageListIterator arg1 ;
  ImageListIterator arg2 ;
  std::string *arg3 = 0 ;
  ImageListContainer temp_list1 ;
  int res3 = SWIG_OLDOBJ ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    {
      {
        if (info[0].IsArray()) {
          Napi::Array array = info[0].As<Napi::Array>();
          for (size_t i = 0; i < array.Length(); i++) {
            Magick::Image *im = nullptr;
            if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
              SWIG_exception_fail(SWIG_TypeError, "in method 'writeImages', array element is not an Image");
            }
            // Emplace the newly constructed copies in the std::container
            temp_list1.emplace_back(Magick::Image(*im));
          }
          arg1 = temp_list1.begin();
          arg2 = temp_list1.end();
        } else {
          SWIG_exception_fail(SWIG_TypeError, "in method 'writeImages', argument 1 is not an array");
        }
      }
    }
    {
      {
        std::string *ptr = (std::string *)0;
        res3 = SWIG_AsPtr_std_string(info[1], &ptr);
        if (!SWIG_IsOK(res3)) {
          SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "writeImages" "', argument " "3"" of type '" "std::string const &""'"); 
        }
        if (!ptr) {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "writeImages" "', argument " "3"" of type '" "std::string const &""'"); 
        }
        arg3 = ptr;
      }
    }
    
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR writeImages< ImageListIterator >(SWIG_STD_MOVE(arg1),SWIG_STD_MOVE(arg2),(std::string const &)*arg3);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    
    if (SWIG_IsNewObj(res3)) delete arg3;
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    if (SWIG_IsNewObj(res3)) delete arg3;
    
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function_async
Napi::Value _wrap_writeImagesAsync__SWIG_2(const Napi::CallbackInfo &info) {
  // js_async_worker_local_class
  class _std_coderInfoArray__wrap_writeImagesAsync__SWIG_2_Tasklet : public SWIG_NAPI_AsyncContext {
    Napi::Env env;
    ImageListIterator arg1 ;
    ImageListIterator arg2 ;
    Magick::Blob *arg3 = (Magick::Blob *) 0 ;
    bool arg4 ;
    ImageListContainer temp_list1 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    bool val4 ;
    int ecode4 = 0 ;
    
    // js_locks_list
    SWIG_Locks_List SWIG_locks;
    
  public:
    _std_coderInfoArray__wrap_writeImagesAsync__SWIG_2_Tasklet(Napi::Env _env)
    :SWIG_NAPI_AsyncContext(_env), env(_env) {
      
    }
    
    virtual void SWIG_NAPI_Execute() override {
      // This runs the action code in a worker thread and V8 is not accessible
      Napi::Env env(SWIG_NULLPTR);
      
      // js_guard
      SWIG_Guard SWIG_guard(SWIG_locks);
      
      
      // js_lock
      SWIG_guard.lock();
      
      
      Magick::SWIGTEMPLATEDISAMBIGUATOR writeImages< ImageListIterator >(SWIG_STD_MOVE(arg1),SWIG_STD_MOVE(arg2),arg3,arg4);
      
      goto fail;
    fail:
      return;
    }
    
#ifdef NAPI_CPP_EXCEPTIONS
    virtual void SWIG_NAPI_Rethrow(const std::exception_ptr &saved) override {
      // Back in the main thread with V8 access, caller has HandleScope
      
      {
        try {
          if (saved) std::rethrow_exception(saved);
        } catch (const Magick::Exception &e) {
          do {
            SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
          } while (0);
          SWIG_fail;
        }
      }
      
      
    }
#endif
    
    virtual void SWIG_NAPI_Resolve() override {
      // Back in the main thread with V8 access, caller has HandleScope
      Napi::Value jsresult;
      jsresult = env.Undefined();
      
      if (!SWIG_NAPI_Cleanup()) goto fail;
      SWIG_NAPI_deferred_finalized = true;
      SWIG_NAPI_deferred.Resolve(jsresult);
      goto fail;
    fail:
      return;
    }
    
    virtual bool SWIG_NAPI_Cleanup() override {
      return true;
      goto fail;
    fail:
      return false;
    }
    
    virtual SWIG_NAPI_Status SWIG_NAPI_Init(const Napi::CallbackInfo &info) override {
#ifdef NAPI_CPP_EXCEPTIONS
      try {
#endif
        {
          {
            if (info[0].IsArray()) {
              Napi::Array array = info[0].As<Napi::Array>();
              for (size_t i = 0; i < array.Length(); i++) {
                Magick::Image *im = nullptr;
                if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
                  SWIG_exception_fail(SWIG_TypeError, "in method 'writeImages', array element is not an Image");
                }
                // Emplace the newly constructed copies in the std::container
                temp_list1.emplace_back(Magick::Image(*im));
              }
              arg1 = temp_list1.begin();
              arg2 = temp_list1.end();
            } else {
              SWIG_exception_fail(SWIG_TypeError, "in method 'writeImages', argument 1 is not an array");
            }
          }
        }
        res3 = SWIG_ConvertPtr(info[1], &argp3,SWIGTYPE_p_Magick__Blob, 0 |  0 );
        if (!SWIG_IsOK(res3)) {
          SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "writeImages" "', argument " "3"" of type '" "Magick::Blob *""'"); 
        }
        arg3 = reinterpret_cast< Magick::Blob * >(argp3);ecode4 = SWIG_AsVal_bool(info[2], &val4);
        if (!SWIG_IsOK(ecode4)) {
          SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "writeImages" "', argument " "4"" of type '" "bool""'");
        } 
        arg4 = static_cast< bool >(val4);
#define SWIG_NAPI_Raise SWIG_NAPI_Reject
        {
          SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
          if (info[1].IsObject()) {
            Napi::Object obj;
            NAPI_CHECK_RESULT(info[1].ToObject(), obj);
            if (SWIG_NAPI_IsWrappedObject(env, obj)) {
              ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
              if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
                SWIG_locks.insert({
                  reinterpret_cast<void*>(ow), {
                    [ow](){
                      ow->lock();
                    }, [ow](){
                      ow->unlock();
                    }
                    }
                });
              }
            }
          }
        }
        
#undef SWIG_NAPI_Raise
        return SWIG_NAPI_Status::OK;
#ifdef NAPI_CPP_EXCEPTIONS
      } catch (...) {
        SWIG_NAPI_Cleanup();
        std::rethrow_exception(std::current_exception());
      }
#endif
      goto fail;
    fail:
      SWIG_NAPI_Cleanup();
      return SWIG_NAPI_Status::THROW;
    }
  };
  
  Napi::Env env = info.Env();
  _std_coderInfoArray__wrap_writeImagesAsync__SWIG_2_Tasklet *context = SWIG_NULLPTR;
  SWIG_NAPI_AsyncWorker *worker = SWIG_NULLPTR;
  if(static_cast<int>(info.Length()) < 3 || static_cast<int>(info.Length()) > 3) {
    SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_writeImagesAsync__SWIG_2.");
  }
  context = new _std_coderInfoArray__wrap_writeImagesAsync__SWIG_2_Tasklet(env);
  worker = new SWIG_NAPI_AsyncWorker(
    env, "SWIG__wrap_writeImagesAsync__SWIG_2_Async_Worker", context);
  return worker->Run(info);
#ifdef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_writeImages__SWIG_2(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  ImageListIterator arg1 ;
  ImageListIterator arg2 ;
  Magick::Blob *arg3 = (Magick::Blob *) 0 ;
  bool arg4 ;
  ImageListContainer temp_list1 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    {
      {
        if (info[0].IsArray()) {
          Napi::Array array = info[0].As<Napi::Array>();
          for (size_t i = 0; i < array.Length(); i++) {
            Magick::Image *im = nullptr;
            if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
              SWIG_exception_fail(SWIG_TypeError, "in method 'writeImages', array element is not an Image");
            }
            // Emplace the newly constructed copies in the std::container
            temp_list1.emplace_back(Magick::Image(*im));
          }
          arg1 = temp_list1.begin();
          arg2 = temp_list1.end();
        } else {
          SWIG_exception_fail(SWIG_TypeError, "in method 'writeImages', argument 1 is not an array");
        }
      }
    }
    res3 = SWIG_ConvertPtr(info[1], &argp3,SWIGTYPE_p_Magick__Blob, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "writeImages" "', argument " "3"" of type '" "Magick::Blob *""'"); 
    }
    arg3 = reinterpret_cast< Magick::Blob * >(argp3);ecode4 = SWIG_AsVal_bool(info[2], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "writeImages" "', argument " "4"" of type '" "bool""'");
    } 
    arg4 = static_cast< bool >(val4);
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[1].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[1].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR writeImages< ImageListIterator >(SWIG_STD_MOVE(arg1),SWIG_STD_MOVE(arg2),arg3,arg4);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_overloaded_function_async
Napi::Value _wrap_writeImagesAsync__SWIG_3(const Napi::CallbackInfo &info) {
  // js_async_worker_local_class
  class _std_coderInfoArray__wrap_writeImagesAsync__SWIG_3_Tasklet : public SWIG_NAPI_AsyncContext {
    Napi::Env env;
    ImageListIterator arg1 ;
    ImageListIterator arg2 ;
    Magick::Blob *arg3 = (Magick::Blob *) 0 ;
    ImageListContainer temp_list1 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    
    // js_locks_list
    SWIG_Locks_List SWIG_locks;
    
  public:
    _std_coderInfoArray__wrap_writeImagesAsync__SWIG_3_Tasklet(Napi::Env _env)
    :SWIG_NAPI_AsyncContext(_env), env(_env) {
      
    }
    
    virtual void SWIG_NAPI_Execute() override {
      // This runs the action code in a worker thread and V8 is not accessible
      Napi::Env env(SWIG_NULLPTR);
      
      // js_guard
      SWIG_Guard SWIG_guard(SWIG_locks);
      
      
      // js_lock
      SWIG_guard.lock();
      
      
      Magick::SWIGTEMPLATEDISAMBIGUATOR writeImages< ImageListIterator >(SWIG_STD_MOVE(arg1),SWIG_STD_MOVE(arg2),arg3);
      
      goto fail;
    fail:
      return;
    }
    
#ifdef NAPI_CPP_EXCEPTIONS
    virtual void SWIG_NAPI_Rethrow(const std::exception_ptr &saved) override {
      // Back in the main thread with V8 access, caller has HandleScope
      
      {
        try {
          if (saved) std::rethrow_exception(saved);
        } catch (const Magick::Exception &e) {
          do {
            SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
          } while (0);
          SWIG_fail;
        }
      }
      
      
    }
#endif
    
    virtual void SWIG_NAPI_Resolve() override {
      // Back in the main thread with V8 access, caller has HandleScope
      Napi::Value jsresult;
      jsresult = env.Undefined();
      
      if (!SWIG_NAPI_Cleanup()) goto fail;
      SWIG_NAPI_deferred_finalized = true;
      SWIG_NAPI_deferred.Resolve(jsresult);
      goto fail;
    fail:
      return;
    }
    
    virtual bool SWIG_NAPI_Cleanup() override {
      return true;
      goto fail;
    fail:
      return false;
    }
    
    virtual SWIG_NAPI_Status SWIG_NAPI_Init(const Napi::CallbackInfo &info) override {
#ifdef NAPI_CPP_EXCEPTIONS
      try {
#endif
        {
          {
            if (info[0].IsArray()) {
              Napi::Array array = info[0].As<Napi::Array>();
              for (size_t i = 0; i < array.Length(); i++) {
                Magick::Image *im = nullptr;
                if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
                  SWIG_exception_fail(SWIG_TypeError, "in method 'writeImages', array element is not an Image");
                }
                // Emplace the newly constructed copies in the std::container
                temp_list1.emplace_back(Magick::Image(*im));
              }
              arg1 = temp_list1.begin();
              arg2 = temp_list1.end();
            } else {
              SWIG_exception_fail(SWIG_TypeError, "in method 'writeImages', argument 1 is not an array");
            }
          }
        }
        res3 = SWIG_ConvertPtr(info[1], &argp3,SWIGTYPE_p_Magick__Blob, 0 |  0 );
        if (!SWIG_IsOK(res3)) {
          SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "writeImages" "', argument " "3"" of type '" "Magick::Blob *""'"); 
        }
        arg3 = reinterpret_cast< Magick::Blob * >(argp3);
#define SWIG_NAPI_Raise SWIG_NAPI_Reject
        {
          SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
          if (info[1].IsObject()) {
            Napi::Object obj;
            NAPI_CHECK_RESULT(info[1].ToObject(), obj);
            if (SWIG_NAPI_IsWrappedObject(env, obj)) {
              ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
              if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
                SWIG_locks.insert({
                  reinterpret_cast<void*>(ow), {
                    [ow](){
                      ow->lock();
                    }, [ow](){
                      ow->unlock();
                    }
                    }
                });
              }
            }
          }
        }
        
#undef SWIG_NAPI_Raise
        return SWIG_NAPI_Status::OK;
#ifdef NAPI_CPP_EXCEPTIONS
      } catch (...) {
        SWIG_NAPI_Cleanup();
        std::rethrow_exception(std::current_exception());
      }
#endif
      goto fail;
    fail:
      SWIG_NAPI_Cleanup();
      return SWIG_NAPI_Status::THROW;
    }
  };
  
  Napi::Env env = info.Env();
  _std_coderInfoArray__wrap_writeImagesAsync__SWIG_3_Tasklet *context = SWIG_NULLPTR;
  SWIG_NAPI_AsyncWorker *worker = SWIG_NULLPTR;
  if(static_cast<int>(info.Length()) < 2 || static_cast<int>(info.Length()) > 2) {
    SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_writeImagesAsync__SWIG_3.");
  }
  context = new _std_coderInfoArray__wrap_writeImagesAsync__SWIG_3_Tasklet(env);
  worker = new SWIG_NAPI_AsyncWorker(
    env, "SWIG__wrap_writeImagesAsync__SWIG_3_Async_Worker", context);
  return worker->Run(info);
#ifdef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


// js_global_function_dispatcher
Napi::Value _wrap_Magick__wrap_writeImagesAsync(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 3 && static_cast<int>(info.Length()) <= 3) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_writeImagesAsync__SWIG_0(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_writeImagesAsync__SWIG_0(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_writeImagesAsync__SWIG_1(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_writeImagesAsync__SWIG_1(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 3 && static_cast<int>(info.Length()) <= 3) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_writeImagesAsync__SWIG_2(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_writeImagesAsync__SWIG_2(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_writeImagesAsync__SWIG_3(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_writeImagesAsync__SWIG_3(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  
  SWIG_Error(SWIG_ERROR, "Illegal arguments for function writeImagesAsync.");
  
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


// js_global_overloaded_function
Napi::Value _wrap_writeImages__SWIG_3(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  ImageListIterator arg1 ;
  ImageListIterator arg2 ;
  Magick::Blob *arg3 = (Magick::Blob *) 0 ;
  ImageListContainer temp_list1 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    {
      {
        if (info[0].IsArray()) {
          Napi::Array array = info[0].As<Napi::Array>();
          for (size_t i = 0; i < array.Length(); i++) {
            Magick::Image *im = nullptr;
            if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
              SWIG_exception_fail(SWIG_TypeError, "in method 'writeImages', array element is not an Image");
            }
            // Emplace the newly constructed copies in the std::container
            temp_list1.emplace_back(Magick::Image(*im));
          }
          arg1 = temp_list1.begin();
          arg2 = temp_list1.end();
        } else {
          SWIG_exception_fail(SWIG_TypeError, "in method 'writeImages', argument 1 is not an array");
        }
      }
    }
    res3 = SWIG_ConvertPtr(info[1], &argp3,SWIGTYPE_p_Magick__Blob, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "writeImages" "', argument " "3"" of type '" "Magick::Blob *""'"); 
    }
    arg3 = reinterpret_cast< Magick::Blob * >(argp3);
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[1].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[1].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR writeImages< ImageListIterator >(SWIG_STD_MOVE(arg1),SWIG_STD_MOVE(arg2),arg3);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


// js_global_function_dispatcher
Napi::Value _wrap_Magick__wrap_writeImages(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 3 && static_cast<int>(info.Length()) <= 3) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_writeImages__SWIG_0(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_writeImages__SWIG_0(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_writeImages__SWIG_1(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_writeImages__SWIG_1(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 3 && static_cast<int>(info.Length()) <= 3) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_writeImages__SWIG_2(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_writeImages__SWIG_2(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_writeImages__SWIG_3(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_writeImages__SWIG_3(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  
  SWIG_Error(SWIG_ERROR, "Illegal arguments for function writeImages.");
  
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_Magick__ColorCMYKTo_p_Magick__Color(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Color *)  ((Magick::ColorCMYK *) x));
}
static void *_p_Magick__ColorGrayTo_p_Magick__Color(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Color *)  ((Magick::ColorGray *) x));
}
static void *_p_Magick__ColorHSLTo_p_Magick__Color(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Color *)  ((Magick::ColorHSL *) x));
}
static void *_p_Magick__ColorMonoTo_p_Magick__Color(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Color *)  ((Magick::ColorMono *) x));
}
static void *_p_Magick__ColorRGBTo_p_Magick__Color(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Color *)  ((Magick::ColorRGB *) x));
}
static void *_p_Magick__ColorYUVTo_p_Magick__Color(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Color *)  ((Magick::ColorYUV *) x));
}
static void *_p_Magick__DrawableAffineTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableAffine *) x));
}
static void *_p_Magick__DrawableAlphaTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableAlpha *) x));
}
static void *_p_Magick__DrawableArcTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableArc *) x));
}
static void *_p_Magick__DrawableBezierTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableBezier *) x));
}
static void *_p_Magick__DrawableBorderColorTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableBorderColor *) x));
}
static void *_p_Magick__DrawableCircleTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableCircle *) x));
}
static void *_p_Magick__DrawableClipPathTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableClipPath *) x));
}
static void *_p_Magick__DrawableClipRuleTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableClipRule *) x));
}
static void *_p_Magick__DrawableClipUnitsTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableClipUnits *) x));
}
static void *_p_Magick__DrawableColorTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableColor *) x));
}
static void *_p_Magick__DrawableCompositeImageTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableCompositeImage *) x));
}
static void *_p_Magick__DrawableDensityTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableDensity *) x));
}
static void *_p_Magick__DrawableEllipseTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableEllipse *) x));
}
static void *_p_Magick__DrawableFillColorTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableFillColor *) x));
}
static void *_p_Magick__DrawableFillOpacityTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableFillOpacity *) x));
}
static void *_p_Magick__DrawableFillPatternUrlTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableFillPatternUrl *) x));
}
static void *_p_Magick__DrawableFillRuleTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableFillRule *) x));
}
static void *_p_Magick__DrawableFontTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableFont *) x));
}
static void *_p_Magick__DrawableGravityTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableGravity *) x));
}
static void *_p_Magick__DrawableLineTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableLine *) x));
}
static void *_p_Magick__DrawableMiterLimitTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableMiterLimit *) x));
}
static void *_p_Magick__DrawablePathTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawablePath *) x));
}
static void *_p_Magick__DrawablePointTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawablePoint *) x));
}
static void *_p_Magick__DrawablePointSizeTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawablePointSize *) x));
}
static void *_p_Magick__DrawablePolygonTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawablePolygon *) x));
}
static void *_p_Magick__DrawablePolylineTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawablePolyline *) x));
}
static void *_p_Magick__DrawablePopClipPathTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawablePopClipPath *) x));
}
static void *_p_Magick__DrawablePopGraphicContextTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawablePopGraphicContext *) x));
}
static void *_p_Magick__DrawablePopPatternTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawablePopPattern *) x));
}
static void *_p_Magick__DrawablePushClipPathTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawablePushClipPath *) x));
}
static void *_p_Magick__DrawablePushGraphicContextTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawablePushGraphicContext *) x));
}
static void *_p_Magick__DrawablePushPatternTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawablePushPattern *) x));
}
static void *_p_Magick__DrawableRectangleTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableRectangle *) x));
}
static void *_p_Magick__DrawableRotationTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableRotation *) x));
}
static void *_p_Magick__DrawableRoundRectangleTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableRoundRectangle *) x));
}
static void *_p_Magick__DrawableScalingTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableScaling *) x));
}
static void *_p_Magick__DrawableSkewXTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableSkewX *) x));
}
static void *_p_Magick__DrawableSkewYTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableSkewY *) x));
}
static void *_p_Magick__DrawableStrokeAntialiasTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableStrokeAntialias *) x));
}
static void *_p_Magick__DrawableStrokeColorTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableStrokeColor *) x));
}
static void *_p_Magick__DrawableStrokeDashArrayTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableStrokeDashArray *) x));
}
static void *_p_Magick__DrawableStrokeDashOffsetTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableStrokeDashOffset *) x));
}
static void *_p_Magick__DrawableStrokeLineCapTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableStrokeLineCap *) x));
}
static void *_p_Magick__DrawableStrokeLineJoinTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableStrokeLineJoin *) x));
}
static void *_p_Magick__DrawableStrokeOpacityTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableStrokeOpacity *) x));
}
static void *_p_Magick__DrawableStrokePatternUrlTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableStrokePatternUrl *) x));
}
static void *_p_Magick__DrawableStrokeWidthTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableStrokeWidth *) x));
}
static void *_p_Magick__DrawableTextTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableText *) x));
}
static void *_p_Magick__DrawableTextAlignmentTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableTextAlignment *) x));
}
static void *_p_Magick__DrawableTextAntialiasTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableTextAntialias *) x));
}
static void *_p_Magick__DrawableTextDecorationTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableTextDecoration *) x));
}
static void *_p_Magick__DrawableTextDirectionTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableTextDirection *) x));
}
static void *_p_Magick__DrawableTextInterlineSpacingTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableTextInterlineSpacing *) x));
}
static void *_p_Magick__DrawableTextInterwordSpacingTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableTextInterwordSpacing *) x));
}
static void *_p_Magick__DrawableTextKerningTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableTextKerning *) x));
}
static void *_p_Magick__DrawableTextUnderColorTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableTextUnderColor *) x));
}
static void *_p_Magick__DrawableTranslationTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableTranslation *) x));
}
static void *_p_Magick__DrawableViewboxTo_p_Magick__DrawableBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::DrawableBase *)  ((Magick::DrawableViewbox *) x));
}
static void *_p_Magick__ErrorBlobTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorBlob *) x));
}
static void *_p_Magick__ErrorCacheTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorCache *) x));
}
static void *_p_Magick__ErrorCoderTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorCoder *) x));
}
static void *_p_Magick__ErrorConfigureTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorConfigure *) x));
}
static void *_p_Magick__ErrorCorruptImageTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorCorruptImage *) x));
}
static void *_p_Magick__ErrorDelegateTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorDelegate *) x));
}
static void *_p_Magick__ErrorDrawTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorDraw *) x));
}
static void *_p_Magick__ErrorFileOpenTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorFileOpen *) x));
}
static void *_p_Magick__ErrorImageTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorImage *) x));
}
static void *_p_Magick__ErrorMissingDelegateTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorMissingDelegate *) x));
}
static void *_p_Magick__ErrorModuleTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorModule *) x));
}
static void *_p_Magick__ErrorMonitorTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorMonitor *) x));
}
static void *_p_Magick__ErrorOptionTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorOption *) x));
}
static void *_p_Magick__ErrorPolicyTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorPolicy *) x));
}
static void *_p_Magick__ErrorRegistryTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorRegistry *) x));
}
static void *_p_Magick__ErrorResourceLimitTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorResourceLimit *) x));
}
static void *_p_Magick__ErrorStreamTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorStream *) x));
}
static void *_p_Magick__ErrorTypeTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorType *) x));
}
static void *_p_Magick__ErrorUndefinedTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorUndefined *) x));
}
static void *_p_Magick__ErrorXServerTo_p_Magick__Error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Error *)  ((Magick::ErrorXServer *) x));
}
static void *_p_Magick__ErrorTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *)  ((Magick::Error *) x));
}
static void *_p_Magick__ErrorBlobTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorBlob *) x));
}
static void *_p_Magick__ErrorCacheTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorCache *) x));
}
static void *_p_Magick__ErrorCoderTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorCoder *) x));
}
static void *_p_Magick__ErrorConfigureTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorConfigure *) x));
}
static void *_p_Magick__ErrorCorruptImageTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorCorruptImage *) x));
}
static void *_p_Magick__ErrorDelegateTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorDelegate *) x));
}
static void *_p_Magick__ErrorDrawTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorDraw *) x));
}
static void *_p_Magick__ErrorFileOpenTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorFileOpen *) x));
}
static void *_p_Magick__ErrorImageTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorImage *) x));
}
static void *_p_Magick__ErrorMissingDelegateTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorMissingDelegate *) x));
}
static void *_p_Magick__ErrorModuleTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorModule *) x));
}
static void *_p_Magick__ErrorMonitorTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorMonitor *) x));
}
static void *_p_Magick__ErrorOptionTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorOption *) x));
}
static void *_p_Magick__ErrorPolicyTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorPolicy *) x));
}
static void *_p_Magick__ErrorRegistryTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorRegistry *) x));
}
static void *_p_Magick__ErrorResourceLimitTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorResourceLimit *) x));
}
static void *_p_Magick__ErrorStreamTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorStream *) x));
}
static void *_p_Magick__ErrorTypeTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorType *) x));
}
static void *_p_Magick__ErrorUndefinedTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorUndefined *) x));
}
static void *_p_Magick__ErrorXServerTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Error *) ((Magick::ErrorXServer *) x));
}
static void *_p_Magick__WarningTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *)  ((Magick::Warning *) x));
}
static void *_p_Magick__WarningBlobTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningBlob *) x));
}
static void *_p_Magick__WarningCacheTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningCache *) x));
}
static void *_p_Magick__WarningCoderTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningCoder *) x));
}
static void *_p_Magick__WarningConfigureTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningConfigure *) x));
}
static void *_p_Magick__WarningCorruptImageTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningCorruptImage *) x));
}
static void *_p_Magick__WarningDelegateTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningDelegate *) x));
}
static void *_p_Magick__WarningDrawTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningDraw *) x));
}
static void *_p_Magick__WarningFileOpenTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningFileOpen *) x));
}
static void *_p_Magick__WarningImageTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningImage *) x));
}
static void *_p_Magick__WarningMissingDelegateTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningMissingDelegate *) x));
}
static void *_p_Magick__WarningModuleTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningModule *) x));
}
static void *_p_Magick__WarningMonitorTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningMonitor *) x));
}
static void *_p_Magick__WarningOptionTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningOption *) x));
}
static void *_p_Magick__WarningPolicyTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningPolicy *) x));
}
static void *_p_Magick__WarningRegistryTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningRegistry *) x));
}
static void *_p_Magick__WarningResourceLimitTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningResourceLimit *) x));
}
static void *_p_Magick__WarningStreamTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningStream *) x));
}
static void *_p_Magick__WarningTypeTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningType *) x));
}
static void *_p_Magick__WarningUndefinedTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningUndefined *) x));
}
static void *_p_Magick__WarningXServerTo_p_Magick__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Exception *) (Magick::Warning *) ((Magick::WarningXServer *) x));
}
static void *_p_Magick__MontageFramedTo_p_Magick__Montage(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Montage *)  ((Magick::MontageFramed *) x));
}
static void *_p_Magick__PathArcAbsTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathArcAbs *) x));
}
static void *_p_Magick__PathArcRelTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathArcRel *) x));
}
static void *_p_Magick__PathClosePathTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathClosePath *) x));
}
static void *_p_Magick__PathCurvetoAbsTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathCurvetoAbs *) x));
}
static void *_p_Magick__PathCurvetoRelTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathCurvetoRel *) x));
}
static void *_p_Magick__PathLinetoAbsTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathLinetoAbs *) x));
}
static void *_p_Magick__PathLinetoHorizontalAbsTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathLinetoHorizontalAbs *) x));
}
static void *_p_Magick__PathLinetoHorizontalRelTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathLinetoHorizontalRel *) x));
}
static void *_p_Magick__PathLinetoRelTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathLinetoRel *) x));
}
static void *_p_Magick__PathLinetoVerticalAbsTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathLinetoVerticalAbs *) x));
}
static void *_p_Magick__PathLinetoVerticalRelTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathLinetoVerticalRel *) x));
}
static void *_p_Magick__PathMovetoAbsTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathMovetoAbs *) x));
}
static void *_p_Magick__PathMovetoRelTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathMovetoRel *) x));
}
static void *_p_Magick__PathQuadraticCurvetoAbsTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathQuadraticCurvetoAbs *) x));
}
static void *_p_Magick__PathQuadraticCurvetoRelTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathQuadraticCurvetoRel *) x));
}
static void *_p_Magick__PathSmoothCurvetoAbsTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathSmoothCurvetoAbs *) x));
}
static void *_p_Magick__PathSmoothCurvetoRelTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathSmoothCurvetoRel *) x));
}
static void *_p_Magick__PathSmoothQuadraticCurvetoAbsTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathSmoothQuadraticCurvetoAbs *) x));
}
static void *_p_Magick__PathSmoothQuadraticCurvetoRelTo_p_Magick__VPathBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::VPathBase *)  ((Magick::PathSmoothQuadraticCurvetoRel *) x));
}
static void *_p_Magick__WarningBlobTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningBlob *) x));
}
static void *_p_Magick__WarningCacheTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningCache *) x));
}
static void *_p_Magick__WarningCoderTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningCoder *) x));
}
static void *_p_Magick__WarningConfigureTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningConfigure *) x));
}
static void *_p_Magick__WarningCorruptImageTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningCorruptImage *) x));
}
static void *_p_Magick__WarningDelegateTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningDelegate *) x));
}
static void *_p_Magick__WarningDrawTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningDraw *) x));
}
static void *_p_Magick__WarningFileOpenTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningFileOpen *) x));
}
static void *_p_Magick__WarningImageTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningImage *) x));
}
static void *_p_Magick__WarningMissingDelegateTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningMissingDelegate *) x));
}
static void *_p_Magick__WarningModuleTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningModule *) x));
}
static void *_p_Magick__WarningMonitorTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningMonitor *) x));
}
static void *_p_Magick__WarningOptionTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningOption *) x));
}
static void *_p_Magick__WarningPolicyTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningPolicy *) x));
}
static void *_p_Magick__WarningRegistryTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningRegistry *) x));
}
static void *_p_Magick__WarningResourceLimitTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningResourceLimit *) x));
}
static void *_p_Magick__WarningStreamTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningStream *) x));
}
static void *_p_Magick__WarningTypeTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningType *) x));
}
static void *_p_Magick__WarningUndefinedTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningUndefined *) x));
}
static void *_p_Magick__WarningXServerTo_p_Magick__Warning(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Magick::Warning *)  ((Magick::WarningXServer *) x));
}
static void *_p_Magick__ErrorTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *) ((Magick::Error *) x));
}
static void *_p_Magick__ErrorBlobTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorBlob *) x));
}
static void *_p_Magick__ErrorCacheTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorCache *) x));
}
static void *_p_Magick__ErrorCoderTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorCoder *) x));
}
static void *_p_Magick__ErrorConfigureTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorConfigure *) x));
}
static void *_p_Magick__ErrorCorruptImageTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorCorruptImage *) x));
}
static void *_p_Magick__ErrorDelegateTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorDelegate *) x));
}
static void *_p_Magick__ErrorDrawTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorDraw *) x));
}
static void *_p_Magick__ErrorFileOpenTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorFileOpen *) x));
}
static void *_p_Magick__ErrorImageTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorImage *) x));
}
static void *_p_Magick__ErrorMissingDelegateTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorMissingDelegate *) x));
}
static void *_p_Magick__ErrorModuleTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorModule *) x));
}
static void *_p_Magick__ErrorMonitorTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorMonitor *) x));
}
static void *_p_Magick__ErrorOptionTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorOption *) x));
}
static void *_p_Magick__ErrorPolicyTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorPolicy *) x));
}
static void *_p_Magick__ErrorRegistryTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorRegistry *) x));
}
static void *_p_Magick__ErrorResourceLimitTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorResourceLimit *) x));
}
static void *_p_Magick__ErrorStreamTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorStream *) x));
}
static void *_p_Magick__ErrorTypeTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorType *) x));
}
static void *_p_Magick__ErrorUndefinedTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorUndefined *) x));
}
static void *_p_Magick__ErrorXServerTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Error *) ((Magick::ErrorXServer *) x));
}
static void *_p_Magick__ExceptionTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *)  ((Magick::Exception *) x));
}
static void *_p_Magick__WarningTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *) ((Magick::Warning *) x));
}
static void *_p_Magick__WarningBlobTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningBlob *) x));
}
static void *_p_Magick__WarningCacheTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningCache *) x));
}
static void *_p_Magick__WarningCoderTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningCoder *) x));
}
static void *_p_Magick__WarningConfigureTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningConfigure *) x));
}
static void *_p_Magick__WarningCorruptImageTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningCorruptImage *) x));
}
static void *_p_Magick__WarningDelegateTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningDelegate *) x));
}
static void *_p_Magick__WarningDrawTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningDraw *) x));
}
static void *_p_Magick__WarningFileOpenTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningFileOpen *) x));
}
static void *_p_Magick__WarningImageTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningImage *) x));
}
static void *_p_Magick__WarningMissingDelegateTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningMissingDelegate *) x));
}
static void *_p_Magick__WarningModuleTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningModule *) x));
}
static void *_p_Magick__WarningMonitorTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningMonitor *) x));
}
static void *_p_Magick__WarningOptionTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningOption *) x));
}
static void *_p_Magick__WarningPolicyTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningPolicy *) x));
}
static void *_p_Magick__WarningRegistryTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningRegistry *) x));
}
static void *_p_Magick__WarningResourceLimitTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningResourceLimit *) x));
}
static void *_p_Magick__WarningStreamTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningStream *) x));
}
static void *_p_Magick__WarningTypeTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningType *) x));
}
static void *_p_Magick__WarningUndefinedTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningUndefined *) x));
}
static void *_p_Magick__WarningXServerTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::exception *) (Magick::Exception *)(Magick::Warning *) ((Magick::WarningXServer *) x));
}
SWIGINTERN swig_type_info _swigt__p_FILE = {"_p_FILE", "FILE *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_ImageListContainer = {"_p_ImageListContainer", "ImageListContainer *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_ImageListIterator = {"_p_ImageListIterator", "ImageListIterator *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__AlignType = {"_p_MagickCore__AlignType", "MagickCore::AlignType *|enum MagickCore::AlignType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__CacheType = {"_p_MagickCore__CacheType", "MagickCore::CacheType *|enum MagickCore::CacheType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__ChannelType = {"_p_MagickCore__ChannelType", "MagickCore::ChannelType *|enum MagickCore::ChannelType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__ClassType = {"_p_MagickCore__ClassType", "MagickCore::ClassType *|enum MagickCore::ClassType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__ColorspaceType = {"_p_MagickCore__ColorspaceType", "MagickCore::ColorspaceType *|enum MagickCore::ColorspaceType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__ComplexOperator = {"_p_MagickCore__ComplexOperator", "MagickCore::ComplexOperator *|enum MagickCore::ComplexOperator *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__ComplianceType = {"_p_MagickCore__ComplianceType", "MagickCore::ComplianceType *|enum MagickCore::ComplianceType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__CompositeOperator = {"_p_MagickCore__CompositeOperator", "MagickCore::CompositeOperator *|enum MagickCore::CompositeOperator *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__CompressionType = {"_p_MagickCore__CompressionType", "MagickCore::CompressionType *|enum MagickCore::CompressionType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__DecorationType = {"_p_MagickCore__DecorationType", "MagickCore::DecorationType *|enum MagickCore::DecorationType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__DirectionType = {"_p_MagickCore__DirectionType", "MagickCore::DirectionType *|enum MagickCore::DirectionType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__DisposeType = {"_p_MagickCore__DisposeType", "MagickCore::DisposeType *|enum MagickCore::DisposeType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__EndianType = {"_p_MagickCore__EndianType", "MagickCore::EndianType *|enum MagickCore::EndianType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__ExceptionType = {"_p_MagickCore__ExceptionType", "MagickCore::ExceptionType *|enum MagickCore::ExceptionType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__FilterType = {"_p_MagickCore__FilterType", "MagickCore::FilterType *|enum MagickCore::FilterType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__GradientType = {"_p_MagickCore__GradientType", "MagickCore::GradientType *|enum MagickCore::GradientType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__GravityType = {"_p_MagickCore__GravityType", "MagickCore::GravityType *|enum MagickCore::GravityType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__IlluminantType = {"_p_MagickCore__IlluminantType", "MagickCore::IlluminantType *|enum MagickCore::IlluminantType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__ImageType = {"_p_MagickCore__ImageType", "MagickCore::ImageType *|enum MagickCore::ImageType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__InterlaceType = {"_p_MagickCore__InterlaceType", "MagickCore::InterlaceType *|enum MagickCore::InterlaceType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__KernelInfoType = {"_p_MagickCore__KernelInfoType", "MagickCore::KernelInfoType *|enum MagickCore::KernelInfoType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__LogEventType = {"_p_MagickCore__LogEventType", "MagickCore::LogEventType *|enum MagickCore::LogEventType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__MagickBooleanType = {"_p_MagickCore__MagickBooleanType", "MagickCore::MagickBooleanType *|enum MagickCore::MagickBooleanType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__MagickCLDeviceType = {"_p_MagickCore__MagickCLDeviceType", "MagickCore::MagickCLDeviceType *|enum MagickCore::MagickCLDeviceType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__MagickEvaluateOperator = {"_p_MagickCore__MagickEvaluateOperator", "MagickCore::MagickEvaluateOperator *|enum MagickCore::MagickEvaluateOperator *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__MagickFormatType = {"_p_MagickCore__MagickFormatType", "MagickCore::MagickFormatType *|enum MagickCore::MagickFormatType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__MagickModuleType = {"_p_MagickCore__MagickModuleType", "MagickCore::MagickModuleType *|enum MagickCore::MagickModuleType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__MetricType = {"_p_MagickCore__MetricType", "MagickCore::MetricType *|enum MagickCore::MetricType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__NoiseType = {"_p_MagickCore__NoiseType", "MagickCore::NoiseType *|enum MagickCore::NoiseType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__OrientationType = {"_p_MagickCore__OrientationType", "MagickCore::OrientationType *|enum MagickCore::OrientationType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__PathType = {"_p_MagickCore__PathType", "MagickCore::PathType *|enum MagickCore::PathType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__PolicyDomain = {"_p_MagickCore__PolicyDomain", "MagickCore::PolicyDomain *|enum MagickCore::PolicyDomain *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__PolicyRights = {"_p_MagickCore__PolicyRights", "MagickCore::PolicyRights *|enum MagickCore::PolicyRights *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__PreviewType = {"_p_MagickCore__PreviewType", "MagickCore::PreviewType *|enum MagickCore::PreviewType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__PrimitiveType = {"_p_MagickCore__PrimitiveType", "MagickCore::PrimitiveType *|enum MagickCore::PrimitiveType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__QuantumAlphaType = {"_p_MagickCore__QuantumAlphaType", "MagickCore::QuantumAlphaType *|enum MagickCore::QuantumAlphaType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__QuantumFormatType = {"_p_MagickCore__QuantumFormatType", "MagickCore::QuantumFormatType *|enum MagickCore::QuantumFormatType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__QuantumType = {"_p_MagickCore__QuantumType", "MagickCore::QuantumType *|enum MagickCore::QuantumType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__ReferenceType = {"_p_MagickCore__ReferenceType", "MagickCore::ReferenceType *|enum MagickCore::ReferenceType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__RegistryType = {"_p_MagickCore__RegistryType", "MagickCore::RegistryType *|enum MagickCore::RegistryType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__ResolutionType = {"_p_MagickCore__ResolutionType", "MagickCore::ResolutionType *|enum MagickCore::ResolutionType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__ResourceType = {"_p_MagickCore__ResourceType", "MagickCore::ResourceType *|enum MagickCore::ResourceType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__StatisticType = {"_p_MagickCore__StatisticType", "MagickCore::StatisticType *|enum MagickCore::StatisticType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__StorageType = {"_p_MagickCore__StorageType", "MagickCore::StorageType *|enum MagickCore::StorageType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__StretchType = {"_p_MagickCore__StretchType", "MagickCore::StretchType *|enum MagickCore::StretchType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__StyleType = {"_p_MagickCore__StyleType", "MagickCore::StyleType *|enum MagickCore::StyleType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__TransmitType = {"_p_MagickCore__TransmitType", "MagickCore::TransmitType *|enum MagickCore::TransmitType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__ValidateType = {"_p_MagickCore__ValidateType", "MagickCore::ValidateType *|enum MagickCore::ValidateType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore__WordBreakType = {"_p_MagickCore__WordBreakType", "MagickCore::WordBreakType *|enum MagickCore::WordBreakType *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore___ChannelMoments = {"_p_MagickCore___ChannelMoments", "MagickCore::ChannelMoments *|MagickCore::_ChannelMoments *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore___ChannelPerceptualHash = {"_p_MagickCore___ChannelPerceptualHash", "MagickCore::ChannelPerceptualHash *|MagickCore::_ChannelPerceptualHash *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore___ChannelStatistics = {"_p_MagickCore___ChannelStatistics", "MagickCore::ChannelStatistics *|MagickCore::_ChannelStatistics *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore___ExceptionInfo = {"_p_MagickCore___ExceptionInfo", "MagickCore::ExceptionInfo *|MagickCore::_ExceptionInfo *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore___Image = {"_p_MagickCore___Image", "MagickCore::Image *|MagickCore::_Image *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore___ImageInfo = {"_p_MagickCore___ImageInfo", "MagickCore::ImageInfo *|MagickCore::_ImageInfo *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore___MontageInfo = {"_p_MagickCore___MontageInfo", "MagickCore::MontageInfo *|MagickCore::_MontageInfo *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore___QuantizeInfo = {"_p_MagickCore___QuantizeInfo", "MagickCore::QuantizeInfo *|MagickCore::_QuantizeInfo *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickCore___RectangleInfo = {"_p_MagickCore___RectangleInfo", "MagickCore::RectangleInfo *|MagickCore::_RectangleInfo *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_MagickWand = {"_p_MagickWand", "MagickWand *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__Blob = {"_p_Magick__Blob", "Magick::Blob *|p_Magick__Blob", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ChannelMoments = {"_p_Magick__ChannelMoments", "Magick::ChannelMoments *|p_Magick__ChannelMoments", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ChannelPerceptualHash = {"_p_Magick__ChannelPerceptualHash", "p_Magick__ChannelPerceptualHash|Magick::ChannelPerceptualHash *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ChannelStatistics = {"_p_Magick__ChannelStatistics", "p_Magick__ChannelStatistics|Magick::ChannelStatistics *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__CoderInfo = {"_p_Magick__CoderInfo", "p_Magick__CoderInfo|std::vector< Magick::CoderInfo >::value_type *|Magick::CoderInfo *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__Color = {"_p_Magick__Color", "p_Magick__Color|Magick::Color *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ColorCMYK = {"_p_Magick__ColorCMYK", "Magick::ColorCMYK *|p_Magick__ColorCMYK", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ColorGray = {"_p_Magick__ColorGray", "Magick::ColorGray *|p_Magick__ColorGray", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ColorHSL = {"_p_Magick__ColorHSL", "p_Magick__ColorHSL|Magick::ColorHSL *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ColorMono = {"_p_Magick__ColorMono", "p_Magick__ColorMono|Magick::ColorMono *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ColorRGB = {"_p_Magick__ColorRGB", "Magick::ColorRGB *|p_Magick__ColorRGB", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ColorYUV = {"_p_Magick__ColorYUV", "Magick::ColorYUV *|p_Magick__ColorYUV", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__Coordinate = {"_p_Magick__Coordinate", "p_Magick__Coordinate|Magick::Coordinate *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__Drawable = {"_p_Magick__Drawable", "p_Magick__Drawable|Magick::Drawable *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableAffine = {"_p_Magick__DrawableAffine", "Magick::DrawableAffine *|p_Magick__DrawableAffine", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableAlpha = {"_p_Magick__DrawableAlpha", "p_Magick__DrawableAlpha|Magick::DrawableAlpha *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableArc = {"_p_Magick__DrawableArc", "p_Magick__DrawableArc|Magick::DrawableArc *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableBase = {"_p_Magick__DrawableBase", "p_Magick__DrawableBase|Magick::DrawableBase *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableBezier = {"_p_Magick__DrawableBezier", "Magick::DrawableBezier *|p_Magick__DrawableBezier", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableBorderColor = {"_p_Magick__DrawableBorderColor", "p_Magick__DrawableBorderColor|Magick::DrawableBorderColor *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableCircle = {"_p_Magick__DrawableCircle", "Magick::DrawableCircle *|p_Magick__DrawableCircle", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableClipPath = {"_p_Magick__DrawableClipPath", "Magick::DrawableClipPath *|p_Magick__DrawableClipPath", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableClipRule = {"_p_Magick__DrawableClipRule", "Magick::DrawableClipRule *|p_Magick__DrawableClipRule", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableClipUnits = {"_p_Magick__DrawableClipUnits", "p_Magick__DrawableClipUnits|Magick::DrawableClipUnits *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableColor = {"_p_Magick__DrawableColor", "Magick::DrawableColor *|p_Magick__DrawableColor", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableCompositeImage = {"_p_Magick__DrawableCompositeImage", "p_Magick__DrawableCompositeImage|Magick::DrawableCompositeImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableDensity = {"_p_Magick__DrawableDensity", "Magick::DrawableDensity *|p_Magick__DrawableDensity", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableEllipse = {"_p_Magick__DrawableEllipse", "Magick::DrawableEllipse *|p_Magick__DrawableEllipse", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableFillColor = {"_p_Magick__DrawableFillColor", "p_Magick__DrawableFillColor|Magick::DrawableFillColor *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableFillOpacity = {"_p_Magick__DrawableFillOpacity", "Magick::DrawableFillOpacity *|p_Magick__DrawableFillOpacity", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableFillPatternUrl = {"_p_Magick__DrawableFillPatternUrl", "p_Magick__DrawableFillPatternUrl|Magick::DrawableFillPatternUrl *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableFillRule = {"_p_Magick__DrawableFillRule", "p_Magick__DrawableFillRule|Magick::DrawableFillRule *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableFont = {"_p_Magick__DrawableFont", "p_Magick__DrawableFont|Magick::DrawableFont *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableGravity = {"_p_Magick__DrawableGravity", "Magick::DrawableGravity *|p_Magick__DrawableGravity", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableLine = {"_p_Magick__DrawableLine", "p_Magick__DrawableLine|Magick::DrawableLine *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableMiterLimit = {"_p_Magick__DrawableMiterLimit", "Magick::DrawableMiterLimit *|p_Magick__DrawableMiterLimit", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawablePath = {"_p_Magick__DrawablePath", "Magick::DrawablePath *|p_Magick__DrawablePath", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawablePoint = {"_p_Magick__DrawablePoint", "p_Magick__DrawablePoint|Magick::DrawablePoint *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawablePointSize = {"_p_Magick__DrawablePointSize", "Magick::DrawablePointSize *|p_Magick__DrawablePointSize", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawablePolygon = {"_p_Magick__DrawablePolygon", "Magick::DrawablePolygon *|p_Magick__DrawablePolygon", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawablePolyline = {"_p_Magick__DrawablePolyline", "Magick::DrawablePolyline *|p_Magick__DrawablePolyline", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawablePopClipPath = {"_p_Magick__DrawablePopClipPath", "p_Magick__DrawablePopClipPath|Magick::DrawablePopClipPath *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawablePopGraphicContext = {"_p_Magick__DrawablePopGraphicContext", "p_Magick__DrawablePopGraphicContext|Magick::DrawablePopGraphicContext *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawablePopPattern = {"_p_Magick__DrawablePopPattern", "p_Magick__DrawablePopPattern|Magick::DrawablePopPattern *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawablePushClipPath = {"_p_Magick__DrawablePushClipPath", "Magick::DrawablePushClipPath *|p_Magick__DrawablePushClipPath", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawablePushGraphicContext = {"_p_Magick__DrawablePushGraphicContext", "p_Magick__DrawablePushGraphicContext|Magick::DrawablePushGraphicContext *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawablePushPattern = {"_p_Magick__DrawablePushPattern", "p_Magick__DrawablePushPattern|Magick::DrawablePushPattern *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableRectangle = {"_p_Magick__DrawableRectangle", "p_Magick__DrawableRectangle|Magick::DrawableRectangle *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableRotation = {"_p_Magick__DrawableRotation", "p_Magick__DrawableRotation|Magick::DrawableRotation *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableRoundRectangle = {"_p_Magick__DrawableRoundRectangle", "p_Magick__DrawableRoundRectangle|Magick::DrawableRoundRectangle *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableScaling = {"_p_Magick__DrawableScaling", "Magick::DrawableScaling *|p_Magick__DrawableScaling", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableSkewX = {"_p_Magick__DrawableSkewX", "Magick::DrawableSkewX *|p_Magick__DrawableSkewX", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableSkewY = {"_p_Magick__DrawableSkewY", "Magick::DrawableSkewY *|p_Magick__DrawableSkewY", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableStrokeAntialias = {"_p_Magick__DrawableStrokeAntialias", "Magick::DrawableStrokeAntialias *|p_Magick__DrawableStrokeAntialias", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableStrokeColor = {"_p_Magick__DrawableStrokeColor", "p_Magick__DrawableStrokeColor|Magick::DrawableStrokeColor *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableStrokeDashArray = {"_p_Magick__DrawableStrokeDashArray", "Magick::DrawableStrokeDashArray *|p_Magick__DrawableStrokeDashArray", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableStrokeDashOffset = {"_p_Magick__DrawableStrokeDashOffset", "Magick::DrawableStrokeDashOffset *|p_Magick__DrawableStrokeDashOffset", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableStrokeLineCap = {"_p_Magick__DrawableStrokeLineCap", "Magick::DrawableStrokeLineCap *|p_Magick__DrawableStrokeLineCap", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableStrokeLineJoin = {"_p_Magick__DrawableStrokeLineJoin", "Magick::DrawableStrokeLineJoin *|p_Magick__DrawableStrokeLineJoin", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableStrokeOpacity = {"_p_Magick__DrawableStrokeOpacity", "p_Magick__DrawableStrokeOpacity|Magick::DrawableStrokeOpacity *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableStrokePatternUrl = {"_p_Magick__DrawableStrokePatternUrl", "Magick::DrawableStrokePatternUrl *|p_Magick__DrawableStrokePatternUrl", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableStrokeWidth = {"_p_Magick__DrawableStrokeWidth", "p_Magick__DrawableStrokeWidth|Magick::DrawableStrokeWidth *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableText = {"_p_Magick__DrawableText", "p_Magick__DrawableText|Magick::DrawableText *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableTextAlignment = {"_p_Magick__DrawableTextAlignment", "Magick::DrawableTextAlignment *|p_Magick__DrawableTextAlignment", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableTextAntialias = {"_p_Magick__DrawableTextAntialias", "Magick::DrawableTextAntialias *|p_Magick__DrawableTextAntialias", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableTextDecoration = {"_p_Magick__DrawableTextDecoration", "p_Magick__DrawableTextDecoration|Magick::DrawableTextDecoration *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableTextDirection = {"_p_Magick__DrawableTextDirection", "Magick::DrawableTextDirection *|p_Magick__DrawableTextDirection", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableTextInterlineSpacing = {"_p_Magick__DrawableTextInterlineSpacing", "Magick::DrawableTextInterlineSpacing *|p_Magick__DrawableTextInterlineSpacing", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableTextInterwordSpacing = {"_p_Magick__DrawableTextInterwordSpacing", "p_Magick__DrawableTextInterwordSpacing|Magick::DrawableTextInterwordSpacing *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableTextKerning = {"_p_Magick__DrawableTextKerning", "Magick::DrawableTextKerning *|p_Magick__DrawableTextKerning", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableTextUnderColor = {"_p_Magick__DrawableTextUnderColor", "p_Magick__DrawableTextUnderColor|Magick::DrawableTextUnderColor *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableTranslation = {"_p_Magick__DrawableTranslation", "p_Magick__DrawableTranslation|Magick::DrawableTranslation *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__DrawableViewbox = {"_p_Magick__DrawableViewbox", "Magick::DrawableViewbox *|p_Magick__DrawableViewbox", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__Error = {"_p_Magick__Error", "Magick::Error *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ErrorBlob = {"_p_Magick__ErrorBlob", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ErrorCache = {"_p_Magick__ErrorCache", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ErrorCoder = {"_p_Magick__ErrorCoder", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ErrorConfigure = {"_p_Magick__ErrorConfigure", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ErrorCorruptImage = {"_p_Magick__ErrorCorruptImage", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ErrorDelegate = {"_p_Magick__ErrorDelegate", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ErrorDraw = {"_p_Magick__ErrorDraw", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ErrorFileOpen = {"_p_Magick__ErrorFileOpen", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ErrorImage = {"_p_Magick__ErrorImage", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ErrorMissingDelegate = {"_p_Magick__ErrorMissingDelegate", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ErrorModule = {"_p_Magick__ErrorModule", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ErrorMonitor = {"_p_Magick__ErrorMonitor", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ErrorOption = {"_p_Magick__ErrorOption", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ErrorRegistry = {"_p_Magick__ErrorRegistry", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ErrorResourceLimit = {"_p_Magick__ErrorResourceLimit", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ErrorStream = {"_p_Magick__ErrorStream", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ErrorUndefined = {"_p_Magick__ErrorUndefined", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ErrorXServer = {"_p_Magick__ErrorXServer", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ErrorPolicy = {"_p_Magick__ErrorPolicy", "p_Magick__ErrorPolicy", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ErrorType = {"_p_Magick__ErrorType", "p_Magick__ErrorType", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__Exception = {"_p_Magick__Exception", "Magick::Exception *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__WarningBlob = {"_p_Magick__WarningBlob", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__WarningCache = {"_p_Magick__WarningCache", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__WarningCoder = {"_p_Magick__WarningCoder", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__WarningConfigure = {"_p_Magick__WarningConfigure", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__WarningCorruptImage = {"_p_Magick__WarningCorruptImage", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__WarningDelegate = {"_p_Magick__WarningDelegate", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__WarningDraw = {"_p_Magick__WarningDraw", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__WarningFileOpen = {"_p_Magick__WarningFileOpen", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__WarningImage = {"_p_Magick__WarningImage", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__WarningMissingDelegate = {"_p_Magick__WarningMissingDelegate", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__WarningModule = {"_p_Magick__WarningModule", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__WarningMonitor = {"_p_Magick__WarningMonitor", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__WarningOption = {"_p_Magick__WarningOption", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__WarningRegistry = {"_p_Magick__WarningRegistry", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__WarningResourceLimit = {"_p_Magick__WarningResourceLimit", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__WarningStream = {"_p_Magick__WarningStream", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__WarningUndefined = {"_p_Magick__WarningUndefined", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__WarningXServer = {"_p_Magick__WarningXServer", 0, 0, 0, 0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__Geometry = {"_p_Magick__Geometry", "Magick::Geometry *|p_Magick__Geometry", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__Image = {"_p_Magick__Image", "p_Magick__Image|Magick::Image *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ImageMoments = {"_p_Magick__ImageMoments", "p_Magick__ImageMoments|Magick::ImageMoments *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ImagePerceptualHash = {"_p_Magick__ImagePerceptualHash", "Magick::ImagePerceptualHash *|p_Magick__ImagePerceptualHash", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ImageStatistics = {"_p_Magick__ImageStatistics", "p_Magick__ImageStatistics|Magick::ImageStatistics *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__Montage = {"_p_Magick__Montage", "p_Magick__Montage|Magick::Montage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__MontageFramed = {"_p_Magick__MontageFramed", "Magick::MontageFramed *|p_Magick__MontageFramed", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__Offset = {"_p_Magick__Offset", "Magick::Offset *|p_Magick__Offset", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__Options = {"_p_Magick__Options", "Magick::Options *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__PathArcAbs = {"_p_Magick__PathArcAbs", "p_Magick__PathArcAbs|Magick::PathArcAbs *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__PathArcArgs = {"_p_Magick__PathArcArgs", "p_Magick__PathArcArgs|Magick::PathArcArgs *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__PathArcRel = {"_p_Magick__PathArcRel", "p_Magick__PathArcRel|Magick::PathArcRel *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__PathClosePath = {"_p_Magick__PathClosePath", "Magick::PathClosePath *|p_Magick__PathClosePath", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__PathCurvetoAbs = {"_p_Magick__PathCurvetoAbs", "p_Magick__PathCurvetoAbs|Magick::PathCurvetoAbs *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__PathCurvetoArgs = {"_p_Magick__PathCurvetoArgs", "Magick::PathCurvetoArgs *|p_Magick__PathCurvetoArgs", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__PathCurvetoRel = {"_p_Magick__PathCurvetoRel", "p_Magick__PathCurvetoRel|Magick::PathCurvetoRel *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__PathLinetoAbs = {"_p_Magick__PathLinetoAbs", "p_Magick__PathLinetoAbs|Magick::PathLinetoAbs *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__PathLinetoHorizontalAbs = {"_p_Magick__PathLinetoHorizontalAbs", "p_Magick__PathLinetoHorizontalAbs|Magick::PathLinetoHorizontalAbs *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__PathLinetoHorizontalRel = {"_p_Magick__PathLinetoHorizontalRel", "p_Magick__PathLinetoHorizontalRel|Magick::PathLinetoHorizontalRel *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__PathLinetoRel = {"_p_Magick__PathLinetoRel", "Magick::PathLinetoRel *|p_Magick__PathLinetoRel", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__PathLinetoVerticalAbs = {"_p_Magick__PathLinetoVerticalAbs", "Magick::PathLinetoVerticalAbs *|p_Magick__PathLinetoVerticalAbs", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__PathLinetoVerticalRel = {"_p_Magick__PathLinetoVerticalRel", "Magick::PathLinetoVerticalRel *|p_Magick__PathLinetoVerticalRel", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__PathMovetoAbs = {"_p_Magick__PathMovetoAbs", "Magick::PathMovetoAbs *|p_Magick__PathMovetoAbs", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__PathMovetoRel = {"_p_Magick__PathMovetoRel", "p_Magick__PathMovetoRel|Magick::PathMovetoRel *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__PathQuadraticCurvetoAbs = {"_p_Magick__PathQuadraticCurvetoAbs", "p_Magick__PathQuadraticCurvetoAbs|Magick::PathQuadraticCurvetoAbs *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__PathQuadraticCurvetoArgs = {"_p_Magick__PathQuadraticCurvetoArgs", "Magick::PathQuadraticCurvetoArgs *|p_Magick__PathQuadraticCurvetoArgs", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__PathQuadraticCurvetoRel = {"_p_Magick__PathQuadraticCurvetoRel", "p_Magick__PathQuadraticCurvetoRel|Magick::PathQuadraticCurvetoRel *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__PathSmoothCurvetoAbs = {"_p_Magick__PathSmoothCurvetoAbs", "Magick::PathSmoothCurvetoAbs *|p_Magick__PathSmoothCurvetoAbs", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__PathSmoothCurvetoRel = {"_p_Magick__PathSmoothCurvetoRel", "Magick::PathSmoothCurvetoRel *|p_Magick__PathSmoothCurvetoRel", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__PathSmoothQuadraticCurvetoAbs = {"_p_Magick__PathSmoothQuadraticCurvetoAbs", "p_Magick__PathSmoothQuadraticCurvetoAbs|Magick::PathSmoothQuadraticCurvetoAbs *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__PathSmoothQuadraticCurvetoRel = {"_p_Magick__PathSmoothQuadraticCurvetoRel", "p_Magick__PathSmoothQuadraticCurvetoRel|Magick::PathSmoothQuadraticCurvetoRel *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__Point = {"_p_Magick__Point", "Magick::Point *|p_Magick__Point", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ReadOptions = {"_p_Magick__ReadOptions", "Magick::ReadOptions *|p_Magick__ReadOptions", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__ResourceLimits = {"_p_Magick__ResourceLimits", "p_Magick__ResourceLimits", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__TypeMetric = {"_p_Magick__TypeMetric", "p_Magick__TypeMetric|Magick::TypeMetric *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__VPath = {"_p_Magick__VPath", "p_Magick__VPath|Magick::VPath *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__VPathBase = {"_p_Magick__VPathBase", "Magick::VPathBase *|p_Magick__VPathBase", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__Warning = {"_p_Magick__Warning", "Magick::Warning *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__WarningPolicy = {"_p_Magick__WarningPolicy", "p_Magick__WarningPolicy", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__WarningType = {"_p_Magick__WarningType", "p_Magick__WarningType", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__adaptiveBlurImage = {"_p_Magick__adaptiveBlurImage", "p_Magick__adaptiveBlurImage|Magick::adaptiveBlurImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__adaptiveThresholdImage = {"_p_Magick__adaptiveThresholdImage", "p_Magick__adaptiveThresholdImage|Magick::adaptiveThresholdImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__addNoiseImage = {"_p_Magick__addNoiseImage", "Magick::addNoiseImage *|p_Magick__addNoiseImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__adjoinImage = {"_p_Magick__adjoinImage", "Magick::adjoinImage *|p_Magick__adjoinImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__affineTransformImage = {"_p_Magick__affineTransformImage", "p_Magick__affineTransformImage|Magick::affineTransformImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__alphaFlagImage = {"_p_Magick__alphaFlagImage", "Magick::alphaFlagImage *|p_Magick__alphaFlagImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__alphaImage = {"_p_Magick__alphaImage", "p_Magick__alphaImage|Magick::alphaImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__animationDelayImage = {"_p_Magick__animationDelayImage", "Magick::animationDelayImage *|p_Magick__animationDelayImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__animationIterationsImage = {"_p_Magick__animationIterationsImage", "Magick::animationIterationsImage *|p_Magick__animationIterationsImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__annotateImage = {"_p_Magick__annotateImage", "Magick::annotateImage *|p_Magick__annotateImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__backgroundColorImage = {"_p_Magick__backgroundColorImage", "Magick::backgroundColorImage *|p_Magick__backgroundColorImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__backgroundTextureImage = {"_p_Magick__backgroundTextureImage", "p_Magick__backgroundTextureImage|Magick::backgroundTextureImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__blurImage = {"_p_Magick__blurImage", "p_Magick__blurImage|Magick::blurImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__borderColorImage = {"_p_Magick__borderColorImage", "p_Magick__borderColorImage|Magick::borderColorImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__borderImage = {"_p_Magick__borderImage", "p_Magick__borderImage|Magick::borderImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__boxColorImage = {"_p_Magick__boxColorImage", "Magick::boxColorImage *|p_Magick__boxColorImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__cdlImage = {"_p_Magick__cdlImage", "Magick::cdlImage *|p_Magick__cdlImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__channelImage = {"_p_Magick__channelImage", "Magick::channelImage *|p_Magick__channelImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__charcoalImage = {"_p_Magick__charcoalImage", "p_Magick__charcoalImage|Magick::charcoalImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__chopImage = {"_p_Magick__chopImage", "Magick::chopImage *|p_Magick__chopImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__chromaBluePrimaryImage = {"_p_Magick__chromaBluePrimaryImage", "p_Magick__chromaBluePrimaryImage|Magick::chromaBluePrimaryImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__chromaGreenPrimaryImage = {"_p_Magick__chromaGreenPrimaryImage", "Magick::chromaGreenPrimaryImage *|p_Magick__chromaGreenPrimaryImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__chromaRedPrimaryImage = {"_p_Magick__chromaRedPrimaryImage", "p_Magick__chromaRedPrimaryImage|Magick::chromaRedPrimaryImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__chromaWhitePointImage = {"_p_Magick__chromaWhitePointImage", "p_Magick__chromaWhitePointImage|Magick::chromaWhitePointImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__colorFuzzImage = {"_p_Magick__colorFuzzImage", "p_Magick__colorFuzzImage|Magick::colorFuzzImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__colorMapImage = {"_p_Magick__colorMapImage", "p_Magick__colorMapImage|Magick::colorMapImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__colorMatrixImage = {"_p_Magick__colorMatrixImage", "Magick::colorMatrixImage *|p_Magick__colorMatrixImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__colorSpaceImage = {"_p_Magick__colorSpaceImage", "p_Magick__colorSpaceImage|Magick::colorSpaceImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__colorizeImage = {"_p_Magick__colorizeImage", "p_Magick__colorizeImage|Magick::colorizeImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__commentImage = {"_p_Magick__commentImage", "p_Magick__commentImage|Magick::commentImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__composeImage = {"_p_Magick__composeImage", "p_Magick__composeImage|Magick::composeImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__compositeImage = {"_p_Magick__compositeImage", "p_Magick__compositeImage|Magick::compositeImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__compressTypeImage = {"_p_Magick__compressTypeImage", "Magick::compressTypeImage *|p_Magick__compressTypeImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__contrastImage = {"_p_Magick__contrastImage", "Magick::contrastImage *|p_Magick__contrastImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__cropImage = {"_p_Magick__cropImage", "Magick::cropImage *|p_Magick__cropImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__cycleColormapImage = {"_p_Magick__cycleColormapImage", "p_Magick__cycleColormapImage|Magick::cycleColormapImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__densityImage = {"_p_Magick__densityImage", "Magick::densityImage *|p_Magick__densityImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__depthImage = {"_p_Magick__depthImage", "p_Magick__depthImage|Magick::depthImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__despeckleImage = {"_p_Magick__despeckleImage", "Magick::despeckleImage *|p_Magick__despeckleImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__distortImage = {"_p_Magick__distortImage", "p_Magick__distortImage|Magick::distortImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__drawImage = {"_p_Magick__drawImage", "p_Magick__drawImage|Magick::drawImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__edgeImage = {"_p_Magick__edgeImage", "p_Magick__edgeImage|Magick::edgeImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__embossImage = {"_p_Magick__embossImage", "Magick::embossImage *|p_Magick__embossImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__endianImage = {"_p_Magick__endianImage", "Magick::endianImage *|p_Magick__endianImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__enhanceImage = {"_p_Magick__enhanceImage", "p_Magick__enhanceImage|Magick::enhanceImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__equalizeImage = {"_p_Magick__equalizeImage", "Magick::equalizeImage *|p_Magick__equalizeImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__fileNameImage = {"_p_Magick__fileNameImage", "p_Magick__fileNameImage|Magick::fileNameImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__fillColorImage = {"_p_Magick__fillColorImage", "p_Magick__fillColorImage|Magick::fillColorImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__filterTypeImage = {"_p_Magick__filterTypeImage", "Magick::filterTypeImage *|p_Magick__filterTypeImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__flipImage = {"_p_Magick__flipImage", "Magick::flipImage *|p_Magick__flipImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__floodFillAlphaImage = {"_p_Magick__floodFillAlphaImage", "p_Magick__floodFillAlphaImage|Magick::floodFillAlphaImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__floodFillColorImage = {"_p_Magick__floodFillColorImage", "Magick::floodFillColorImage *|p_Magick__floodFillColorImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__floodFillTextureImage = {"_p_Magick__floodFillTextureImage", "Magick::floodFillTextureImage *|p_Magick__floodFillTextureImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__flopImage = {"_p_Magick__flopImage", "Magick::flopImage *|p_Magick__flopImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__fontImage = {"_p_Magick__fontImage", "p_Magick__fontImage|Magick::fontImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__fontPointsizeImage = {"_p_Magick__fontPointsizeImage", "Magick::fontPointsizeImage *|p_Magick__fontPointsizeImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__frameImage = {"_p_Magick__frameImage", "p_Magick__frameImage|Magick::frameImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__gammaImage = {"_p_Magick__gammaImage", "p_Magick__gammaImage|Magick::gammaImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__gaussianBlurImage = {"_p_Magick__gaussianBlurImage", "Magick::gaussianBlurImage *|p_Magick__gaussianBlurImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__gifDisposeMethodImage = {"_p_Magick__gifDisposeMethodImage", "p_Magick__gifDisposeMethodImage|Magick::gifDisposeMethodImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__haldClutImage = {"_p_Magick__haldClutImage", "p_Magick__haldClutImage|Magick::haldClutImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__implodeImage = {"_p_Magick__implodeImage", "p_Magick__implodeImage|Magick::implodeImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__interlaceTypeImage = {"_p_Magick__interlaceTypeImage", "p_Magick__interlaceTypeImage|Magick::interlaceTypeImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__inverseFourierTransformImage = {"_p_Magick__inverseFourierTransformImage", "Magick::inverseFourierTransformImage *|p_Magick__inverseFourierTransformImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__isValidImage = {"_p_Magick__isValidImage", "p_Magick__isValidImage|Magick::isValidImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__labelImage = {"_p_Magick__labelImage", "Magick::labelImage *|p_Magick__labelImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__levelImage = {"_p_Magick__levelImage", "p_Magick__levelImage|Magick::levelImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__magickImage = {"_p_Magick__magickImage", "p_Magick__magickImage|Magick::magickImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__magnifyImage = {"_p_Magick__magnifyImage", "Magick::magnifyImage *|p_Magick__magnifyImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__mapImage = {"_p_Magick__mapImage", "p_Magick__mapImage|Magick::mapImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__matteColorImage = {"_p_Magick__matteColorImage", "Magick::matteColorImage *|p_Magick__matteColorImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__medianConvolveImage = {"_p_Magick__medianConvolveImage", "p_Magick__medianConvolveImage|Magick::medianConvolveImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__minifyImage = {"_p_Magick__minifyImage", "Magick::minifyImage *|p_Magick__minifyImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__modulateImage = {"_p_Magick__modulateImage", "Magick::modulateImage *|p_Magick__modulateImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__monochromeImage = {"_p_Magick__monochromeImage", "Magick::monochromeImage *|p_Magick__monochromeImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__negateImage = {"_p_Magick__negateImage", "Magick::negateImage *|p_Magick__negateImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__normalizeImage = {"_p_Magick__normalizeImage", "Magick::normalizeImage *|p_Magick__normalizeImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__oilPaintImage = {"_p_Magick__oilPaintImage", "p_Magick__oilPaintImage|Magick::oilPaintImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__opaqueImage = {"_p_Magick__opaqueImage", "p_Magick__opaqueImage|Magick::opaqueImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__pageImage = {"_p_Magick__pageImage", "p_Magick__pageImage|Magick::pageImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__pixelColorImage = {"_p_Magick__pixelColorImage", "p_Magick__pixelColorImage|Magick::pixelColorImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__qualityImage = {"_p_Magick__qualityImage", "p_Magick__qualityImage|Magick::qualityImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__quantizeColorSpaceImage = {"_p_Magick__quantizeColorSpaceImage", "Magick::quantizeColorSpaceImage *|p_Magick__quantizeColorSpaceImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__quantizeColorsImage = {"_p_Magick__quantizeColorsImage", "Magick::quantizeColorsImage *|p_Magick__quantizeColorsImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__quantizeDitherImage = {"_p_Magick__quantizeDitherImage", "Magick::quantizeDitherImage *|p_Magick__quantizeDitherImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__quantizeImage = {"_p_Magick__quantizeImage", "Magick::quantizeImage *|p_Magick__quantizeImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__quantizeTreeDepthImage = {"_p_Magick__quantizeTreeDepthImage", "p_Magick__quantizeTreeDepthImage|Magick::quantizeTreeDepthImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__raiseImage = {"_p_Magick__raiseImage", "p_Magick__raiseImage|Magick::raiseImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__reduceNoiseImage = {"_p_Magick__reduceNoiseImage", "Magick::reduceNoiseImage *|p_Magick__reduceNoiseImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__renderingIntentImage = {"_p_Magick__renderingIntentImage", "p_Magick__renderingIntentImage|Magick::renderingIntentImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__resizeImage = {"_p_Magick__resizeImage", "p_Magick__resizeImage|Magick::resizeImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__resolutionUnitsImage = {"_p_Magick__resolutionUnitsImage", "Magick::resolutionUnitsImage *|p_Magick__resolutionUnitsImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__rollImage = {"_p_Magick__rollImage", "Magick::rollImage *|p_Magick__rollImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__rotateImage = {"_p_Magick__rotateImage", "p_Magick__rotateImage|Magick::rotateImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__sampleImage = {"_p_Magick__sampleImage", "Magick::sampleImage *|p_Magick__sampleImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__scaleImage = {"_p_Magick__scaleImage", "p_Magick__scaleImage|Magick::scaleImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__sceneImage = {"_p_Magick__sceneImage", "p_Magick__sceneImage|Magick::sceneImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__segmentImage = {"_p_Magick__segmentImage", "Magick::segmentImage *|p_Magick__segmentImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__shadeImage = {"_p_Magick__shadeImage", "p_Magick__shadeImage|Magick::shadeImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__shadowImage = {"_p_Magick__shadowImage", "p_Magick__shadowImage|Magick::shadowImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__sharpenImage = {"_p_Magick__sharpenImage", "p_Magick__sharpenImage|Magick::sharpenImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__shaveImage = {"_p_Magick__shaveImage", "p_Magick__shaveImage|Magick::shaveImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__shearImage = {"_p_Magick__shearImage", "Magick::shearImage *|p_Magick__shearImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__sizeImage = {"_p_Magick__sizeImage", "p_Magick__sizeImage|Magick::sizeImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__solarizeImage = {"_p_Magick__solarizeImage", "p_Magick__solarizeImage|Magick::solarizeImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__spliceImage = {"_p_Magick__spliceImage", "p_Magick__spliceImage|Magick::spliceImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__spreadImage = {"_p_Magick__spreadImage", "p_Magick__spreadImage|Magick::spreadImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__steganoImage = {"_p_Magick__steganoImage", "p_Magick__steganoImage|Magick::steganoImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__stereoImage = {"_p_Magick__stereoImage", "Magick::stereoImage *|p_Magick__stereoImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__stripImage = {"_p_Magick__stripImage", "p_Magick__stripImage|Magick::stripImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__strokeColorImage = {"_p_Magick__strokeColorImage", "Magick::strokeColorImage *|p_Magick__strokeColorImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__subImageImage = {"_p_Magick__subImageImage", "Magick::subImageImage *|p_Magick__subImageImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__subRangeImage = {"_p_Magick__subRangeImage", "Magick::subRangeImage *|p_Magick__subRangeImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__swirlImage = {"_p_Magick__swirlImage", "Magick::swirlImage *|p_Magick__swirlImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__textAntiAliasImage = {"_p_Magick__textAntiAliasImage", "p_Magick__textAntiAliasImage|Magick::textAntiAliasImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__textureImage = {"_p_Magick__textureImage", "p_Magick__textureImage|Magick::textureImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__thresholdImage = {"_p_Magick__thresholdImage", "Magick::thresholdImage *|p_Magick__thresholdImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__transparentImage = {"_p_Magick__transparentImage", "Magick::transparentImage *|p_Magick__transparentImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__trimImage = {"_p_Magick__trimImage", "p_Magick__trimImage|Magick::trimImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__typeImage = {"_p_Magick__typeImage", "Magick::typeImage *|p_Magick__typeImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__verboseImage = {"_p_Magick__verboseImage", "p_Magick__verboseImage|Magick::verboseImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__waveImage = {"_p_Magick__waveImage", "Magick::waveImage *|p_Magick__waveImage", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__x11DisplayImage = {"_p_Magick__x11DisplayImage", "p_Magick__x11DisplayImage|Magick::x11DisplayImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_Magick__zoomImage = {"_p_Magick__zoomImage", "p_Magick__zoomImage|Magick::zoomImage *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p__DrawingWand = {"_p__DrawingWand", "MagickCore::DrawingWand *|_DrawingWand *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p__PolicyInfo = {"_p__PolicyInfo", "MagickCore::PolicyInfo *|_PolicyInfo *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_difference_type = {"_p_difference_type", "difference_type *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_double = {"_p_double", "MagickCore::MagickDoubleType *|MagickCore::MagickRealType *|double *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_float = {"_p_float", "MagickCore::MagickFloatType *|float *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_long_long = {"_p_long_long", "MagickCore::MagickOffsetType *|long long *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_p_MagickCore___Image = {"_p_p_MagickCore___Image", "MagickCore::Image **|MagickCore::_Image **", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_p_void = {"_p_p_void", "void **", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_size_t = {"_p_size_t", "size_t *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_size_type = {"_p_size_type", "size_type *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_std__exception = {"_p_std__exception", "std::exception *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_std__vectorT_Magick__CoderInfo_t = {"_p_std__vectorT_Magick__CoderInfo_t", "p_std__vectorT_Magick__CoderInfo_t|std::vector< Magick::CoderInfo > *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_std__vectorT_Magick__Coordinate_t = {"_p_std__vectorT_Magick__Coordinate_t", "Magick::CoordinateList *|std::vector< Magick::Coordinate > *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_std__vectorT_Magick__Drawable_t = {"_p_std__vectorT_Magick__Drawable_t", "Magick::DrawableList *|std::vector< Magick::Drawable > *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_std__vectorT_Magick__PathArcArgs_t = {"_p_std__vectorT_Magick__PathArcArgs_t", "Magick::PathArcArgsList *|std::vector< Magick::PathArcArgs > *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_std__vectorT_Magick__PathCurvetoArgs_t = {"_p_std__vectorT_Magick__PathCurvetoArgs_t", "Magick::PathCurveToArgsList *|std::vector< Magick::PathCurvetoArgs > *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_std__vectorT_Magick__PathQuadraticCurvetoArgs_t = {"_p_std__vectorT_Magick__PathQuadraticCurvetoArgs_t", "Magick::PathQuadraticCurvetoArgsList *|std::vector< Magick::PathQuadraticCurvetoArgs > *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_std__vectorT_Magick__VPath_t = {"_p_std__vectorT_Magick__VPath_t", "Magick::VPathList *|std::vector< Magick::VPath > *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_uintptr_t = {"_p_uintptr_t", "MagickCore::MagickAddressType *|uintptr_t *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "MagickCore::MagickStatusType *|unsigned int *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "MagickCore::MagickSizeType *|unsigned long long *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_value_type = {"_p_value_type", "value_type *", 0, 0, (void*)0, 0};
SWIGINTERN swig_type_info _swigt__p_void = {"_p_void", "void *", 0, 0, (void*)0, 0};

SWIGINTERN swig_type_info *swig_type_initial[] = {

/* -------- TYPES TABLE (BEGIN) -------- */

  &_swigt__p_FILE,
  &_swigt__p_ImageListContainer,
  &_swigt__p_ImageListIterator,
  &_swigt__p_MagickCore__AlignType,
  &_swigt__p_MagickCore__CacheType,
  &_swigt__p_MagickCore__ChannelType,
  &_swigt__p_MagickCore__ClassType,
  &_swigt__p_MagickCore__ColorspaceType,
  &_swigt__p_MagickCore__ComplexOperator,
  &_swigt__p_MagickCore__ComplianceType,
  &_swigt__p_MagickCore__CompositeOperator,
  &_swigt__p_MagickCore__CompressionType,
  &_swigt__p_MagickCore__DecorationType,
  &_swigt__p_MagickCore__DirectionType,
  &_swigt__p_MagickCore__DisposeType,
  &_swigt__p_MagickCore__EndianType,
  &_swigt__p_MagickCore__ExceptionType,
  &_swigt__p_MagickCore__FilterType,
  &_swigt__p_MagickCore__GradientType,
  &_swigt__p_MagickCore__GravityType,
  &_swigt__p_MagickCore__IlluminantType,
  &_swigt__p_MagickCore__ImageType,
  &_swigt__p_MagickCore__InterlaceType,
  &_swigt__p_MagickCore__KernelInfoType,
  &_swigt__p_MagickCore__LogEventType,
  &_swigt__p_MagickCore__MagickBooleanType,
  &_swigt__p_MagickCore__MagickCLDeviceType,
  &_swigt__p_MagickCore__MagickEvaluateOperator,
  &_swigt__p_MagickCore__MagickFormatType,
  &_swigt__p_MagickCore__MagickModuleType,
  &_swigt__p_MagickCore__MetricType,
  &_swigt__p_MagickCore__NoiseType,
  &_swigt__p_MagickCore__OrientationType,
  &_swigt__p_MagickCore__PathType,
  &_swigt__p_MagickCore__PolicyDomain,
  &_swigt__p_MagickCore__PolicyRights,
  &_swigt__p_MagickCore__PreviewType,
  &_swigt__p_MagickCore__PrimitiveType,
  &_swigt__p_MagickCore__QuantumAlphaType,
  &_swigt__p_MagickCore__QuantumFormatType,
  &_swigt__p_MagickCore__QuantumType,
  &_swigt__p_MagickCore__ReferenceType,
  &_swigt__p_MagickCore__RegistryType,
  &_swigt__p_MagickCore__ResolutionType,
  &_swigt__p_MagickCore__ResourceType,
  &_swigt__p_MagickCore__StatisticType,
  &_swigt__p_MagickCore__StorageType,
  &_swigt__p_MagickCore__StretchType,
  &_swigt__p_MagickCore__StyleType,
  &_swigt__p_MagickCore__TransmitType,
  &_swigt__p_MagickCore__ValidateType,
  &_swigt__p_MagickCore__WordBreakType,
  &_swigt__p_MagickCore___ChannelMoments,
  &_swigt__p_MagickCore___ChannelPerceptualHash,
  &_swigt__p_MagickCore___ChannelStatistics,
  &_swigt__p_MagickCore___ExceptionInfo,
  &_swigt__p_MagickCore___Image,
  &_swigt__p_MagickCore___ImageInfo,
  &_swigt__p_MagickCore___MontageInfo,
  &_swigt__p_MagickCore___QuantizeInfo,
  &_swigt__p_MagickCore___RectangleInfo,
  &_swigt__p_MagickWand,
  &_swigt__p_Magick__Blob,
  &_swigt__p_Magick__ChannelMoments,
  &_swigt__p_Magick__ChannelPerceptualHash,
  &_swigt__p_Magick__ChannelStatistics,
  &_swigt__p_Magick__CoderInfo,
  &_swigt__p_Magick__Color,
  &_swigt__p_Magick__ColorCMYK,
  &_swigt__p_Magick__ColorGray,
  &_swigt__p_Magick__ColorHSL,
  &_swigt__p_Magick__ColorMono,
  &_swigt__p_Magick__ColorRGB,
  &_swigt__p_Magick__ColorYUV,
  &_swigt__p_Magick__Coordinate,
  &_swigt__p_Magick__Drawable,
  &_swigt__p_Magick__DrawableAffine,
  &_swigt__p_Magick__DrawableAlpha,
  &_swigt__p_Magick__DrawableArc,
  &_swigt__p_Magick__DrawableBase,
  &_swigt__p_Magick__DrawableBezier,
  &_swigt__p_Magick__DrawableBorderColor,
  &_swigt__p_Magick__DrawableCircle,
  &_swigt__p_Magick__DrawableClipPath,
  &_swigt__p_Magick__DrawableClipRule,
  &_swigt__p_Magick__DrawableClipUnits,
  &_swigt__p_Magick__DrawableColor,
  &_swigt__p_Magick__DrawableCompositeImage,
  &_swigt__p_Magick__DrawableDensity,
  &_swigt__p_Magick__DrawableEllipse,
  &_swigt__p_Magick__DrawableFillColor,
  &_swigt__p_Magick__DrawableFillOpacity,
  &_swigt__p_Magick__DrawableFillPatternUrl,
  &_swigt__p_Magick__DrawableFillRule,
  &_swigt__p_Magick__DrawableFont,
  &_swigt__p_Magick__DrawableGravity,
  &_swigt__p_Magick__DrawableLine,
  &_swigt__p_Magick__DrawableMiterLimit,
  &_swigt__p_Magick__DrawablePath,
  &_swigt__p_Magick__DrawablePoint,
  &_swigt__p_Magick__DrawablePointSize,
  &_swigt__p_Magick__DrawablePolygon,
  &_swigt__p_Magick__DrawablePolyline,
  &_swigt__p_Magick__DrawablePopClipPath,
  &_swigt__p_Magick__DrawablePopGraphicContext,
  &_swigt__p_Magick__DrawablePopPattern,
  &_swigt__p_Magick__DrawablePushClipPath,
  &_swigt__p_Magick__DrawablePushGraphicContext,
  &_swigt__p_Magick__DrawablePushPattern,
  &_swigt__p_Magick__DrawableRectangle,
  &_swigt__p_Magick__DrawableRotation,
  &_swigt__p_Magick__DrawableRoundRectangle,
  &_swigt__p_Magick__DrawableScaling,
  &_swigt__p_Magick__DrawableSkewX,
  &_swigt__p_Magick__DrawableSkewY,
  &_swigt__p_Magick__DrawableStrokeAntialias,
  &_swigt__p_Magick__DrawableStrokeColor,
  &_swigt__p_Magick__DrawableStrokeDashArray,
  &_swigt__p_Magick__DrawableStrokeDashOffset,
  &_swigt__p_Magick__DrawableStrokeLineCap,
  &_swigt__p_Magick__DrawableStrokeLineJoin,
  &_swigt__p_Magick__DrawableStrokeOpacity,
  &_swigt__p_Magick__DrawableStrokePatternUrl,
  &_swigt__p_Magick__DrawableStrokeWidth,
  &_swigt__p_Magick__DrawableText,
  &_swigt__p_Magick__DrawableTextAlignment,
  &_swigt__p_Magick__DrawableTextAntialias,
  &_swigt__p_Magick__DrawableTextDecoration,
  &_swigt__p_Magick__DrawableTextDirection,
  &_swigt__p_Magick__DrawableTextInterlineSpacing,
  &_swigt__p_Magick__DrawableTextInterwordSpacing,
  &_swigt__p_Magick__DrawableTextKerning,
  &_swigt__p_Magick__DrawableTextUnderColor,
  &_swigt__p_Magick__DrawableTranslation,
  &_swigt__p_Magick__DrawableViewbox,
  &_swigt__p_Magick__Error,
  &_swigt__p_Magick__ErrorBlob,
  &_swigt__p_Magick__ErrorCache,
  &_swigt__p_Magick__ErrorCoder,
  &_swigt__p_Magick__ErrorConfigure,
  &_swigt__p_Magick__ErrorCorruptImage,
  &_swigt__p_Magick__ErrorDelegate,
  &_swigt__p_Magick__ErrorDraw,
  &_swigt__p_Magick__ErrorFileOpen,
  &_swigt__p_Magick__ErrorImage,
  &_swigt__p_Magick__ErrorMissingDelegate,
  &_swigt__p_Magick__ErrorModule,
  &_swigt__p_Magick__ErrorMonitor,
  &_swigt__p_Magick__ErrorOption,
  &_swigt__p_Magick__ErrorPolicy,
  &_swigt__p_Magick__ErrorRegistry,
  &_swigt__p_Magick__ErrorResourceLimit,
  &_swigt__p_Magick__ErrorStream,
  &_swigt__p_Magick__ErrorType,
  &_swigt__p_Magick__ErrorUndefined,
  &_swigt__p_Magick__ErrorXServer,
  &_swigt__p_Magick__Exception,
  &_swigt__p_Magick__Geometry,
  &_swigt__p_Magick__Image,
  &_swigt__p_Magick__ImageMoments,
  &_swigt__p_Magick__ImagePerceptualHash,
  &_swigt__p_Magick__ImageStatistics,
  &_swigt__p_Magick__Montage,
  &_swigt__p_Magick__MontageFramed,
  &_swigt__p_Magick__Offset,
  &_swigt__p_Magick__Options,
  &_swigt__p_Magick__PathArcAbs,
  &_swigt__p_Magick__PathArcArgs,
  &_swigt__p_Magick__PathArcRel,
  &_swigt__p_Magick__PathClosePath,
  &_swigt__p_Magick__PathCurvetoAbs,
  &_swigt__p_Magick__PathCurvetoArgs,
  &_swigt__p_Magick__PathCurvetoRel,
  &_swigt__p_Magick__PathLinetoAbs,
  &_swigt__p_Magick__PathLinetoHorizontalAbs,
  &_swigt__p_Magick__PathLinetoHorizontalRel,
  &_swigt__p_Magick__PathLinetoRel,
  &_swigt__p_Magick__PathLinetoVerticalAbs,
  &_swigt__p_Magick__PathLinetoVerticalRel,
  &_swigt__p_Magick__PathMovetoAbs,
  &_swigt__p_Magick__PathMovetoRel,
  &_swigt__p_Magick__PathQuadraticCurvetoAbs,
  &_swigt__p_Magick__PathQuadraticCurvetoArgs,
  &_swigt__p_Magick__PathQuadraticCurvetoRel,
  &_swigt__p_Magick__PathSmoothCurvetoAbs,
  &_swigt__p_Magick__PathSmoothCurvetoRel,
  &_swigt__p_Magick__PathSmoothQuadraticCurvetoAbs,
  &_swigt__p_Magick__PathSmoothQuadraticCurvetoRel,
  &_swigt__p_Magick__Point,
  &_swigt__p_Magick__ReadOptions,
  &_swigt__p_Magick__ResourceLimits,
  &_swigt__p_Magick__TypeMetric,
  &_swigt__p_Magick__VPath,
  &_swigt__p_Magick__VPathBase,
  &_swigt__p_Magick__Warning,
  &_swigt__p_Magick__WarningBlob,
  &_swigt__p_Magick__WarningCache,
  &_swigt__p_Magick__WarningCoder,
  &_swigt__p_Magick__WarningConfigure,
  &_swigt__p_Magick__WarningCorruptImage,
  &_swigt__p_Magick__WarningDelegate,
  &_swigt__p_Magick__WarningDraw,
  &_swigt__p_Magick__WarningFileOpen,
  &_swigt__p_Magick__WarningImage,
  &_swigt__p_Magick__WarningMissingDelegate,
  &_swigt__p_Magick__WarningModule,
  &_swigt__p_Magick__WarningMonitor,
  &_swigt__p_Magick__WarningOption,
  &_swigt__p_Magick__WarningPolicy,
  &_swigt__p_Magick__WarningRegistry,
  &_swigt__p_Magick__WarningResourceLimit,
  &_swigt__p_Magick__WarningStream,
  &_swigt__p_Magick__WarningType,
  &_swigt__p_Magick__WarningUndefined,
  &_swigt__p_Magick__WarningXServer,
  &_swigt__p_Magick__adaptiveBlurImage,
  &_swigt__p_Magick__adaptiveThresholdImage,
  &_swigt__p_Magick__addNoiseImage,
  &_swigt__p_Magick__adjoinImage,
  &_swigt__p_Magick__affineTransformImage,
  &_swigt__p_Magick__alphaFlagImage,
  &_swigt__p_Magick__alphaImage,
  &_swigt__p_Magick__animationDelayImage,
  &_swigt__p_Magick__animationIterationsImage,
  &_swigt__p_Magick__annotateImage,
  &_swigt__p_Magick__backgroundColorImage,
  &_swigt__p_Magick__backgroundTextureImage,
  &_swigt__p_Magick__blurImage,
  &_swigt__p_Magick__borderColorImage,
  &_swigt__p_Magick__borderImage,
  &_swigt__p_Magick__boxColorImage,
  &_swigt__p_Magick__cdlImage,
  &_swigt__p_Magick__channelImage,
  &_swigt__p_Magick__charcoalImage,
  &_swigt__p_Magick__chopImage,
  &_swigt__p_Magick__chromaBluePrimaryImage,
  &_swigt__p_Magick__chromaGreenPrimaryImage,
  &_swigt__p_Magick__chromaRedPrimaryImage,
  &_swigt__p_Magick__chromaWhitePointImage,
  &_swigt__p_Magick__colorFuzzImage,
  &_swigt__p_Magick__colorMapImage,
  &_swigt__p_Magick__colorMatrixImage,
  &_swigt__p_Magick__colorSpaceImage,
  &_swigt__p_Magick__colorizeImage,
  &_swigt__p_Magick__commentImage,
  &_swigt__p_Magick__composeImage,
  &_swigt__p_Magick__compositeImage,
  &_swigt__p_Magick__compressTypeImage,
  &_swigt__p_Magick__contrastImage,
  &_swigt__p_Magick__cropImage,
  &_swigt__p_Magick__cycleColormapImage,
  &_swigt__p_Magick__densityImage,
  &_swigt__p_Magick__depthImage,
  &_swigt__p_Magick__despeckleImage,
  &_swigt__p_Magick__distortImage,
  &_swigt__p_Magick__drawImage,
  &_swigt__p_Magick__edgeImage,
  &_swigt__p_Magick__embossImage,
  &_swigt__p_Magick__endianImage,
  &_swigt__p_Magick__enhanceImage,
  &_swigt__p_Magick__equalizeImage,
  &_swigt__p_Magick__fileNameImage,
  &_swigt__p_Magick__fillColorImage,
  &_swigt__p_Magick__filterTypeImage,
  &_swigt__p_Magick__flipImage,
  &_swigt__p_Magick__floodFillAlphaImage,
  &_swigt__p_Magick__floodFillColorImage,
  &_swigt__p_Magick__floodFillTextureImage,
  &_swigt__p_Magick__flopImage,
  &_swigt__p_Magick__fontImage,
  &_swigt__p_Magick__fontPointsizeImage,
  &_swigt__p_Magick__frameImage,
  &_swigt__p_Magick__gammaImage,
  &_swigt__p_Magick__gaussianBlurImage,
  &_swigt__p_Magick__gifDisposeMethodImage,
  &_swigt__p_Magick__haldClutImage,
  &_swigt__p_Magick__implodeImage,
  &_swigt__p_Magick__interlaceTypeImage,
  &_swigt__p_Magick__inverseFourierTransformImage,
  &_swigt__p_Magick__isValidImage,
  &_swigt__p_Magick__labelImage,
  &_swigt__p_Magick__levelImage,
  &_swigt__p_Magick__magickImage,
  &_swigt__p_Magick__magnifyImage,
  &_swigt__p_Magick__mapImage,
  &_swigt__p_Magick__matteColorImage,
  &_swigt__p_Magick__medianConvolveImage,
  &_swigt__p_Magick__minifyImage,
  &_swigt__p_Magick__modulateImage,
  &_swigt__p_Magick__monochromeImage,
  &_swigt__p_Magick__negateImage,
  &_swigt__p_Magick__normalizeImage,
  &_swigt__p_Magick__oilPaintImage,
  &_swigt__p_Magick__opaqueImage,
  &_swigt__p_Magick__pageImage,
  &_swigt__p_Magick__pixelColorImage,
  &_swigt__p_Magick__qualityImage,
  &_swigt__p_Magick__quantizeColorSpaceImage,
  &_swigt__p_Magick__quantizeColorsImage,
  &_swigt__p_Magick__quantizeDitherImage,
  &_swigt__p_Magick__quantizeImage,
  &_swigt__p_Magick__quantizeTreeDepthImage,
  &_swigt__p_Magick__raiseImage,
  &_swigt__p_Magick__reduceNoiseImage,
  &_swigt__p_Magick__renderingIntentImage,
  &_swigt__p_Magick__resizeImage,
  &_swigt__p_Magick__resolutionUnitsImage,
  &_swigt__p_Magick__rollImage,
  &_swigt__p_Magick__rotateImage,
  &_swigt__p_Magick__sampleImage,
  &_swigt__p_Magick__scaleImage,
  &_swigt__p_Magick__sceneImage,
  &_swigt__p_Magick__segmentImage,
  &_swigt__p_Magick__shadeImage,
  &_swigt__p_Magick__shadowImage,
  &_swigt__p_Magick__sharpenImage,
  &_swigt__p_Magick__shaveImage,
  &_swigt__p_Magick__shearImage,
  &_swigt__p_Magick__sizeImage,
  &_swigt__p_Magick__solarizeImage,
  &_swigt__p_Magick__spliceImage,
  &_swigt__p_Magick__spreadImage,
  &_swigt__p_Magick__steganoImage,
  &_swigt__p_Magick__stereoImage,
  &_swigt__p_Magick__stripImage,
  &_swigt__p_Magick__strokeColorImage,
  &_swigt__p_Magick__subImageImage,
  &_swigt__p_Magick__subRangeImage,
  &_swigt__p_Magick__swirlImage,
  &_swigt__p_Magick__textAntiAliasImage,
  &_swigt__p_Magick__textureImage,
  &_swigt__p_Magick__thresholdImage,
  &_swigt__p_Magick__transparentImage,
  &_swigt__p_Magick__trimImage,
  &_swigt__p_Magick__typeImage,
  &_swigt__p_Magick__verboseImage,
  &_swigt__p_Magick__waveImage,
  &_swigt__p_Magick__x11DisplayImage,
  &_swigt__p_Magick__zoomImage,
  &_swigt__p__DrawingWand,
  &_swigt__p__PolicyInfo,
  &_swigt__p_char,
  &_swigt__p_difference_type,
  &_swigt__p_double,
  &_swigt__p_float,
  &_swigt__p_long_long,
  &_swigt__p_p_MagickCore___Image,
  &_swigt__p_p_char,
  &_swigt__p_p_void,
  &_swigt__p_size_t,
  &_swigt__p_size_type,
  &_swigt__p_std__exception,
  &_swigt__p_std__vectorT_Magick__CoderInfo_t,
  &_swigt__p_std__vectorT_Magick__Coordinate_t,
  &_swigt__p_std__vectorT_Magick__Drawable_t,
  &_swigt__p_std__vectorT_Magick__PathArcArgs_t,
  &_swigt__p_std__vectorT_Magick__PathCurvetoArgs_t,
  &_swigt__p_std__vectorT_Magick__PathQuadraticCurvetoArgs_t,
  &_swigt__p_std__vectorT_Magick__VPath_t,
  &_swigt__p_uintptr_t,
  &_swigt__p_unsigned_int,
  &_swigt__p_unsigned_long_long,
  &_swigt__p_value_type,
  &_swigt__p_void,
};

SWIGINTERN swig_cast_info _swigc__p_FILE[] = {  {&_swigt__p_FILE, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_ImageListContainer[] = {  {&_swigt__p_ImageListContainer, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_ImageListIterator[] = {  {&_swigt__p_ImageListIterator, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__AlignType[] = {  {&_swigt__p_MagickCore__AlignType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__CacheType[] = {  {&_swigt__p_MagickCore__CacheType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__ChannelType[] = {  {&_swigt__p_MagickCore__ChannelType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__ClassType[] = {  {&_swigt__p_MagickCore__ClassType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__ColorspaceType[] = {  {&_swigt__p_MagickCore__ColorspaceType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__ComplexOperator[] = {  {&_swigt__p_MagickCore__ComplexOperator, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__ComplianceType[] = {  {&_swigt__p_MagickCore__ComplianceType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__CompositeOperator[] = {  {&_swigt__p_MagickCore__CompositeOperator, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__CompressionType[] = {  {&_swigt__p_MagickCore__CompressionType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__DecorationType[] = {  {&_swigt__p_MagickCore__DecorationType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__DirectionType[] = {  {&_swigt__p_MagickCore__DirectionType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__DisposeType[] = {  {&_swigt__p_MagickCore__DisposeType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__EndianType[] = {  {&_swigt__p_MagickCore__EndianType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__ExceptionType[] = {  {&_swigt__p_MagickCore__ExceptionType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__FilterType[] = {  {&_swigt__p_MagickCore__FilterType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__GradientType[] = {  {&_swigt__p_MagickCore__GradientType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__GravityType[] = {  {&_swigt__p_MagickCore__GravityType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__IlluminantType[] = {  {&_swigt__p_MagickCore__IlluminantType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__ImageType[] = {  {&_swigt__p_MagickCore__ImageType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__InterlaceType[] = {  {&_swigt__p_MagickCore__InterlaceType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__KernelInfoType[] = {  {&_swigt__p_MagickCore__KernelInfoType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__LogEventType[] = {  {&_swigt__p_MagickCore__LogEventType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__MagickBooleanType[] = {  {&_swigt__p_MagickCore__MagickBooleanType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__MagickCLDeviceType[] = {  {&_swigt__p_MagickCore__MagickCLDeviceType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__MagickEvaluateOperator[] = {  {&_swigt__p_MagickCore__MagickEvaluateOperator, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__MagickFormatType[] = {  {&_swigt__p_MagickCore__MagickFormatType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__MagickModuleType[] = {  {&_swigt__p_MagickCore__MagickModuleType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__MetricType[] = {  {&_swigt__p_MagickCore__MetricType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__NoiseType[] = {  {&_swigt__p_MagickCore__NoiseType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__OrientationType[] = {  {&_swigt__p_MagickCore__OrientationType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__PathType[] = {  {&_swigt__p_MagickCore__PathType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__PolicyDomain[] = {  {&_swigt__p_MagickCore__PolicyDomain, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__PolicyRights[] = {  {&_swigt__p_MagickCore__PolicyRights, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__PreviewType[] = {  {&_swigt__p_MagickCore__PreviewType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__PrimitiveType[] = {  {&_swigt__p_MagickCore__PrimitiveType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__QuantumAlphaType[] = {  {&_swigt__p_MagickCore__QuantumAlphaType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__QuantumFormatType[] = {  {&_swigt__p_MagickCore__QuantumFormatType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__QuantumType[] = {  {&_swigt__p_MagickCore__QuantumType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__ReferenceType[] = {  {&_swigt__p_MagickCore__ReferenceType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__RegistryType[] = {  {&_swigt__p_MagickCore__RegistryType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__ResolutionType[] = {  {&_swigt__p_MagickCore__ResolutionType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__ResourceType[] = {  {&_swigt__p_MagickCore__ResourceType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__StatisticType[] = {  {&_swigt__p_MagickCore__StatisticType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__StorageType[] = {  {&_swigt__p_MagickCore__StorageType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__StretchType[] = {  {&_swigt__p_MagickCore__StretchType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__StyleType[] = {  {&_swigt__p_MagickCore__StyleType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__TransmitType[] = {  {&_swigt__p_MagickCore__TransmitType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__ValidateType[] = {  {&_swigt__p_MagickCore__ValidateType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore__WordBreakType[] = {  {&_swigt__p_MagickCore__WordBreakType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore___ChannelMoments[] = {  {&_swigt__p_MagickCore___ChannelMoments, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore___ChannelPerceptualHash[] = {  {&_swigt__p_MagickCore___ChannelPerceptualHash, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore___ChannelStatistics[] = {  {&_swigt__p_MagickCore___ChannelStatistics, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore___ExceptionInfo[] = {  {&_swigt__p_MagickCore___ExceptionInfo, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore___Image[] = {  {&_swigt__p_MagickCore___Image, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore___ImageInfo[] = {  {&_swigt__p_MagickCore___ImageInfo, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore___MontageInfo[] = {  {&_swigt__p_MagickCore___MontageInfo, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore___QuantizeInfo[] = {  {&_swigt__p_MagickCore___QuantizeInfo, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickCore___RectangleInfo[] = {  {&_swigt__p_MagickCore___RectangleInfo, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_MagickWand[] = {  {&_swigt__p_MagickWand, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__Blob[] = {  {&_swigt__p_Magick__Blob, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ChannelMoments[] = {  {&_swigt__p_Magick__ChannelMoments, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ChannelPerceptualHash[] = {  {&_swigt__p_Magick__ChannelPerceptualHash, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ChannelStatistics[] = {  {&_swigt__p_Magick__ChannelStatistics, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__CoderInfo[] = {  {&_swigt__p_Magick__CoderInfo, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__Color[] = {  {&_swigt__p_Magick__Color, 0, 0, 0},  {&_swigt__p_Magick__ColorCMYK, _p_Magick__ColorCMYKTo_p_Magick__Color, 0, 0},  {&_swigt__p_Magick__ColorGray, _p_Magick__ColorGrayTo_p_Magick__Color, 0, 0},  {&_swigt__p_Magick__ColorHSL, _p_Magick__ColorHSLTo_p_Magick__Color, 0, 0},  {&_swigt__p_Magick__ColorMono, _p_Magick__ColorMonoTo_p_Magick__Color, 0, 0},  {&_swigt__p_Magick__ColorRGB, _p_Magick__ColorRGBTo_p_Magick__Color, 0, 0},  {&_swigt__p_Magick__ColorYUV, _p_Magick__ColorYUVTo_p_Magick__Color, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ColorCMYK[] = {  {&_swigt__p_Magick__ColorCMYK, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ColorGray[] = {  {&_swigt__p_Magick__ColorGray, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ColorHSL[] = {  {&_swigt__p_Magick__ColorHSL, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ColorMono[] = {  {&_swigt__p_Magick__ColorMono, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ColorRGB[] = {  {&_swigt__p_Magick__ColorRGB, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ColorYUV[] = {  {&_swigt__p_Magick__ColorYUV, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__Coordinate[] = {  {&_swigt__p_Magick__Coordinate, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__Drawable[] = {  {&_swigt__p_Magick__Drawable, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableAffine[] = {  {&_swigt__p_Magick__DrawableAffine, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableAlpha[] = {  {&_swigt__p_Magick__DrawableAlpha, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableArc[] = {  {&_swigt__p_Magick__DrawableArc, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableBase[] = {  {&_swigt__p_Magick__DrawableBase, 0, 0, 0},  {&_swigt__p_Magick__DrawableAffine, _p_Magick__DrawableAffineTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableAlpha, _p_Magick__DrawableAlphaTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableArc, _p_Magick__DrawableArcTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableBezier, _p_Magick__DrawableBezierTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableBorderColor, _p_Magick__DrawableBorderColorTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableCircle, _p_Magick__DrawableCircleTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableClipPath, _p_Magick__DrawableClipPathTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableClipRule, _p_Magick__DrawableClipRuleTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableClipUnits, _p_Magick__DrawableClipUnitsTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableColor, _p_Magick__DrawableColorTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableCompositeImage, _p_Magick__DrawableCompositeImageTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableDensity, _p_Magick__DrawableDensityTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableEllipse, _p_Magick__DrawableEllipseTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableFillColor, _p_Magick__DrawableFillColorTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableFillOpacity, _p_Magick__DrawableFillOpacityTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableFillPatternUrl, _p_Magick__DrawableFillPatternUrlTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableFillRule, _p_Magick__DrawableFillRuleTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableFont, _p_Magick__DrawableFontTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableGravity, _p_Magick__DrawableGravityTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableLine, _p_Magick__DrawableLineTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableMiterLimit, _p_Magick__DrawableMiterLimitTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawablePath, _p_Magick__DrawablePathTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawablePoint, _p_Magick__DrawablePointTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawablePointSize, _p_Magick__DrawablePointSizeTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawablePolygon, _p_Magick__DrawablePolygonTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawablePolyline, _p_Magick__DrawablePolylineTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawablePopClipPath, _p_Magick__DrawablePopClipPathTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawablePopGraphicContext, _p_Magick__DrawablePopGraphicContextTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawablePopPattern, _p_Magick__DrawablePopPatternTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawablePushClipPath, _p_Magick__DrawablePushClipPathTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawablePushGraphicContext, _p_Magick__DrawablePushGraphicContextTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawablePushPattern, _p_Magick__DrawablePushPatternTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableRectangle, _p_Magick__DrawableRectangleTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableRotation, _p_Magick__DrawableRotationTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableRoundRectangle, _p_Magick__DrawableRoundRectangleTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableScaling, _p_Magick__DrawableScalingTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableSkewX, _p_Magick__DrawableSkewXTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableSkewY, _p_Magick__DrawableSkewYTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableStrokeAntialias, _p_Magick__DrawableStrokeAntialiasTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableStrokeColor, _p_Magick__DrawableStrokeColorTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableStrokeDashArray, _p_Magick__DrawableStrokeDashArrayTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableStrokeDashOffset, _p_Magick__DrawableStrokeDashOffsetTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableStrokeLineCap, _p_Magick__DrawableStrokeLineCapTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableStrokeLineJoin, _p_Magick__DrawableStrokeLineJoinTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableStrokeOpacity, _p_Magick__DrawableStrokeOpacityTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableStrokePatternUrl, _p_Magick__DrawableStrokePatternUrlTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableStrokeWidth, _p_Magick__DrawableStrokeWidthTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableText, _p_Magick__DrawableTextTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableTextAlignment, _p_Magick__DrawableTextAlignmentTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableTextAntialias, _p_Magick__DrawableTextAntialiasTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableTextDecoration, _p_Magick__DrawableTextDecorationTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableTextDirection, _p_Magick__DrawableTextDirectionTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableTextInterlineSpacing, _p_Magick__DrawableTextInterlineSpacingTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableTextInterwordSpacing, _p_Magick__DrawableTextInterwordSpacingTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableTextKerning, _p_Magick__DrawableTextKerningTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableTextUnderColor, _p_Magick__DrawableTextUnderColorTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableTranslation, _p_Magick__DrawableTranslationTo_p_Magick__DrawableBase, 0, 0},  {&_swigt__p_Magick__DrawableViewbox, _p_Magick__DrawableViewboxTo_p_Magick__DrawableBase, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableBezier[] = {  {&_swigt__p_Magick__DrawableBezier, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableBorderColor[] = {  {&_swigt__p_Magick__DrawableBorderColor, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableCircle[] = {  {&_swigt__p_Magick__DrawableCircle, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableClipPath[] = {  {&_swigt__p_Magick__DrawableClipPath, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableClipRule[] = {  {&_swigt__p_Magick__DrawableClipRule, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableClipUnits[] = {  {&_swigt__p_Magick__DrawableClipUnits, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableColor[] = {  {&_swigt__p_Magick__DrawableColor, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableCompositeImage[] = {  {&_swigt__p_Magick__DrawableCompositeImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableDensity[] = {  {&_swigt__p_Magick__DrawableDensity, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableEllipse[] = {  {&_swigt__p_Magick__DrawableEllipse, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableFillColor[] = {  {&_swigt__p_Magick__DrawableFillColor, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableFillOpacity[] = {  {&_swigt__p_Magick__DrawableFillOpacity, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableFillPatternUrl[] = {  {&_swigt__p_Magick__DrawableFillPatternUrl, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableFillRule[] = {  {&_swigt__p_Magick__DrawableFillRule, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableFont[] = {  {&_swigt__p_Magick__DrawableFont, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableGravity[] = {  {&_swigt__p_Magick__DrawableGravity, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableLine[] = {  {&_swigt__p_Magick__DrawableLine, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableMiterLimit[] = {  {&_swigt__p_Magick__DrawableMiterLimit, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawablePath[] = {  {&_swigt__p_Magick__DrawablePath, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawablePoint[] = {  {&_swigt__p_Magick__DrawablePoint, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawablePointSize[] = {  {&_swigt__p_Magick__DrawablePointSize, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawablePolygon[] = {  {&_swigt__p_Magick__DrawablePolygon, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawablePolyline[] = {  {&_swigt__p_Magick__DrawablePolyline, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawablePopClipPath[] = {  {&_swigt__p_Magick__DrawablePopClipPath, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawablePopGraphicContext[] = {  {&_swigt__p_Magick__DrawablePopGraphicContext, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawablePopPattern[] = {  {&_swigt__p_Magick__DrawablePopPattern, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawablePushClipPath[] = {  {&_swigt__p_Magick__DrawablePushClipPath, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawablePushGraphicContext[] = {  {&_swigt__p_Magick__DrawablePushGraphicContext, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawablePushPattern[] = {  {&_swigt__p_Magick__DrawablePushPattern, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableRectangle[] = {  {&_swigt__p_Magick__DrawableRectangle, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableRotation[] = {  {&_swigt__p_Magick__DrawableRotation, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableRoundRectangle[] = {  {&_swigt__p_Magick__DrawableRoundRectangle, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableScaling[] = {  {&_swigt__p_Magick__DrawableScaling, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableSkewX[] = {  {&_swigt__p_Magick__DrawableSkewX, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableSkewY[] = {  {&_swigt__p_Magick__DrawableSkewY, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableStrokeAntialias[] = {  {&_swigt__p_Magick__DrawableStrokeAntialias, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableStrokeColor[] = {  {&_swigt__p_Magick__DrawableStrokeColor, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableStrokeDashArray[] = {  {&_swigt__p_Magick__DrawableStrokeDashArray, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableStrokeDashOffset[] = {  {&_swigt__p_Magick__DrawableStrokeDashOffset, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableStrokeLineCap[] = {  {&_swigt__p_Magick__DrawableStrokeLineCap, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableStrokeLineJoin[] = {  {&_swigt__p_Magick__DrawableStrokeLineJoin, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableStrokeOpacity[] = {  {&_swigt__p_Magick__DrawableStrokeOpacity, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableStrokePatternUrl[] = {  {&_swigt__p_Magick__DrawableStrokePatternUrl, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableStrokeWidth[] = {  {&_swigt__p_Magick__DrawableStrokeWidth, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableText[] = {  {&_swigt__p_Magick__DrawableText, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableTextAlignment[] = {  {&_swigt__p_Magick__DrawableTextAlignment, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableTextAntialias[] = {  {&_swigt__p_Magick__DrawableTextAntialias, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableTextDecoration[] = {  {&_swigt__p_Magick__DrawableTextDecoration, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableTextDirection[] = {  {&_swigt__p_Magick__DrawableTextDirection, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableTextInterlineSpacing[] = {  {&_swigt__p_Magick__DrawableTextInterlineSpacing, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableTextInterwordSpacing[] = {  {&_swigt__p_Magick__DrawableTextInterwordSpacing, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableTextKerning[] = {  {&_swigt__p_Magick__DrawableTextKerning, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableTextUnderColor[] = {  {&_swigt__p_Magick__DrawableTextUnderColor, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableTranslation[] = {  {&_swigt__p_Magick__DrawableTranslation, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__DrawableViewbox[] = {  {&_swigt__p_Magick__DrawableViewbox, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ErrorBlob[] = {{&_swigt__p_Magick__ErrorBlob, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ErrorCache[] = {{&_swigt__p_Magick__ErrorCache, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ErrorCoder[] = {{&_swigt__p_Magick__ErrorCoder, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ErrorConfigure[] = {{&_swigt__p_Magick__ErrorConfigure, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ErrorCorruptImage[] = {{&_swigt__p_Magick__ErrorCorruptImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ErrorDelegate[] = {{&_swigt__p_Magick__ErrorDelegate, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ErrorDraw[] = {{&_swigt__p_Magick__ErrorDraw, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ErrorFileOpen[] = {{&_swigt__p_Magick__ErrorFileOpen, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ErrorImage[] = {{&_swigt__p_Magick__ErrorImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ErrorMissingDelegate[] = {{&_swigt__p_Magick__ErrorMissingDelegate, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ErrorModule[] = {{&_swigt__p_Magick__ErrorModule, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ErrorMonitor[] = {{&_swigt__p_Magick__ErrorMonitor, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ErrorOption[] = {{&_swigt__p_Magick__ErrorOption, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ErrorRegistry[] = {{&_swigt__p_Magick__ErrorRegistry, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ErrorResourceLimit[] = {{&_swigt__p_Magick__ErrorResourceLimit, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ErrorStream[] = {{&_swigt__p_Magick__ErrorStream, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ErrorUndefined[] = {{&_swigt__p_Magick__ErrorUndefined, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ErrorXServer[] = {{&_swigt__p_Magick__ErrorXServer, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__Error[] = {  {&_swigt__p_Magick__Error, 0, 0, 0},  {&_swigt__p_Magick__ErrorBlob, _p_Magick__ErrorBlobTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorCache, _p_Magick__ErrorCacheTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorCoder, _p_Magick__ErrorCoderTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorConfigure, _p_Magick__ErrorConfigureTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorCorruptImage, _p_Magick__ErrorCorruptImageTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorDelegate, _p_Magick__ErrorDelegateTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorDraw, _p_Magick__ErrorDrawTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorFileOpen, _p_Magick__ErrorFileOpenTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorImage, _p_Magick__ErrorImageTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorMissingDelegate, _p_Magick__ErrorMissingDelegateTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorModule, _p_Magick__ErrorModuleTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorMonitor, _p_Magick__ErrorMonitorTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorOption, _p_Magick__ErrorOptionTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorPolicy, _p_Magick__ErrorPolicyTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorRegistry, _p_Magick__ErrorRegistryTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorResourceLimit, _p_Magick__ErrorResourceLimitTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorStream, _p_Magick__ErrorStreamTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorType, _p_Magick__ErrorTypeTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorUndefined, _p_Magick__ErrorUndefinedTo_p_Magick__Error, 0, 0},  {&_swigt__p_Magick__ErrorXServer, _p_Magick__ErrorXServerTo_p_Magick__Error, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ErrorPolicy[] = {  {&_swigt__p_Magick__ErrorPolicy, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ErrorType[] = {  {&_swigt__p_Magick__ErrorType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__WarningBlob[] = {{&_swigt__p_Magick__WarningBlob, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__WarningCache[] = {{&_swigt__p_Magick__WarningCache, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__WarningCoder[] = {{&_swigt__p_Magick__WarningCoder, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__WarningConfigure[] = {{&_swigt__p_Magick__WarningConfigure, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__WarningCorruptImage[] = {{&_swigt__p_Magick__WarningCorruptImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__WarningDelegate[] = {{&_swigt__p_Magick__WarningDelegate, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__WarningDraw[] = {{&_swigt__p_Magick__WarningDraw, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__WarningFileOpen[] = {{&_swigt__p_Magick__WarningFileOpen, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__WarningImage[] = {{&_swigt__p_Magick__WarningImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__WarningMissingDelegate[] = {{&_swigt__p_Magick__WarningMissingDelegate, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__WarningModule[] = {{&_swigt__p_Magick__WarningModule, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__WarningMonitor[] = {{&_swigt__p_Magick__WarningMonitor, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__WarningOption[] = {{&_swigt__p_Magick__WarningOption, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__WarningRegistry[] = {{&_swigt__p_Magick__WarningRegistry, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__WarningResourceLimit[] = {{&_swigt__p_Magick__WarningResourceLimit, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__WarningStream[] = {{&_swigt__p_Magick__WarningStream, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__WarningUndefined[] = {{&_swigt__p_Magick__WarningUndefined, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__WarningXServer[] = {{&_swigt__p_Magick__WarningXServer, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__Exception[] = {  {&_swigt__p_Magick__Exception, 0, 0, 0},  {&_swigt__p_Magick__Error, _p_Magick__ErrorTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorBlob, _p_Magick__ErrorBlobTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorCache, _p_Magick__ErrorCacheTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorCoder, _p_Magick__ErrorCoderTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorConfigure, _p_Magick__ErrorConfigureTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorCorruptImage, _p_Magick__ErrorCorruptImageTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorDelegate, _p_Magick__ErrorDelegateTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorDraw, _p_Magick__ErrorDrawTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorFileOpen, _p_Magick__ErrorFileOpenTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorImage, _p_Magick__ErrorImageTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorMissingDelegate, _p_Magick__ErrorMissingDelegateTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorModule, _p_Magick__ErrorModuleTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorMonitor, _p_Magick__ErrorMonitorTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorOption, _p_Magick__ErrorOptionTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorPolicy, _p_Magick__ErrorPolicyTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorRegistry, _p_Magick__ErrorRegistryTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorResourceLimit, _p_Magick__ErrorResourceLimitTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorStream, _p_Magick__ErrorStreamTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorType, _p_Magick__ErrorTypeTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorUndefined, _p_Magick__ErrorUndefinedTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__ErrorXServer, _p_Magick__ErrorXServerTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__Warning, _p_Magick__WarningTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningBlob, _p_Magick__WarningBlobTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningCache, _p_Magick__WarningCacheTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningCoder, _p_Magick__WarningCoderTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningConfigure, _p_Magick__WarningConfigureTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningCorruptImage, _p_Magick__WarningCorruptImageTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningDelegate, _p_Magick__WarningDelegateTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningDraw, _p_Magick__WarningDrawTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningFileOpen, _p_Magick__WarningFileOpenTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningImage, _p_Magick__WarningImageTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningMissingDelegate, _p_Magick__WarningMissingDelegateTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningModule, _p_Magick__WarningModuleTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningMonitor, _p_Magick__WarningMonitorTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningOption, _p_Magick__WarningOptionTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningPolicy, _p_Magick__WarningPolicyTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningRegistry, _p_Magick__WarningRegistryTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningResourceLimit, _p_Magick__WarningResourceLimitTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningStream, _p_Magick__WarningStreamTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningType, _p_Magick__WarningTypeTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningUndefined, _p_Magick__WarningUndefinedTo_p_Magick__Exception, 0, 0},  {&_swigt__p_Magick__WarningXServer, _p_Magick__WarningXServerTo_p_Magick__Exception, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__Geometry[] = {  {&_swigt__p_Magick__Geometry, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__Image[] = {  {&_swigt__p_Magick__Image, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ImageMoments[] = {  {&_swigt__p_Magick__ImageMoments, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ImagePerceptualHash[] = {  {&_swigt__p_Magick__ImagePerceptualHash, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ImageStatistics[] = {  {&_swigt__p_Magick__ImageStatistics, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__Montage[] = {  {&_swigt__p_Magick__Montage, 0, 0, 0},  {&_swigt__p_Magick__MontageFramed, _p_Magick__MontageFramedTo_p_Magick__Montage, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__MontageFramed[] = {  {&_swigt__p_Magick__MontageFramed, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__Offset[] = {  {&_swigt__p_Magick__Offset, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__Options[] = {  {&_swigt__p_Magick__Options, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__PathArcAbs[] = {  {&_swigt__p_Magick__PathArcAbs, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__PathArcArgs[] = {  {&_swigt__p_Magick__PathArcArgs, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__PathArcRel[] = {  {&_swigt__p_Magick__PathArcRel, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__PathClosePath[] = {  {&_swigt__p_Magick__PathClosePath, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__PathCurvetoAbs[] = {  {&_swigt__p_Magick__PathCurvetoAbs, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__PathCurvetoArgs[] = {  {&_swigt__p_Magick__PathCurvetoArgs, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__PathCurvetoRel[] = {  {&_swigt__p_Magick__PathCurvetoRel, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__PathLinetoAbs[] = {  {&_swigt__p_Magick__PathLinetoAbs, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__PathLinetoHorizontalAbs[] = {  {&_swigt__p_Magick__PathLinetoHorizontalAbs, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__PathLinetoHorizontalRel[] = {  {&_swigt__p_Magick__PathLinetoHorizontalRel, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__PathLinetoRel[] = {  {&_swigt__p_Magick__PathLinetoRel, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__PathLinetoVerticalAbs[] = {  {&_swigt__p_Magick__PathLinetoVerticalAbs, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__PathLinetoVerticalRel[] = {  {&_swigt__p_Magick__PathLinetoVerticalRel, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__PathMovetoAbs[] = {  {&_swigt__p_Magick__PathMovetoAbs, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__PathMovetoRel[] = {  {&_swigt__p_Magick__PathMovetoRel, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__PathQuadraticCurvetoAbs[] = {  {&_swigt__p_Magick__PathQuadraticCurvetoAbs, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__PathQuadraticCurvetoArgs[] = {  {&_swigt__p_Magick__PathQuadraticCurvetoArgs, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__PathQuadraticCurvetoRel[] = {  {&_swigt__p_Magick__PathQuadraticCurvetoRel, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__PathSmoothCurvetoAbs[] = {  {&_swigt__p_Magick__PathSmoothCurvetoAbs, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__PathSmoothCurvetoRel[] = {  {&_swigt__p_Magick__PathSmoothCurvetoRel, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__PathSmoothQuadraticCurvetoAbs[] = {  {&_swigt__p_Magick__PathSmoothQuadraticCurvetoAbs, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__PathSmoothQuadraticCurvetoRel[] = {  {&_swigt__p_Magick__PathSmoothQuadraticCurvetoRel, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__Point[] = {  {&_swigt__p_Magick__Point, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ReadOptions[] = {  {&_swigt__p_Magick__ReadOptions, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__ResourceLimits[] = {  {&_swigt__p_Magick__ResourceLimits, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__TypeMetric[] = {  {&_swigt__p_Magick__TypeMetric, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__VPath[] = {  {&_swigt__p_Magick__VPath, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__VPathBase[] = {  {&_swigt__p_Magick__VPathBase, 0, 0, 0},  {&_swigt__p_Magick__PathArcAbs, _p_Magick__PathArcAbsTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathArcRel, _p_Magick__PathArcRelTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathClosePath, _p_Magick__PathClosePathTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathCurvetoAbs, _p_Magick__PathCurvetoAbsTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathCurvetoRel, _p_Magick__PathCurvetoRelTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathLinetoAbs, _p_Magick__PathLinetoAbsTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathLinetoHorizontalAbs, _p_Magick__PathLinetoHorizontalAbsTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathLinetoHorizontalRel, _p_Magick__PathLinetoHorizontalRelTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathLinetoRel, _p_Magick__PathLinetoRelTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathLinetoVerticalAbs, _p_Magick__PathLinetoVerticalAbsTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathLinetoVerticalRel, _p_Magick__PathLinetoVerticalRelTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathMovetoAbs, _p_Magick__PathMovetoAbsTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathMovetoRel, _p_Magick__PathMovetoRelTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathQuadraticCurvetoAbs, _p_Magick__PathQuadraticCurvetoAbsTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathQuadraticCurvetoRel, _p_Magick__PathQuadraticCurvetoRelTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathSmoothCurvetoAbs, _p_Magick__PathSmoothCurvetoAbsTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathSmoothCurvetoRel, _p_Magick__PathSmoothCurvetoRelTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathSmoothQuadraticCurvetoAbs, _p_Magick__PathSmoothQuadraticCurvetoAbsTo_p_Magick__VPathBase, 0, 0},  {&_swigt__p_Magick__PathSmoothQuadraticCurvetoRel, _p_Magick__PathSmoothQuadraticCurvetoRelTo_p_Magick__VPathBase, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__Warning[] = {  {&_swigt__p_Magick__Warning, 0, 0, 0},  {&_swigt__p_Magick__WarningBlob, _p_Magick__WarningBlobTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningCache, _p_Magick__WarningCacheTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningCoder, _p_Magick__WarningCoderTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningConfigure, _p_Magick__WarningConfigureTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningCorruptImage, _p_Magick__WarningCorruptImageTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningDelegate, _p_Magick__WarningDelegateTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningDraw, _p_Magick__WarningDrawTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningFileOpen, _p_Magick__WarningFileOpenTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningImage, _p_Magick__WarningImageTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningMissingDelegate, _p_Magick__WarningMissingDelegateTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningModule, _p_Magick__WarningModuleTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningMonitor, _p_Magick__WarningMonitorTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningOption, _p_Magick__WarningOptionTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningPolicy, _p_Magick__WarningPolicyTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningRegistry, _p_Magick__WarningRegistryTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningResourceLimit, _p_Magick__WarningResourceLimitTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningStream, _p_Magick__WarningStreamTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningType, _p_Magick__WarningTypeTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningUndefined, _p_Magick__WarningUndefinedTo_p_Magick__Warning, 0, 0},  {&_swigt__p_Magick__WarningXServer, _p_Magick__WarningXServerTo_p_Magick__Warning, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__WarningPolicy[] = {  {&_swigt__p_Magick__WarningPolicy, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__WarningType[] = {  {&_swigt__p_Magick__WarningType, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__adaptiveBlurImage[] = {  {&_swigt__p_Magick__adaptiveBlurImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__adaptiveThresholdImage[] = {  {&_swigt__p_Magick__adaptiveThresholdImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__addNoiseImage[] = {  {&_swigt__p_Magick__addNoiseImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__adjoinImage[] = {  {&_swigt__p_Magick__adjoinImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__affineTransformImage[] = {  {&_swigt__p_Magick__affineTransformImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__alphaFlagImage[] = {  {&_swigt__p_Magick__alphaFlagImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__alphaImage[] = {  {&_swigt__p_Magick__alphaImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__animationDelayImage[] = {  {&_swigt__p_Magick__animationDelayImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__animationIterationsImage[] = {  {&_swigt__p_Magick__animationIterationsImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__annotateImage[] = {  {&_swigt__p_Magick__annotateImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__backgroundColorImage[] = {  {&_swigt__p_Magick__backgroundColorImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__backgroundTextureImage[] = {  {&_swigt__p_Magick__backgroundTextureImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__blurImage[] = {  {&_swigt__p_Magick__blurImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__borderColorImage[] = {  {&_swigt__p_Magick__borderColorImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__borderImage[] = {  {&_swigt__p_Magick__borderImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__boxColorImage[] = {  {&_swigt__p_Magick__boxColorImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__cdlImage[] = {  {&_swigt__p_Magick__cdlImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__channelImage[] = {  {&_swigt__p_Magick__channelImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__charcoalImage[] = {  {&_swigt__p_Magick__charcoalImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__chopImage[] = {  {&_swigt__p_Magick__chopImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__chromaBluePrimaryImage[] = {  {&_swigt__p_Magick__chromaBluePrimaryImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__chromaGreenPrimaryImage[] = {  {&_swigt__p_Magick__chromaGreenPrimaryImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__chromaRedPrimaryImage[] = {  {&_swigt__p_Magick__chromaRedPrimaryImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__chromaWhitePointImage[] = {  {&_swigt__p_Magick__chromaWhitePointImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__colorFuzzImage[] = {  {&_swigt__p_Magick__colorFuzzImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__colorMapImage[] = {  {&_swigt__p_Magick__colorMapImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__colorMatrixImage[] = {  {&_swigt__p_Magick__colorMatrixImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__colorSpaceImage[] = {  {&_swigt__p_Magick__colorSpaceImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__colorizeImage[] = {  {&_swigt__p_Magick__colorizeImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__commentImage[] = {  {&_swigt__p_Magick__commentImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__composeImage[] = {  {&_swigt__p_Magick__composeImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__compositeImage[] = {  {&_swigt__p_Magick__compositeImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__compressTypeImage[] = {  {&_swigt__p_Magick__compressTypeImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__contrastImage[] = {  {&_swigt__p_Magick__contrastImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__cropImage[] = {  {&_swigt__p_Magick__cropImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__cycleColormapImage[] = {  {&_swigt__p_Magick__cycleColormapImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__densityImage[] = {  {&_swigt__p_Magick__densityImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__depthImage[] = {  {&_swigt__p_Magick__depthImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__despeckleImage[] = {  {&_swigt__p_Magick__despeckleImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__distortImage[] = {  {&_swigt__p_Magick__distortImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__drawImage[] = {  {&_swigt__p_Magick__drawImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__edgeImage[] = {  {&_swigt__p_Magick__edgeImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__embossImage[] = {  {&_swigt__p_Magick__embossImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__endianImage[] = {  {&_swigt__p_Magick__endianImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__enhanceImage[] = {  {&_swigt__p_Magick__enhanceImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__equalizeImage[] = {  {&_swigt__p_Magick__equalizeImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__fileNameImage[] = {  {&_swigt__p_Magick__fileNameImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__fillColorImage[] = {  {&_swigt__p_Magick__fillColorImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__filterTypeImage[] = {  {&_swigt__p_Magick__filterTypeImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__flipImage[] = {  {&_swigt__p_Magick__flipImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__floodFillAlphaImage[] = {  {&_swigt__p_Magick__floodFillAlphaImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__floodFillColorImage[] = {  {&_swigt__p_Magick__floodFillColorImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__floodFillTextureImage[] = {  {&_swigt__p_Magick__floodFillTextureImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__flopImage[] = {  {&_swigt__p_Magick__flopImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__fontImage[] = {  {&_swigt__p_Magick__fontImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__fontPointsizeImage[] = {  {&_swigt__p_Magick__fontPointsizeImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__frameImage[] = {  {&_swigt__p_Magick__frameImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__gammaImage[] = {  {&_swigt__p_Magick__gammaImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__gaussianBlurImage[] = {  {&_swigt__p_Magick__gaussianBlurImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__gifDisposeMethodImage[] = {  {&_swigt__p_Magick__gifDisposeMethodImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__haldClutImage[] = {  {&_swigt__p_Magick__haldClutImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__implodeImage[] = {  {&_swigt__p_Magick__implodeImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__interlaceTypeImage[] = {  {&_swigt__p_Magick__interlaceTypeImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__inverseFourierTransformImage[] = {  {&_swigt__p_Magick__inverseFourierTransformImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__isValidImage[] = {  {&_swigt__p_Magick__isValidImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__labelImage[] = {  {&_swigt__p_Magick__labelImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__levelImage[] = {  {&_swigt__p_Magick__levelImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__magickImage[] = {  {&_swigt__p_Magick__magickImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__magnifyImage[] = {  {&_swigt__p_Magick__magnifyImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__mapImage[] = {  {&_swigt__p_Magick__mapImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__matteColorImage[] = {  {&_swigt__p_Magick__matteColorImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__medianConvolveImage[] = {  {&_swigt__p_Magick__medianConvolveImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__minifyImage[] = {  {&_swigt__p_Magick__minifyImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__modulateImage[] = {  {&_swigt__p_Magick__modulateImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__monochromeImage[] = {  {&_swigt__p_Magick__monochromeImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__negateImage[] = {  {&_swigt__p_Magick__negateImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__normalizeImage[] = {  {&_swigt__p_Magick__normalizeImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__oilPaintImage[] = {  {&_swigt__p_Magick__oilPaintImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__opaqueImage[] = {  {&_swigt__p_Magick__opaqueImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__pageImage[] = {  {&_swigt__p_Magick__pageImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__pixelColorImage[] = {  {&_swigt__p_Magick__pixelColorImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__qualityImage[] = {  {&_swigt__p_Magick__qualityImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__quantizeColorSpaceImage[] = {  {&_swigt__p_Magick__quantizeColorSpaceImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__quantizeColorsImage[] = {  {&_swigt__p_Magick__quantizeColorsImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__quantizeDitherImage[] = {  {&_swigt__p_Magick__quantizeDitherImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__quantizeImage[] = {  {&_swigt__p_Magick__quantizeImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__quantizeTreeDepthImage[] = {  {&_swigt__p_Magick__quantizeTreeDepthImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__raiseImage[] = {  {&_swigt__p_Magick__raiseImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__reduceNoiseImage[] = {  {&_swigt__p_Magick__reduceNoiseImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__renderingIntentImage[] = {  {&_swigt__p_Magick__renderingIntentImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__resizeImage[] = {  {&_swigt__p_Magick__resizeImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__resolutionUnitsImage[] = {  {&_swigt__p_Magick__resolutionUnitsImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__rollImage[] = {  {&_swigt__p_Magick__rollImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__rotateImage[] = {  {&_swigt__p_Magick__rotateImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__sampleImage[] = {  {&_swigt__p_Magick__sampleImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__scaleImage[] = {  {&_swigt__p_Magick__scaleImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__sceneImage[] = {  {&_swigt__p_Magick__sceneImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__segmentImage[] = {  {&_swigt__p_Magick__segmentImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__shadeImage[] = {  {&_swigt__p_Magick__shadeImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__shadowImage[] = {  {&_swigt__p_Magick__shadowImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__sharpenImage[] = {  {&_swigt__p_Magick__sharpenImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__shaveImage[] = {  {&_swigt__p_Magick__shaveImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__shearImage[] = {  {&_swigt__p_Magick__shearImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__sizeImage[] = {  {&_swigt__p_Magick__sizeImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__solarizeImage[] = {  {&_swigt__p_Magick__solarizeImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__spliceImage[] = {  {&_swigt__p_Magick__spliceImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__spreadImage[] = {  {&_swigt__p_Magick__spreadImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__steganoImage[] = {  {&_swigt__p_Magick__steganoImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__stereoImage[] = {  {&_swigt__p_Magick__stereoImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__stripImage[] = {  {&_swigt__p_Magick__stripImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__strokeColorImage[] = {  {&_swigt__p_Magick__strokeColorImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__subImageImage[] = {  {&_swigt__p_Magick__subImageImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__subRangeImage[] = {  {&_swigt__p_Magick__subRangeImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__swirlImage[] = {  {&_swigt__p_Magick__swirlImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__textAntiAliasImage[] = {  {&_swigt__p_Magick__textAntiAliasImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__textureImage[] = {  {&_swigt__p_Magick__textureImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__thresholdImage[] = {  {&_swigt__p_Magick__thresholdImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__transparentImage[] = {  {&_swigt__p_Magick__transparentImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__trimImage[] = {  {&_swigt__p_Magick__trimImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__typeImage[] = {  {&_swigt__p_Magick__typeImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__verboseImage[] = {  {&_swigt__p_Magick__verboseImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__waveImage[] = {  {&_swigt__p_Magick__waveImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__x11DisplayImage[] = {  {&_swigt__p_Magick__x11DisplayImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_Magick__zoomImage[] = {  {&_swigt__p_Magick__zoomImage, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p__DrawingWand[] = {  {&_swigt__p__DrawingWand, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p__PolicyInfo[] = {  {&_swigt__p__PolicyInfo, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_difference_type[] = {  {&_swigt__p_difference_type, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_double[] = {  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_float[] = {  {&_swigt__p_float, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_long_long[] = {  {&_swigt__p_long_long, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_p_MagickCore___Image[] = {  {&_swigt__p_p_MagickCore___Image, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_p_char[] = {  {&_swigt__p_p_char, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_p_void[] = {  {&_swigt__p_p_void, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_size_t[] = {  {&_swigt__p_size_t, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_size_type[] = {  {&_swigt__p_size_type, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_std__exception[] = {  {&_swigt__p_std__exception, 0, 0, 0},  {&_swigt__p_Magick__Error, _p_Magick__ErrorTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorBlob, _p_Magick__ErrorBlobTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorCache, _p_Magick__ErrorCacheTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorCoder, _p_Magick__ErrorCoderTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorConfigure, _p_Magick__ErrorConfigureTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorCorruptImage, _p_Magick__ErrorCorruptImageTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorDelegate, _p_Magick__ErrorDelegateTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorDraw, _p_Magick__ErrorDrawTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorFileOpen, _p_Magick__ErrorFileOpenTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorImage, _p_Magick__ErrorImageTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorMissingDelegate, _p_Magick__ErrorMissingDelegateTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorModule, _p_Magick__ErrorModuleTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorMonitor, _p_Magick__ErrorMonitorTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorOption, _p_Magick__ErrorOptionTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorPolicy, _p_Magick__ErrorPolicyTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorRegistry, _p_Magick__ErrorRegistryTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorResourceLimit, _p_Magick__ErrorResourceLimitTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorStream, _p_Magick__ErrorStreamTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorType, _p_Magick__ErrorTypeTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorUndefined, _p_Magick__ErrorUndefinedTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__ErrorXServer, _p_Magick__ErrorXServerTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__Exception, _p_Magick__ExceptionTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__Warning, _p_Magick__WarningTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningBlob, _p_Magick__WarningBlobTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningCache, _p_Magick__WarningCacheTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningCoder, _p_Magick__WarningCoderTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningConfigure, _p_Magick__WarningConfigureTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningCorruptImage, _p_Magick__WarningCorruptImageTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningDelegate, _p_Magick__WarningDelegateTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningDraw, _p_Magick__WarningDrawTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningFileOpen, _p_Magick__WarningFileOpenTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningImage, _p_Magick__WarningImageTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningMissingDelegate, _p_Magick__WarningMissingDelegateTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningModule, _p_Magick__WarningModuleTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningMonitor, _p_Magick__WarningMonitorTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningOption, _p_Magick__WarningOptionTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningPolicy, _p_Magick__WarningPolicyTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningRegistry, _p_Magick__WarningRegistryTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningResourceLimit, _p_Magick__WarningResourceLimitTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningStream, _p_Magick__WarningStreamTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningType, _p_Magick__WarningTypeTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningUndefined, _p_Magick__WarningUndefinedTo_p_std__exception, 0, 0},  {&_swigt__p_Magick__WarningXServer, _p_Magick__WarningXServerTo_p_std__exception, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_std__vectorT_Magick__CoderInfo_t[] = {  {&_swigt__p_std__vectorT_Magick__CoderInfo_t, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_std__vectorT_Magick__Coordinate_t[] = {  {&_swigt__p_std__vectorT_Magick__Coordinate_t, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_std__vectorT_Magick__Drawable_t[] = {  {&_swigt__p_std__vectorT_Magick__Drawable_t, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_std__vectorT_Magick__PathArcArgs_t[] = {  {&_swigt__p_std__vectorT_Magick__PathArcArgs_t, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_std__vectorT_Magick__PathCurvetoArgs_t[] = {  {&_swigt__p_std__vectorT_Magick__PathCurvetoArgs_t, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_std__vectorT_Magick__PathQuadraticCurvetoArgs_t[] = {  {&_swigt__p_std__vectorT_Magick__PathQuadraticCurvetoArgs_t, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_std__vectorT_Magick__VPath_t[] = {  {&_swigt__p_std__vectorT_Magick__VPath_t, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_uintptr_t[] = {  {&_swigt__p_uintptr_t, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_unsigned_int[] = {  {&_swigt__p_unsigned_int, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_unsigned_long_long[] = {  {&_swigt__p_unsigned_long_long, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_value_type[] = {  {&_swigt__p_value_type, 0, 0, 0},{0, 0, 0, 0}};
SWIGINTERN swig_cast_info _swigc__p_void[] = {  {&_swigt__p_void, 0, 0, 0},{0, 0, 0, 0}};

SWIGINTERN swig_cast_info *swig_cast_initial[] = {
  _swigc__p_FILE,
  _swigc__p_ImageListContainer,
  _swigc__p_ImageListIterator,
  _swigc__p_MagickCore__AlignType,
  _swigc__p_MagickCore__CacheType,
  _swigc__p_MagickCore__ChannelType,
  _swigc__p_MagickCore__ClassType,
  _swigc__p_MagickCore__ColorspaceType,
  _swigc__p_MagickCore__ComplexOperator,
  _swigc__p_MagickCore__ComplianceType,
  _swigc__p_MagickCore__CompositeOperator,
  _swigc__p_MagickCore__CompressionType,
  _swigc__p_MagickCore__DecorationType,
  _swigc__p_MagickCore__DirectionType,
  _swigc__p_MagickCore__DisposeType,
  _swigc__p_MagickCore__EndianType,
  _swigc__p_MagickCore__ExceptionType,
  _swigc__p_MagickCore__FilterType,
  _swigc__p_MagickCore__GradientType,
  _swigc__p_MagickCore__GravityType,
  _swigc__p_MagickCore__IlluminantType,
  _swigc__p_MagickCore__ImageType,
  _swigc__p_MagickCore__InterlaceType,
  _swigc__p_MagickCore__KernelInfoType,
  _swigc__p_MagickCore__LogEventType,
  _swigc__p_MagickCore__MagickBooleanType,
  _swigc__p_MagickCore__MagickCLDeviceType,
  _swigc__p_MagickCore__MagickEvaluateOperator,
  _swigc__p_MagickCore__MagickFormatType,
  _swigc__p_MagickCore__MagickModuleType,
  _swigc__p_MagickCore__MetricType,
  _swigc__p_MagickCore__NoiseType,
  _swigc__p_MagickCore__OrientationType,
  _swigc__p_MagickCore__PathType,
  _swigc__p_MagickCore__PolicyDomain,
  _swigc__p_MagickCore__PolicyRights,
  _swigc__p_MagickCore__PreviewType,
  _swigc__p_MagickCore__PrimitiveType,
  _swigc__p_MagickCore__QuantumAlphaType,
  _swigc__p_MagickCore__QuantumFormatType,
  _swigc__p_MagickCore__QuantumType,
  _swigc__p_MagickCore__ReferenceType,
  _swigc__p_MagickCore__RegistryType,
  _swigc__p_MagickCore__ResolutionType,
  _swigc__p_MagickCore__ResourceType,
  _swigc__p_MagickCore__StatisticType,
  _swigc__p_MagickCore__StorageType,
  _swigc__p_MagickCore__StretchType,
  _swigc__p_MagickCore__StyleType,
  _swigc__p_MagickCore__TransmitType,
  _swigc__p_MagickCore__ValidateType,
  _swigc__p_MagickCore__WordBreakType,
  _swigc__p_MagickCore___ChannelMoments,
  _swigc__p_MagickCore___ChannelPerceptualHash,
  _swigc__p_MagickCore___ChannelStatistics,
  _swigc__p_MagickCore___ExceptionInfo,
  _swigc__p_MagickCore___Image,
  _swigc__p_MagickCore___ImageInfo,
  _swigc__p_MagickCore___MontageInfo,
  _swigc__p_MagickCore___QuantizeInfo,
  _swigc__p_MagickCore___RectangleInfo,
  _swigc__p_MagickWand,
  _swigc__p_Magick__Blob,
  _swigc__p_Magick__ChannelMoments,
  _swigc__p_Magick__ChannelPerceptualHash,
  _swigc__p_Magick__ChannelStatistics,
  _swigc__p_Magick__CoderInfo,
  _swigc__p_Magick__Color,
  _swigc__p_Magick__ColorCMYK,
  _swigc__p_Magick__ColorGray,
  _swigc__p_Magick__ColorHSL,
  _swigc__p_Magick__ColorMono,
  _swigc__p_Magick__ColorRGB,
  _swigc__p_Magick__ColorYUV,
  _swigc__p_Magick__Coordinate,
  _swigc__p_Magick__Drawable,
  _swigc__p_Magick__DrawableAffine,
  _swigc__p_Magick__DrawableAlpha,
  _swigc__p_Magick__DrawableArc,
  _swigc__p_Magick__DrawableBase,
  _swigc__p_Magick__DrawableBezier,
  _swigc__p_Magick__DrawableBorderColor,
  _swigc__p_Magick__DrawableCircle,
  _swigc__p_Magick__DrawableClipPath,
  _swigc__p_Magick__DrawableClipRule,
  _swigc__p_Magick__DrawableClipUnits,
  _swigc__p_Magick__DrawableColor,
  _swigc__p_Magick__DrawableCompositeImage,
  _swigc__p_Magick__DrawableDensity,
  _swigc__p_Magick__DrawableEllipse,
  _swigc__p_Magick__DrawableFillColor,
  _swigc__p_Magick__DrawableFillOpacity,
  _swigc__p_Magick__DrawableFillPatternUrl,
  _swigc__p_Magick__DrawableFillRule,
  _swigc__p_Magick__DrawableFont,
  _swigc__p_Magick__DrawableGravity,
  _swigc__p_Magick__DrawableLine,
  _swigc__p_Magick__DrawableMiterLimit,
  _swigc__p_Magick__DrawablePath,
  _swigc__p_Magick__DrawablePoint,
  _swigc__p_Magick__DrawablePointSize,
  _swigc__p_Magick__DrawablePolygon,
  _swigc__p_Magick__DrawablePolyline,
  _swigc__p_Magick__DrawablePopClipPath,
  _swigc__p_Magick__DrawablePopGraphicContext,
  _swigc__p_Magick__DrawablePopPattern,
  _swigc__p_Magick__DrawablePushClipPath,
  _swigc__p_Magick__DrawablePushGraphicContext,
  _swigc__p_Magick__DrawablePushPattern,
  _swigc__p_Magick__DrawableRectangle,
  _swigc__p_Magick__DrawableRotation,
  _swigc__p_Magick__DrawableRoundRectangle,
  _swigc__p_Magick__DrawableScaling,
  _swigc__p_Magick__DrawableSkewX,
  _swigc__p_Magick__DrawableSkewY,
  _swigc__p_Magick__DrawableStrokeAntialias,
  _swigc__p_Magick__DrawableStrokeColor,
  _swigc__p_Magick__DrawableStrokeDashArray,
  _swigc__p_Magick__DrawableStrokeDashOffset,
  _swigc__p_Magick__DrawableStrokeLineCap,
  _swigc__p_Magick__DrawableStrokeLineJoin,
  _swigc__p_Magick__DrawableStrokeOpacity,
  _swigc__p_Magick__DrawableStrokePatternUrl,
  _swigc__p_Magick__DrawableStrokeWidth,
  _swigc__p_Magick__DrawableText,
  _swigc__p_Magick__DrawableTextAlignment,
  _swigc__p_Magick__DrawableTextAntialias,
  _swigc__p_Magick__DrawableTextDecoration,
  _swigc__p_Magick__DrawableTextDirection,
  _swigc__p_Magick__DrawableTextInterlineSpacing,
  _swigc__p_Magick__DrawableTextInterwordSpacing,
  _swigc__p_Magick__DrawableTextKerning,
  _swigc__p_Magick__DrawableTextUnderColor,
  _swigc__p_Magick__DrawableTranslation,
  _swigc__p_Magick__DrawableViewbox,
  _swigc__p_Magick__Error,
  _swigc__p_Magick__ErrorBlob,
  _swigc__p_Magick__ErrorCache,
  _swigc__p_Magick__ErrorCoder,
  _swigc__p_Magick__ErrorConfigure,
  _swigc__p_Magick__ErrorCorruptImage,
  _swigc__p_Magick__ErrorDelegate,
  _swigc__p_Magick__ErrorDraw,
  _swigc__p_Magick__ErrorFileOpen,
  _swigc__p_Magick__ErrorImage,
  _swigc__p_Magick__ErrorMissingDelegate,
  _swigc__p_Magick__ErrorModule,
  _swigc__p_Magick__ErrorMonitor,
  _swigc__p_Magick__ErrorOption,
  _swigc__p_Magick__ErrorPolicy,
  _swigc__p_Magick__ErrorRegistry,
  _swigc__p_Magick__ErrorResourceLimit,
  _swigc__p_Magick__ErrorStream,
  _swigc__p_Magick__ErrorType,
  _swigc__p_Magick__ErrorUndefined,
  _swigc__p_Magick__ErrorXServer,
  _swigc__p_Magick__Exception,
  _swigc__p_Magick__Geometry,
  _swigc__p_Magick__Image,
  _swigc__p_Magick__ImageMoments,
  _swigc__p_Magick__ImagePerceptualHash,
  _swigc__p_Magick__ImageStatistics,
  _swigc__p_Magick__Montage,
  _swigc__p_Magick__MontageFramed,
  _swigc__p_Magick__Offset,
  _swigc__p_Magick__Options,
  _swigc__p_Magick__PathArcAbs,
  _swigc__p_Magick__PathArcArgs,
  _swigc__p_Magick__PathArcRel,
  _swigc__p_Magick__PathClosePath,
  _swigc__p_Magick__PathCurvetoAbs,
  _swigc__p_Magick__PathCurvetoArgs,
  _swigc__p_Magick__PathCurvetoRel,
  _swigc__p_Magick__PathLinetoAbs,
  _swigc__p_Magick__PathLinetoHorizontalAbs,
  _swigc__p_Magick__PathLinetoHorizontalRel,
  _swigc__p_Magick__PathLinetoRel,
  _swigc__p_Magick__PathLinetoVerticalAbs,
  _swigc__p_Magick__PathLinetoVerticalRel,
  _swigc__p_Magick__PathMovetoAbs,
  _swigc__p_Magick__PathMovetoRel,
  _swigc__p_Magick__PathQuadraticCurvetoAbs,
  _swigc__p_Magick__PathQuadraticCurvetoArgs,
  _swigc__p_Magick__PathQuadraticCurvetoRel,
  _swigc__p_Magick__PathSmoothCurvetoAbs,
  _swigc__p_Magick__PathSmoothCurvetoRel,
  _swigc__p_Magick__PathSmoothQuadraticCurvetoAbs,
  _swigc__p_Magick__PathSmoothQuadraticCurvetoRel,
  _swigc__p_Magick__Point,
  _swigc__p_Magick__ReadOptions,
  _swigc__p_Magick__ResourceLimits,
  _swigc__p_Magick__TypeMetric,
  _swigc__p_Magick__VPath,
  _swigc__p_Magick__VPathBase,
  _swigc__p_Magick__Warning,
  _swigc__p_Magick__WarningBlob,
  _swigc__p_Magick__WarningCache,
  _swigc__p_Magick__WarningCoder,
  _swigc__p_Magick__WarningConfigure,
  _swigc__p_Magick__WarningCorruptImage,
  _swigc__p_Magick__WarningDelegate,
  _swigc__p_Magick__WarningDraw,
  _swigc__p_Magick__WarningFileOpen,
  _swigc__p_Magick__WarningImage,
  _swigc__p_Magick__WarningMissingDelegate,
  _swigc__p_Magick__WarningModule,
  _swigc__p_Magick__WarningMonitor,
  _swigc__p_Magick__WarningOption,
  _swigc__p_Magick__WarningPolicy,
  _swigc__p_Magick__WarningRegistry,
  _swigc__p_Magick__WarningResourceLimit,
  _swigc__p_Magick__WarningStream,
  _swigc__p_Magick__WarningType,
  _swigc__p_Magick__WarningUndefined,
  _swigc__p_Magick__WarningXServer,
  _swigc__p_Magick__adaptiveBlurImage,
  _swigc__p_Magick__adaptiveThresholdImage,
  _swigc__p_Magick__addNoiseImage,
  _swigc__p_Magick__adjoinImage,
  _swigc__p_Magick__affineTransformImage,
  _swigc__p_Magick__alphaFlagImage,
  _swigc__p_Magick__alphaImage,
  _swigc__p_Magick__animationDelayImage,
  _swigc__p_Magick__animationIterationsImage,
  _swigc__p_Magick__annotateImage,
  _swigc__p_Magick__backgroundColorImage,
  _swigc__p_Magick__backgroundTextureImage,
  _swigc__p_Magick__blurImage,
  _swigc__p_Magick__borderColorImage,
  _swigc__p_Magick__borderImage,
  _swigc__p_Magick__boxColorImage,
  _swigc__p_Magick__cdlImage,
  _swigc__p_Magick__channelImage,
  _swigc__p_Magick__charcoalImage,
  _swigc__p_Magick__chopImage,
  _swigc__p_Magick__chromaBluePrimaryImage,
  _swigc__p_Magick__chromaGreenPrimaryImage,
  _swigc__p_Magick__chromaRedPrimaryImage,
  _swigc__p_Magick__chromaWhitePointImage,
  _swigc__p_Magick__colorFuzzImage,
  _swigc__p_Magick__colorMapImage,
  _swigc__p_Magick__colorMatrixImage,
  _swigc__p_Magick__colorSpaceImage,
  _swigc__p_Magick__colorizeImage,
  _swigc__p_Magick__commentImage,
  _swigc__p_Magick__composeImage,
  _swigc__p_Magick__compositeImage,
  _swigc__p_Magick__compressTypeImage,
  _swigc__p_Magick__contrastImage,
  _swigc__p_Magick__cropImage,
  _swigc__p_Magick__cycleColormapImage,
  _swigc__p_Magick__densityImage,
  _swigc__p_Magick__depthImage,
  _swigc__p_Magick__despeckleImage,
  _swigc__p_Magick__distortImage,
  _swigc__p_Magick__drawImage,
  _swigc__p_Magick__edgeImage,
  _swigc__p_Magick__embossImage,
  _swigc__p_Magick__endianImage,
  _swigc__p_Magick__enhanceImage,
  _swigc__p_Magick__equalizeImage,
  _swigc__p_Magick__fileNameImage,
  _swigc__p_Magick__fillColorImage,
  _swigc__p_Magick__filterTypeImage,
  _swigc__p_Magick__flipImage,
  _swigc__p_Magick__floodFillAlphaImage,
  _swigc__p_Magick__floodFillColorImage,
  _swigc__p_Magick__floodFillTextureImage,
  _swigc__p_Magick__flopImage,
  _swigc__p_Magick__fontImage,
  _swigc__p_Magick__fontPointsizeImage,
  _swigc__p_Magick__frameImage,
  _swigc__p_Magick__gammaImage,
  _swigc__p_Magick__gaussianBlurImage,
  _swigc__p_Magick__gifDisposeMethodImage,
  _swigc__p_Magick__haldClutImage,
  _swigc__p_Magick__implodeImage,
  _swigc__p_Magick__interlaceTypeImage,
  _swigc__p_Magick__inverseFourierTransformImage,
  _swigc__p_Magick__isValidImage,
  _swigc__p_Magick__labelImage,
  _swigc__p_Magick__levelImage,
  _swigc__p_Magick__magickImage,
  _swigc__p_Magick__magnifyImage,
  _swigc__p_Magick__mapImage,
  _swigc__p_Magick__matteColorImage,
  _swigc__p_Magick__medianConvolveImage,
  _swigc__p_Magick__minifyImage,
  _swigc__p_Magick__modulateImage,
  _swigc__p_Magick__monochromeImage,
  _swigc__p_Magick__negateImage,
  _swigc__p_Magick__normalizeImage,
  _swigc__p_Magick__oilPaintImage,
  _swigc__p_Magick__opaqueImage,
  _swigc__p_Magick__pageImage,
  _swigc__p_Magick__pixelColorImage,
  _swigc__p_Magick__qualityImage,
  _swigc__p_Magick__quantizeColorSpaceImage,
  _swigc__p_Magick__quantizeColorsImage,
  _swigc__p_Magick__quantizeDitherImage,
  _swigc__p_Magick__quantizeImage,
  _swigc__p_Magick__quantizeTreeDepthImage,
  _swigc__p_Magick__raiseImage,
  _swigc__p_Magick__reduceNoiseImage,
  _swigc__p_Magick__renderingIntentImage,
  _swigc__p_Magick__resizeImage,
  _swigc__p_Magick__resolutionUnitsImage,
  _swigc__p_Magick__rollImage,
  _swigc__p_Magick__rotateImage,
  _swigc__p_Magick__sampleImage,
  _swigc__p_Magick__scaleImage,
  _swigc__p_Magick__sceneImage,
  _swigc__p_Magick__segmentImage,
  _swigc__p_Magick__shadeImage,
  _swigc__p_Magick__shadowImage,
  _swigc__p_Magick__sharpenImage,
  _swigc__p_Magick__shaveImage,
  _swigc__p_Magick__shearImage,
  _swigc__p_Magick__sizeImage,
  _swigc__p_Magick__solarizeImage,
  _swigc__p_Magick__spliceImage,
  _swigc__p_Magick__spreadImage,
  _swigc__p_Magick__steganoImage,
  _swigc__p_Magick__stereoImage,
  _swigc__p_Magick__stripImage,
  _swigc__p_Magick__strokeColorImage,
  _swigc__p_Magick__subImageImage,
  _swigc__p_Magick__subRangeImage,
  _swigc__p_Magick__swirlImage,
  _swigc__p_Magick__textAntiAliasImage,
  _swigc__p_Magick__textureImage,
  _swigc__p_Magick__thresholdImage,
  _swigc__p_Magick__transparentImage,
  _swigc__p_Magick__trimImage,
  _swigc__p_Magick__typeImage,
  _swigc__p_Magick__verboseImage,
  _swigc__p_Magick__waveImage,
  _swigc__p_Magick__x11DisplayImage,
  _swigc__p_Magick__zoomImage,
  _swigc__p__DrawingWand,
  _swigc__p__PolicyInfo,
  _swigc__p_char,
  _swigc__p_difference_type,
  _swigc__p_double,
  _swigc__p_float,
  _swigc__p_long_long,
  _swigc__p_p_MagickCore___Image,
  _swigc__p_p_char,
  _swigc__p_p_void,
  _swigc__p_size_t,
  _swigc__p_size_type,
  _swigc__p_std__exception,
  _swigc__p_std__vectorT_Magick__CoderInfo_t,
  _swigc__p_std__vectorT_Magick__Coordinate_t,
  _swigc__p_std__vectorT_Magick__Drawable_t,
  _swigc__p_std__vectorT_Magick__PathArcArgs_t,
  _swigc__p_std__vectorT_Magick__PathCurvetoArgs_t,
  _swigc__p_std__vectorT_Magick__PathQuadraticCurvetoArgs_t,
  _swigc__p_std__vectorT_Magick__VPath_t,
  _swigc__p_uintptr_t,
  _swigc__p_unsigned_int,
  _swigc__p_unsigned_long_long,
  _swigc__p_value_type,
  _swigc__p_void,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

SWIGINTERN swig_type_info *swig_types[365];
SWIGINTERN swig_module_info swig_module = {swig_types, 364, 0, 0, 0, 0};

