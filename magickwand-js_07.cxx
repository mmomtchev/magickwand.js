/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.2.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

#include "swig/magickwand-js.h"

/* Class: ResourceLimits (_Magick_ResourceLimits) */
// jsnapi_getclass
Napi::Function _Magick_ResourceLimits_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_ResourceLimits_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_ResourceLimits_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_ResourceLimits_inst>::DefineClass(env, "ResourceLimits", symbolTable);
}

void _Magick_ResourceLimits_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_ResourceLimits_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_ResourceLimits_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  
  /* add static class functions and variables */
  // jsnapi_register_static_function
  staticMembers.erase("area");
  staticMembers.insert({
    "area",
      StaticMethod("area",
        &_Magick_ResourceLimits_templ::_wrap_ResourceLimits__wrap_Magick_ResourceLimits_area,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_static_function
  staticMembers.erase("disk");
  staticMembers.insert({
    "disk",
      StaticMethod("disk",
        &_Magick_ResourceLimits_templ::_wrap_ResourceLimits__wrap_Magick_ResourceLimits_disk,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_static_function
  staticMembers.erase("file");
  staticMembers.insert({
    "file",
      StaticMethod("file",
        &_Magick_ResourceLimits_templ::_wrap_ResourceLimits__wrap_Magick_ResourceLimits_file,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_static_function
  staticMembers.erase("height");
  staticMembers.insert({
    "height",
      StaticMethod("height",
        &_Magick_ResourceLimits_templ::_wrap_ResourceLimits__wrap_Magick_ResourceLimits_height,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_static_function
  staticMembers.erase("listLength");
  staticMembers.insert({
    "listLength",
      StaticMethod("listLength",
        &_Magick_ResourceLimits_templ::_wrap_ResourceLimits__wrap_Magick_ResourceLimits_listLength,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_static_function
  staticMembers.erase("map");
  staticMembers.insert({
    "map",
      StaticMethod("map",
        &_Magick_ResourceLimits_templ::_wrap_ResourceLimits__wrap_Magick_ResourceLimits_map,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_static_function
  staticMembers.erase("memory");
  staticMembers.insert({
    "memory",
      StaticMethod("memory",
        &_Magick_ResourceLimits_templ::_wrap_ResourceLimits__wrap_Magick_ResourceLimits_memory,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_static_function
  staticMembers.erase("thread");
  staticMembers.insert({
    "thread",
      StaticMethod("thread",
        &_Magick_ResourceLimits_templ::_wrap_ResourceLimits__wrap_Magick_ResourceLimits_thread,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_static_function
  staticMembers.erase("throttle");
  staticMembers.insert({
    "throttle",
      StaticMethod("throttle",
        &_Magick_ResourceLimits_templ::_wrap_ResourceLimits__wrap_Magick_ResourceLimits_throttle,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_static_function
  staticMembers.erase("width");
  staticMembers.insert({
    "width",
      StaticMethod("width",
        &_Magick_ResourceLimits_templ::_wrap_ResourceLimits__wrap_Magick_ResourceLimits_width,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
}

/* Class: CoderInfo (_Magick_CoderInfo) */
// jsnapi_getclass
Napi::Function _Magick_CoderInfo_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_CoderInfo_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_CoderInfo_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_CoderInfo_inst>::DefineClass(env, "CoderInfo", symbolTable);
}

void _Magick_CoderInfo_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_CoderInfo_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_CoderInfo_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("clone");
  members.insert({
    "clone",
      _Magick_CoderInfo_templ::InstanceMethod("clone",
        &_Magick_CoderInfo_templ::_wrap_Magick_CoderInfo_clone,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("canReadMultithreaded");
  members.insert({
    "canReadMultithreaded",
      _Magick_CoderInfo_templ::InstanceMethod("canReadMultithreaded",
        &_Magick_CoderInfo_templ::_wrap_Magick_CoderInfo_canReadMultithreaded,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("canWriteMultithreaded");
  members.insert({
    "canWriteMultithreaded",
      _Magick_CoderInfo_templ::InstanceMethod("canWriteMultithreaded",
        &_Magick_CoderInfo_templ::_wrap_Magick_CoderInfo_canWriteMultithreaded,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("description");
  members.insert({
    "description",
      _Magick_CoderInfo_templ::InstanceMethod("description",
        &_Magick_CoderInfo_templ::_wrap_Magick_CoderInfo_description,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("isMultiFrame");
  members.insert({
    "isMultiFrame",
      _Magick_CoderInfo_templ::InstanceMethod("isMultiFrame",
        &_Magick_CoderInfo_templ::_wrap_Magick_CoderInfo_isMultiFrame,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("isReadable");
  members.insert({
    "isReadable",
      _Magick_CoderInfo_templ::InstanceMethod("isReadable",
        &_Magick_CoderInfo_templ::_wrap_Magick_CoderInfo_isReadable,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("isWritable");
  members.insert({
    "isWritable",
      _Magick_CoderInfo_templ::InstanceMethod("isWritable",
        &_Magick_CoderInfo_templ::_wrap_Magick_CoderInfo_isWritable,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("mimeType");
  members.insert({
    "mimeType",
      _Magick_CoderInfo_templ::InstanceMethod("mimeType",
        &_Magick_CoderInfo_templ::_wrap_Magick_CoderInfo_mimeType,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("module");
  members.insert({
    "module",
      _Magick_CoderInfo_templ::InstanceMethod("module",
        &_Magick_CoderInfo_templ::_wrap_Magick_CoderInfo_module,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("name");
  members.insert({
    "name",
      _Magick_CoderInfo_templ::InstanceMethod("name",
        &_Magick_CoderInfo_templ::_wrap_Magick_CoderInfo_name,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("unregister");
  members.insert({
    "unregister",
      _Magick_CoderInfo_templ::InstanceMethod("unregister",
        &_Magick_CoderInfo_templ::_wrap_Magick_CoderInfo_unregister,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_CoderInfo_AnyMatch_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("AnyMatch");
    staticMembers.insert({
      "AnyMatch", StaticValue("AnyMatch", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_CoderInfo_TrueMatch_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("TrueMatch");
    staticMembers.insert({
      "TrueMatch", StaticValue("TrueMatch", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_CoderInfo_FalseMatch_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("FalseMatch");
    staticMembers.insert({
      "FalseMatch", StaticValue("FalseMatch", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  
}

/* Class: Montage (_Magick_Montage) */
// jsnapi_getclass
Napi::Function _Magick_Montage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_Montage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_Montage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_Montage_inst>::DefineClass(env, "Montage", symbolTable);
}

void _Magick_Montage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_Montage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_Montage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("backgroundColorAsync");
  members.insert({
    "backgroundColorAsync",
      _Magick_Montage_templ::InstanceMethod("backgroundColorAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_backgroundColorAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("backgroundColor");
  members.insert({
    "backgroundColor",
      _Magick_Montage_templ::InstanceMethod("backgroundColor",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_backgroundColor,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("fileNameAsync");
  members.insert({
    "fileNameAsync",
      _Magick_Montage_templ::InstanceMethod("fileNameAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_fileNameAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("fileName");
  members.insert({
    "fileName",
      _Magick_Montage_templ::InstanceMethod("fileName",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_fileName,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("fillColorAsync");
  members.insert({
    "fillColorAsync",
      _Magick_Montage_templ::InstanceMethod("fillColorAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_fillColorAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("fillColor");
  members.insert({
    "fillColor",
      _Magick_Montage_templ::InstanceMethod("fillColor",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_fillColor,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("fontAsync");
  members.insert({
    "fontAsync",
      _Magick_Montage_templ::InstanceMethod("fontAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_fontAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("font");
  members.insert({
    "font",
      _Magick_Montage_templ::InstanceMethod("font",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_font,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("geometryAsync");
  members.insert({
    "geometryAsync",
      _Magick_Montage_templ::InstanceMethod("geometryAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_geometryAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("geometry");
  members.insert({
    "geometry",
      _Magick_Montage_templ::InstanceMethod("geometry",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_geometry,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("gravityAsync");
  members.insert({
    "gravityAsync",
      _Magick_Montage_templ::InstanceMethod("gravityAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_gravityAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("gravity");
  members.insert({
    "gravity",
      _Magick_Montage_templ::InstanceMethod("gravity",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_gravity,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("labelAsync");
  members.insert({
    "labelAsync",
      _Magick_Montage_templ::InstanceMethod("labelAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_labelAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("label");
  members.insert({
    "label",
      _Magick_Montage_templ::InstanceMethod("label",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_label,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("pointSizeAsync");
  members.insert({
    "pointSizeAsync",
      _Magick_Montage_templ::InstanceMethod("pointSizeAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_pointSizeAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("pointSize");
  members.insert({
    "pointSize",
      _Magick_Montage_templ::InstanceMethod("pointSize",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_pointSize,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("shadowAsync");
  members.insert({
    "shadowAsync",
      _Magick_Montage_templ::InstanceMethod("shadowAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_shadowAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("shadow");
  members.insert({
    "shadow",
      _Magick_Montage_templ::InstanceMethod("shadow",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_shadow,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("strokeColorAsync");
  members.insert({
    "strokeColorAsync",
      _Magick_Montage_templ::InstanceMethod("strokeColorAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_strokeColorAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("strokeColor");
  members.insert({
    "strokeColor",
      _Magick_Montage_templ::InstanceMethod("strokeColor",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_strokeColor,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("textureAsync");
  members.insert({
    "textureAsync",
      _Magick_Montage_templ::InstanceMethod("textureAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_textureAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("texture");
  members.insert({
    "texture",
      _Magick_Montage_templ::InstanceMethod("texture",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_texture,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("tileAsync");
  members.insert({
    "tileAsync",
      _Magick_Montage_templ::InstanceMethod("tileAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_tileAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("tile");
  members.insert({
    "tile",
      _Magick_Montage_templ::InstanceMethod("tile",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_tile,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("titleAsync");
  members.insert({
    "titleAsync",
      _Magick_Montage_templ::InstanceMethod("titleAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_titleAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("title");
  members.insert({
    "title",
      _Magick_Montage_templ::InstanceMethod("title",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_title,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("transparentColorAsync");
  members.insert({
    "transparentColorAsync",
      _Magick_Montage_templ::InstanceMethod("transparentColorAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_transparentColorAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("transparentColor");
  members.insert({
    "transparentColor",
      _Magick_Montage_templ::InstanceMethod("transparentColor",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_transparentColor,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("updateMontageInfoAsync");
  members.insert({
    "updateMontageInfoAsync",
      _Magick_Montage_templ::InstanceMethod("updateMontageInfoAsync",
        &_Magick_Montage_templ::_wrap_Magick_Montage_updateMontageInfoAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("updateMontageInfo");
  members.insert({
    "updateMontageInfo",
      _Magick_Montage_templ::InstanceMethod("updateMontageInfo",
        &_Magick_Montage_templ::_wrap_Magick_Montage_updateMontageInfo,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: MontageFramed (_Magick_MontageFramed) */
// jsnapi_getclass
Napi::Function _Magick_MontageFramed_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_MontageFramed_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_MontageFramed_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_MontageFramed_inst>::DefineClass(env, "MontageFramed", symbolTable);
}

void _Magick_MontageFramed_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_MontageFramed_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_MontageFramed_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_Montage_templ<_Magick_Montage_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_Montage_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("backgroundColorAsync");
  members.insert({
    "backgroundColorAsync",
      _Magick_Montage_templ::InstanceMethod("backgroundColorAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_backgroundColorAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("backgroundColor");
  members.insert({
    "backgroundColor",
      _Magick_Montage_templ::InstanceMethod("backgroundColor",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_backgroundColor,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("fileNameAsync");
  members.insert({
    "fileNameAsync",
      _Magick_Montage_templ::InstanceMethod("fileNameAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_fileNameAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("fileName");
  members.insert({
    "fileName",
      _Magick_Montage_templ::InstanceMethod("fileName",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_fileName,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("fillColorAsync");
  members.insert({
    "fillColorAsync",
      _Magick_Montage_templ::InstanceMethod("fillColorAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_fillColorAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("fillColor");
  members.insert({
    "fillColor",
      _Magick_Montage_templ::InstanceMethod("fillColor",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_fillColor,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("fontAsync");
  members.insert({
    "fontAsync",
      _Magick_Montage_templ::InstanceMethod("fontAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_fontAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("font");
  members.insert({
    "font",
      _Magick_Montage_templ::InstanceMethod("font",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_font,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("geometryAsync");
  members.insert({
    "geometryAsync",
      _Magick_Montage_templ::InstanceMethod("geometryAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_geometryAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("geometry");
  members.insert({
    "geometry",
      _Magick_Montage_templ::InstanceMethod("geometry",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_geometry,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("gravityAsync");
  members.insert({
    "gravityAsync",
      _Magick_Montage_templ::InstanceMethod("gravityAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_gravityAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("gravity");
  members.insert({
    "gravity",
      _Magick_Montage_templ::InstanceMethod("gravity",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_gravity,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("labelAsync");
  members.insert({
    "labelAsync",
      _Magick_Montage_templ::InstanceMethod("labelAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_labelAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("label");
  members.insert({
    "label",
      _Magick_Montage_templ::InstanceMethod("label",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_label,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("pointSizeAsync");
  members.insert({
    "pointSizeAsync",
      _Magick_Montage_templ::InstanceMethod("pointSizeAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_pointSizeAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("pointSize");
  members.insert({
    "pointSize",
      _Magick_Montage_templ::InstanceMethod("pointSize",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_pointSize,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("shadowAsync");
  members.insert({
    "shadowAsync",
      _Magick_Montage_templ::InstanceMethod("shadowAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_shadowAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("shadow");
  members.insert({
    "shadow",
      _Magick_Montage_templ::InstanceMethod("shadow",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_shadow,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("strokeColorAsync");
  members.insert({
    "strokeColorAsync",
      _Magick_Montage_templ::InstanceMethod("strokeColorAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_strokeColorAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("strokeColor");
  members.insert({
    "strokeColor",
      _Magick_Montage_templ::InstanceMethod("strokeColor",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_strokeColor,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("textureAsync");
  members.insert({
    "textureAsync",
      _Magick_Montage_templ::InstanceMethod("textureAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_textureAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("texture");
  members.insert({
    "texture",
      _Magick_Montage_templ::InstanceMethod("texture",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_texture,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("tileAsync");
  members.insert({
    "tileAsync",
      _Magick_Montage_templ::InstanceMethod("tileAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_tileAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("tile");
  members.insert({
    "tile",
      _Magick_Montage_templ::InstanceMethod("tile",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_tile,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("titleAsync");
  members.insert({
    "titleAsync",
      _Magick_Montage_templ::InstanceMethod("titleAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_titleAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("title");
  members.insert({
    "title",
      _Magick_Montage_templ::InstanceMethod("title",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_title,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("transparentColorAsync");
  members.insert({
    "transparentColorAsync",
      _Magick_Montage_templ::InstanceMethod("transparentColorAsync",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_transparentColorAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("transparentColor");
  members.insert({
    "transparentColor",
      _Magick_Montage_templ::InstanceMethod("transparentColor",
        &_Magick_Montage_templ::_wrap_Montage__wrap_Magick_Montage_transparentColor,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("updateMontageInfoAsync");
  members.insert({
    "updateMontageInfoAsync",
      _Magick_Montage_templ::InstanceMethod("updateMontageInfoAsync",
        &_Magick_Montage_templ::_wrap_Magick_Montage_updateMontageInfoAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("updateMontageInfo");
  members.insert({
    "updateMontageInfo",
      _Magick_Montage_templ::InstanceMethod("updateMontageInfo",
        &_Magick_Montage_templ::_wrap_Magick_Montage_updateMontageInfo,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("matteColorAsync");
  members.insert({
    "matteColorAsync",
      _Magick_MontageFramed_templ::InstanceMethod("matteColorAsync",
        &_Magick_MontageFramed_templ::_wrap_MontageFramed__wrap_Magick_MontageFramed_matteColorAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("matteColor");
  members.insert({
    "matteColor",
      _Magick_MontageFramed_templ::InstanceMethod("matteColor",
        &_Magick_MontageFramed_templ::_wrap_MontageFramed__wrap_Magick_MontageFramed_matteColor,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("borderColorAsync");
  members.insert({
    "borderColorAsync",
      _Magick_MontageFramed_templ::InstanceMethod("borderColorAsync",
        &_Magick_MontageFramed_templ::_wrap_MontageFramed__wrap_Magick_MontageFramed_borderColorAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("borderColor");
  members.insert({
    "borderColor",
      _Magick_MontageFramed_templ::InstanceMethod("borderColor",
        &_Magick_MontageFramed_templ::_wrap_MontageFramed__wrap_Magick_MontageFramed_borderColor,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("borderWidthAsync");
  members.insert({
    "borderWidthAsync",
      _Magick_MontageFramed_templ::InstanceMethod("borderWidthAsync",
        &_Magick_MontageFramed_templ::_wrap_MontageFramed__wrap_Magick_MontageFramed_borderWidthAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("borderWidth");
  members.insert({
    "borderWidth",
      _Magick_MontageFramed_templ::InstanceMethod("borderWidth",
        &_Magick_MontageFramed_templ::_wrap_MontageFramed__wrap_Magick_MontageFramed_borderWidth,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("frameGeometryAsync");
  members.insert({
    "frameGeometryAsync",
      _Magick_MontageFramed_templ::InstanceMethod("frameGeometryAsync",
        &_Magick_MontageFramed_templ::_wrap_MontageFramed__wrap_Magick_MontageFramed_frameGeometryAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("frameGeometry");
  members.insert({
    "frameGeometry",
      _Magick_MontageFramed_templ::InstanceMethod("frameGeometry",
        &_Magick_MontageFramed_templ::_wrap_MontageFramed__wrap_Magick_MontageFramed_frameGeometry,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("updateMontageInfoAsync");
  members.insert({
    "updateMontageInfoAsync",
      _Magick_MontageFramed_templ::InstanceMethod("updateMontageInfoAsync",
        &_Magick_MontageFramed_templ::_wrap_Magick_MontageFramed_updateMontageInfoAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("updateMontageInfo");
  members.insert({
    "updateMontageInfo",
      _Magick_MontageFramed_templ::InstanceMethod("updateMontageInfo",
        &_Magick_MontageFramed_templ::_wrap_Magick_MontageFramed_updateMontageInfo,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: adaptiveBlurImage (_Magick_adaptiveBlurImage) */
// jsnapi_getclass
Napi::Function _Magick_adaptiveBlurImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_adaptiveBlurImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_adaptiveBlurImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_adaptiveBlurImage_inst>::DefineClass(env, "adaptiveBlurImage", symbolTable);
}

void _Magick_adaptiveBlurImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_adaptiveBlurImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_adaptiveBlurImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_adaptiveBlurImage_templ::InstanceMethod("callAsync",
        &_Magick_adaptiveBlurImage_templ::_wrap_Magick_adaptiveBlurImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_adaptiveBlurImage_templ::InstanceMethod("call",
        &_Magick_adaptiveBlurImage_templ::_wrap_Magick_adaptiveBlurImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: adaptiveThresholdImage (_Magick_adaptiveThresholdImage) */
// jsnapi_getclass
Napi::Function _Magick_adaptiveThresholdImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_adaptiveThresholdImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_adaptiveThresholdImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_adaptiveThresholdImage_inst>::DefineClass(env, "adaptiveThresholdImage", symbolTable);
}

void _Magick_adaptiveThresholdImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_adaptiveThresholdImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_adaptiveThresholdImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_adaptiveThresholdImage_templ::InstanceMethod("callAsync",
        &_Magick_adaptiveThresholdImage_templ::_wrap_Magick_adaptiveThresholdImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_adaptiveThresholdImage_templ::InstanceMethod("call",
        &_Magick_adaptiveThresholdImage_templ::_wrap_Magick_adaptiveThresholdImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: addNoiseImage (_Magick_addNoiseImage) */
// jsnapi_getclass
Napi::Function _Magick_addNoiseImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_addNoiseImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_addNoiseImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_addNoiseImage_inst>::DefineClass(env, "addNoiseImage", symbolTable);
}

void _Magick_addNoiseImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_addNoiseImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_addNoiseImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_addNoiseImage_templ::InstanceMethod("callAsync",
        &_Magick_addNoiseImage_templ::_wrap_Magick_addNoiseImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_addNoiseImage_templ::InstanceMethod("call",
        &_Magick_addNoiseImage_templ::_wrap_Magick_addNoiseImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: affineTransformImage (_Magick_affineTransformImage) */
// jsnapi_getclass
Napi::Function _Magick_affineTransformImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_affineTransformImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_affineTransformImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_affineTransformImage_inst>::DefineClass(env, "affineTransformImage", symbolTable);
}

void _Magick_affineTransformImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_affineTransformImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_affineTransformImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_affineTransformImage_templ::InstanceMethod("callAsync",
        &_Magick_affineTransformImage_templ::_wrap_Magick_affineTransformImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_affineTransformImage_templ::InstanceMethod("call",
        &_Magick_affineTransformImage_templ::_wrap_Magick_affineTransformImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: annotateImage (_Magick_annotateImage) */
// jsnapi_getclass
Napi::Function _Magick_annotateImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_annotateImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_annotateImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_annotateImage_inst>::DefineClass(env, "annotateImage", symbolTable);
}

void _Magick_annotateImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_annotateImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_annotateImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_annotateImage_templ::InstanceMethod("callAsync",
        &_Magick_annotateImage_templ::_wrap_Magick_annotateImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_annotateImage_templ::InstanceMethod("call",
        &_Magick_annotateImage_templ::_wrap_Magick_annotateImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: blurImage (_Magick_blurImage) */
// jsnapi_getclass
Napi::Function _Magick_blurImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_blurImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_blurImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_blurImage_inst>::DefineClass(env, "blurImage", symbolTable);
}

void _Magick_blurImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_blurImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_blurImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_blurImage_templ::InstanceMethod("callAsync",
        &_Magick_blurImage_templ::_wrap_Magick_blurImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_blurImage_templ::InstanceMethod("call",
        &_Magick_blurImage_templ::_wrap_Magick_blurImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: borderImage (_Magick_borderImage) */
// jsnapi_getclass
Napi::Function _Magick_borderImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_borderImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_borderImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_borderImage_inst>::DefineClass(env, "borderImage", symbolTable);
}

void _Magick_borderImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_borderImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_borderImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_borderImage_templ::InstanceMethod("callAsync",
        &_Magick_borderImage_templ::_wrap_Magick_borderImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_borderImage_templ::InstanceMethod("call",
        &_Magick_borderImage_templ::_wrap_Magick_borderImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: channelImage (_Magick_channelImage) */
// jsnapi_getclass
Napi::Function _Magick_channelImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_channelImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_channelImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_channelImage_inst>::DefineClass(env, "channelImage", symbolTable);
}

void _Magick_channelImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_channelImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_channelImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_channelImage_templ::InstanceMethod("callAsync",
        &_Magick_channelImage_templ::_wrap_Magick_channelImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_channelImage_templ::InstanceMethod("call",
        &_Magick_channelImage_templ::_wrap_Magick_channelImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: charcoalImage (_Magick_charcoalImage) */
// jsnapi_getclass
Napi::Function _Magick_charcoalImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_charcoalImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_charcoalImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_charcoalImage_inst>::DefineClass(env, "charcoalImage", symbolTable);
}

void _Magick_charcoalImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_charcoalImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_charcoalImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_charcoalImage_templ::InstanceMethod("callAsync",
        &_Magick_charcoalImage_templ::_wrap_Magick_charcoalImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_charcoalImage_templ::InstanceMethod("call",
        &_Magick_charcoalImage_templ::_wrap_Magick_charcoalImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: chopImage (_Magick_chopImage) */
// jsnapi_getclass
Napi::Function _Magick_chopImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_chopImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_chopImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_chopImage_inst>::DefineClass(env, "chopImage", symbolTable);
}

void _Magick_chopImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_chopImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_chopImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_chopImage_templ::InstanceMethod("callAsync",
        &_Magick_chopImage_templ::_wrap_Magick_chopImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_chopImage_templ::InstanceMethod("call",
        &_Magick_chopImage_templ::_wrap_Magick_chopImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: cdlImage (_Magick_cdlImage) */
// jsnapi_getclass
Napi::Function _Magick_cdlImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_cdlImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_cdlImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_cdlImage_inst>::DefineClass(env, "cdlImage", symbolTable);
}

void _Magick_cdlImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_cdlImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_cdlImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_cdlImage_templ::InstanceMethod("callAsync",
        &_Magick_cdlImage_templ::_wrap_Magick_cdlImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_cdlImage_templ::InstanceMethod("call",
        &_Magick_cdlImage_templ::_wrap_Magick_cdlImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: colorizeImage (_Magick_colorizeImage) */
// jsnapi_getclass
Napi::Function _Magick_colorizeImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_colorizeImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_colorizeImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_colorizeImage_inst>::DefineClass(env, "colorizeImage", symbolTable);
}

void _Magick_colorizeImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_colorizeImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_colorizeImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_colorizeImage_templ::InstanceMethod("callAsync",
        &_Magick_colorizeImage_templ::_wrap_Magick_colorizeImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_colorizeImage_templ::InstanceMethod("call",
        &_Magick_colorizeImage_templ::_wrap_Magick_colorizeImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: colorMatrixImage (_Magick_colorMatrixImage) */
// jsnapi_getclass
Napi::Function _Magick_colorMatrixImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_colorMatrixImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_colorMatrixImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_colorMatrixImage_inst>::DefineClass(env, "colorMatrixImage", symbolTable);
}

void _Magick_colorMatrixImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_colorMatrixImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_colorMatrixImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_colorMatrixImage_templ::InstanceMethod("callAsync",
        &_Magick_colorMatrixImage_templ::_wrap_Magick_colorMatrixImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_colorMatrixImage_templ::InstanceMethod("call",
        &_Magick_colorMatrixImage_templ::_wrap_Magick_colorMatrixImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: colorSpaceImage (_Magick_colorSpaceImage) */
// jsnapi_getclass
Napi::Function _Magick_colorSpaceImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_colorSpaceImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_colorSpaceImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_colorSpaceImage_inst>::DefineClass(env, "colorSpaceImage", symbolTable);
}

void _Magick_colorSpaceImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_colorSpaceImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_colorSpaceImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_colorSpaceImage_templ::InstanceMethod("callAsync",
        &_Magick_colorSpaceImage_templ::_wrap_Magick_colorSpaceImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_colorSpaceImage_templ::InstanceMethod("call",
        &_Magick_colorSpaceImage_templ::_wrap_Magick_colorSpaceImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: commentImage (_Magick_commentImage) */
// jsnapi_getclass
Napi::Function _Magick_commentImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_commentImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_commentImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_commentImage_inst>::DefineClass(env, "commentImage", symbolTable);
}

void _Magick_commentImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_commentImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_commentImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_commentImage_templ::InstanceMethod("callAsync",
        &_Magick_commentImage_templ::_wrap_Magick_commentImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_commentImage_templ::InstanceMethod("call",
        &_Magick_commentImage_templ::_wrap_Magick_commentImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: compositeImage (_Magick_compositeImage) */
// jsnapi_getclass
Napi::Function _Magick_compositeImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_compositeImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_compositeImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_compositeImage_inst>::DefineClass(env, "compositeImage", symbolTable);
}

void _Magick_compositeImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_compositeImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_compositeImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_compositeImage_templ::InstanceMethod("callAsync",
        &_Magick_compositeImage_templ::_wrap_Magick_compositeImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_compositeImage_templ::InstanceMethod("call",
        &_Magick_compositeImage_templ::_wrap_Magick_compositeImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: contrastImage (_Magick_contrastImage) */
// jsnapi_getclass
Napi::Function _Magick_contrastImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_contrastImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_contrastImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_contrastImage_inst>::DefineClass(env, "contrastImage", symbolTable);
}

void _Magick_contrastImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_contrastImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_contrastImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_contrastImage_templ::InstanceMethod("callAsync",
        &_Magick_contrastImage_templ::_wrap_Magick_contrastImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_contrastImage_templ::InstanceMethod("call",
        &_Magick_contrastImage_templ::_wrap_Magick_contrastImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: cropImage (_Magick_cropImage) */
// jsnapi_getclass
Napi::Function _Magick_cropImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_cropImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_cropImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_cropImage_inst>::DefineClass(env, "cropImage", symbolTable);
}

void _Magick_cropImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_cropImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_cropImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_cropImage_templ::InstanceMethod("callAsync",
        &_Magick_cropImage_templ::_wrap_Magick_cropImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_cropImage_templ::InstanceMethod("call",
        &_Magick_cropImage_templ::_wrap_Magick_cropImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: cycleColormapImage (_Magick_cycleColormapImage) */
// jsnapi_getclass
Napi::Function _Magick_cycleColormapImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_cycleColormapImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_cycleColormapImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_cycleColormapImage_inst>::DefineClass(env, "cycleColormapImage", symbolTable);
}

void _Magick_cycleColormapImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_cycleColormapImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_cycleColormapImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_cycleColormapImage_templ::InstanceMethod("call",
        &_Magick_cycleColormapImage_templ::_wrap_Magick_cycleColormapImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: despeckleImage (_Magick_despeckleImage) */
// jsnapi_getclass
Napi::Function _Magick_despeckleImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_despeckleImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_despeckleImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_despeckleImage_inst>::DefineClass(env, "despeckleImage", symbolTable);
}

void _Magick_despeckleImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_despeckleImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_despeckleImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_despeckleImage_templ::InstanceMethod("callAsync",
        &_Magick_despeckleImage_templ::_wrap_Magick_despeckleImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_despeckleImage_templ::InstanceMethod("call",
        &_Magick_despeckleImage_templ::_wrap_Magick_despeckleImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: distortImage (_Magick_distortImage) */
// jsnapi_getclass
Napi::Function _Magick_distortImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_distortImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_distortImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_distortImage_inst>::DefineClass(env, "distortImage", symbolTable);
}

void _Magick_distortImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_distortImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_distortImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_distortImage_templ::InstanceMethod("callAsync",
        &_Magick_distortImage_templ::_wrap_Magick_distortImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_distortImage_templ::InstanceMethod("call",
        &_Magick_distortImage_templ::_wrap_Magick_distortImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: drawImage (_Magick_drawImage) */
// jsnapi_getclass
Napi::Function _Magick_drawImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_drawImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_drawImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_drawImage_inst>::DefineClass(env, "drawImage", symbolTable);
}

void _Magick_drawImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_drawImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_drawImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_drawImage_templ::InstanceMethod("callAsync",
        &_Magick_drawImage_templ::_wrap_Magick_drawImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_drawImage_templ::InstanceMethod("call",
        &_Magick_drawImage_templ::_wrap_Magick_drawImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: edgeImage (_Magick_edgeImage) */
// jsnapi_getclass
Napi::Function _Magick_edgeImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_edgeImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_edgeImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_edgeImage_inst>::DefineClass(env, "edgeImage", symbolTable);
}

void _Magick_edgeImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_edgeImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_edgeImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_edgeImage_templ::InstanceMethod("callAsync",
        &_Magick_edgeImage_templ::_wrap_Magick_edgeImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_edgeImage_templ::InstanceMethod("call",
        &_Magick_edgeImage_templ::_wrap_Magick_edgeImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: embossImage (_Magick_embossImage) */
// jsnapi_getclass
Napi::Function _Magick_embossImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_embossImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_embossImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_embossImage_inst>::DefineClass(env, "embossImage", symbolTable);
}

void _Magick_embossImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_embossImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_embossImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_embossImage_templ::InstanceMethod("callAsync",
        &_Magick_embossImage_templ::_wrap_Magick_embossImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_embossImage_templ::InstanceMethod("call",
        &_Magick_embossImage_templ::_wrap_Magick_embossImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: enhanceImage (_Magick_enhanceImage) */
// jsnapi_getclass
Napi::Function _Magick_enhanceImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_enhanceImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_enhanceImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_enhanceImage_inst>::DefineClass(env, "enhanceImage", symbolTable);
}

void _Magick_enhanceImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_enhanceImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_enhanceImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_enhanceImage_templ::InstanceMethod("callAsync",
        &_Magick_enhanceImage_templ::_wrap_Magick_enhanceImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_enhanceImage_templ::InstanceMethod("call",
        &_Magick_enhanceImage_templ::_wrap_Magick_enhanceImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: equalizeImage (_Magick_equalizeImage) */
// jsnapi_getclass
Napi::Function _Magick_equalizeImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_equalizeImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_equalizeImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_equalizeImage_inst>::DefineClass(env, "equalizeImage", symbolTable);
}

void _Magick_equalizeImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_equalizeImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_equalizeImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_equalizeImage_templ::InstanceMethod("callAsync",
        &_Magick_equalizeImage_templ::_wrap_Magick_equalizeImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_equalizeImage_templ::InstanceMethod("call",
        &_Magick_equalizeImage_templ::_wrap_Magick_equalizeImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: fillColorImage (_Magick_fillColorImage) */
// jsnapi_getclass
Napi::Function _Magick_fillColorImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_fillColorImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_fillColorImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_fillColorImage_inst>::DefineClass(env, "fillColorImage", symbolTable);
}

void _Magick_fillColorImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_fillColorImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_fillColorImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_fillColorImage_templ::InstanceMethod("call",
        &_Magick_fillColorImage_templ::_wrap_Magick_fillColorImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: flipImage (_Magick_flipImage) */
// jsnapi_getclass
Napi::Function _Magick_flipImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_flipImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_flipImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_flipImage_inst>::DefineClass(env, "flipImage", symbolTable);
}

void _Magick_flipImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_flipImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_flipImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_flipImage_templ::InstanceMethod("callAsync",
        &_Magick_flipImage_templ::_wrap_Magick_flipImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_flipImage_templ::InstanceMethod("call",
        &_Magick_flipImage_templ::_wrap_Magick_flipImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: floodFillAlphaImage (_Magick_floodFillAlphaImage) */
// jsnapi_getclass
Napi::Function _Magick_floodFillAlphaImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_floodFillAlphaImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_floodFillAlphaImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_floodFillAlphaImage_inst>::DefineClass(env, "floodFillAlphaImage", symbolTable);
}

void _Magick_floodFillAlphaImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_floodFillAlphaImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_floodFillAlphaImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_floodFillAlphaImage_templ::InstanceMethod("callAsync",
        &_Magick_floodFillAlphaImage_templ::_wrap_Magick_floodFillAlphaImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_floodFillAlphaImage_templ::InstanceMethod("call",
        &_Magick_floodFillAlphaImage_templ::_wrap_Magick_floodFillAlphaImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: floodFillColorImage (_Magick_floodFillColorImage) */
// jsnapi_getclass
Napi::Function _Magick_floodFillColorImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_floodFillColorImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_floodFillColorImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_floodFillColorImage_inst>::DefineClass(env, "floodFillColorImage", symbolTable);
}

void _Magick_floodFillColorImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_floodFillColorImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_floodFillColorImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_floodFillColorImage_templ::InstanceMethod("call",
        &_Magick_floodFillColorImage_templ::_wrap_Magick_floodFillColorImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: floodFillTextureImage (_Magick_floodFillTextureImage) */
// jsnapi_getclass
Napi::Function _Magick_floodFillTextureImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_floodFillTextureImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_floodFillTextureImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_floodFillTextureImage_inst>::DefineClass(env, "floodFillTextureImage", symbolTable);
}

void _Magick_floodFillTextureImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_floodFillTextureImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_floodFillTextureImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_floodFillTextureImage_templ::InstanceMethod("callAsync",
        &_Magick_floodFillTextureImage_templ::_wrap_Magick_floodFillTextureImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_floodFillTextureImage_templ::InstanceMethod("call",
        &_Magick_floodFillTextureImage_templ::_wrap_Magick_floodFillTextureImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: flopImage (_Magick_flopImage) */
// jsnapi_getclass
Napi::Function _Magick_flopImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_flopImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_flopImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_flopImage_inst>::DefineClass(env, "flopImage", symbolTable);
}

void _Magick_flopImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_flopImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_flopImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_flopImage_templ::InstanceMethod("callAsync",
        &_Magick_flopImage_templ::_wrap_Magick_flopImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_flopImage_templ::InstanceMethod("call",
        &_Magick_flopImage_templ::_wrap_Magick_flopImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: frameImage (_Magick_frameImage) */
// jsnapi_getclass
Napi::Function _Magick_frameImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_frameImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_frameImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_frameImage_inst>::DefineClass(env, "frameImage", symbolTable);
}

void _Magick_frameImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_frameImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_frameImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_frameImage_templ::InstanceMethod("callAsync",
        &_Magick_frameImage_templ::_wrap_Magick_frameImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_frameImage_templ::InstanceMethod("call",
        &_Magick_frameImage_templ::_wrap_Magick_frameImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: gammaImage (_Magick_gammaImage) */
// jsnapi_getclass
Napi::Function _Magick_gammaImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_gammaImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_gammaImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_gammaImage_inst>::DefineClass(env, "gammaImage", symbolTable);
}

void _Magick_gammaImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_gammaImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_gammaImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_gammaImage_templ::InstanceMethod("callAsync",
        &_Magick_gammaImage_templ::_wrap_Magick_gammaImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_gammaImage_templ::InstanceMethod("call",
        &_Magick_gammaImage_templ::_wrap_Magick_gammaImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: gaussianBlurImage (_Magick_gaussianBlurImage) */
// jsnapi_getclass
Napi::Function _Magick_gaussianBlurImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_gaussianBlurImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_gaussianBlurImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_gaussianBlurImage_inst>::DefineClass(env, "gaussianBlurImage", symbolTable);
}

void _Magick_gaussianBlurImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_gaussianBlurImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_gaussianBlurImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_gaussianBlurImage_templ::InstanceMethod("callAsync",
        &_Magick_gaussianBlurImage_templ::_wrap_Magick_gaussianBlurImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_gaussianBlurImage_templ::InstanceMethod("call",
        &_Magick_gaussianBlurImage_templ::_wrap_Magick_gaussianBlurImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: haldClutImage (_Magick_haldClutImage) */
// jsnapi_getclass
Napi::Function _Magick_haldClutImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_haldClutImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_haldClutImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_haldClutImage_inst>::DefineClass(env, "haldClutImage", symbolTable);
}

void _Magick_haldClutImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_haldClutImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_haldClutImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_haldClutImage_templ::InstanceMethod("callAsync",
        &_Magick_haldClutImage_templ::_wrap_Magick_haldClutImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_haldClutImage_templ::InstanceMethod("call",
        &_Magick_haldClutImage_templ::_wrap_Magick_haldClutImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: implodeImage (_Magick_implodeImage) */
// jsnapi_getclass
Napi::Function _Magick_implodeImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_implodeImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_implodeImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_implodeImage_inst>::DefineClass(env, "implodeImage", symbolTable);
}

void _Magick_implodeImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_implodeImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_implodeImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_implodeImage_templ::InstanceMethod("callAsync",
        &_Magick_implodeImage_templ::_wrap_Magick_implodeImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_implodeImage_templ::InstanceMethod("call",
        &_Magick_implodeImage_templ::_wrap_Magick_implodeImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: inverseFourierTransformImage (_Magick_inverseFourierTransformImage) */
// jsnapi_getclass
Napi::Function _Magick_inverseFourierTransformImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_inverseFourierTransformImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_inverseFourierTransformImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_inverseFourierTransformImage_inst>::DefineClass(env, "inverseFourierTransformImage", symbolTable);
}

void _Magick_inverseFourierTransformImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_inverseFourierTransformImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_inverseFourierTransformImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_inverseFourierTransformImage_templ::InstanceMethod("callAsync",
        &_Magick_inverseFourierTransformImage_templ::_wrap_Magick_inverseFourierTransformImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_inverseFourierTransformImage_templ::InstanceMethod("call",
        &_Magick_inverseFourierTransformImage_templ::_wrap_Magick_inverseFourierTransformImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: isValidImage (_Magick_isValidImage) */
// jsnapi_getclass
Napi::Function _Magick_isValidImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_isValidImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_isValidImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_isValidImage_inst>::DefineClass(env, "isValidImage", symbolTable);
}

void _Magick_isValidImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_isValidImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_isValidImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_isValidImage_templ::InstanceMethod("callAsync",
        &_Magick_isValidImage_templ::_wrap_Magick_isValidImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_isValidImage_templ::InstanceMethod("call",
        &_Magick_isValidImage_templ::_wrap_Magick_isValidImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: labelImage (_Magick_labelImage) */
// jsnapi_getclass
Napi::Function _Magick_labelImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_labelImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_labelImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_labelImage_inst>::DefineClass(env, "labelImage", symbolTable);
}

void _Magick_labelImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_labelImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_labelImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_labelImage_templ::InstanceMethod("callAsync",
        &_Magick_labelImage_templ::_wrap_Magick_labelImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_labelImage_templ::InstanceMethod("call",
        &_Magick_labelImage_templ::_wrap_Magick_labelImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: levelImage (_Magick_levelImage) */
// jsnapi_getclass
Napi::Function _Magick_levelImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_levelImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_levelImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_levelImage_inst>::DefineClass(env, "levelImage", symbolTable);
}

void _Magick_levelImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_levelImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_levelImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_levelImage_templ::InstanceMethod("callAsync",
        &_Magick_levelImage_templ::_wrap_Magick_levelImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_levelImage_templ::InstanceMethod("call",
        &_Magick_levelImage_templ::_wrap_Magick_levelImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: magnifyImage (_Magick_magnifyImage) */
// jsnapi_getclass
Napi::Function _Magick_magnifyImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_magnifyImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_magnifyImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_magnifyImage_inst>::DefineClass(env, "magnifyImage", symbolTable);
}

void _Magick_magnifyImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_magnifyImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_magnifyImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_magnifyImage_templ::InstanceMethod("callAsync",
        &_Magick_magnifyImage_templ::_wrap_Magick_magnifyImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_magnifyImage_templ::InstanceMethod("call",
        &_Magick_magnifyImage_templ::_wrap_Magick_magnifyImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: mapImage (_Magick_mapImage) */
// jsnapi_getclass
Napi::Function _Magick_mapImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_mapImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_mapImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_mapImage_inst>::DefineClass(env, "mapImage", symbolTable);
}

void _Magick_mapImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_mapImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_mapImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_mapImage_templ::InstanceMethod("callAsync",
        &_Magick_mapImage_templ::_wrap_Magick_mapImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_mapImage_templ::InstanceMethod("call",
        &_Magick_mapImage_templ::_wrap_Magick_mapImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: medianConvolveImage (_Magick_medianConvolveImage) */
// jsnapi_getclass
Napi::Function _Magick_medianConvolveImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_medianConvolveImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_medianConvolveImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_medianConvolveImage_inst>::DefineClass(env, "medianConvolveImage", symbolTable);
}

void _Magick_medianConvolveImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_medianConvolveImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_medianConvolveImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_medianConvolveImage_templ::InstanceMethod("callAsync",
        &_Magick_medianConvolveImage_templ::_wrap_Magick_medianConvolveImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_medianConvolveImage_templ::InstanceMethod("call",
        &_Magick_medianConvolveImage_templ::_wrap_Magick_medianConvolveImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: minifyImage (_Magick_minifyImage) */
// jsnapi_getclass
Napi::Function _Magick_minifyImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_minifyImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_minifyImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_minifyImage_inst>::DefineClass(env, "minifyImage", symbolTable);
}

void _Magick_minifyImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_minifyImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_minifyImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_minifyImage_templ::InstanceMethod("callAsync",
        &_Magick_minifyImage_templ::_wrap_Magick_minifyImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_minifyImage_templ::InstanceMethod("call",
        &_Magick_minifyImage_templ::_wrap_Magick_minifyImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: modulateImage (_Magick_modulateImage) */
// jsnapi_getclass
Napi::Function _Magick_modulateImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_modulateImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_modulateImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_modulateImage_inst>::DefineClass(env, "modulateImage", symbolTable);
}

void _Magick_modulateImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_modulateImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_modulateImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_modulateImage_templ::InstanceMethod("callAsync",
        &_Magick_modulateImage_templ::_wrap_Magick_modulateImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_modulateImage_templ::InstanceMethod("call",
        &_Magick_modulateImage_templ::_wrap_Magick_modulateImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: negateImage (_Magick_negateImage) */
// jsnapi_getclass
Napi::Function _Magick_negateImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_negateImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_negateImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_negateImage_inst>::DefineClass(env, "negateImage", symbolTable);
}

void _Magick_negateImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_negateImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_negateImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_negateImage_templ::InstanceMethod("callAsync",
        &_Magick_negateImage_templ::_wrap_Magick_negateImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_negateImage_templ::InstanceMethod("call",
        &_Magick_negateImage_templ::_wrap_Magick_negateImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

