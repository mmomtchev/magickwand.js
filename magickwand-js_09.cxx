/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.2.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

#include "swig/magickwand-js.h"

/* Class: quantizeDitherImage (_Magick_quantizeDitherImage) */
// jsnapi_getclass
Napi::Function _Magick_quantizeDitherImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_quantizeDitherImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_quantizeDitherImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_quantizeDitherImage_inst>::DefineClass(env, "quantizeDitherImage", symbolTable);
}

void _Magick_quantizeDitherImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_quantizeDitherImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_quantizeDitherImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_quantizeDitherImage_templ::InstanceMethod("callAsync",
        &_Magick_quantizeDitherImage_templ::_wrap_Magick_quantizeDitherImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_quantizeDitherImage_templ::InstanceMethod("call",
        &_Magick_quantizeDitherImage_templ::_wrap_Magick_quantizeDitherImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: quantizeTreeDepthImage (_Magick_quantizeTreeDepthImage) */
// jsnapi_getclass
Napi::Function _Magick_quantizeTreeDepthImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_quantizeTreeDepthImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_quantizeTreeDepthImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_quantizeTreeDepthImage_inst>::DefineClass(env, "quantizeTreeDepthImage", symbolTable);
}

void _Magick_quantizeTreeDepthImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_quantizeTreeDepthImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_quantizeTreeDepthImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_quantizeTreeDepthImage_templ::InstanceMethod("callAsync",
        &_Magick_quantizeTreeDepthImage_templ::_wrap_Magick_quantizeTreeDepthImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_quantizeTreeDepthImage_templ::InstanceMethod("call",
        &_Magick_quantizeTreeDepthImage_templ::_wrap_Magick_quantizeTreeDepthImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: renderingIntentImage (_Magick_renderingIntentImage) */
// jsnapi_getclass
Napi::Function _Magick_renderingIntentImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_renderingIntentImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_renderingIntentImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_renderingIntentImage_inst>::DefineClass(env, "renderingIntentImage", symbolTable);
}

void _Magick_renderingIntentImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_renderingIntentImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_renderingIntentImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_renderingIntentImage_templ::InstanceMethod("callAsync",
        &_Magick_renderingIntentImage_templ::_wrap_Magick_renderingIntentImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_renderingIntentImage_templ::InstanceMethod("call",
        &_Magick_renderingIntentImage_templ::_wrap_Magick_renderingIntentImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: resolutionUnitsImage (_Magick_resolutionUnitsImage) */
// jsnapi_getclass
Napi::Function _Magick_resolutionUnitsImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_resolutionUnitsImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_resolutionUnitsImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_resolutionUnitsImage_inst>::DefineClass(env, "resolutionUnitsImage", symbolTable);
}

void _Magick_resolutionUnitsImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_resolutionUnitsImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_resolutionUnitsImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_resolutionUnitsImage_templ::InstanceMethod("callAsync",
        &_Magick_resolutionUnitsImage_templ::_wrap_Magick_resolutionUnitsImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_resolutionUnitsImage_templ::InstanceMethod("call",
        &_Magick_resolutionUnitsImage_templ::_wrap_Magick_resolutionUnitsImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: sceneImage (_Magick_sceneImage) */
// jsnapi_getclass
Napi::Function _Magick_sceneImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_sceneImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_sceneImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_sceneImage_inst>::DefineClass(env, "sceneImage", symbolTable);
}

void _Magick_sceneImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_sceneImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_sceneImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_sceneImage_templ::InstanceMethod("callAsync",
        &_Magick_sceneImage_templ::_wrap_Magick_sceneImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_sceneImage_templ::InstanceMethod("call",
        &_Magick_sceneImage_templ::_wrap_Magick_sceneImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: sizeImage (_Magick_sizeImage) */
// jsnapi_getclass
Napi::Function _Magick_sizeImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_sizeImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_sizeImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_sizeImage_inst>::DefineClass(env, "sizeImage", symbolTable);
}

void _Magick_sizeImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_sizeImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_sizeImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_sizeImage_templ::InstanceMethod("callAsync",
        &_Magick_sizeImage_templ::_wrap_Magick_sizeImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_sizeImage_templ::InstanceMethod("call",
        &_Magick_sizeImage_templ::_wrap_Magick_sizeImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: stripImage (_Magick_stripImage) */
// jsnapi_getclass
Napi::Function _Magick_stripImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_stripImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_stripImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_stripImage_inst>::DefineClass(env, "stripImage", symbolTable);
}

void _Magick_stripImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_stripImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_stripImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_stripImage_templ::InstanceMethod("callAsync",
        &_Magick_stripImage_templ::_wrap_Magick_stripImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_stripImage_templ::InstanceMethod("call",
        &_Magick_stripImage_templ::_wrap_Magick_stripImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: subImageImage (_Magick_subImageImage) */
// jsnapi_getclass
Napi::Function _Magick_subImageImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_subImageImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_subImageImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_subImageImage_inst>::DefineClass(env, "subImageImage", symbolTable);
}

void _Magick_subImageImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_subImageImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_subImageImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_subImageImage_templ::InstanceMethod("callAsync",
        &_Magick_subImageImage_templ::_wrap_Magick_subImageImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_subImageImage_templ::InstanceMethod("call",
        &_Magick_subImageImage_templ::_wrap_Magick_subImageImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: subRangeImage (_Magick_subRangeImage) */
// jsnapi_getclass
Napi::Function _Magick_subRangeImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_subRangeImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_subRangeImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_subRangeImage_inst>::DefineClass(env, "subRangeImage", symbolTable);
}

void _Magick_subRangeImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_subRangeImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_subRangeImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_subRangeImage_templ::InstanceMethod("callAsync",
        &_Magick_subRangeImage_templ::_wrap_Magick_subRangeImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_subRangeImage_templ::InstanceMethod("call",
        &_Magick_subRangeImage_templ::_wrap_Magick_subRangeImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: textAntiAliasImage (_Magick_textAntiAliasImage) */
// jsnapi_getclass
Napi::Function _Magick_textAntiAliasImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_textAntiAliasImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_textAntiAliasImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_textAntiAliasImage_inst>::DefineClass(env, "textAntiAliasImage", symbolTable);
}

void _Magick_textAntiAliasImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_textAntiAliasImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_textAntiAliasImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_textAntiAliasImage_templ::InstanceMethod("callAsync",
        &_Magick_textAntiAliasImage_templ::_wrap_Magick_textAntiAliasImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_textAntiAliasImage_templ::InstanceMethod("call",
        &_Magick_textAntiAliasImage_templ::_wrap_Magick_textAntiAliasImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: typeImage (_Magick_typeImage) */
// jsnapi_getclass
Napi::Function _Magick_typeImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_typeImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_typeImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_typeImage_inst>::DefineClass(env, "typeImage", symbolTable);
}

void _Magick_typeImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_typeImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_typeImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_typeImage_templ::InstanceMethod("callAsync",
        &_Magick_typeImage_templ::_wrap_Magick_typeImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_typeImage_templ::InstanceMethod("call",
        &_Magick_typeImage_templ::_wrap_Magick_typeImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: verboseImage (_Magick_verboseImage) */
// jsnapi_getclass
Napi::Function _Magick_verboseImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_verboseImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_verboseImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_verboseImage_inst>::DefineClass(env, "verboseImage", symbolTable);
}

void _Magick_verboseImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_verboseImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_verboseImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_verboseImage_templ::InstanceMethod("callAsync",
        &_Magick_verboseImage_templ::_wrap_Magick_verboseImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_verboseImage_templ::InstanceMethod("call",
        &_Magick_verboseImage_templ::_wrap_Magick_verboseImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: x11DisplayImage (_Magick_x11DisplayImage) */
// jsnapi_getclass
Napi::Function _Magick_x11DisplayImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_x11DisplayImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_x11DisplayImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_x11DisplayImage_inst>::DefineClass(env, "x11DisplayImage", symbolTable);
}

void _Magick_x11DisplayImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_x11DisplayImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_x11DisplayImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_x11DisplayImage_templ::InstanceMethod("callAsync",
        &_Magick_x11DisplayImage_templ::_wrap_Magick_x11DisplayImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_x11DisplayImage_templ::InstanceMethod("call",
        &_Magick_x11DisplayImage_templ::_wrap_Magick_x11DisplayImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: coderInfoArray (_std_coderInfoArray) */
// jsnapi_getclass
Napi::Function _std_coderInfoArray_inst::GetClass(Napi::Env env) {
  std::map<std::string, _std_coderInfoArray_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_std_coderInfoArray_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_std_coderInfoArray_inst>::DefineClass(env, "coderInfoArray", symbolTable);
}

void _std_coderInfoArray_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _std_coderInfoArray_templ::PropertyDescriptor> &members,
  std::map<std::string, _std_coderInfoArray_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("size");
  members.insert({
    "size",
      _std_coderInfoArray_templ::InstanceMethod("size",
        &_std_coderInfoArray_templ::_wrap_std_coderInfoArray_size,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("capacity");
  members.insert({
    "capacity",
      _std_coderInfoArray_templ::InstanceMethod("capacity",
        &_std_coderInfoArray_templ::_wrap_std_coderInfoArray_capacity,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("reserve");
  members.insert({
    "reserve",
      _std_coderInfoArray_templ::InstanceMethod("reserve",
        &_std_coderInfoArray_templ::_wrap_std_coderInfoArray_reserve,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("isEmpty");
  members.insert({
    "isEmpty",
      _std_coderInfoArray_templ::InstanceMethod("isEmpty",
        &_std_coderInfoArray_templ::_wrap_std_coderInfoArray_isEmpty,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("clear");
  members.insert({
    "clear",
      _std_coderInfoArray_templ::InstanceMethod("clear",
        &_std_coderInfoArray_templ::_wrap_std_coderInfoArray_clear,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("add");
  members.insert({
    "add",
      _std_coderInfoArray_templ::InstanceMethod("add",
        &_std_coderInfoArray_templ::_wrap_std_coderInfoArray_add,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("get");
  members.insert({
    "get",
      _std_coderInfoArray_templ::InstanceMethod("get",
        &_std_coderInfoArray_templ::_wrap_std_coderInfoArray_get,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("set");
  members.insert({
    "set",
      _std_coderInfoArray_templ::InstanceMethod("set",
        &_std_coderInfoArray_templ::_wrap_std_coderInfoArray_set,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}


// js_global_overloaded_function
Napi::Value _wrap_coderInfoList__SWIG_0(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  std::vector< Magick::CoderInfo > *arg1 = (std::vector< Magick::CoderInfo > *) 0 ;
  Magick::CoderInfo::MatchType arg2 ;
  Magick::CoderInfo::MatchType arg3 ;
  Magick::CoderInfo::MatchType arg4 ;
  std::vector< Magick::CoderInfo > temp1 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    {
      arg1 = new std::vector<Magick::CoderInfo>;
    }
    ecode2 = SWIG_AsVal_int(info[0], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "coderInfoList" "', argument " "2"" of type '" "Magick::CoderInfo::MatchType""'");
    } 
    arg2 = static_cast< Magick::CoderInfo::MatchType >(val2);ecode3 = SWIG_AsVal_int(info[1], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "coderInfoList" "', argument " "3"" of type '" "Magick::CoderInfo::MatchType""'");
    } 
    arg3 = static_cast< Magick::CoderInfo::MatchType >(val3);ecode4 = SWIG_AsVal_int(info[2], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "coderInfoList" "', argument " "4"" of type '" "Magick::CoderInfo::MatchType""'");
    } 
    arg4 = static_cast< Magick::CoderInfo::MatchType >(val4);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR coderInfoList< std::vector< Magick::CoderInfo > >(arg1,arg2,arg3,arg4);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      jsresult = SWIG_NAPI_NewPointerObj(env, arg1, SWIGTYPE_p_std__vectorT_Magick__CoderInfo_t, SWIG_POINTER_OWN);
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_coderInfoList__SWIG_1(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  std::vector< Magick::CoderInfo > *arg1 = (std::vector< Magick::CoderInfo > *) 0 ;
  Magick::CoderInfo::MatchType arg2 ;
  Magick::CoderInfo::MatchType arg3 ;
  std::vector< Magick::CoderInfo > temp1 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    {
      arg1 = new std::vector<Magick::CoderInfo>;
    }
    ecode2 = SWIG_AsVal_int(info[0], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "coderInfoList" "', argument " "2"" of type '" "Magick::CoderInfo::MatchType""'");
    } 
    arg2 = static_cast< Magick::CoderInfo::MatchType >(val2);ecode3 = SWIG_AsVal_int(info[1], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "coderInfoList" "', argument " "3"" of type '" "Magick::CoderInfo::MatchType""'");
    } 
    arg3 = static_cast< Magick::CoderInfo::MatchType >(val3);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR coderInfoList< std::vector< Magick::CoderInfo > >(arg1,arg2,arg3);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      jsresult = SWIG_NAPI_NewPointerObj(env, arg1, SWIGTYPE_p_std__vectorT_Magick__CoderInfo_t, SWIG_POINTER_OWN);
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_coderInfoList__SWIG_2(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  std::vector< Magick::CoderInfo > *arg1 = (std::vector< Magick::CoderInfo > *) 0 ;
  Magick::CoderInfo::MatchType arg2 ;
  std::vector< Magick::CoderInfo > temp1 ;
  int val2 ;
  int ecode2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    {
      arg1 = new std::vector<Magick::CoderInfo>;
    }
    ecode2 = SWIG_AsVal_int(info[0], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "coderInfoList" "', argument " "2"" of type '" "Magick::CoderInfo::MatchType""'");
    } 
    arg2 = static_cast< Magick::CoderInfo::MatchType >(val2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR coderInfoList< std::vector< Magick::CoderInfo > >(arg1,arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      jsresult = SWIG_NAPI_NewPointerObj(env, arg1, SWIGTYPE_p_std__vectorT_Magick__CoderInfo_t, SWIG_POINTER_OWN);
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_coderInfoList__SWIG_3(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  std::vector< Magick::CoderInfo > *arg1 = (std::vector< Magick::CoderInfo > *) 0 ;
  std::vector< Magick::CoderInfo > temp1 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    {
      arg1 = new std::vector<Magick::CoderInfo>;
    }
    
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR coderInfoList< std::vector< Magick::CoderInfo > >(arg1);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      jsresult = SWIG_NAPI_NewPointerObj(env, arg1, SWIGTYPE_p_std__vectorT_Magick__CoderInfo_t, SWIG_POINTER_OWN);
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_function_dispatcher
Napi::Value _wrap_Magick__wrap_coderInfoList(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 3 && static_cast<int>(info.Length()) <= 3) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_coderInfoList__SWIG_0(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_coderInfoList__SWIG_0(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_coderInfoList__SWIG_1(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_coderInfoList__SWIG_1(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 1 && static_cast<int>(info.Length()) <= 1) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_coderInfoList__SWIG_2(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_coderInfoList__SWIG_2(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 0 && static_cast<int>(info.Length()) <= 0) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_coderInfoList__SWIG_3(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_coderInfoList__SWIG_3(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  
  SWIG_Error(SWIG_ERROR, "Illegal arguments for function coderInfoList.");
  
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


/* Class: CoordinateList (_std_CoordinateList) */
// jsnapi_getclass
Napi::Function _std_CoordinateList_inst::GetClass(Napi::Env env) {
  std::map<std::string, _std_CoordinateList_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_std_CoordinateList_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_std_CoordinateList_inst>::DefineClass(env, "CoordinateList", symbolTable);
}

void _std_CoordinateList_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _std_CoordinateList_templ::PropertyDescriptor> &members,
  std::map<std::string, _std_CoordinateList_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("size");
  members.insert({
    "size",
      _std_CoordinateList_templ::InstanceMethod("size",
        &_std_CoordinateList_templ::_wrap_std_CoordinateList_size,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("capacity");
  members.insert({
    "capacity",
      _std_CoordinateList_templ::InstanceMethod("capacity",
        &_std_CoordinateList_templ::_wrap_std_CoordinateList_capacity,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("reserve");
  members.insert({
    "reserve",
      _std_CoordinateList_templ::InstanceMethod("reserve",
        &_std_CoordinateList_templ::_wrap_std_CoordinateList_reserve,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("isEmpty");
  members.insert({
    "isEmpty",
      _std_CoordinateList_templ::InstanceMethod("isEmpty",
        &_std_CoordinateList_templ::_wrap_std_CoordinateList_isEmpty,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("clear");
  members.insert({
    "clear",
      _std_CoordinateList_templ::InstanceMethod("clear",
        &_std_CoordinateList_templ::_wrap_std_CoordinateList_clear,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("add");
  members.insert({
    "add",
      _std_CoordinateList_templ::InstanceMethod("add",
        &_std_CoordinateList_templ::_wrap_std_CoordinateList_add,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("get");
  members.insert({
    "get",
      _std_CoordinateList_templ::InstanceMethod("get",
        &_std_CoordinateList_templ::_wrap_std_CoordinateList_get,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("set");
  members.insert({
    "set",
      _std_CoordinateList_templ::InstanceMethod("set",
        &_std_CoordinateList_templ::_wrap_std_CoordinateList_set,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}


// js_global_overloaded_function_async
Napi::Value _wrap_appendImagesAsync__SWIG_0(const Napi::CallbackInfo &info) {
  // js_async_worker_local_class
  class _std_CoordinateList__wrap_appendImagesAsync__SWIG_0_Tasklet : public SWIG_NAPI_AsyncContext {
    Napi::Env env;
    Magick::Image *arg1 = (Magick::Image *) 0 ;
    ImageListIterator arg2 ;
    ImageListIterator arg3 ;
    bool arg4 ;
    ImageListContainer temp_list2 ;
    bool val4 ;
    int ecode4 = 0 ;
    
    // js_locks_list
    SWIG_Locks_List SWIG_locks;
    
  public:
    _std_CoordinateList__wrap_appendImagesAsync__SWIG_0_Tasklet(Napi::Env _env)
    :SWIG_NAPI_AsyncContext(_env), env(_env) {
      
    }
    
    virtual void SWIG_NAPI_Execute() override {
      // This runs the action code in a worker thread and V8 is not accessible
      Napi::Env env(SWIG_NULLPTR);
      
      // js_guard
      SWIG_Guard SWIG_guard(SWIG_locks);
      
      
      // js_lock
      SWIG_guard.lock();
      
      
      Magick::SWIGTEMPLATEDISAMBIGUATOR appendImages< ImageListIterator >(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3),arg4);
      
      goto fail;
    fail:
      return;
    }
    
#ifdef NAPI_CPP_EXCEPTIONS
    virtual void SWIG_NAPI_Rethrow(const std::exception_ptr &saved) override {
      // Back in the main thread with V8 access, caller has HandleScope
      
      {
        try {
          if (saved) std::rethrow_exception(saved);
        } catch (const Magick::Exception &e) {
          do {
            SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
          } while (0);
          SWIG_fail;
        }
      }
      
      
    }
#endif
    
    virtual void SWIG_NAPI_Resolve() override {
      // Back in the main thread with V8 access, caller has HandleScope
      Napi::Value jsresult;
      jsresult = env.Undefined();
      {
        if (arg1 != nullptr) {
          jsresult = SWIG_NAPI_NewPointerObj(env, arg1, SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
        } else {
          jsresult = env.Null();
        }
      }
      
      if (!SWIG_NAPI_Cleanup()) goto fail;
      SWIG_NAPI_deferred_finalized = true;
      SWIG_NAPI_deferred.Resolve(jsresult);
      goto fail;
    fail:
      return;
    }
    
    virtual bool SWIG_NAPI_Cleanup() override {
      return true;
      goto fail;
    fail:
      return false;
    }
    
    virtual Status SWIG_NAPI_Init(const Napi::CallbackInfo &info) override {
      {
        arg1 = new Magick::Image();
      }
      {
        {
          if (info[0].IsArray()) {
            Napi::Array array = info[0].As<Napi::Array>();
            for (size_t i = 0; i < array.Length(); i++) {
              Magick::Image *im = nullptr;
              if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
                SWIG_exception_fail(SWIG_TypeError, "in method 'appendImages', array element is not an Image");
              }
              // Emplace the newly constructed copies in the std::container
              temp_list2.emplace_back(Magick::Image(*im));
            }
            arg2 = temp_list2.begin();
            arg3 = temp_list2.end();
          } else {
            SWIG_exception_fail(SWIG_TypeError, "in method 'appendImages', argument 2 is not an array");
          }
        }
      }
      ecode4 = SWIG_AsVal_bool(info[1], &val4);
      if (!SWIG_IsOK(ecode4)) {
        SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "appendImages" "', argument " "4"" of type '" "bool""'");
      } 
      arg4 = static_cast< bool >(val4);
#define SWIG_NAPI_Raise SWIG_NAPI_Reject
      {
        SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
        if (info[0].IsObject()) {
          Napi::Object obj;
          NAPI_CHECK_RESULT(info[0].ToObject(), obj);
          if (SWIG_NAPI_IsWrappedObject(env, obj)) {
            ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
            if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
              SWIG_locks.insert({
                reinterpret_cast<void*>(ow), {
                  [ow](){
                    ow->lock();
                  }, [ow](){
                    ow->unlock();
                  }
                  }
              });
            }
          }
        }
      }
      
#undef SWIG_NAPI_Raise
      return Status::OK;
      goto fail;
    fail:
      return Status::THROW;
    }
  };
  
  Napi::Env env = info.Env();
  _std_CoordinateList__wrap_appendImagesAsync__SWIG_0_Tasklet *context = SWIG_NULLPTR;
  SWIG_NAPI_AsyncWorker *worker = SWIG_NULLPTR;
  if(static_cast<int>(info.Length()) < 2 || static_cast<int>(info.Length()) > 2) {
    SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_appendImagesAsync__SWIG_0.");
  }
  context = new _std_CoordinateList__wrap_appendImagesAsync__SWIG_0_Tasklet(env);
  worker = new SWIG_NAPI_AsyncWorker(
    env, "SWIG__wrap_appendImagesAsync__SWIG_0_Async_Worker", context);
  return worker->Run(info);
#ifdef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_appendImages__SWIG_0(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ImageListIterator arg2 ;
  ImageListIterator arg3 ;
  bool arg4 ;
  ImageListContainer temp_list2 ;
  bool val4 ;
  int ecode4 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    {
      arg1 = new Magick::Image();
    }
    {
      {
        if (info[0].IsArray()) {
          Napi::Array array = info[0].As<Napi::Array>();
          for (size_t i = 0; i < array.Length(); i++) {
            Magick::Image *im = nullptr;
            if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
              SWIG_exception_fail(SWIG_TypeError, "in method 'appendImages', array element is not an Image");
            }
            // Emplace the newly constructed copies in the std::container
            temp_list2.emplace_back(Magick::Image(*im));
          }
          arg2 = temp_list2.begin();
          arg3 = temp_list2.end();
        } else {
          SWIG_exception_fail(SWIG_TypeError, "in method 'appendImages', argument 2 is not an array");
        }
      }
    }
    ecode4 = SWIG_AsVal_bool(info[1], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "appendImages" "', argument " "4"" of type '" "bool""'");
    } 
    arg4 = static_cast< bool >(val4);
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[0].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[0].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR appendImages< ImageListIterator >(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3),arg4);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      if (arg1 != nullptr) {
        jsresult = SWIG_NAPI_NewPointerObj(env, arg1, SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
      } else {
        jsresult = env.Null();
      }
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function_async
Napi::Value _wrap_appendImagesAsync__SWIG_1(const Napi::CallbackInfo &info) {
  // js_async_worker_local_class
  class _std_CoordinateList__wrap_appendImagesAsync__SWIG_1_Tasklet : public SWIG_NAPI_AsyncContext {
    Napi::Env env;
    Magick::Image *arg1 = (Magick::Image *) 0 ;
    ImageListIterator arg2 ;
    ImageListIterator arg3 ;
    ImageListContainer temp_list2 ;
    
    // js_locks_list
    SWIG_Locks_List SWIG_locks;
    
  public:
    _std_CoordinateList__wrap_appendImagesAsync__SWIG_1_Tasklet(Napi::Env _env)
    :SWIG_NAPI_AsyncContext(_env), env(_env) {
      
    }
    
    virtual void SWIG_NAPI_Execute() override {
      // This runs the action code in a worker thread and V8 is not accessible
      Napi::Env env(SWIG_NULLPTR);
      
      // js_guard
      SWIG_Guard SWIG_guard(SWIG_locks);
      
      
      // js_lock
      SWIG_guard.lock();
      
      
      Magick::SWIGTEMPLATEDISAMBIGUATOR appendImages< ImageListIterator >(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
      
      goto fail;
    fail:
      return;
    }
    
#ifdef NAPI_CPP_EXCEPTIONS
    virtual void SWIG_NAPI_Rethrow(const std::exception_ptr &saved) override {
      // Back in the main thread with V8 access, caller has HandleScope
      
      {
        try {
          if (saved) std::rethrow_exception(saved);
        } catch (const Magick::Exception &e) {
          do {
            SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
          } while (0);
          SWIG_fail;
        }
      }
      
      
    }
#endif
    
    virtual void SWIG_NAPI_Resolve() override {
      // Back in the main thread with V8 access, caller has HandleScope
      Napi::Value jsresult;
      jsresult = env.Undefined();
      {
        if (arg1 != nullptr) {
          jsresult = SWIG_NAPI_NewPointerObj(env, arg1, SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
        } else {
          jsresult = env.Null();
        }
      }
      
      if (!SWIG_NAPI_Cleanup()) goto fail;
      SWIG_NAPI_deferred_finalized = true;
      SWIG_NAPI_deferred.Resolve(jsresult);
      goto fail;
    fail:
      return;
    }
    
    virtual bool SWIG_NAPI_Cleanup() override {
      return true;
      goto fail;
    fail:
      return false;
    }
    
    virtual Status SWIG_NAPI_Init(const Napi::CallbackInfo &info) override {
      {
        arg1 = new Magick::Image();
      }
      {
        {
          if (info[0].IsArray()) {
            Napi::Array array = info[0].As<Napi::Array>();
            for (size_t i = 0; i < array.Length(); i++) {
              Magick::Image *im = nullptr;
              if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
                SWIG_exception_fail(SWIG_TypeError, "in method 'appendImages', array element is not an Image");
              }
              // Emplace the newly constructed copies in the std::container
              temp_list2.emplace_back(Magick::Image(*im));
            }
            arg2 = temp_list2.begin();
            arg3 = temp_list2.end();
          } else {
            SWIG_exception_fail(SWIG_TypeError, "in method 'appendImages', argument 2 is not an array");
          }
        }
      }
      
#define SWIG_NAPI_Raise SWIG_NAPI_Reject
      {
        SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
        if (info[0].IsObject()) {
          Napi::Object obj;
          NAPI_CHECK_RESULT(info[0].ToObject(), obj);
          if (SWIG_NAPI_IsWrappedObject(env, obj)) {
            ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
            if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
              SWIG_locks.insert({
                reinterpret_cast<void*>(ow), {
                  [ow](){
                    ow->lock();
                  }, [ow](){
                    ow->unlock();
                  }
                  }
              });
            }
          }
        }
      }
      
#undef SWIG_NAPI_Raise
      return Status::OK;
      goto fail;
    fail:
      return Status::THROW;
    }
  };
  
  Napi::Env env = info.Env();
  _std_CoordinateList__wrap_appendImagesAsync__SWIG_1_Tasklet *context = SWIG_NULLPTR;
  SWIG_NAPI_AsyncWorker *worker = SWIG_NULLPTR;
  if(static_cast<int>(info.Length()) < 1 || static_cast<int>(info.Length()) > 1) {
    SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_appendImagesAsync__SWIG_1.");
  }
  context = new _std_CoordinateList__wrap_appendImagesAsync__SWIG_1_Tasklet(env);
  worker = new SWIG_NAPI_AsyncWorker(
    env, "SWIG__wrap_appendImagesAsync__SWIG_1_Async_Worker", context);
  return worker->Run(info);
#ifdef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}



// js_global_function_dispatcher
Napi::Value _wrap_Magick__wrap_appendImagesAsync(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_appendImagesAsync__SWIG_0(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_appendImagesAsync__SWIG_0(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 1 && static_cast<int>(info.Length()) <= 1) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_appendImagesAsync__SWIG_1(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_appendImagesAsync__SWIG_1(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  
  SWIG_Error(SWIG_ERROR, "Illegal arguments for function appendImagesAsync.");
  
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_appendImages__SWIG_1(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ImageListIterator arg2 ;
  ImageListIterator arg3 ;
  ImageListContainer temp_list2 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    {
      arg1 = new Magick::Image();
    }
    {
      {
        if (info[0].IsArray()) {
          Napi::Array array = info[0].As<Napi::Array>();
          for (size_t i = 0; i < array.Length(); i++) {
            Magick::Image *im = nullptr;
            if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
              SWIG_exception_fail(SWIG_TypeError, "in method 'appendImages', array element is not an Image");
            }
            // Emplace the newly constructed copies in the std::container
            temp_list2.emplace_back(Magick::Image(*im));
          }
          arg2 = temp_list2.begin();
          arg3 = temp_list2.end();
        } else {
          SWIG_exception_fail(SWIG_TypeError, "in method 'appendImages', argument 2 is not an array");
        }
      }
    }
    
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[0].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[0].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR appendImages< ImageListIterator >(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      if (arg1 != nullptr) {
        jsresult = SWIG_NAPI_NewPointerObj(env, arg1, SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
      } else {
        jsresult = env.Null();
      }
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_function_dispatcher
Napi::Value _wrap_Magick__wrap_appendImages(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_appendImages__SWIG_0(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_appendImages__SWIG_0(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 1 && static_cast<int>(info.Length()) <= 1) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_appendImages__SWIG_1(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_appendImages__SWIG_1(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  
  SWIG_Error(SWIG_ERROR, "Illegal arguments for function appendImages.");
  
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}



// js_global_function
Napi::Value _wrap_averageImages(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ImageListIterator arg2 ;
  ImageListIterator arg3 ;
  ImageListContainer temp_list2 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    if(static_cast<int>(info.Length()) < 1 || static_cast<int>(info.Length()) > 1) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_averageImages.");
    }
    
    {
      arg1 = new Magick::Image();
    }
    {
      {
        if (info[0].IsArray()) {
          Napi::Array array = info[0].As<Napi::Array>();
          for (size_t i = 0; i < array.Length(); i++) {
            Magick::Image *im = nullptr;
            if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
              SWIG_exception_fail(SWIG_TypeError, "in method 'averageImages', array element is not an Image");
            }
            // Emplace the newly constructed copies in the std::container
            temp_list2.emplace_back(Magick::Image(*im));
          }
          arg2 = temp_list2.begin();
          arg3 = temp_list2.end();
        } else {
          SWIG_exception_fail(SWIG_TypeError, "in method 'averageImages', argument 2 is not an array");
        }
      }
    }
    
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[0].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[0].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR averageImages< ImageListIterator >(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      if (arg1 != nullptr) {
        jsresult = SWIG_NAPI_NewPointerObj(env, arg1, SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
      } else {
        jsresult = env.Null();
      }
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_function
Napi::Value _wrap_flattenImages(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ImageListIterator arg2 ;
  ImageListIterator arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ImageListContainer temp_list2 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    if(static_cast<int>(info.Length()) < 2 || static_cast<int>(info.Length()) > 2) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_flattenImages.");
    }
    
    res1 = SWIG_ConvertPtr(info[0], &argp1,SWIGTYPE_p_Magick__Image, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "flattenImages" "', argument " "1"" of type '" "Magick::Image *""'"); 
    }
    arg1 = reinterpret_cast< Magick::Image * >(argp1);{
      {
        if (info[1].IsArray()) {
          Napi::Array array = info[1].As<Napi::Array>();
          for (size_t i = 0; i < array.Length(); i++) {
            Magick::Image *im = nullptr;
            if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
              SWIG_exception_fail(SWIG_TypeError, "in method 'flattenImages', array element is not an Image");
            }
            // Emplace the newly constructed copies in the std::container
            temp_list2.emplace_back(Magick::Image(*im));
          }
          arg2 = temp_list2.begin();
          arg3 = temp_list2.end();
        } else {
          SWIG_exception_fail(SWIG_TypeError, "in method 'flattenImages', argument 2 is not an array");
        }
      }
    }
    
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[0].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[0].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR flattenImages< ImageListIterator >(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_function
Napi::Value _wrap_mosaicImages(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Image *arg1 = (Magick::Image *) 0 ;
  ImageListIterator arg2 ;
  ImageListIterator arg3 ;
  ImageListContainer temp_list2 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    if(static_cast<int>(info.Length()) < 1 || static_cast<int>(info.Length()) > 1) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_mosaicImages.");
    }
    
    {
      arg1 = new Magick::Image();
    }
    {
      {
        if (info[0].IsArray()) {
          Napi::Array array = info[0].As<Napi::Array>();
          for (size_t i = 0; i < array.Length(); i++) {
            Magick::Image *im = nullptr;
            if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
              SWIG_exception_fail(SWIG_TypeError, "in method 'mosaicImages', array element is not an Image");
            }
            // Emplace the newly constructed copies in the std::container
            temp_list2.emplace_back(Magick::Image(*im));
          }
          arg2 = temp_list2.begin();
          arg3 = temp_list2.end();
        } else {
          SWIG_exception_fail(SWIG_TypeError, "in method 'mosaicImages', argument 2 is not an array");
        }
      }
    }
    
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[0].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[0].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR mosaicImages< ImageListIterator >(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      if (arg1 != nullptr) {
        jsresult = SWIG_NAPI_NewPointerObj(env, arg1, SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
      } else {
        jsresult = env.Null();
      }
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_function
Napi::Value _wrap_coalesceImages(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  ImageListContainer *arg1 = (ImageListContainer *) 0 ;
  ImageListIterator arg2 ;
  ImageListIterator arg3 ;
  ImageListContainer temp_list1 ;
  ImageListContainer temp_list2 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    if(static_cast<int>(info.Length()) < 1 || static_cast<int>(info.Length()) > 1) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_coalesceImages.");
    }
    
    {
      arg1 = &temp_list1;
    }
    {
      {
        if (info[0].IsArray()) {
          Napi::Array array = info[0].As<Napi::Array>();
          for (size_t i = 0; i < array.Length(); i++) {
            Magick::Image *im = nullptr;
            if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
              SWIG_exception_fail(SWIG_TypeError, "in method 'coalesceImages', array element is not an Image");
            }
            // Emplace the newly constructed copies in the std::container
            temp_list2.emplace_back(Magick::Image(*im));
          }
          arg2 = temp_list2.begin();
          arg3 = temp_list2.end();
        } else {
          SWIG_exception_fail(SWIG_TypeError, "in method 'coalesceImages', argument 2 is not an array");
        }
      }
    }
    
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR coalesceImages< ImageListIterator,ImageListContainer >(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      if (arg1 != nullptr) {
        Napi::Array array = Napi::Array::New(env, arg1->size());
        size_t i = 0;
        // Iterate over the std::Container using standard C++ semantics
        for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
          Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
          array.Set(i, element);
        }
        jsresult = array;
      } else {
        jsresult = env.Null();
      }
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_function
Napi::Value _wrap_deconstructImages(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  ImageListContainer *arg1 = (ImageListContainer *) 0 ;
  ImageListIterator arg2 ;
  ImageListIterator arg3 ;
  ImageListContainer temp_list1 ;
  ImageListContainer temp_list2 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    if(static_cast<int>(info.Length()) < 1 || static_cast<int>(info.Length()) > 1) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_deconstructImages.");
    }
    
    {
      arg1 = &temp_list1;
    }
    {
      {
        if (info[0].IsArray()) {
          Napi::Array array = info[0].As<Napi::Array>();
          for (size_t i = 0; i < array.Length(); i++) {
            Magick::Image *im = nullptr;
            if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
              SWIG_exception_fail(SWIG_TypeError, "in method 'deconstructImages', array element is not an Image");
            }
            // Emplace the newly constructed copies in the std::container
            temp_list2.emplace_back(Magick::Image(*im));
          }
          arg2 = temp_list2.begin();
          arg3 = temp_list2.end();
        } else {
          SWIG_exception_fail(SWIG_TypeError, "in method 'deconstructImages', argument 2 is not an array");
        }
      }
    }
    
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR deconstructImages< ImageListIterator,ImageListContainer >(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      if (arg1 != nullptr) {
        Napi::Array array = Napi::Array::New(env, arg1->size());
        size_t i = 0;
        // Iterate over the std::Container using standard C++ semantics
        for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
          Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
          array.Set(i, element);
        }
        jsresult = array;
      } else {
        jsresult = env.Null();
      }
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function_async
Napi::Value _wrap_forwardFourierTransformImageAsync__SWIG_0(const Napi::CallbackInfo &info) {
  // js_async_worker_local_class
  class _std_CoordinateList__wrap_forwardFourierTransformImageAsync__SWIG_0_Tasklet : public SWIG_NAPI_AsyncContext {
    Napi::Env env;
    ImageListContainer *arg1 = (ImageListContainer *) 0 ;
    Magick::Image *arg2 = 0 ;
    ImageListContainer temp_list1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    // js_locks_list
    SWIG_Locks_List SWIG_locks;
    
  public:
    _std_CoordinateList__wrap_forwardFourierTransformImageAsync__SWIG_0_Tasklet(Napi::Env _env)
    :SWIG_NAPI_AsyncContext(_env), env(_env) {
      
    }
    
    virtual void SWIG_NAPI_Execute() override {
      // This runs the action code in a worker thread and V8 is not accessible
      Napi::Env env(SWIG_NULLPTR);
      
      // js_guard
      SWIG_Guard SWIG_guard(SWIG_locks);
      
      
      // js_lock
      SWIG_guard.lock();
      
      
      Magick::SWIGTEMPLATEDISAMBIGUATOR forwardFourierTransformImage< ImageListContainer >(arg1,(Magick::Image const &)*arg2);
      
      goto fail;
    fail:
      return;
    }
    
#ifdef NAPI_CPP_EXCEPTIONS
    virtual void SWIG_NAPI_Rethrow(const std::exception_ptr &saved) override {
      // Back in the main thread with V8 access, caller has HandleScope
      
      {
        try {
          if (saved) std::rethrow_exception(saved);
        } catch (const Magick::Exception &e) {
          do {
            SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
          } while (0);
          SWIG_fail;
        }
      }
      
      
    }
#endif
    
    virtual void SWIG_NAPI_Resolve() override {
      // Back in the main thread with V8 access, caller has HandleScope
      Napi::Value jsresult;
      jsresult = env.Undefined();
      {
        if (arg1 != nullptr) {
          Napi::Array array = Napi::Array::New(env, arg1->size());
          size_t i = 0;
          // Iterate over the std::Container using standard C++ semantics
          for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
            Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
            array.Set(i, element);
          }
          jsresult = array;
        } else {
          jsresult = env.Null();
        }
      }
      
      if (!SWIG_NAPI_Cleanup()) goto fail;
      SWIG_NAPI_deferred_finalized = true;
      SWIG_NAPI_deferred.Resolve(jsresult);
      goto fail;
    fail:
      return;
    }
    
    virtual bool SWIG_NAPI_Cleanup() override {
      return true;
      goto fail;
    fail:
      return false;
    }
    
    virtual Status SWIG_NAPI_Init(const Napi::CallbackInfo &info) override {
      {
        arg1 = &temp_list1;
      }
      res2 = SWIG_ConvertPtr(info[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
      if (!SWIG_IsOK(res2)) {
        SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "forwardFourierTransformImage" "', argument " "2"" of type '" "Magick::Image const &""'"); 
      }
      if (!argp2) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "forwardFourierTransformImage" "', argument " "2"" of type '" "Magick::Image const &""'"); 
      }
      arg2 = reinterpret_cast< Magick::Image * >(argp2);
#define SWIG_NAPI_Raise SWIG_NAPI_Reject
      {
        SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
        if (info[0].IsObject()) {
          Napi::Object obj;
          NAPI_CHECK_RESULT(info[0].ToObject(), obj);
          if (SWIG_NAPI_IsWrappedObject(env, obj)) {
            ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
            if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
              SWIG_locks.insert({
                reinterpret_cast<void*>(ow), {
                  [ow](){
                    ow->lock();
                  }, [ow](){
                    ow->unlock();
                  }
                  }
              });
            }
          }
        }
      }
      
#undef SWIG_NAPI_Raise
      return Status::OK;
      goto fail;
    fail:
      return Status::THROW;
    }
  };
  
  Napi::Env env = info.Env();
  _std_CoordinateList__wrap_forwardFourierTransformImageAsync__SWIG_0_Tasklet *context = SWIG_NULLPTR;
  SWIG_NAPI_AsyncWorker *worker = SWIG_NULLPTR;
  if(static_cast<int>(info.Length()) < 1 || static_cast<int>(info.Length()) > 1) {
    SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_forwardFourierTransformImageAsync__SWIG_0.");
  }
  context = new _std_CoordinateList__wrap_forwardFourierTransformImageAsync__SWIG_0_Tasklet(env);
  worker = new SWIG_NAPI_AsyncWorker(
    env, "SWIG__wrap_forwardFourierTransformImageAsync__SWIG_0_Async_Worker", context);
  return worker->Run(info);
#ifdef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_forwardFourierTransformImage__SWIG_0(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  ImageListContainer *arg1 = (ImageListContainer *) 0 ;
  Magick::Image *arg2 = 0 ;
  ImageListContainer temp_list1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    {
      arg1 = &temp_list1;
    }
    res2 = SWIG_ConvertPtr(info[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "forwardFourierTransformImage" "', argument " "2"" of type '" "Magick::Image const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "forwardFourierTransformImage" "', argument " "2"" of type '" "Magick::Image const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Image * >(argp2);
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[0].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[0].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR forwardFourierTransformImage< ImageListContainer >(arg1,(Magick::Image const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      if (arg1 != nullptr) {
        Napi::Array array = Napi::Array::New(env, arg1->size());
        size_t i = 0;
        // Iterate over the std::Container using standard C++ semantics
        for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
          Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
          array.Set(i, element);
        }
        jsresult = array;
      } else {
        jsresult = env.Null();
      }
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function_async
Napi::Value _wrap_forwardFourierTransformImageAsync__SWIG_1(const Napi::CallbackInfo &info) {
  // js_async_worker_local_class
  class _std_CoordinateList__wrap_forwardFourierTransformImageAsync__SWIG_1_Tasklet : public SWIG_NAPI_AsyncContext {
    Napi::Env env;
    ImageListContainer *arg1 = (ImageListContainer *) 0 ;
    Magick::Image *arg2 = 0 ;
    bool arg3 ;
    ImageListContainer temp_list1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    bool val3 ;
    int ecode3 = 0 ;
    
    // js_locks_list
    SWIG_Locks_List SWIG_locks;
    
  public:
    _std_CoordinateList__wrap_forwardFourierTransformImageAsync__SWIG_1_Tasklet(Napi::Env _env)
    :SWIG_NAPI_AsyncContext(_env), env(_env) {
      
    }
    
    virtual void SWIG_NAPI_Execute() override {
      // This runs the action code in a worker thread and V8 is not accessible
      Napi::Env env(SWIG_NULLPTR);
      
      // js_guard
      SWIG_Guard SWIG_guard(SWIG_locks);
      
      
      // js_lock
      SWIG_guard.lock();
      
      
      Magick::SWIGTEMPLATEDISAMBIGUATOR forwardFourierTransformImage< ImageListContainer >(arg1,(Magick::Image const &)*arg2,arg3);
      
      goto fail;
    fail:
      return;
    }
    
#ifdef NAPI_CPP_EXCEPTIONS
    virtual void SWIG_NAPI_Rethrow(const std::exception_ptr &saved) override {
      // Back in the main thread with V8 access, caller has HandleScope
      
      {
        try {
          if (saved) std::rethrow_exception(saved);
        } catch (const Magick::Exception &e) {
          do {
            SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
          } while (0);
          SWIG_fail;
        }
      }
      
      
    }
#endif
    
    virtual void SWIG_NAPI_Resolve() override {
      // Back in the main thread with V8 access, caller has HandleScope
      Napi::Value jsresult;
      jsresult = env.Undefined();
      {
        if (arg1 != nullptr) {
          Napi::Array array = Napi::Array::New(env, arg1->size());
          size_t i = 0;
          // Iterate over the std::Container using standard C++ semantics
          for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
            Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
            array.Set(i, element);
          }
          jsresult = array;
        } else {
          jsresult = env.Null();
        }
      }
      
      if (!SWIG_NAPI_Cleanup()) goto fail;
      SWIG_NAPI_deferred_finalized = true;
      SWIG_NAPI_deferred.Resolve(jsresult);
      goto fail;
    fail:
      return;
    }
    
    virtual bool SWIG_NAPI_Cleanup() override {
      return true;
      goto fail;
    fail:
      return false;
    }
    
    virtual Status SWIG_NAPI_Init(const Napi::CallbackInfo &info) override {
      {
        arg1 = &temp_list1;
      }
      res2 = SWIG_ConvertPtr(info[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
      if (!SWIG_IsOK(res2)) {
        SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "forwardFourierTransformImage" "', argument " "2"" of type '" "Magick::Image const &""'"); 
      }
      if (!argp2) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "forwardFourierTransformImage" "', argument " "2"" of type '" "Magick::Image const &""'"); 
      }
      arg2 = reinterpret_cast< Magick::Image * >(argp2);ecode3 = SWIG_AsVal_bool(info[1], &val3);
      if (!SWIG_IsOK(ecode3)) {
        SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "forwardFourierTransformImage" "', argument " "3"" of type '" "bool""'");
      } 
      arg3 = static_cast< bool >(val3);
#define SWIG_NAPI_Raise SWIG_NAPI_Reject
      {
        SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
        if (info[0].IsObject()) {
          Napi::Object obj;
          NAPI_CHECK_RESULT(info[0].ToObject(), obj);
          if (SWIG_NAPI_IsWrappedObject(env, obj)) {
            ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
            if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
              SWIG_locks.insert({
                reinterpret_cast<void*>(ow), {
                  [ow](){
                    ow->lock();
                  }, [ow](){
                    ow->unlock();
                  }
                  }
              });
            }
          }
        }
      }
      
#undef SWIG_NAPI_Raise
      return Status::OK;
      goto fail;
    fail:
      return Status::THROW;
    }
  };
  
  Napi::Env env = info.Env();
  _std_CoordinateList__wrap_forwardFourierTransformImageAsync__SWIG_1_Tasklet *context = SWIG_NULLPTR;
  SWIG_NAPI_AsyncWorker *worker = SWIG_NULLPTR;
  if(static_cast<int>(info.Length()) < 2 || static_cast<int>(info.Length()) > 2) {
    SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_forwardFourierTransformImageAsync__SWIG_1.");
  }
  context = new _std_CoordinateList__wrap_forwardFourierTransformImageAsync__SWIG_1_Tasklet(env);
  worker = new SWIG_NAPI_AsyncWorker(
    env, "SWIG__wrap_forwardFourierTransformImageAsync__SWIG_1_Async_Worker", context);
  return worker->Run(info);
#ifdef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}



// js_global_function_dispatcher
Napi::Value _wrap_Magick__wrap_forwardFourierTransformImageAsync(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 1 && static_cast<int>(info.Length()) <= 1) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_forwardFourierTransformImageAsync__SWIG_0(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_forwardFourierTransformImageAsync__SWIG_0(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_forwardFourierTransformImageAsync__SWIG_1(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_forwardFourierTransformImageAsync__SWIG_1(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  
  SWIG_Error(SWIG_ERROR, "Illegal arguments for function forwardFourierTransformImageAsync.");
  
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_forwardFourierTransformImage__SWIG_1(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  ImageListContainer *arg1 = (ImageListContainer *) 0 ;
  Magick::Image *arg2 = 0 ;
  bool arg3 ;
  ImageListContainer temp_list1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    {
      arg1 = &temp_list1;
    }
    res2 = SWIG_ConvertPtr(info[0], &argp2, SWIGTYPE_p_Magick__Image,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "forwardFourierTransformImage" "', argument " "2"" of type '" "Magick::Image const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "forwardFourierTransformImage" "', argument " "2"" of type '" "Magick::Image const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Image * >(argp2);ecode3 = SWIG_AsVal_bool(info[1], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "forwardFourierTransformImage" "', argument " "3"" of type '" "bool""'");
    } 
    arg3 = static_cast< bool >(val3);
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[0].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[0].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR forwardFourierTransformImage< ImageListContainer >(arg1,(Magick::Image const &)*arg2,arg3);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      if (arg1 != nullptr) {
        Napi::Array array = Napi::Array::New(env, arg1->size());
        size_t i = 0;
        // Iterate over the std::Container using standard C++ semantics
        for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
          Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
          array.Set(i, element);
        }
        jsresult = array;
      } else {
        jsresult = env.Null();
      }
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_function_dispatcher
Napi::Value _wrap_Magick__wrap_forwardFourierTransformImage(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 1 && static_cast<int>(info.Length()) <= 1) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_forwardFourierTransformImage__SWIG_0(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_forwardFourierTransformImage__SWIG_0(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  // js_function_dispatch_case
  if(static_cast<int>(info.Length()) >= 2 && static_cast<int>(info.Length()) <= 2) {
#ifdef NAPI_CPP_EXCEPTIONS
    bool tryNext = false;
    try {
      jsresult = _wrap_forwardFourierTransformImage__SWIG_1(info);
    } catch (const Napi::TypeError &) {
      tryNext = true;
    } catch (const Napi::Error &e) {
      throw e;
    }
    if (!tryNext)
    return jsresult;
#else
    _wrap_forwardFourierTransformImage__SWIG_1(info);
    if (env.IsExceptionPending()) {
      Napi::Error e = env.GetAndClearPendingException();
      Napi::Value typeErrorValue;
      bool isTypeError;
      Napi::Function typeErrorCons;
      // Yes, this is ugly
      // TODO: Fix this in Node.js when the core team grows up
      NAPI_CHECK_RESULT(env.Global().Get("TypeError"), typeErrorValue);
      typeErrorCons = typeErrorValue.As<Napi::Function>();
      NAPI_CHECK_RESULT(e.Value().InstanceOf(typeErrorCons), isTypeError);
      if (!isTypeError) {
        // This is not the error you are looking for
        e.ThrowAsJavaScriptException();
        SWIG_fail;
      }
    } else {
      return jsresult;
    }
#endif
  }
  
  
  SWIG_Error(SWIG_ERROR, "Illegal arguments for function forwardFourierTransformImage.");
  
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}



// js_global_function
Napi::Value _wrap_montageImages(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  ImageListContainer *arg1 = (ImageListContainer *) 0 ;
  ImageListIterator arg2 ;
  ImageListIterator arg3 ;
  Magick::Montage *arg4 = 0 ;
  ImageListContainer temp_list1 ;
  ImageListContainer temp_list2 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    if(static_cast<int>(info.Length()) < 2 || static_cast<int>(info.Length()) > 2) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_montageImages.");
    }
    
    {
      arg1 = &temp_list1;
    }
    {
      {
        if (info[0].IsArray()) {
          Napi::Array array = info[0].As<Napi::Array>();
          for (size_t i = 0; i < array.Length(); i++) {
            Magick::Image *im = nullptr;
            if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
              SWIG_exception_fail(SWIG_TypeError, "in method 'montageImages', array element is not an Image");
            }
            // Emplace the newly constructed copies in the std::container
            temp_list2.emplace_back(Magick::Image(*im));
          }
          arg2 = temp_list2.begin();
          arg3 = temp_list2.end();
        } else {
          SWIG_exception_fail(SWIG_TypeError, "in method 'montageImages', argument 2 is not an array");
        }
      }
    }
    res4 = SWIG_ConvertPtr(info[1], &argp4, SWIGTYPE_p_Magick__Montage,  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "montageImages" "', argument " "4"" of type '" "Magick::Montage const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "montageImages" "', argument " "4"" of type '" "Magick::Montage const &""'"); 
    }
    arg4 = reinterpret_cast< Magick::Montage * >(argp4);
    {
      SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
      if (info[1].IsObject()) {
        Napi::Object obj;
        NAPI_CHECK_RESULT(info[1].ToObject(), obj);
        if (SWIG_NAPI_IsWrappedObject(env, obj)) {
          ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
          if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
            SWIG_locks.insert({
              reinterpret_cast<void*>(ow), {
                [ow](){
                  ow->lock();
                }, [ow](){
                  ow->unlock();
                }
                }
            });
          }
        }
      }
    }
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR montageImages< ImageListContainer,ImageListIterator >(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3),(Magick::Montage const &)*arg4);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      if (arg1 != nullptr) {
        Napi::Array array = Napi::Array::New(env, arg1->size());
        size_t i = 0;
        // Iterate over the std::Container using standard C++ semantics
        for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
          Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
          array.Set(i, element);
        }
        jsresult = array;
      } else {
        jsresult = env.Null();
      }
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_function
Napi::Value _wrap_morphImages(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  ImageListContainer *arg1 = (ImageListContainer *) 0 ;
  ImageListIterator arg2 ;
  ImageListIterator arg3 ;
  size_t arg4 ;
  ImageListContainer temp_list1 ;
  ImageListContainer temp_list2 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    if(static_cast<int>(info.Length()) < 2 || static_cast<int>(info.Length()) > 2) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_morphImages.");
    }
    
    {
      arg1 = &temp_list1;
    }
    {
      {
        if (info[0].IsArray()) {
          Napi::Array array = info[0].As<Napi::Array>();
          for (size_t i = 0; i < array.Length(); i++) {
            Magick::Image *im = nullptr;
            if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(array.Get(i), reinterpret_cast<void **>(&im), SWIGTYPE_p_Magick__Image, 0)) || im == nullptr) {
              SWIG_exception_fail(SWIG_TypeError, "in method 'morphImages', array element is not an Image");
            }
            // Emplace the newly constructed copies in the std::container
            temp_list2.emplace_back(Magick::Image(*im));
          }
          arg2 = temp_list2.begin();
          arg3 = temp_list2.end();
        } else {
          SWIG_exception_fail(SWIG_TypeError, "in method 'morphImages', argument 2 is not an array");
        }
      }
    }
    ecode4 = SWIG_AsVal_unsigned_SS_int(info[1], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "morphImages" "', argument " "4"" of type '" "size_t""'");
    } 
    arg4 = static_cast< size_t >(val4);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR morphImages< ImageListIterator,ImageListContainer >(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3),SWIG_STD_MOVE(arg4));
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      if (arg1 != nullptr) {
        Napi::Array array = Napi::Array::New(env, arg1->size());
        size_t i = 0;
        // Iterate over the std::Container using standard C++ semantics
        for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
          Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
          array.Set(i, element);
        }
        jsresult = array;
      } else {
        jsresult = env.Null();
      }
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function_async
Napi::Value _wrap_readImagesAsync__SWIG_0(const Napi::CallbackInfo &info) {
  // js_async_worker_local_class
  class _std_CoordinateList__wrap_readImagesAsync__SWIG_0_Tasklet : public SWIG_NAPI_AsyncContext {
    Napi::Env env;
    ImageListContainer *arg1 = (ImageListContainer *) 0 ;
    std::string *arg2 = 0 ;
    Magick::ReadOptions *arg3 = 0 ;
    ImageListContainer temp_list1 ;
    int res2 = SWIG_OLDOBJ ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    
    // js_locks_list
    SWIG_Locks_List SWIG_locks;
    
  public:
    _std_CoordinateList__wrap_readImagesAsync__SWIG_0_Tasklet(Napi::Env _env)
    :SWIG_NAPI_AsyncContext(_env), env(_env) {
      
    }
    
    virtual void SWIG_NAPI_Execute() override {
      // This runs the action code in a worker thread and V8 is not accessible
      Napi::Env env(SWIG_NULLPTR);
      
      // js_guard
      SWIG_Guard SWIG_guard(SWIG_locks);
      
      
      // js_lock
      SWIG_guard.lock();
      
      
      Magick::SWIGTEMPLATEDISAMBIGUATOR readImages< ImageListContainer >(arg1,(std::string const &)*arg2,*arg3);
      
      goto fail;
    fail:
      return;
    }
    
#ifdef NAPI_CPP_EXCEPTIONS
    virtual void SWIG_NAPI_Rethrow(const std::exception_ptr &saved) override {
      // Back in the main thread with V8 access, caller has HandleScope
      
      {
        try {
          if (saved) std::rethrow_exception(saved);
        } catch (const Magick::Exception &e) {
          do {
            SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
          } while (0);
          SWIG_fail;
        }
      }
      
      
    }
#endif
    
    virtual void SWIG_NAPI_Resolve() override {
      // Back in the main thread with V8 access, caller has HandleScope
      Napi::Value jsresult;
      jsresult = env.Undefined();
      {
        if (arg1 != nullptr) {
          Napi::Array array = Napi::Array::New(env, arg1->size());
          size_t i = 0;
          // Iterate over the std::Container using standard C++ semantics
          for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
            Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
            array.Set(i, element);
          }
          jsresult = array;
        } else {
          jsresult = env.Null();
        }
      }
      
      if (!SWIG_NAPI_Cleanup()) goto fail;
      SWIG_NAPI_deferred_finalized = true;
      SWIG_NAPI_deferred.Resolve(jsresult);
      goto fail;
    fail:
      return;
    }
    
    virtual bool SWIG_NAPI_Cleanup() override {
      if (SWIG_IsNewObj(res2)) delete arg2;
      
      return true;
      goto fail;
    fail:
      return false;
    }
    
    virtual Status SWIG_NAPI_Init(const Napi::CallbackInfo &info) override {
      {
        arg1 = &temp_list1;
      }
      {
        {
          std::string *ptr = (std::string *)0;
          res2 = SWIG_AsPtr_std_string(info[0], &ptr);
          if (!SWIG_IsOK(res2)) {
            SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "readImages" "', argument " "2"" of type '" "std::string const &""'"); 
          }
          if (!ptr) {
            SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "readImages" "', argument " "2"" of type '" "std::string const &""'"); 
          }
          arg2 = ptr;
        }
      }
      res3 = SWIG_ConvertPtr(info[1], &argp3, SWIGTYPE_p_Magick__ReadOptions,  0 );
      if (!SWIG_IsOK(res3)) {
        SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "readImages" "', argument " "3"" of type '" "Magick::ReadOptions &""'"); 
      }
      if (!argp3) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "readImages" "', argument " "3"" of type '" "Magick::ReadOptions &""'"); 
      }
      arg3 = reinterpret_cast< Magick::ReadOptions * >(argp3);
#define SWIG_NAPI_Raise SWIG_NAPI_Reject
      
#undef SWIG_NAPI_Raise
      return Status::OK;
      goto fail;
    fail:
      return Status::THROW;
    }
  };
  
  Napi::Env env = info.Env();
  _std_CoordinateList__wrap_readImagesAsync__SWIG_0_Tasklet *context = SWIG_NULLPTR;
  SWIG_NAPI_AsyncWorker *worker = SWIG_NULLPTR;
  if(static_cast<int>(info.Length()) < 2 || static_cast<int>(info.Length()) > 2) {
    SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_readImagesAsync__SWIG_0.");
  }
  context = new _std_CoordinateList__wrap_readImagesAsync__SWIG_0_Tasklet(env);
  worker = new SWIG_NAPI_AsyncWorker(
    env, "SWIG__wrap_readImagesAsync__SWIG_0_Async_Worker", context);
  return worker->Run(info);
#ifdef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_readImages__SWIG_0(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  ImageListContainer *arg1 = (ImageListContainer *) 0 ;
  std::string *arg2 = 0 ;
  Magick::ReadOptions *arg3 = 0 ;
  ImageListContainer temp_list1 ;
  int res2 = SWIG_OLDOBJ ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    {
      arg1 = &temp_list1;
    }
    {
      {
        std::string *ptr = (std::string *)0;
        res2 = SWIG_AsPtr_std_string(info[0], &ptr);
        if (!SWIG_IsOK(res2)) {
          SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "readImages" "', argument " "2"" of type '" "std::string const &""'"); 
        }
        if (!ptr) {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "readImages" "', argument " "2"" of type '" "std::string const &""'"); 
        }
        arg2 = ptr;
      }
    }
    res3 = SWIG_ConvertPtr(info[1], &argp3, SWIGTYPE_p_Magick__ReadOptions,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "readImages" "', argument " "3"" of type '" "Magick::ReadOptions &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "readImages" "', argument " "3"" of type '" "Magick::ReadOptions &""'"); 
    }
    arg3 = reinterpret_cast< Magick::ReadOptions * >(argp3);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR readImages< ImageListContainer >(arg1,(std::string const &)*arg2,*arg3);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      if (arg1 != nullptr) {
        Napi::Array array = Napi::Array::New(env, arg1->size());
        size_t i = 0;
        // Iterate over the std::Container using standard C++ semantics
        for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
          Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
          array.Set(i, element);
        }
        jsresult = array;
      } else {
        jsresult = env.Null();
      }
    }
    
    if (SWIG_IsNewObj(res2)) delete arg2;
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    if (SWIG_IsNewObj(res2)) delete arg2;
    
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function_async
Napi::Value _wrap_readImagesAsync__SWIG_1(const Napi::CallbackInfo &info) {
  // js_async_worker_local_class
  class _std_CoordinateList__wrap_readImagesAsync__SWIG_1_Tasklet : public SWIG_NAPI_AsyncContext {
    Napi::Env env;
    ImageListContainer *arg1 = (ImageListContainer *) 0 ;
    std::string *arg2 = 0 ;
    ImageListContainer temp_list1 ;
    int res2 = SWIG_OLDOBJ ;
    
    // js_locks_list
    SWIG_Locks_List SWIG_locks;
    
  public:
    _std_CoordinateList__wrap_readImagesAsync__SWIG_1_Tasklet(Napi::Env _env)
    :SWIG_NAPI_AsyncContext(_env), env(_env) {
      
    }
    
    virtual void SWIG_NAPI_Execute() override {
      // This runs the action code in a worker thread and V8 is not accessible
      Napi::Env env(SWIG_NULLPTR);
      
      // js_guard
      SWIG_Guard SWIG_guard(SWIG_locks);
      
      
      // js_lock
      SWIG_guard.lock();
      
      
      Magick::SWIGTEMPLATEDISAMBIGUATOR readImages< ImageListContainer >(arg1,(std::string const &)*arg2);
      
      goto fail;
    fail:
      return;
    }
    
#ifdef NAPI_CPP_EXCEPTIONS
    virtual void SWIG_NAPI_Rethrow(const std::exception_ptr &saved) override {
      // Back in the main thread with V8 access, caller has HandleScope
      
      {
        try {
          if (saved) std::rethrow_exception(saved);
        } catch (const Magick::Exception &e) {
          do {
            SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
          } while (0);
          SWIG_fail;
        }
      }
      
      
    }
#endif
    
    virtual void SWIG_NAPI_Resolve() override {
      // Back in the main thread with V8 access, caller has HandleScope
      Napi::Value jsresult;
      jsresult = env.Undefined();
      {
        if (arg1 != nullptr) {
          Napi::Array array = Napi::Array::New(env, arg1->size());
          size_t i = 0;
          // Iterate over the std::Container using standard C++ semantics
          for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
            Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
            array.Set(i, element);
          }
          jsresult = array;
        } else {
          jsresult = env.Null();
        }
      }
      
      if (!SWIG_NAPI_Cleanup()) goto fail;
      SWIG_NAPI_deferred_finalized = true;
      SWIG_NAPI_deferred.Resolve(jsresult);
      goto fail;
    fail:
      return;
    }
    
    virtual bool SWIG_NAPI_Cleanup() override {
      if (SWIG_IsNewObj(res2)) delete arg2;
      
      return true;
      goto fail;
    fail:
      return false;
    }
    
    virtual Status SWIG_NAPI_Init(const Napi::CallbackInfo &info) override {
      {
        arg1 = &temp_list1;
      }
      {
        {
          std::string *ptr = (std::string *)0;
          res2 = SWIG_AsPtr_std_string(info[0], &ptr);
          if (!SWIG_IsOK(res2)) {
            SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "readImages" "', argument " "2"" of type '" "std::string const &""'"); 
          }
          if (!ptr) {
            SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "readImages" "', argument " "2"" of type '" "std::string const &""'"); 
          }
          arg2 = ptr;
        }
      }
      
#define SWIG_NAPI_Raise SWIG_NAPI_Reject
      
#undef SWIG_NAPI_Raise
      return Status::OK;
      goto fail;
    fail:
      return Status::THROW;
    }
  };
  
  Napi::Env env = info.Env();
  _std_CoordinateList__wrap_readImagesAsync__SWIG_1_Tasklet *context = SWIG_NULLPTR;
  SWIG_NAPI_AsyncWorker *worker = SWIG_NULLPTR;
  if(static_cast<int>(info.Length()) < 1 || static_cast<int>(info.Length()) > 1) {
    SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_readImagesAsync__SWIG_1.");
  }
  context = new _std_CoordinateList__wrap_readImagesAsync__SWIG_1_Tasklet(env);
  worker = new SWIG_NAPI_AsyncWorker(
    env, "SWIG__wrap_readImagesAsync__SWIG_1_Async_Worker", context);
  return worker->Run(info);
#ifdef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_readImages__SWIG_1(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  ImageListContainer *arg1 = (ImageListContainer *) 0 ;
  std::string *arg2 = 0 ;
  ImageListContainer temp_list1 ;
  int res2 = SWIG_OLDOBJ ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    {
      arg1 = &temp_list1;
    }
    {
      {
        std::string *ptr = (std::string *)0;
        res2 = SWIG_AsPtr_std_string(info[0], &ptr);
        if (!SWIG_IsOK(res2)) {
          SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "readImages" "', argument " "2"" of type '" "std::string const &""'"); 
        }
        if (!ptr) {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "readImages" "', argument " "2"" of type '" "std::string const &""'"); 
        }
        arg2 = ptr;
      }
    }
    
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SWIGTEMPLATEDISAMBIGUATOR readImages< ImageListContainer >(arg1,(std::string const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    {
      if (arg1 != nullptr) {
        Napi::Array array = Napi::Array::New(env, arg1->size());
        size_t i = 0;
        // Iterate over the std::Container using standard C++ semantics
        for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
          Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
          array.Set(i, element);
        }
        jsresult = array;
      } else {
        jsresult = env.Null();
      }
    }
    
    if (SWIG_IsNewObj(res2)) delete arg2;
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    if (SWIG_IsNewObj(res2)) delete arg2;
    
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function_async
Napi::Value _wrap_readImagesAsync__SWIG_2(const Napi::CallbackInfo &info) {
  // js_async_worker_local_class
  class _std_CoordinateList__wrap_readImagesAsync__SWIG_2_Tasklet : public SWIG_NAPI_AsyncContext {
    Napi::Env env;
    ImageListContainer *arg1 = (ImageListContainer *) 0 ;
    Magick::Blob *arg2 = 0 ;
    Magick::ReadOptions *arg3 = 0 ;
    ImageListContainer temp_list1 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    void *argp3 = 0 ;
    int res3 = 0 ;
    
    // js_locks_list
    SWIG_Locks_List SWIG_locks;
    
  public:
    _std_CoordinateList__wrap_readImagesAsync__SWIG_2_Tasklet(Napi::Env _env)
    :SWIG_NAPI_AsyncContext(_env), env(_env) {
      
    }
    
    virtual void SWIG_NAPI_Execute() override {
      // This runs the action code in a worker thread and V8 is not accessible
      Napi::Env env(SWIG_NULLPTR);
      
      // js_guard
      SWIG_Guard SWIG_guard(SWIG_locks);
      
      
      // js_lock
      SWIG_guard.lock();
      
      
      Magick::SWIGTEMPLATEDISAMBIGUATOR readImages< ImageListContainer >(arg1,(Magick::Blob const &)*arg2,*arg3);
      
      goto fail;
    fail:
      return;
    }
    
#ifdef NAPI_CPP_EXCEPTIONS
    virtual void SWIG_NAPI_Rethrow(const std::exception_ptr &saved) override {
      // Back in the main thread with V8 access, caller has HandleScope
      
      {
        try {
          if (saved) std::rethrow_exception(saved);
        } catch (const Magick::Exception &e) {
          do {
            SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
          } while (0);
          SWIG_fail;
        }
      }
      
      
    }
#endif
    
    virtual void SWIG_NAPI_Resolve() override {
      // Back in the main thread with V8 access, caller has HandleScope
      Napi::Value jsresult;
      jsresult = env.Undefined();
      {
        if (arg1 != nullptr) {
          Napi::Array array = Napi::Array::New(env, arg1->size());
          size_t i = 0;
          // Iterate over the std::Container using standard C++ semantics
          for (auto it = arg1->begin(); it != arg1->end(); it++, i++) {
            Napi::Value element = SWIG_NAPI_NewPointerObj(env, new Magick::Image(*it), SWIGTYPE_p_Magick__Image, SWIG_POINTER_OWN);
            array.Set(i, element);
          }
          jsresult = array;
        } else {
          jsresult = env.Null();
        }
      }
      
      if (!SWIG_NAPI_Cleanup()) goto fail;
      SWIG_NAPI_deferred_finalized = true;
      SWIG_NAPI_deferred.Resolve(jsresult);
      goto fail;
    fail:
      return;
    }
    
    virtual bool SWIG_NAPI_Cleanup() override {
      return true;
      goto fail;
    fail:
      return false;
    }
    
    virtual Status SWIG_NAPI_Init(const Napi::CallbackInfo &info) override {
      {
        arg1 = &temp_list1;
      }
      res2 = SWIG_ConvertPtr(info[0], &argp2, SWIGTYPE_p_Magick__Blob,  0 );
      if (!SWIG_IsOK(res2)) {
        SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "readImages" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
      }
      if (!argp2) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "readImages" "', argument " "2"" of type '" "Magick::Blob const &""'"); 
      }
      arg2 = reinterpret_cast< Magick::Blob * >(argp2);res3 = SWIG_ConvertPtr(info[1], &argp3, SWIGTYPE_p_Magick__ReadOptions,  0 );
      if (!SWIG_IsOK(res3)) {
        SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "readImages" "', argument " "3"" of type '" "Magick::ReadOptions &""'"); 
      }
      if (!argp3) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "readImages" "', argument " "3"" of type '" "Magick::ReadOptions &""'"); 
      }
      arg3 = reinterpret_cast< Magick::ReadOptions * >(argp3);
#define SWIG_NAPI_Raise SWIG_NAPI_Reject
      {
        SWIG_NAPI_ObjectWrap_inst *ow = SWIG_NULLPTR;
        if (info[0].IsObject()) {
          Napi::Object obj;
          NAPI_CHECK_RESULT(info[0].ToObject(), obj);
          if (SWIG_NAPI_IsWrappedObject(env, obj)) {
            ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
            if (ow != SWIG_NULLPTR && SWIG_locks.count(ow) == 0) {
              SWIG_locks.insert({
                reinterpret_cast<void*>(ow), {
                  [ow](){
                    ow->lock();
                  }, [ow](){
                    ow->unlock();
                  }
                  }
              });
            }
          }
        }
      }
      
#undef SWIG_NAPI_Raise
      return Status::OK;
      goto fail;
    fail:
      return Status::THROW;
    }
  };
  
  Napi::Env env = info.Env();
  _std_CoordinateList__wrap_readImagesAsync__SWIG_2_Tasklet *context = SWIG_NULLPTR;
  SWIG_NAPI_AsyncWorker *worker = SWIG_NULLPTR;
  if(static_cast<int>(info.Length()) < 2 || static_cast<int>(info.Length()) > 2) {
    SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_readImagesAsync__SWIG_2.");
  }
  context = new _std_CoordinateList__wrap_readImagesAsync__SWIG_2_Tasklet(env);
  worker = new SWIG_NAPI_AsyncWorker(
    env, "SWIG__wrap_readImagesAsync__SWIG_2_Async_Worker", context);
  return worker->Run(info);
#ifdef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
#endif
  return Napi::Value();
}


