/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.2.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

#include "swig/node-magickwand.h"

/* Class: DrawableScaling (_Magick_DrawableScaling) */
// jsnapi_getclass
Napi::Function _Magick_DrawableScaling_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_DrawableScaling_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_DrawableScaling_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_DrawableScaling_inst>::DefineClass(env, "DrawableScaling", symbolTable);
}

void _Magick_DrawableScaling_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_DrawableScaling_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_DrawableScaling_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_DrawableBase_templ<_Magick_DrawableBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_DrawableBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableBase_templ::InstanceMethod("call",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableBase_templ::InstanceMethod("copy",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableScaling_templ::InstanceMethod("call",
        &_Magick_DrawableScaling_templ::_wrap_Magick_DrawableScaling_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableScaling_templ::InstanceMethod("copy",
        &_Magick_DrawableScaling_templ::_wrap_Magick_DrawableScaling_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("x");
  members.insert({
    "x",
      _Magick_DrawableScaling_templ::InstanceMethod("x",
        &_Magick_DrawableScaling_templ::_wrap_DrawableScaling__wrap_Magick_DrawableScaling_x,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("y");
  members.insert({
    "y",
      _Magick_DrawableScaling_templ::InstanceMethod("y",
        &_Magick_DrawableScaling_templ::_wrap_DrawableScaling__wrap_Magick_DrawableScaling_y,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: DrawableSkewX (_Magick_DrawableSkewX) */
// jsnapi_getclass
Napi::Function _Magick_DrawableSkewX_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_DrawableSkewX_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_DrawableSkewX_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_DrawableSkewX_inst>::DefineClass(env, "DrawableSkewX", symbolTable);
}

void _Magick_DrawableSkewX_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_DrawableSkewX_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_DrawableSkewX_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_DrawableBase_templ<_Magick_DrawableBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_DrawableBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableBase_templ::InstanceMethod("call",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableBase_templ::InstanceMethod("copy",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableSkewX_templ::InstanceMethod("call",
        &_Magick_DrawableSkewX_templ::_wrap_Magick_DrawableSkewX_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableSkewX_templ::InstanceMethod("copy",
        &_Magick_DrawableSkewX_templ::_wrap_Magick_DrawableSkewX_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("angle");
  members.insert({
    "angle",
      _Magick_DrawableSkewX_templ::InstanceMethod("angle",
        &_Magick_DrawableSkewX_templ::_wrap_DrawableSkewX__wrap_Magick_DrawableSkewX_angle,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: DrawableSkewY (_Magick_DrawableSkewY) */
// jsnapi_getclass
Napi::Function _Magick_DrawableSkewY_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_DrawableSkewY_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_DrawableSkewY_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_DrawableSkewY_inst>::DefineClass(env, "DrawableSkewY", symbolTable);
}

void _Magick_DrawableSkewY_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_DrawableSkewY_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_DrawableSkewY_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_DrawableBase_templ<_Magick_DrawableBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_DrawableBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableBase_templ::InstanceMethod("call",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableBase_templ::InstanceMethod("copy",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableSkewY_templ::InstanceMethod("call",
        &_Magick_DrawableSkewY_templ::_wrap_Magick_DrawableSkewY_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableSkewY_templ::InstanceMethod("copy",
        &_Magick_DrawableSkewY_templ::_wrap_Magick_DrawableSkewY_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("angle");
  members.insert({
    "angle",
      _Magick_DrawableSkewY_templ::InstanceMethod("angle",
        &_Magick_DrawableSkewY_templ::_wrap_DrawableSkewY__wrap_Magick_DrawableSkewY_angle,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: DrawableStrokeDashArray (_Magick_DrawableStrokeDashArray) */
// jsnapi_getclass
Napi::Function _Magick_DrawableStrokeDashArray_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_DrawableStrokeDashArray_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_DrawableStrokeDashArray_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_DrawableStrokeDashArray_inst>::DefineClass(env, "DrawableStrokeDashArray", symbolTable);
}

void _Magick_DrawableStrokeDashArray_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_DrawableStrokeDashArray_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_DrawableStrokeDashArray_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_DrawableBase_templ<_Magick_DrawableBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_DrawableBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableBase_templ::InstanceMethod("call",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableBase_templ::InstanceMethod("copy",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableStrokeDashArray_templ::InstanceMethod("call",
        &_Magick_DrawableStrokeDashArray_templ::_wrap_Magick_DrawableStrokeDashArray_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableStrokeDashArray_templ::InstanceMethod("copy",
        &_Magick_DrawableStrokeDashArray_templ::_wrap_Magick_DrawableStrokeDashArray_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("dasharray");
  members.insert({
    "dasharray",
      _Magick_DrawableStrokeDashArray_templ::InstanceMethod("dasharray",
        &_Magick_DrawableStrokeDashArray_templ::_wrap_DrawableStrokeDashArray__wrap_Magick_DrawableStrokeDashArray_dasharray,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("clone");
  members.insert({
    "clone",
      _Magick_DrawableStrokeDashArray_templ::InstanceMethod("clone",
        &_Magick_DrawableStrokeDashArray_templ::_wrap_Magick_DrawableStrokeDashArray_clone,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: DrawableStrokeDashOffset (_Magick_DrawableStrokeDashOffset) */
// jsnapi_getclass
Napi::Function _Magick_DrawableStrokeDashOffset_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_DrawableStrokeDashOffset_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_DrawableStrokeDashOffset_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_DrawableStrokeDashOffset_inst>::DefineClass(env, "DrawableStrokeDashOffset", symbolTable);
}

void _Magick_DrawableStrokeDashOffset_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_DrawableStrokeDashOffset_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_DrawableStrokeDashOffset_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_DrawableBase_templ<_Magick_DrawableBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_DrawableBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableBase_templ::InstanceMethod("call",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableBase_templ::InstanceMethod("copy",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableStrokeDashOffset_templ::InstanceMethod("call",
        &_Magick_DrawableStrokeDashOffset_templ::_wrap_Magick_DrawableStrokeDashOffset_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableStrokeDashOffset_templ::InstanceMethod("copy",
        &_Magick_DrawableStrokeDashOffset_templ::_wrap_Magick_DrawableStrokeDashOffset_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("offset");
  members.insert({
    "offset",
      _Magick_DrawableStrokeDashOffset_templ::InstanceMethod("offset",
        &_Magick_DrawableStrokeDashOffset_templ::_wrap_DrawableStrokeDashOffset__wrap_Magick_DrawableStrokeDashOffset_offset,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: DrawableStrokeLineCap (_Magick_DrawableStrokeLineCap) */
// jsnapi_getclass
Napi::Function _Magick_DrawableStrokeLineCap_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_DrawableStrokeLineCap_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_DrawableStrokeLineCap_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_DrawableStrokeLineCap_inst>::DefineClass(env, "DrawableStrokeLineCap", symbolTable);
}

void _Magick_DrawableStrokeLineCap_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_DrawableStrokeLineCap_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_DrawableStrokeLineCap_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_DrawableBase_templ<_Magick_DrawableBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_DrawableBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableBase_templ::InstanceMethod("call",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableBase_templ::InstanceMethod("copy",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableStrokeLineCap_templ::InstanceMethod("call",
        &_Magick_DrawableStrokeLineCap_templ::_wrap_Magick_DrawableStrokeLineCap_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableStrokeLineCap_templ::InstanceMethod("copy",
        &_Magick_DrawableStrokeLineCap_templ::_wrap_Magick_DrawableStrokeLineCap_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("linecap");
  members.insert({
    "linecap",
      _Magick_DrawableStrokeLineCap_templ::InstanceMethod("linecap",
        &_Magick_DrawableStrokeLineCap_templ::_wrap_DrawableStrokeLineCap__wrap_Magick_DrawableStrokeLineCap_linecap,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: DrawableStrokeLineJoin (_Magick_DrawableStrokeLineJoin) */
// jsnapi_getclass
Napi::Function _Magick_DrawableStrokeLineJoin_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_DrawableStrokeLineJoin_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_DrawableStrokeLineJoin_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_DrawableStrokeLineJoin_inst>::DefineClass(env, "DrawableStrokeLineJoin", symbolTable);
}

void _Magick_DrawableStrokeLineJoin_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_DrawableStrokeLineJoin_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_DrawableStrokeLineJoin_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_DrawableBase_templ<_Magick_DrawableBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_DrawableBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableBase_templ::InstanceMethod("call",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableBase_templ::InstanceMethod("copy",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableStrokeLineJoin_templ::InstanceMethod("call",
        &_Magick_DrawableStrokeLineJoin_templ::_wrap_Magick_DrawableStrokeLineJoin_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableStrokeLineJoin_templ::InstanceMethod("copy",
        &_Magick_DrawableStrokeLineJoin_templ::_wrap_Magick_DrawableStrokeLineJoin_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("linejoin");
  members.insert({
    "linejoin",
      _Magick_DrawableStrokeLineJoin_templ::InstanceMethod("linejoin",
        &_Magick_DrawableStrokeLineJoin_templ::_wrap_DrawableStrokeLineJoin__wrap_Magick_DrawableStrokeLineJoin_linejoin,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: DrawableMiterLimit (_Magick_DrawableMiterLimit) */
// jsnapi_getclass
Napi::Function _Magick_DrawableMiterLimit_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_DrawableMiterLimit_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_DrawableMiterLimit_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_DrawableMiterLimit_inst>::DefineClass(env, "DrawableMiterLimit", symbolTable);
}

void _Magick_DrawableMiterLimit_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_DrawableMiterLimit_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_DrawableMiterLimit_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_DrawableBase_templ<_Magick_DrawableBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_DrawableBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableBase_templ::InstanceMethod("call",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableBase_templ::InstanceMethod("copy",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableMiterLimit_templ::InstanceMethod("call",
        &_Magick_DrawableMiterLimit_templ::_wrap_Magick_DrawableMiterLimit_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableMiterLimit_templ::InstanceMethod("copy",
        &_Magick_DrawableMiterLimit_templ::_wrap_Magick_DrawableMiterLimit_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("miterlimit");
  members.insert({
    "miterlimit",
      _Magick_DrawableMiterLimit_templ::InstanceMethod("miterlimit",
        &_Magick_DrawableMiterLimit_templ::_wrap_DrawableMiterLimit__wrap_Magick_DrawableMiterLimit_miterlimit,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: DrawableStrokePatternUrl (_Magick_DrawableStrokePatternUrl) */
// jsnapi_getclass
Napi::Function _Magick_DrawableStrokePatternUrl_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_DrawableStrokePatternUrl_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_DrawableStrokePatternUrl_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_DrawableStrokePatternUrl_inst>::DefineClass(env, "DrawableStrokePatternUrl", symbolTable);
}

void _Magick_DrawableStrokePatternUrl_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_DrawableStrokePatternUrl_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_DrawableStrokePatternUrl_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_DrawableBase_templ<_Magick_DrawableBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_DrawableBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableBase_templ::InstanceMethod("call",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableBase_templ::InstanceMethod("copy",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableStrokePatternUrl_templ::InstanceMethod("call",
        &_Magick_DrawableStrokePatternUrl_templ::_wrap_Magick_DrawableStrokePatternUrl_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("url");
  members.insert({
    "url",
      _Magick_DrawableStrokePatternUrl_templ::InstanceMethod("url",
        &_Magick_DrawableStrokePatternUrl_templ::_wrap_DrawableStrokePatternUrl__wrap_Magick_DrawableStrokePatternUrl_url,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableStrokePatternUrl_templ::InstanceMethod("copy",
        &_Magick_DrawableStrokePatternUrl_templ::_wrap_Magick_DrawableStrokePatternUrl_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: DrawableStrokeAntialias (_Magick_DrawableStrokeAntialias) */
// jsnapi_getclass
Napi::Function _Magick_DrawableStrokeAntialias_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_DrawableStrokeAntialias_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_DrawableStrokeAntialias_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_DrawableStrokeAntialias_inst>::DefineClass(env, "DrawableStrokeAntialias", symbolTable);
}

void _Magick_DrawableStrokeAntialias_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_DrawableStrokeAntialias_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_DrawableStrokeAntialias_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_DrawableBase_templ<_Magick_DrawableBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_DrawableBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableBase_templ::InstanceMethod("call",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableBase_templ::InstanceMethod("copy",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableStrokeAntialias_templ::InstanceMethod("call",
        &_Magick_DrawableStrokeAntialias_templ::_wrap_Magick_DrawableStrokeAntialias_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableStrokeAntialias_templ::InstanceMethod("copy",
        &_Magick_DrawableStrokeAntialias_templ::_wrap_Magick_DrawableStrokeAntialias_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("flag");
  members.insert({
    "flag",
      _Magick_DrawableStrokeAntialias_templ::InstanceMethod("flag",
        &_Magick_DrawableStrokeAntialias_templ::_wrap_DrawableStrokeAntialias__wrap_Magick_DrawableStrokeAntialias_flag,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: DrawableStrokeColor (_Magick_DrawableStrokeColor) */
// jsnapi_getclass
Napi::Function _Magick_DrawableStrokeColor_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_DrawableStrokeColor_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_DrawableStrokeColor_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_DrawableStrokeColor_inst>::DefineClass(env, "DrawableStrokeColor", symbolTable);
}

void _Magick_DrawableStrokeColor_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_DrawableStrokeColor_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_DrawableStrokeColor_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_DrawableBase_templ<_Magick_DrawableBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_DrawableBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableBase_templ::InstanceMethod("call",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableBase_templ::InstanceMethod("copy",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableStrokeColor_templ::InstanceMethod("call",
        &_Magick_DrawableStrokeColor_templ::_wrap_Magick_DrawableStrokeColor_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableStrokeColor_templ::InstanceMethod("copy",
        &_Magick_DrawableStrokeColor_templ::_wrap_Magick_DrawableStrokeColor_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("color");
  members.insert({
    "color",
      _Magick_DrawableStrokeColor_templ::InstanceMethod("color",
        &_Magick_DrawableStrokeColor_templ::_wrap_DrawableStrokeColor__wrap_Magick_DrawableStrokeColor_color,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: DrawableStrokeOpacity (_Magick_DrawableStrokeOpacity) */
// jsnapi_getclass
Napi::Function _Magick_DrawableStrokeOpacity_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_DrawableStrokeOpacity_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_DrawableStrokeOpacity_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_DrawableStrokeOpacity_inst>::DefineClass(env, "DrawableStrokeOpacity", symbolTable);
}

void _Magick_DrawableStrokeOpacity_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_DrawableStrokeOpacity_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_DrawableStrokeOpacity_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_DrawableBase_templ<_Magick_DrawableBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_DrawableBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableBase_templ::InstanceMethod("call",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableBase_templ::InstanceMethod("copy",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableStrokeOpacity_templ::InstanceMethod("call",
        &_Magick_DrawableStrokeOpacity_templ::_wrap_Magick_DrawableStrokeOpacity_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableStrokeOpacity_templ::InstanceMethod("copy",
        &_Magick_DrawableStrokeOpacity_templ::_wrap_Magick_DrawableStrokeOpacity_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("opacity");
  members.insert({
    "opacity",
      _Magick_DrawableStrokeOpacity_templ::InstanceMethod("opacity",
        &_Magick_DrawableStrokeOpacity_templ::_wrap_DrawableStrokeOpacity__wrap_Magick_DrawableStrokeOpacity_opacity,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: DrawableStrokeWidth (_Magick_DrawableStrokeWidth) */
// jsnapi_getclass
Napi::Function _Magick_DrawableStrokeWidth_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_DrawableStrokeWidth_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_DrawableStrokeWidth_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_DrawableStrokeWidth_inst>::DefineClass(env, "DrawableStrokeWidth", symbolTable);
}

void _Magick_DrawableStrokeWidth_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_DrawableStrokeWidth_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_DrawableStrokeWidth_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_DrawableBase_templ<_Magick_DrawableBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_DrawableBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableBase_templ::InstanceMethod("call",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableBase_templ::InstanceMethod("copy",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableStrokeWidth_templ::InstanceMethod("call",
        &_Magick_DrawableStrokeWidth_templ::_wrap_Magick_DrawableStrokeWidth_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableStrokeWidth_templ::InstanceMethod("copy",
        &_Magick_DrawableStrokeWidth_templ::_wrap_Magick_DrawableStrokeWidth_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("width");
  members.insert({
    "width",
      _Magick_DrawableStrokeWidth_templ::InstanceMethod("width",
        &_Magick_DrawableStrokeWidth_templ::_wrap_DrawableStrokeWidth__wrap_Magick_DrawableStrokeWidth_width,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: DrawableText (_Magick_DrawableText) */
// jsnapi_getclass
Napi::Function _Magick_DrawableText_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_DrawableText_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_DrawableText_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_DrawableText_inst>::DefineClass(env, "DrawableText", symbolTable);
}

void _Magick_DrawableText_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_DrawableText_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_DrawableText_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_DrawableBase_templ<_Magick_DrawableBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_DrawableBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableBase_templ::InstanceMethod("call",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableBase_templ::InstanceMethod("copy",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableText_templ::InstanceMethod("call",
        &_Magick_DrawableText_templ::_wrap_Magick_DrawableText_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableText_templ::InstanceMethod("copy",
        &_Magick_DrawableText_templ::_wrap_Magick_DrawableText_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("encoding");
  members.insert({
    "encoding",
      _Magick_DrawableText_templ::InstanceMethod("encoding",
        &_Magick_DrawableText_templ::_wrap_Magick_DrawableText_encoding,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("x");
  members.insert({
    "x",
      _Magick_DrawableText_templ::InstanceMethod("x",
        &_Magick_DrawableText_templ::_wrap_DrawableText__wrap_Magick_DrawableText_x,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("y");
  members.insert({
    "y",
      _Magick_DrawableText_templ::InstanceMethod("y",
        &_Magick_DrawableText_templ::_wrap_DrawableText__wrap_Magick_DrawableText_y,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("text");
  members.insert({
    "text",
      _Magick_DrawableText_templ::InstanceMethod("text",
        &_Magick_DrawableText_templ::_wrap_DrawableText__wrap_Magick_DrawableText_text,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: DrawableTextAlignment (_Magick_DrawableTextAlignment) */
// jsnapi_getclass
Napi::Function _Magick_DrawableTextAlignment_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_DrawableTextAlignment_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_DrawableTextAlignment_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_DrawableTextAlignment_inst>::DefineClass(env, "DrawableTextAlignment", symbolTable);
}

void _Magick_DrawableTextAlignment_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_DrawableTextAlignment_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_DrawableTextAlignment_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_DrawableBase_templ<_Magick_DrawableBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_DrawableBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableBase_templ::InstanceMethod("call",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableBase_templ::InstanceMethod("copy",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableTextAlignment_templ::InstanceMethod("call",
        &_Magick_DrawableTextAlignment_templ::_wrap_Magick_DrawableTextAlignment_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("alignment");
  members.insert({
    "alignment",
      _Magick_DrawableTextAlignment_templ::InstanceMethod("alignment",
        &_Magick_DrawableTextAlignment_templ::_wrap_DrawableTextAlignment__wrap_Magick_DrawableTextAlignment_alignment,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableTextAlignment_templ::InstanceMethod("copy",
        &_Magick_DrawableTextAlignment_templ::_wrap_Magick_DrawableTextAlignment_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: DrawableTextAntialias (_Magick_DrawableTextAntialias) */
// jsnapi_getclass
Napi::Function _Magick_DrawableTextAntialias_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_DrawableTextAntialias_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_DrawableTextAntialias_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_DrawableTextAntialias_inst>::DefineClass(env, "DrawableTextAntialias", symbolTable);
}

void _Magick_DrawableTextAntialias_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_DrawableTextAntialias_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_DrawableTextAntialias_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_DrawableBase_templ<_Magick_DrawableBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_DrawableBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableBase_templ::InstanceMethod("call",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableBase_templ::InstanceMethod("copy",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableTextAntialias_templ::InstanceMethod("call",
        &_Magick_DrawableTextAntialias_templ::_wrap_Magick_DrawableTextAntialias_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableTextAntialias_templ::InstanceMethod("copy",
        &_Magick_DrawableTextAntialias_templ::_wrap_Magick_DrawableTextAntialias_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("flag");
  members.insert({
    "flag",
      _Magick_DrawableTextAntialias_templ::InstanceMethod("flag",
        &_Magick_DrawableTextAntialias_templ::_wrap_DrawableTextAntialias__wrap_Magick_DrawableTextAntialias_flag,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: DrawableTextDecoration (_Magick_DrawableTextDecoration) */
// jsnapi_getclass
Napi::Function _Magick_DrawableTextDecoration_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_DrawableTextDecoration_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_DrawableTextDecoration_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_DrawableTextDecoration_inst>::DefineClass(env, "DrawableTextDecoration", symbolTable);
}

void _Magick_DrawableTextDecoration_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_DrawableTextDecoration_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_DrawableTextDecoration_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_DrawableBase_templ<_Magick_DrawableBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_DrawableBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableBase_templ::InstanceMethod("call",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableBase_templ::InstanceMethod("copy",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableTextDecoration_templ::InstanceMethod("call",
        &_Magick_DrawableTextDecoration_templ::_wrap_Magick_DrawableTextDecoration_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableTextDecoration_templ::InstanceMethod("copy",
        &_Magick_DrawableTextDecoration_templ::_wrap_Magick_DrawableTextDecoration_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("decoration");
  members.insert({
    "decoration",
      _Magick_DrawableTextDecoration_templ::InstanceMethod("decoration",
        &_Magick_DrawableTextDecoration_templ::_wrap_DrawableTextDecoration__wrap_Magick_DrawableTextDecoration_decoration,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: DrawableTextDirection (_Magick_DrawableTextDirection) */
// jsnapi_getclass
Napi::Function _Magick_DrawableTextDirection_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_DrawableTextDirection_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_DrawableTextDirection_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_DrawableTextDirection_inst>::DefineClass(env, "DrawableTextDirection", symbolTable);
}

void _Magick_DrawableTextDirection_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_DrawableTextDirection_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_DrawableTextDirection_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_DrawableBase_templ<_Magick_DrawableBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_DrawableBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableBase_templ::InstanceMethod("call",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableBase_templ::InstanceMethod("copy",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableTextDirection_templ::InstanceMethod("call",
        &_Magick_DrawableTextDirection_templ::_wrap_Magick_DrawableTextDirection_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("direction");
  members.insert({
    "direction",
      _Magick_DrawableTextDirection_templ::InstanceMethod("direction",
        &_Magick_DrawableTextDirection_templ::_wrap_DrawableTextDirection__wrap_Magick_DrawableTextDirection_direction,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableTextDirection_templ::InstanceMethod("copy",
        &_Magick_DrawableTextDirection_templ::_wrap_Magick_DrawableTextDirection_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: DrawableTextInterlineSpacing (_Magick_DrawableTextInterlineSpacing) */
// jsnapi_getclass
Napi::Function _Magick_DrawableTextInterlineSpacing_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_DrawableTextInterlineSpacing_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_DrawableTextInterlineSpacing_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_DrawableTextInterlineSpacing_inst>::DefineClass(env, "DrawableTextInterlineSpacing", symbolTable);
}

void _Magick_DrawableTextInterlineSpacing_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_DrawableTextInterlineSpacing_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_DrawableTextInterlineSpacing_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_DrawableBase_templ<_Magick_DrawableBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_DrawableBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableBase_templ::InstanceMethod("call",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableBase_templ::InstanceMethod("copy",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableTextInterlineSpacing_templ::InstanceMethod("call",
        &_Magick_DrawableTextInterlineSpacing_templ::_wrap_Magick_DrawableTextInterlineSpacing_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("spacing");
  members.insert({
    "spacing",
      _Magick_DrawableTextInterlineSpacing_templ::InstanceMethod("spacing",
        &_Magick_DrawableTextInterlineSpacing_templ::_wrap_DrawableTextInterlineSpacing__wrap_Magick_DrawableTextInterlineSpacing_spacing,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableTextInterlineSpacing_templ::InstanceMethod("copy",
        &_Magick_DrawableTextInterlineSpacing_templ::_wrap_Magick_DrawableTextInterlineSpacing_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: DrawableTextInterwordSpacing (_Magick_DrawableTextInterwordSpacing) */
// jsnapi_getclass
Napi::Function _Magick_DrawableTextInterwordSpacing_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_DrawableTextInterwordSpacing_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_DrawableTextInterwordSpacing_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_DrawableTextInterwordSpacing_inst>::DefineClass(env, "DrawableTextInterwordSpacing", symbolTable);
}

void _Magick_DrawableTextInterwordSpacing_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_DrawableTextInterwordSpacing_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_DrawableTextInterwordSpacing_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_DrawableBase_templ<_Magick_DrawableBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_DrawableBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableBase_templ::InstanceMethod("call",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableBase_templ::InstanceMethod("copy",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableTextInterwordSpacing_templ::InstanceMethod("call",
        &_Magick_DrawableTextInterwordSpacing_templ::_wrap_Magick_DrawableTextInterwordSpacing_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("spacing");
  members.insert({
    "spacing",
      _Magick_DrawableTextInterwordSpacing_templ::InstanceMethod("spacing",
        &_Magick_DrawableTextInterwordSpacing_templ::_wrap_DrawableTextInterwordSpacing__wrap_Magick_DrawableTextInterwordSpacing_spacing,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableTextInterwordSpacing_templ::InstanceMethod("copy",
        &_Magick_DrawableTextInterwordSpacing_templ::_wrap_Magick_DrawableTextInterwordSpacing_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: DrawableTextKerning (_Magick_DrawableTextKerning) */
// jsnapi_getclass
Napi::Function _Magick_DrawableTextKerning_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_DrawableTextKerning_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_DrawableTextKerning_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_DrawableTextKerning_inst>::DefineClass(env, "DrawableTextKerning", symbolTable);
}

void _Magick_DrawableTextKerning_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_DrawableTextKerning_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_DrawableTextKerning_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_DrawableBase_templ<_Magick_DrawableBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_DrawableBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableBase_templ::InstanceMethod("call",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableBase_templ::InstanceMethod("copy",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableTextKerning_templ::InstanceMethod("call",
        &_Magick_DrawableTextKerning_templ::_wrap_Magick_DrawableTextKerning_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("kerning");
  members.insert({
    "kerning",
      _Magick_DrawableTextKerning_templ::InstanceMethod("kerning",
        &_Magick_DrawableTextKerning_templ::_wrap_DrawableTextKerning__wrap_Magick_DrawableTextKerning_kerning,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableTextKerning_templ::InstanceMethod("copy",
        &_Magick_DrawableTextKerning_templ::_wrap_Magick_DrawableTextKerning_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: DrawableTextUnderColor (_Magick_DrawableTextUnderColor) */
// jsnapi_getclass
Napi::Function _Magick_DrawableTextUnderColor_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_DrawableTextUnderColor_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_DrawableTextUnderColor_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_DrawableTextUnderColor_inst>::DefineClass(env, "DrawableTextUnderColor", symbolTable);
}

void _Magick_DrawableTextUnderColor_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_DrawableTextUnderColor_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_DrawableTextUnderColor_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_DrawableBase_templ<_Magick_DrawableBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_DrawableBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableBase_templ::InstanceMethod("call",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableBase_templ::InstanceMethod("copy",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableTextUnderColor_templ::InstanceMethod("call",
        &_Magick_DrawableTextUnderColor_templ::_wrap_Magick_DrawableTextUnderColor_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableTextUnderColor_templ::InstanceMethod("copy",
        &_Magick_DrawableTextUnderColor_templ::_wrap_Magick_DrawableTextUnderColor_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("color");
  members.insert({
    "color",
      _Magick_DrawableTextUnderColor_templ::InstanceMethod("color",
        &_Magick_DrawableTextUnderColor_templ::_wrap_DrawableTextUnderColor__wrap_Magick_DrawableTextUnderColor_color,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: DrawableTranslation (_Magick_DrawableTranslation) */
// jsnapi_getclass
Napi::Function _Magick_DrawableTranslation_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_DrawableTranslation_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_DrawableTranslation_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_DrawableTranslation_inst>::DefineClass(env, "DrawableTranslation", symbolTable);
}

void _Magick_DrawableTranslation_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_DrawableTranslation_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_DrawableTranslation_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_DrawableBase_templ<_Magick_DrawableBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_DrawableBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableBase_templ::InstanceMethod("call",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableBase_templ::InstanceMethod("copy",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableTranslation_templ::InstanceMethod("call",
        &_Magick_DrawableTranslation_templ::_wrap_Magick_DrawableTranslation_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableTranslation_templ::InstanceMethod("copy",
        &_Magick_DrawableTranslation_templ::_wrap_Magick_DrawableTranslation_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("x");
  members.insert({
    "x",
      _Magick_DrawableTranslation_templ::InstanceMethod("x",
        &_Magick_DrawableTranslation_templ::_wrap_DrawableTranslation__wrap_Magick_DrawableTranslation_x,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("y");
  members.insert({
    "y",
      _Magick_DrawableTranslation_templ::InstanceMethod("y",
        &_Magick_DrawableTranslation_templ::_wrap_DrawableTranslation__wrap_Magick_DrawableTranslation_y,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: DrawableViewbox (_Magick_DrawableViewbox) */
// jsnapi_getclass
Napi::Function _Magick_DrawableViewbox_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_DrawableViewbox_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_DrawableViewbox_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_DrawableViewbox_inst>::DefineClass(env, "DrawableViewbox", symbolTable);
}

void _Magick_DrawableViewbox_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_DrawableViewbox_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_DrawableViewbox_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_DrawableBase_templ<_Magick_DrawableBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_DrawableBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableBase_templ::InstanceMethod("call",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableBase_templ::InstanceMethod("copy",
        &_Magick_DrawableBase_templ::_wrap_Magick_DrawableBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_DrawableViewbox_templ::InstanceMethod("call",
        &_Magick_DrawableViewbox_templ::_wrap_Magick_DrawableViewbox_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_DrawableViewbox_templ::InstanceMethod("copy",
        &_Magick_DrawableViewbox_templ::_wrap_Magick_DrawableViewbox_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("x1");
  members.insert({
    "x1",
      _Magick_DrawableViewbox_templ::InstanceMethod("x1",
        &_Magick_DrawableViewbox_templ::_wrap_DrawableViewbox__wrap_Magick_DrawableViewbox_x1,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("y1");
  members.insert({
    "y1",
      _Magick_DrawableViewbox_templ::InstanceMethod("y1",
        &_Magick_DrawableViewbox_templ::_wrap_DrawableViewbox__wrap_Magick_DrawableViewbox_y1,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("x2");
  members.insert({
    "x2",
      _Magick_DrawableViewbox_templ::InstanceMethod("x2",
        &_Magick_DrawableViewbox_templ::_wrap_DrawableViewbox__wrap_Magick_DrawableViewbox_x2,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("y2");
  members.insert({
    "y2",
      _Magick_DrawableViewbox_templ::InstanceMethod("y2",
        &_Magick_DrawableViewbox_templ::_wrap_DrawableViewbox__wrap_Magick_DrawableViewbox_y2,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: PathArcArgs (_Magick_PathArcArgs) */
// jsnapi_getclass
Napi::Function _Magick_PathArcArgs_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_PathArcArgs_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_PathArcArgs_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_PathArcArgs_inst>::DefineClass(env, "PathArcArgs", symbolTable);
}

void _Magick_PathArcArgs_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_PathArcArgs_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_PathArcArgs_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("radiusX");
  members.insert({
    "radiusX",
      _Magick_PathArcArgs_templ::InstanceMethod("radiusX",
        &_Magick_PathArcArgs_templ::_wrap_PathArcArgs__wrap_Magick_PathArcArgs_radiusX,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("radiusY");
  members.insert({
    "radiusY",
      _Magick_PathArcArgs_templ::InstanceMethod("radiusY",
        &_Magick_PathArcArgs_templ::_wrap_PathArcArgs__wrap_Magick_PathArcArgs_radiusY,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("xAxisRotation");
  members.insert({
    "xAxisRotation",
      _Magick_PathArcArgs_templ::InstanceMethod("xAxisRotation",
        &_Magick_PathArcArgs_templ::_wrap_PathArcArgs__wrap_Magick_PathArcArgs_xAxisRotation,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("largeArcFlag");
  members.insert({
    "largeArcFlag",
      _Magick_PathArcArgs_templ::InstanceMethod("largeArcFlag",
        &_Magick_PathArcArgs_templ::_wrap_PathArcArgs__wrap_Magick_PathArcArgs_largeArcFlag,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("sweepFlag");
  members.insert({
    "sweepFlag",
      _Magick_PathArcArgs_templ::InstanceMethod("sweepFlag",
        &_Magick_PathArcArgs_templ::_wrap_PathArcArgs__wrap_Magick_PathArcArgs_sweepFlag,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("x");
  members.insert({
    "x",
      _Magick_PathArcArgs_templ::InstanceMethod("x",
        &_Magick_PathArcArgs_templ::_wrap_PathArcArgs__wrap_Magick_PathArcArgs_x,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("y");
  members.insert({
    "y",
      _Magick_PathArcArgs_templ::InstanceMethod("y",
        &_Magick_PathArcArgs_templ::_wrap_PathArcArgs__wrap_Magick_PathArcArgs_y,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}


// js_global_overloaded_function
Napi::Value _wrap_equal__SWIG_5(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathArcArgs *arg1 = 0 ;
  Magick::PathArcArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathArcArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equal" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathArcArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equal" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathArcArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator ==((Magick::PathArcArgs const &)*arg1,(Magick::PathArcArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_notEqual__SWIG_5(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathArcArgs *arg1 = 0 ;
  Magick::PathArcArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathArcArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "notEqual" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathArcArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "notEqual" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathArcArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator !=((Magick::PathArcArgs const &)*arg1,(Magick::PathArcArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_gt__SWIG_3(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathArcArgs *arg1 = 0 ;
  Magick::PathArcArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathArcArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gt" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathArcArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gt" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathArcArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator >((Magick::PathArcArgs const &)*arg1,(Magick::PathArcArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_lt__SWIG_3(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathArcArgs *arg1 = 0 ;
  Magick::PathArcArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathArcArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lt" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathArcArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lt" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathArcArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator <((Magick::PathArcArgs const &)*arg1,(Magick::PathArcArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_gte__SWIG_3(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathArcArgs *arg1 = 0 ;
  Magick::PathArcArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathArcArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gte" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathArcArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gte" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathArcArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator >=((Magick::PathArcArgs const &)*arg1,(Magick::PathArcArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_lte__SWIG_3(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathArcArgs *arg1 = 0 ;
  Magick::PathArcArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathArcArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lte" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "1"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathArcArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathArcArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lte" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "2"" of type '" "Magick::PathArcArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathArcArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator <=((Magick::PathArcArgs const &)*arg1,(Magick::PathArcArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


/* Class: PathArcAbs (_Magick_PathArcAbs) */
// jsnapi_getclass
Napi::Function _Magick_PathArcAbs_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_PathArcAbs_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_PathArcAbs_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_PathArcAbs_inst>::DefineClass(env, "PathArcAbs", symbolTable);
}

void _Magick_PathArcAbs_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_PathArcAbs_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_PathArcAbs_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_VPathBase_templ<_Magick_VPathBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_VPathBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_VPathBase_templ::InstanceMethod("call",
        &_Magick_VPathBase_templ::_wrap_Magick_VPathBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_VPathBase_templ::InstanceMethod("copy",
        &_Magick_VPathBase_templ::_wrap_Magick_VPathBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_PathArcAbs_templ::InstanceMethod("call",
        &_Magick_PathArcAbs_templ::_wrap_Magick_PathArcAbs_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_PathArcAbs_templ::InstanceMethod("copy",
        &_Magick_PathArcAbs_templ::_wrap_Magick_PathArcAbs_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: PathArcRel (_Magick_PathArcRel) */
// jsnapi_getclass
Napi::Function _Magick_PathArcRel_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_PathArcRel_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_PathArcRel_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_PathArcRel_inst>::DefineClass(env, "PathArcRel", symbolTable);
}

void _Magick_PathArcRel_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_PathArcRel_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_PathArcRel_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_VPathBase_templ<_Magick_VPathBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_VPathBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_VPathBase_templ::InstanceMethod("call",
        &_Magick_VPathBase_templ::_wrap_Magick_VPathBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_VPathBase_templ::InstanceMethod("copy",
        &_Magick_VPathBase_templ::_wrap_Magick_VPathBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_PathArcRel_templ::InstanceMethod("call",
        &_Magick_PathArcRel_templ::_wrap_Magick_PathArcRel_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_PathArcRel_templ::InstanceMethod("copy",
        &_Magick_PathArcRel_templ::_wrap_Magick_PathArcRel_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: PathClosePath (_Magick_PathClosePath) */
// jsnapi_getclass
Napi::Function _Magick_PathClosePath_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_PathClosePath_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_PathClosePath_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_PathClosePath_inst>::DefineClass(env, "PathClosePath", symbolTable);
}

void _Magick_PathClosePath_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_PathClosePath_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_PathClosePath_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_VPathBase_templ<_Magick_VPathBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_VPathBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_VPathBase_templ::InstanceMethod("call",
        &_Magick_VPathBase_templ::_wrap_Magick_VPathBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_VPathBase_templ::InstanceMethod("copy",
        &_Magick_VPathBase_templ::_wrap_Magick_VPathBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_PathClosePath_templ::InstanceMethod("call",
        &_Magick_PathClosePath_templ::_wrap_Magick_PathClosePath_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_PathClosePath_templ::InstanceMethod("copy",
        &_Magick_PathClosePath_templ::_wrap_Magick_PathClosePath_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: PathCurvetoArgs (_Magick_PathCurvetoArgs) */
// jsnapi_getclass
Napi::Function _Magick_PathCurvetoArgs_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_PathCurvetoArgs_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_PathCurvetoArgs_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_PathCurvetoArgs_inst>::DefineClass(env, "PathCurvetoArgs", symbolTable);
}

void _Magick_PathCurvetoArgs_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_PathCurvetoArgs_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_PathCurvetoArgs_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("x1");
  members.insert({
    "x1",
      _Magick_PathCurvetoArgs_templ::InstanceMethod("x1",
        &_Magick_PathCurvetoArgs_templ::_wrap_PathCurvetoArgs__wrap_Magick_PathCurvetoArgs_x1,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("y1");
  members.insert({
    "y1",
      _Magick_PathCurvetoArgs_templ::InstanceMethod("y1",
        &_Magick_PathCurvetoArgs_templ::_wrap_PathCurvetoArgs__wrap_Magick_PathCurvetoArgs_y1,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("x2");
  members.insert({
    "x2",
      _Magick_PathCurvetoArgs_templ::InstanceMethod("x2",
        &_Magick_PathCurvetoArgs_templ::_wrap_PathCurvetoArgs__wrap_Magick_PathCurvetoArgs_x2,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("y2");
  members.insert({
    "y2",
      _Magick_PathCurvetoArgs_templ::InstanceMethod("y2",
        &_Magick_PathCurvetoArgs_templ::_wrap_PathCurvetoArgs__wrap_Magick_PathCurvetoArgs_y2,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("x");
  members.insert({
    "x",
      _Magick_PathCurvetoArgs_templ::InstanceMethod("x",
        &_Magick_PathCurvetoArgs_templ::_wrap_PathCurvetoArgs__wrap_Magick_PathCurvetoArgs_x,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("y");
  members.insert({
    "y",
      _Magick_PathCurvetoArgs_templ::InstanceMethod("y",
        &_Magick_PathCurvetoArgs_templ::_wrap_PathCurvetoArgs__wrap_Magick_PathCurvetoArgs_y,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}


// js_global_overloaded_function
Napi::Value _wrap_equal__SWIG_6(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathCurvetoArgs *arg1 = 0 ;
  Magick::PathCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equal" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equal" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator ==((Magick::PathCurvetoArgs const &)*arg1,(Magick::PathCurvetoArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_notEqual__SWIG_6(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathCurvetoArgs *arg1 = 0 ;
  Magick::PathCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "notEqual" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "notEqual" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator !=((Magick::PathCurvetoArgs const &)*arg1,(Magick::PathCurvetoArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_gt__SWIG_4(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathCurvetoArgs *arg1 = 0 ;
  Magick::PathCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gt" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gt" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator >((Magick::PathCurvetoArgs const &)*arg1,(Magick::PathCurvetoArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_lt__SWIG_4(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathCurvetoArgs *arg1 = 0 ;
  Magick::PathCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lt" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lt" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator <((Magick::PathCurvetoArgs const &)*arg1,(Magick::PathCurvetoArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_gte__SWIG_4(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathCurvetoArgs *arg1 = 0 ;
  Magick::PathCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gte" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gte" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator >=((Magick::PathCurvetoArgs const &)*arg1,(Magick::PathCurvetoArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_lte__SWIG_4(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::PathCurvetoArgs *arg1 = 0 ;
  Magick::PathCurvetoArgs *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lte" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "1"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__PathCurvetoArgs,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lte" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "2"" of type '" "Magick::PathCurvetoArgs const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::PathCurvetoArgs * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator <=((Magick::PathCurvetoArgs const &)*arg1,(Magick::PathCurvetoArgs const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


/* Class: PathCurvetoAbs (_Magick_PathCurvetoAbs) */
// jsnapi_getclass
Napi::Function _Magick_PathCurvetoAbs_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_PathCurvetoAbs_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_PathCurvetoAbs_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_PathCurvetoAbs_inst>::DefineClass(env, "PathCurvetoAbs", symbolTable);
}

void _Magick_PathCurvetoAbs_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_PathCurvetoAbs_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_PathCurvetoAbs_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_VPathBase_templ<_Magick_VPathBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_VPathBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_VPathBase_templ::InstanceMethod("call",
        &_Magick_VPathBase_templ::_wrap_Magick_VPathBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_VPathBase_templ::InstanceMethod("copy",
        &_Magick_VPathBase_templ::_wrap_Magick_VPathBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_PathCurvetoAbs_templ::InstanceMethod("call",
        &_Magick_PathCurvetoAbs_templ::_wrap_Magick_PathCurvetoAbs_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_PathCurvetoAbs_templ::InstanceMethod("copy",
        &_Magick_PathCurvetoAbs_templ::_wrap_Magick_PathCurvetoAbs_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: PathCurvetoRel (_Magick_PathCurvetoRel) */
// jsnapi_getclass
Napi::Function _Magick_PathCurvetoRel_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_PathCurvetoRel_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_PathCurvetoRel_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_PathCurvetoRel_inst>::DefineClass(env, "PathCurvetoRel", symbolTable);
}

void _Magick_PathCurvetoRel_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_PathCurvetoRel_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_PathCurvetoRel_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_VPathBase_templ<_Magick_VPathBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_VPathBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_VPathBase_templ::InstanceMethod("call",
        &_Magick_VPathBase_templ::_wrap_Magick_VPathBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_VPathBase_templ::InstanceMethod("copy",
        &_Magick_VPathBase_templ::_wrap_Magick_VPathBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_PathCurvetoRel_templ::InstanceMethod("call",
        &_Magick_PathCurvetoRel_templ::_wrap_Magick_PathCurvetoRel_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_PathCurvetoRel_templ::InstanceMethod("copy",
        &_Magick_PathCurvetoRel_templ::_wrap_Magick_PathCurvetoRel_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: PathSmoothCurvetoAbs (_Magick_PathSmoothCurvetoAbs) */
// jsnapi_getclass
Napi::Function _Magick_PathSmoothCurvetoAbs_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_PathSmoothCurvetoAbs_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_PathSmoothCurvetoAbs_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_PathSmoothCurvetoAbs_inst>::DefineClass(env, "PathSmoothCurvetoAbs", symbolTable);
}

void _Magick_PathSmoothCurvetoAbs_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_PathSmoothCurvetoAbs_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_PathSmoothCurvetoAbs_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_VPathBase_templ<_Magick_VPathBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_VPathBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_VPathBase_templ::InstanceMethod("call",
        &_Magick_VPathBase_templ::_wrap_Magick_VPathBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_VPathBase_templ::InstanceMethod("copy",
        &_Magick_VPathBase_templ::_wrap_Magick_VPathBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_PathSmoothCurvetoAbs_templ::InstanceMethod("call",
        &_Magick_PathSmoothCurvetoAbs_templ::_wrap_Magick_PathSmoothCurvetoAbs_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_PathSmoothCurvetoAbs_templ::InstanceMethod("copy",
        &_Magick_PathSmoothCurvetoAbs_templ::_wrap_Magick_PathSmoothCurvetoAbs_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: PathSmoothCurvetoRel (_Magick_PathSmoothCurvetoRel) */
// jsnapi_getclass
Napi::Function _Magick_PathSmoothCurvetoRel_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_PathSmoothCurvetoRel_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_PathSmoothCurvetoRel_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_PathSmoothCurvetoRel_inst>::DefineClass(env, "PathSmoothCurvetoRel", symbolTable);
}

void _Magick_PathSmoothCurvetoRel_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_PathSmoothCurvetoRel_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_PathSmoothCurvetoRel_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_VPathBase_templ<_Magick_VPathBase_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_VPathBase_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_VPathBase_templ::InstanceMethod("call",
        &_Magick_VPathBase_templ::_wrap_Magick_VPathBase_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_VPathBase_templ::InstanceMethod("copy",
        &_Magick_VPathBase_templ::_wrap_Magick_VPathBase_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_PathSmoothCurvetoRel_templ::InstanceMethod("call",
        &_Magick_PathSmoothCurvetoRel_templ::_wrap_Magick_PathSmoothCurvetoRel_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("copy");
  members.insert({
    "copy",
      _Magick_PathSmoothCurvetoRel_templ::InstanceMethod("copy",
        &_Magick_PathSmoothCurvetoRel_templ::_wrap_Magick_PathSmoothCurvetoRel_copy,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: PathQuadraticCurvetoArgs (_Magick_PathQuadraticCurvetoArgs) */
// jsnapi_getclass
Napi::Function _Magick_PathQuadraticCurvetoArgs_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_PathQuadraticCurvetoArgs_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_PathQuadraticCurvetoArgs_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_PathQuadraticCurvetoArgs_inst>::DefineClass(env, "PathQuadraticCurvetoArgs", symbolTable);
}

void _Magick_PathQuadraticCurvetoArgs_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_PathQuadraticCurvetoArgs_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_PathQuadraticCurvetoArgs_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("x1");
  members.insert({
    "x1",
      _Magick_PathQuadraticCurvetoArgs_templ::InstanceMethod("x1",
        &_Magick_PathQuadraticCurvetoArgs_templ::_wrap_PathQuadraticCurvetoArgs__wrap_Magick_PathQuadraticCurvetoArgs_x1,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("y1");
  members.insert({
    "y1",
      _Magick_PathQuadraticCurvetoArgs_templ::InstanceMethod("y1",
        &_Magick_PathQuadraticCurvetoArgs_templ::_wrap_PathQuadraticCurvetoArgs__wrap_Magick_PathQuadraticCurvetoArgs_y1,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("x");
  members.insert({
    "x",
      _Magick_PathQuadraticCurvetoArgs_templ::InstanceMethod("x",
        &_Magick_PathQuadraticCurvetoArgs_templ::_wrap_PathQuadraticCurvetoArgs__wrap_Magick_PathQuadraticCurvetoArgs_x,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("y");
  members.insert({
    "y",
      _Magick_PathQuadraticCurvetoArgs_templ::InstanceMethod("y",
        &_Magick_PathQuadraticCurvetoArgs_templ::_wrap_PathQuadraticCurvetoArgs__wrap_Magick_PathQuadraticCurvetoArgs_y,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

