/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.2.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

#include "swig/magickwand-js.h"


// js_global_function
Napi::Value _wrap_GetMagickCopyright(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  char *result = 0 ;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    if(static_cast<int>(info.Length()) < 0 || static_cast<int>(info.Length()) > 0) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_GetMagickCopyright.");
    }
    
    
    
    
    
    
    {
      try {
        result = (char *)MagickCore::GetMagickCopyright();
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_FromCharPtr((const char *)result);
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_function
Napi::Value _wrap_GetMagickDelegates(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  char *result = 0 ;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    if(static_cast<int>(info.Length()) < 0 || static_cast<int>(info.Length()) > 0) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_GetMagickDelegates.");
    }
    
    
    
    
    
    
    {
      try {
        result = (char *)MagickCore::GetMagickDelegates();
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_FromCharPtr((const char *)result);
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_function
Napi::Value _wrap_GetMagickFeatures(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  char *result = 0 ;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    if(static_cast<int>(info.Length()) < 0 || static_cast<int>(info.Length()) > 0) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_GetMagickFeatures.");
    }
    
    
    
    
    
    
    {
      try {
        result = (char *)MagickCore::GetMagickFeatures();
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_FromCharPtr((const char *)result);
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_function
Napi::Value _wrap_GetMagickLicense(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  char *result = 0 ;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    if(static_cast<int>(info.Length()) < 0 || static_cast<int>(info.Length()) > 0) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_GetMagickLicense.");
    }
    
    
    
    
    
    
    {
      try {
        result = (char *)MagickCore::GetMagickLicense();
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_FromCharPtr((const char *)result);
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_function
Napi::Value _wrap_GetMagickPackageName(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  char *result = 0 ;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    if(static_cast<int>(info.Length()) < 0 || static_cast<int>(info.Length()) > 0) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_GetMagickPackageName.");
    }
    
    
    
    
    
    
    {
      try {
        result = (char *)MagickCore::GetMagickPackageName();
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_FromCharPtr((const char *)result);
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_function
Napi::Value _wrap_GetMagickReleaseDate(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  char *result = 0 ;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    if(static_cast<int>(info.Length()) < 0 || static_cast<int>(info.Length()) > 0) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_GetMagickReleaseDate.");
    }
    
    
    
    
    
    
    {
      try {
        result = (char *)MagickCore::GetMagickReleaseDate();
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_FromCharPtr((const char *)result);
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_function
Napi::Value _wrap_GetPolicyValue(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  char *result = 0 ;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    if(static_cast<int>(info.Length()) < 1 || static_cast<int>(info.Length()) > 1) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_GetPolicyValue.");
    }
    
    res1 = SWIG_AsCharPtrAndSize(info[0], &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetPolicyValue" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = reinterpret_cast< char * >(buf1);
    
    
    
    
    {
      try {
        result = (char *)MagickCore::GetPolicyValue((char const *)arg1);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_FromCharPtr((const char *)result);
    
    if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
    
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  
#endif
  return Napi::Value();
}



// js_global_function
Napi::Value _wrap_GetPolicyList(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  char *arg1 = (char *) 0 ;
  size_t *arg2 = (size_t *) 0 ;
  MagickCore::ExceptionInfo *arg3 = (MagickCore::ExceptionInfo *) 0 ;
  MagickCore::ExceptionInfo _global_error ;
  size_t _global_number_policies ;
  char **result = 0 ;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    if(static_cast<int>(info.Length()) < 0 || static_cast<int>(info.Length()) > 0) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_GetPolicyList.");
    }
    
    arg1 = const_cast<char*>("");
    arg2 = &_global_number_policies;
    arg3 = &_global_error;
    _global_error.severity = MagickCore::ExceptionType::UndefinedException;
    
    
    
    
    
    {
      try {
        result = (char **)MagickCore::GetPolicyList((char const *)arg1,arg2,arg3);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    {
      Napi::Array array = Napi::Array::New(env, _global_number_policies);
      if (result) {
        char **policies = reinterpret_cast<char**>(result);
        for (size_t i = 0; i < _global_number_policies; i++) {
          Napi::String s = Napi::String::New(env, policies[i]);
          array.Set(i, s);
        }
      }
      jsresult = array;
    }
    if (_global_error.severity != MagickCore::ExceptionType::UndefinedException) {
      do {
        SWIG_NAPI_Raise(env, MagickCore::GetExceptionMessage(_global_error.error_number)); SWIG_fail; 
      } while (0);
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_function
Napi::Value _wrap_IsRightsAuthorized(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  MagickCore::PolicyDomain arg1 ;
  MagickCore::PolicyRights arg2 ;
  char *arg3 = (char *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  MagickCore::MagickBooleanType result;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    if(static_cast<int>(info.Length()) < 3 || static_cast<int>(info.Length()) > 3) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_IsRightsAuthorized.");
    }
    
    ecode1 = SWIG_AsVal_int(info[0], &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "IsRightsAuthorized" "', argument " "1"" of type '" "MagickCore::PolicyDomain""'");
    } 
    arg1 = static_cast< MagickCore::PolicyDomain >(val1);ecode2 = SWIG_AsVal_int(info[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IsRightsAuthorized" "', argument " "2"" of type '" "MagickCore::PolicyRights""'");
    } 
    arg2 = static_cast< MagickCore::PolicyRights >(val2);res3 = SWIG_AsCharPtrAndSize(info[2], &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "IsRightsAuthorized" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = reinterpret_cast< char * >(buf3);
    
    
    
    
    {
      try {
        result = (MagickCore::MagickBooleanType)MagickCore::IsRightsAuthorized(arg1,arg2,(char const *)arg3);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    {
      jsresult = Napi::Boolean::New(env, result);
    }
    
    if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
    
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  
#endif
  return Napi::Value();
}



// js_global_function
Napi::Value _wrap_ListPolicyInfo(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  FILE *arg1 = (FILE *) 0 ;
  MagickCore::ExceptionInfo *arg2 = (MagickCore::ExceptionInfo *) 0 ;
  MagickCore::ExceptionInfo _global_error ;
  MagickCore::MagickBooleanType result;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    if(static_cast<int>(info.Length()) < 0 || static_cast<int>(info.Length()) > 0) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_ListPolicyInfo.");
    }
    
    arg1 = SWIG_NULLPTR;
    arg2 = &_global_error;
    _global_error.severity = MagickCore::ExceptionType::UndefinedException;
    
    
    
    
    
    {
      try {
        result = (MagickCore::MagickBooleanType)MagickCore::ListPolicyInfo(arg1,arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    {
      jsresult = Napi::Boolean::New(env, result);
    }
    if (_global_error.severity != MagickCore::ExceptionType::UndefinedException) {
      do {
        SWIG_NAPI_Raise(env, MagickCore::GetExceptionMessage(_global_error.error_number)); SWIG_fail; 
      } while (0);
    }
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_function
Napi::Value _wrap_SetMagickSecurityPolicy(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  char *arg1 = (char *) 0 ;
  MagickCore::ExceptionInfo *arg2 = (MagickCore::ExceptionInfo *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  MagickCore::ExceptionInfo _global_error ;
  MagickCore::MagickBooleanType result;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    if(static_cast<int>(info.Length()) < 1 || static_cast<int>(info.Length()) > 1) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_SetMagickSecurityPolicy.");
    }
    
    arg2 = &_global_error;
    _global_error.severity = MagickCore::ExceptionType::UndefinedException;
    res1 = SWIG_AsCharPtrAndSize(info[0], &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetMagickSecurityPolicy" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = reinterpret_cast< char * >(buf1);
    
    
    
    
    {
      try {
        result = (MagickCore::MagickBooleanType)MagickCore::SetMagickSecurityPolicy((char const *)arg1,arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    {
      jsresult = Napi::Boolean::New(env, result);
    }
    if (_global_error.severity != MagickCore::ExceptionType::UndefinedException) {
      do {
        SWIG_NAPI_Raise(env, MagickCore::GetExceptionMessage(_global_error.error_number)); SWIG_fail; 
      } while (0);
    }
    
    if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
    
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  
#endif
  return Napi::Value();
}



// js_global_function
Napi::Value _wrap_SetMagickSecurityPolicyValue(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  MagickCore::PolicyDomain arg1 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  MagickCore::ExceptionInfo *arg4 = (MagickCore::ExceptionInfo *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  MagickCore::ExceptionInfo _global_error ;
  MagickCore::MagickBooleanType result;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    if(static_cast<int>(info.Length()) < 3 || static_cast<int>(info.Length()) > 3) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_SetMagickSecurityPolicyValue.");
    }
    
    arg4 = &_global_error;
    _global_error.severity = MagickCore::ExceptionType::UndefinedException;
    ecode1 = SWIG_AsVal_int(info[0], &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SetMagickSecurityPolicyValue" "', argument " "1"" of type '" "MagickCore::PolicyDomain""'");
    } 
    arg1 = static_cast< MagickCore::PolicyDomain >(val1);res2 = SWIG_AsCharPtrAndSize(info[1], &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetMagickSecurityPolicyValue" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = reinterpret_cast< char * >(buf2);res3 = SWIG_AsCharPtrAndSize(info[2], &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SetMagickSecurityPolicyValue" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = reinterpret_cast< char * >(buf3);
    
    
    
    
    {
      try {
        result = (MagickCore::MagickBooleanType)MagickCore::SetMagickSecurityPolicyValue(arg1,(char const *)arg2,(char const *)arg3,arg4);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    {
      jsresult = Napi::Boolean::New(env, result);
    }
    if (_global_error.severity != MagickCore::ExceptionType::UndefinedException) {
      do {
        SWIG_NAPI_Raise(env, MagickCore::GetExceptionMessage(_global_error.error_number)); SWIG_fail; 
      } while (0);
    }
    
    if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
    if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
    if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
    
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  
#endif
  return Napi::Value();
}



// js_global_function
Napi::Value _wrap_MagickSetSecurityPolicy(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  MagickWand *arg1 = (MagickWand *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  MagickCore::MagickBooleanType result;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    if(static_cast<int>(info.Length()) < 2 || static_cast<int>(info.Length()) > 2) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_MagickSetSecurityPolicy.");
    }
    
    res1 = SWIG_ConvertPtr(info[0], &argp1,SWIGTYPE_p_MagickWand, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MagickSetSecurityPolicy" "', argument " "1"" of type '" "MagickWand *""'"); 
    }
    arg1 = reinterpret_cast< MagickWand * >(argp1);res2 = SWIG_AsCharPtrAndSize(info[1], &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MagickSetSecurityPolicy" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = reinterpret_cast< char * >(buf2);
    
    
    
    
    {
      try {
        result = (MagickCore::MagickBooleanType)MagickCore::MagickSetSecurityPolicy(arg1,(char const *)arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    {
      jsresult = Napi::Boolean::New(env, result);
    }
    
    if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
    
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  
#endif
  return Napi::Value();
}



// js_global_function
Napi::Value _wrap_DisableOpenCL(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    if(static_cast<int>(info.Length()) < 0 || static_cast<int>(info.Length()) > 0) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_DisableOpenCL.");
    }
    
    
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::DisableOpenCL();
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_function
Napi::Value _wrap_EnableOpenCL(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  bool result;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    if(static_cast<int>(info.Length()) < 0 || static_cast<int>(info.Length()) > 0) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_EnableOpenCL.");
    }
    
    
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (bool)Magick::EnableOpenCL();
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_bool  SWIG_NAPI_FROM_CALL_ARGS(static_cast< bool >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_function
Napi::Value _wrap_SetRandomSeed(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  unsigned long arg1 ;
  unsigned long val1 ;
  int ecode1 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    if(static_cast<int>(info.Length()) < 1 || static_cast<int>(info.Length()) > 1) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_SetRandomSeed.");
    }
    
    ecode1 = SWIG_AsVal_unsigned_SS_long(info[0], &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SetRandomSeed" "', argument " "1"" of type '" "unsigned long""'");
    } 
    arg1 = static_cast< unsigned long >(val1);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        Magick::SetRandomSeed(arg1);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = env.Undefined();
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_function
Napi::Value _wrap_SetSecurityPolicy(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  bool result;
  
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    if(static_cast<int>(info.Length()) < 1 || static_cast<int>(info.Length()) > 1) {
      SWIG_Error(SWIG_ERROR, "Illegal number of arguments for _wrap_SetSecurityPolicy.");
    }
    
    {
      {
        std::string *ptr = (std::string *)0;
        res1 = SWIG_AsPtr_std_string(info[0], &ptr);
        if (!SWIG_IsOK(res1)) {
          SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSecurityPolicy" "', argument " "1"" of type '" "std::string const &""'"); 
        }
        if (!ptr) {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetSecurityPolicy" "', argument " "1"" of type '" "std::string const &""'"); 
        }
        arg1 = ptr;
      }
    }
    
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (bool)Magick::SetSecurityPolicy((std::string const &)*arg1);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_bool  SWIG_NAPI_FROM_CALL_ARGS(static_cast< bool >(result));
    
    if (SWIG_IsNewObj(res1)) delete arg1;
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    if (SWIG_IsNewObj(res1)) delete arg1;
    
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  
#endif
  return Napi::Value();
}


/* Class: Blob (_Magick_Blob) */
// jsnapi_getclass
Napi::Function _Magick_Blob_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_Blob_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_Blob_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_Blob_inst>::DefineClass(env, "Blob", symbolTable);
}

void _Magick_Blob_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_Blob_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_Blob_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("clone");
  members.insert({
    "clone",
      _Magick_Blob_templ::InstanceMethod("clone",
        &_Magick_Blob_templ::_wrap_Magick_Blob_clone,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("base64Async");
  members.insert({
    "base64Async",
      _Magick_Blob_templ::InstanceMethod("base64Async",
        &_Magick_Blob_templ::_wrap_Blob__wrap_Magick_Blob_base64Async,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("base64");
  members.insert({
    "base64",
      _Magick_Blob_templ::InstanceMethod("base64",
        &_Magick_Blob_templ::_wrap_Blob__wrap_Magick_Blob_base64,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("lengthAsync");
  members.insert({
    "lengthAsync",
      _Magick_Blob_templ::InstanceMethod("lengthAsync",
        &_Magick_Blob_templ::_wrap_Magick_Blob_lengthAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("length");
  members.insert({
    "length",
      _Magick_Blob_templ::InstanceMethod("length",
        &_Magick_Blob_templ::_wrap_Magick_Blob_length,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("updateAsync");
  members.insert({
    "updateAsync",
      _Magick_Blob_templ::InstanceMethod("updateAsync",
        &_Magick_Blob_templ::_wrap_Magick_Blob_updateAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("update");
  members.insert({
    "update",
      _Magick_Blob_templ::InstanceMethod("update",
        &_Magick_Blob_templ::_wrap_Magick_Blob_update,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("dataAsync");
  members.insert({
    "dataAsync",
      _Magick_Blob_templ::InstanceMethod("dataAsync",
        &_Magick_Blob_templ::_wrap_Magick_Blob_dataAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("data");
  members.insert({
    "data",
      _Magick_Blob_templ::InstanceMethod("data",
        &_Magick_Blob_templ::_wrap_Magick_Blob_data,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}


// js_global_overloaded_function
Napi::Value _wrap_equal__SWIG_0(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Color *arg1 = 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equal" "', argument " "1"" of type '" "Magick::Color const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "1"" of type '" "Magick::Color const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Color * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Color,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equal" "', argument " "2"" of type '" "Magick::Color const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "2"" of type '" "Magick::Color const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Color * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator ==((Magick::Color const &)*arg1,(Magick::Color const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_notEqual__SWIG_0(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Color *arg1 = 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Color const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Color const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Color * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Color,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Color const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Color const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Color * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator !=((Magick::Color const &)*arg1,(Magick::Color const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_gt__SWIG_0(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Color *arg1 = 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gt" "', argument " "1"" of type '" "Magick::Color const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "1"" of type '" "Magick::Color const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Color * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Color,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gt" "', argument " "2"" of type '" "Magick::Color const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "2"" of type '" "Magick::Color const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Color * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator >((Magick::Color const &)*arg1,(Magick::Color const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_lt__SWIG_0(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Color *arg1 = 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lt" "', argument " "1"" of type '" "Magick::Color const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "1"" of type '" "Magick::Color const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Color * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Color,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lt" "', argument " "2"" of type '" "Magick::Color const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "2"" of type '" "Magick::Color const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Color * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator <((Magick::Color const &)*arg1,(Magick::Color const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_gte__SWIG_0(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Color *arg1 = 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gte" "', argument " "1"" of type '" "Magick::Color const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "1"" of type '" "Magick::Color const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Color * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Color,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gte" "', argument " "2"" of type '" "Magick::Color const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "2"" of type '" "Magick::Color const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Color * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator >=((Magick::Color const &)*arg1,(Magick::Color const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_lte__SWIG_0(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Color *arg1 = 0 ;
  Magick::Color *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Color,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lte" "', argument " "1"" of type '" "Magick::Color const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "1"" of type '" "Magick::Color const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Color * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Color,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lte" "', argument " "2"" of type '" "Magick::Color const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "2"" of type '" "Magick::Color const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Color * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator <=((Magick::Color const &)*arg1,(Magick::Color const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


/* Class: Color (_Magick_Color) */
// jsnapi_getclass
Napi::Function _Magick_Color_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_Color_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_Color_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_Color_inst>::DefineClass(env, "Color", symbolTable);
}

void _Magick_Color_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_Color_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_Color_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("clone");
  members.insert({
    "clone",
      _Magick_Color_templ::InstanceMethod("clone",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_clone,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("toString");
  members.insert({
    "toString",
      _Magick_Color_templ::InstanceMethod("toString",
        &_Magick_Color_templ::_wrap_Magick_Color_toString,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("isFuzzyEquivalent");
  members.insert({
    "isFuzzyEquivalent",
      _Magick_Color_templ::InstanceMethod("isFuzzyEquivalent",
        &_Magick_Color_templ::_wrap_Magick_Color_isFuzzyEquivalent,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("isValid");
  members.insert({
    "isValid",
      _Magick_Color_templ::InstanceMethod("isValid",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_isValid,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("pixelType");
  members.insert({
    "pixelType",
      _Magick_Color_templ::InstanceMethod("pixelType",
        &_Magick_Color_templ::_wrap_Magick_Color_pixelType,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumAlpha");
  members.insert({
    "quantumAlpha",
      _Magick_Color_templ::InstanceMethod("quantumAlpha",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumAlpha,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumBlack");
  members.insert({
    "quantumBlack",
      _Magick_Color_templ::InstanceMethod("quantumBlack",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumBlack,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumBlue");
  members.insert({
    "quantumBlue",
      _Magick_Color_templ::InstanceMethod("quantumBlue",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumBlue,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumGreen");
  members.insert({
    "quantumGreen",
      _Magick_Color_templ::InstanceMethod("quantumGreen",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumGreen,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumRed");
  members.insert({
    "quantumRed",
      _Magick_Color_templ::InstanceMethod("quantumRed",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumRed,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_CMYKPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("CMYKPixel");
    staticMembers.insert({
      "CMYKPixel", StaticValue("CMYKPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_CMYKAPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("CMYKAPixel");
    staticMembers.insert({
      "CMYKAPixel", StaticValue("CMYKAPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_RGBPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("RGBPixel");
    staticMembers.insert({
      "RGBPixel", StaticValue("RGBPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_RGBAPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("RGBAPixel");
    staticMembers.insert({
      "RGBAPixel", StaticValue("RGBAPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  
}

/* Class: ColorCMYK (_Magick_ColorCMYK) */
// jsnapi_getclass
Napi::Function _Magick_ColorCMYK_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_ColorCMYK_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_ColorCMYK_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_ColorCMYK_inst>::DefineClass(env, "ColorCMYK", symbolTable);
}

void _Magick_ColorCMYK_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_ColorCMYK_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_ColorCMYK_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_Color_templ<_Magick_Color_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_Color_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("clone");
  members.insert({
    "clone",
      _Magick_Color_templ::InstanceMethod("clone",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_clone,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("toString");
  members.insert({
    "toString",
      _Magick_Color_templ::InstanceMethod("toString",
        &_Magick_Color_templ::_wrap_Magick_Color_toString,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("isFuzzyEquivalent");
  members.insert({
    "isFuzzyEquivalent",
      _Magick_Color_templ::InstanceMethod("isFuzzyEquivalent",
        &_Magick_Color_templ::_wrap_Magick_Color_isFuzzyEquivalent,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("isValid");
  members.insert({
    "isValid",
      _Magick_Color_templ::InstanceMethod("isValid",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_isValid,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("pixelType");
  members.insert({
    "pixelType",
      _Magick_Color_templ::InstanceMethod("pixelType",
        &_Magick_Color_templ::_wrap_Magick_Color_pixelType,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumAlpha");
  members.insert({
    "quantumAlpha",
      _Magick_Color_templ::InstanceMethod("quantumAlpha",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumAlpha,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumBlack");
  members.insert({
    "quantumBlack",
      _Magick_Color_templ::InstanceMethod("quantumBlack",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumBlack,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumBlue");
  members.insert({
    "quantumBlue",
      _Magick_Color_templ::InstanceMethod("quantumBlue",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumBlue,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumGreen");
  members.insert({
    "quantumGreen",
      _Magick_Color_templ::InstanceMethod("quantumGreen",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumGreen,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumRed");
  members.insert({
    "quantumRed",
      _Magick_Color_templ::InstanceMethod("quantumRed",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumRed,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("clone");
  members.insert({
    "clone",
      _Magick_ColorCMYK_templ::InstanceMethod("clone",
        &_Magick_ColorCMYK_templ::_wrap_Magick_ColorCMYK_clone,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("alpha");
  members.insert({
    "alpha",
      _Magick_ColorCMYK_templ::InstanceMethod("alpha",
        &_Magick_ColorCMYK_templ::_wrap_ColorCMYK__wrap_Magick_ColorCMYK_alpha,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("black");
  members.insert({
    "black",
      _Magick_ColorCMYK_templ::InstanceMethod("black",
        &_Magick_ColorCMYK_templ::_wrap_ColorCMYK__wrap_Magick_ColorCMYK_black,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("cyan");
  members.insert({
    "cyan",
      _Magick_ColorCMYK_templ::InstanceMethod("cyan",
        &_Magick_ColorCMYK_templ::_wrap_ColorCMYK__wrap_Magick_ColorCMYK_cyan,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("magenta");
  members.insert({
    "magenta",
      _Magick_ColorCMYK_templ::InstanceMethod("magenta",
        &_Magick_ColorCMYK_templ::_wrap_ColorCMYK__wrap_Magick_ColorCMYK_magenta,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("yellow");
  members.insert({
    "yellow",
      _Magick_ColorCMYK_templ::InstanceMethod("yellow",
        &_Magick_ColorCMYK_templ::_wrap_ColorCMYK__wrap_Magick_ColorCMYK_yellow,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_CMYKPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("CMYKPixel");
    staticMembers.insert({
      "CMYKPixel", StaticValue("CMYKPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_CMYKAPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("CMYKAPixel");
    staticMembers.insert({
      "CMYKAPixel", StaticValue("CMYKAPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_RGBPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("RGBPixel");
    staticMembers.insert({
      "RGBPixel", StaticValue("RGBPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_RGBAPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("RGBAPixel");
    staticMembers.insert({
      "RGBAPixel", StaticValue("RGBAPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  
}

/* Class: ColorGray (_Magick_ColorGray) */
// jsnapi_getclass
Napi::Function _Magick_ColorGray_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_ColorGray_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_ColorGray_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_ColorGray_inst>::DefineClass(env, "ColorGray", symbolTable);
}

void _Magick_ColorGray_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_ColorGray_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_ColorGray_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_Color_templ<_Magick_Color_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_Color_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("clone");
  members.insert({
    "clone",
      _Magick_Color_templ::InstanceMethod("clone",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_clone,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("toString");
  members.insert({
    "toString",
      _Magick_Color_templ::InstanceMethod("toString",
        &_Magick_Color_templ::_wrap_Magick_Color_toString,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("isFuzzyEquivalent");
  members.insert({
    "isFuzzyEquivalent",
      _Magick_Color_templ::InstanceMethod("isFuzzyEquivalent",
        &_Magick_Color_templ::_wrap_Magick_Color_isFuzzyEquivalent,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("isValid");
  members.insert({
    "isValid",
      _Magick_Color_templ::InstanceMethod("isValid",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_isValid,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("pixelType");
  members.insert({
    "pixelType",
      _Magick_Color_templ::InstanceMethod("pixelType",
        &_Magick_Color_templ::_wrap_Magick_Color_pixelType,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumAlpha");
  members.insert({
    "quantumAlpha",
      _Magick_Color_templ::InstanceMethod("quantumAlpha",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumAlpha,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumBlack");
  members.insert({
    "quantumBlack",
      _Magick_Color_templ::InstanceMethod("quantumBlack",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumBlack,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumBlue");
  members.insert({
    "quantumBlue",
      _Magick_Color_templ::InstanceMethod("quantumBlue",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumBlue,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumGreen");
  members.insert({
    "quantumGreen",
      _Magick_Color_templ::InstanceMethod("quantumGreen",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumGreen,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumRed");
  members.insert({
    "quantumRed",
      _Magick_Color_templ::InstanceMethod("quantumRed",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumRed,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("shade");
  members.insert({
    "shade",
      _Magick_ColorGray_templ::InstanceMethod("shade",
        &_Magick_ColorGray_templ::_wrap_ColorGray__wrap_Magick_ColorGray_shade,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("clone");
  members.insert({
    "clone",
      _Magick_ColorGray_templ::InstanceMethod("clone",
        &_Magick_ColorGray_templ::_wrap_Magick_ColorGray_clone,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_CMYKPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("CMYKPixel");
    staticMembers.insert({
      "CMYKPixel", StaticValue("CMYKPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_CMYKAPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("CMYKAPixel");
    staticMembers.insert({
      "CMYKAPixel", StaticValue("CMYKAPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_RGBPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("RGBPixel");
    staticMembers.insert({
      "RGBPixel", StaticValue("RGBPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_RGBAPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("RGBAPixel");
    staticMembers.insert({
      "RGBAPixel", StaticValue("RGBAPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  
}

/* Class: ColorHSL (_Magick_ColorHSL) */
// jsnapi_getclass
Napi::Function _Magick_ColorHSL_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_ColorHSL_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_ColorHSL_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_ColorHSL_inst>::DefineClass(env, "ColorHSL", symbolTable);
}

void _Magick_ColorHSL_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_ColorHSL_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_ColorHSL_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_Color_templ<_Magick_Color_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_Color_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("clone");
  members.insert({
    "clone",
      _Magick_Color_templ::InstanceMethod("clone",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_clone,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("toString");
  members.insert({
    "toString",
      _Magick_Color_templ::InstanceMethod("toString",
        &_Magick_Color_templ::_wrap_Magick_Color_toString,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("isFuzzyEquivalent");
  members.insert({
    "isFuzzyEquivalent",
      _Magick_Color_templ::InstanceMethod("isFuzzyEquivalent",
        &_Magick_Color_templ::_wrap_Magick_Color_isFuzzyEquivalent,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("isValid");
  members.insert({
    "isValid",
      _Magick_Color_templ::InstanceMethod("isValid",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_isValid,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("pixelType");
  members.insert({
    "pixelType",
      _Magick_Color_templ::InstanceMethod("pixelType",
        &_Magick_Color_templ::_wrap_Magick_Color_pixelType,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumAlpha");
  members.insert({
    "quantumAlpha",
      _Magick_Color_templ::InstanceMethod("quantumAlpha",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumAlpha,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumBlack");
  members.insert({
    "quantumBlack",
      _Magick_Color_templ::InstanceMethod("quantumBlack",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumBlack,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumBlue");
  members.insert({
    "quantumBlue",
      _Magick_Color_templ::InstanceMethod("quantumBlue",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumBlue,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumGreen");
  members.insert({
    "quantumGreen",
      _Magick_Color_templ::InstanceMethod("quantumGreen",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumGreen,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumRed");
  members.insert({
    "quantumRed",
      _Magick_Color_templ::InstanceMethod("quantumRed",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumRed,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("clone");
  members.insert({
    "clone",
      _Magick_ColorHSL_templ::InstanceMethod("clone",
        &_Magick_ColorHSL_templ::_wrap_Magick_ColorHSL_clone,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("hue");
  members.insert({
    "hue",
      _Magick_ColorHSL_templ::InstanceMethod("hue",
        &_Magick_ColorHSL_templ::_wrap_ColorHSL__wrap_Magick_ColorHSL_hue,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("lightness");
  members.insert({
    "lightness",
      _Magick_ColorHSL_templ::InstanceMethod("lightness",
        &_Magick_ColorHSL_templ::_wrap_ColorHSL__wrap_Magick_ColorHSL_lightness,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("saturation");
  members.insert({
    "saturation",
      _Magick_ColorHSL_templ::InstanceMethod("saturation",
        &_Magick_ColorHSL_templ::_wrap_ColorHSL__wrap_Magick_ColorHSL_saturation,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_CMYKPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("CMYKPixel");
    staticMembers.insert({
      "CMYKPixel", StaticValue("CMYKPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_CMYKAPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("CMYKAPixel");
    staticMembers.insert({
      "CMYKAPixel", StaticValue("CMYKAPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_RGBPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("RGBPixel");
    staticMembers.insert({
      "RGBPixel", StaticValue("RGBPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_RGBAPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("RGBAPixel");
    staticMembers.insert({
      "RGBAPixel", StaticValue("RGBAPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  
}

/* Class: ColorMono (_Magick_ColorMono) */
// jsnapi_getclass
Napi::Function _Magick_ColorMono_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_ColorMono_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_ColorMono_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_ColorMono_inst>::DefineClass(env, "ColorMono", symbolTable);
}

void _Magick_ColorMono_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_ColorMono_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_ColorMono_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_Color_templ<_Magick_Color_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_Color_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("clone");
  members.insert({
    "clone",
      _Magick_Color_templ::InstanceMethod("clone",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_clone,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("toString");
  members.insert({
    "toString",
      _Magick_Color_templ::InstanceMethod("toString",
        &_Magick_Color_templ::_wrap_Magick_Color_toString,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("isFuzzyEquivalent");
  members.insert({
    "isFuzzyEquivalent",
      _Magick_Color_templ::InstanceMethod("isFuzzyEquivalent",
        &_Magick_Color_templ::_wrap_Magick_Color_isFuzzyEquivalent,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("isValid");
  members.insert({
    "isValid",
      _Magick_Color_templ::InstanceMethod("isValid",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_isValid,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("pixelType");
  members.insert({
    "pixelType",
      _Magick_Color_templ::InstanceMethod("pixelType",
        &_Magick_Color_templ::_wrap_Magick_Color_pixelType,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumAlpha");
  members.insert({
    "quantumAlpha",
      _Magick_Color_templ::InstanceMethod("quantumAlpha",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumAlpha,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumBlack");
  members.insert({
    "quantumBlack",
      _Magick_Color_templ::InstanceMethod("quantumBlack",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumBlack,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumBlue");
  members.insert({
    "quantumBlue",
      _Magick_Color_templ::InstanceMethod("quantumBlue",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumBlue,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumGreen");
  members.insert({
    "quantumGreen",
      _Magick_Color_templ::InstanceMethod("quantumGreen",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumGreen,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumRed");
  members.insert({
    "quantumRed",
      _Magick_Color_templ::InstanceMethod("quantumRed",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumRed,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("clone");
  members.insert({
    "clone",
      _Magick_ColorMono_templ::InstanceMethod("clone",
        &_Magick_ColorMono_templ::_wrap_Magick_ColorMono_clone,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("mono");
  members.insert({
    "mono",
      _Magick_ColorMono_templ::InstanceMethod("mono",
        &_Magick_ColorMono_templ::_wrap_ColorMono__wrap_Magick_ColorMono_mono,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_CMYKPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("CMYKPixel");
    staticMembers.insert({
      "CMYKPixel", StaticValue("CMYKPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_CMYKAPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("CMYKAPixel");
    staticMembers.insert({
      "CMYKAPixel", StaticValue("CMYKAPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_RGBPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("RGBPixel");
    staticMembers.insert({
      "RGBPixel", StaticValue("RGBPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_RGBAPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("RGBAPixel");
    staticMembers.insert({
      "RGBAPixel", StaticValue("RGBAPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  
}

/* Class: ColorRGB (_Magick_ColorRGB) */
// jsnapi_getclass
Napi::Function _Magick_ColorRGB_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_ColorRGB_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_ColorRGB_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_ColorRGB_inst>::DefineClass(env, "ColorRGB", symbolTable);
}

void _Magick_ColorRGB_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_ColorRGB_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_ColorRGB_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_Color_templ<_Magick_Color_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_Color_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("clone");
  members.insert({
    "clone",
      _Magick_Color_templ::InstanceMethod("clone",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_clone,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("toString");
  members.insert({
    "toString",
      _Magick_Color_templ::InstanceMethod("toString",
        &_Magick_Color_templ::_wrap_Magick_Color_toString,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("isFuzzyEquivalent");
  members.insert({
    "isFuzzyEquivalent",
      _Magick_Color_templ::InstanceMethod("isFuzzyEquivalent",
        &_Magick_Color_templ::_wrap_Magick_Color_isFuzzyEquivalent,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("isValid");
  members.insert({
    "isValid",
      _Magick_Color_templ::InstanceMethod("isValid",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_isValid,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("pixelType");
  members.insert({
    "pixelType",
      _Magick_Color_templ::InstanceMethod("pixelType",
        &_Magick_Color_templ::_wrap_Magick_Color_pixelType,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumAlpha");
  members.insert({
    "quantumAlpha",
      _Magick_Color_templ::InstanceMethod("quantumAlpha",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumAlpha,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumBlack");
  members.insert({
    "quantumBlack",
      _Magick_Color_templ::InstanceMethod("quantumBlack",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumBlack,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumBlue");
  members.insert({
    "quantumBlue",
      _Magick_Color_templ::InstanceMethod("quantumBlue",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumBlue,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumGreen");
  members.insert({
    "quantumGreen",
      _Magick_Color_templ::InstanceMethod("quantumGreen",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumGreen,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumRed");
  members.insert({
    "quantumRed",
      _Magick_Color_templ::InstanceMethod("quantumRed",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumRed,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("clone");
  members.insert({
    "clone",
      _Magick_ColorRGB_templ::InstanceMethod("clone",
        &_Magick_ColorRGB_templ::_wrap_Magick_ColorRGB_clone,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("alpha");
  members.insert({
    "alpha",
      _Magick_ColorRGB_templ::InstanceMethod("alpha",
        &_Magick_ColorRGB_templ::_wrap_ColorRGB__wrap_Magick_ColorRGB_alpha,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("blue");
  members.insert({
    "blue",
      _Magick_ColorRGB_templ::InstanceMethod("blue",
        &_Magick_ColorRGB_templ::_wrap_ColorRGB__wrap_Magick_ColorRGB_blue,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("green");
  members.insert({
    "green",
      _Magick_ColorRGB_templ::InstanceMethod("green",
        &_Magick_ColorRGB_templ::_wrap_ColorRGB__wrap_Magick_ColorRGB_green,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("red");
  members.insert({
    "red",
      _Magick_ColorRGB_templ::InstanceMethod("red",
        &_Magick_ColorRGB_templ::_wrap_ColorRGB__wrap_Magick_ColorRGB_red,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_CMYKPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("CMYKPixel");
    staticMembers.insert({
      "CMYKPixel", StaticValue("CMYKPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_CMYKAPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("CMYKAPixel");
    staticMembers.insert({
      "CMYKAPixel", StaticValue("CMYKAPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_RGBPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("RGBPixel");
    staticMembers.insert({
      "RGBPixel", StaticValue("RGBPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_RGBAPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("RGBAPixel");
    staticMembers.insert({
      "RGBAPixel", StaticValue("RGBAPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  
}

/* Class: ColorYUV (_Magick_ColorYUV) */
// jsnapi_getclass
Napi::Function _Magick_ColorYUV_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_ColorYUV_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_ColorYUV_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_ColorYUV_inst>::DefineClass(env, "ColorYUV", symbolTable);
}

void _Magick_ColorYUV_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_ColorYUV_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_ColorYUV_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, _Magick_Color_templ<_Magick_Color_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  _Magick_Color_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("clone");
  members.insert({
    "clone",
      _Magick_Color_templ::InstanceMethod("clone",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_clone,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("toString");
  members.insert({
    "toString",
      _Magick_Color_templ::InstanceMethod("toString",
        &_Magick_Color_templ::_wrap_Magick_Color_toString,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("isFuzzyEquivalent");
  members.insert({
    "isFuzzyEquivalent",
      _Magick_Color_templ::InstanceMethod("isFuzzyEquivalent",
        &_Magick_Color_templ::_wrap_Magick_Color_isFuzzyEquivalent,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("isValid");
  members.insert({
    "isValid",
      _Magick_Color_templ::InstanceMethod("isValid",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_isValid,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("pixelType");
  members.insert({
    "pixelType",
      _Magick_Color_templ::InstanceMethod("pixelType",
        &_Magick_Color_templ::_wrap_Magick_Color_pixelType,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumAlpha");
  members.insert({
    "quantumAlpha",
      _Magick_Color_templ::InstanceMethod("quantumAlpha",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumAlpha,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumBlack");
  members.insert({
    "quantumBlack",
      _Magick_Color_templ::InstanceMethod("quantumBlack",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumBlack,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumBlue");
  members.insert({
    "quantumBlue",
      _Magick_Color_templ::InstanceMethod("quantumBlue",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumBlue,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumGreen");
  members.insert({
    "quantumGreen",
      _Magick_Color_templ::InstanceMethod("quantumGreen",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumGreen,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quantumRed");
  members.insert({
    "quantumRed",
      _Magick_Color_templ::InstanceMethod("quantumRed",
        &_Magick_Color_templ::_wrap_Color__wrap_Magick_Color_quantumRed,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("clone");
  members.insert({
    "clone",
      _Magick_ColorYUV_templ::InstanceMethod("clone",
        &_Magick_ColorYUV_templ::_wrap_Magick_ColorYUV_clone,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("u");
  members.insert({
    "u",
      _Magick_ColorYUV_templ::InstanceMethod("u",
        &_Magick_ColorYUV_templ::_wrap_ColorYUV__wrap_Magick_ColorYUV_u,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("v");
  members.insert({
    "v",
      _Magick_ColorYUV_templ::InstanceMethod("v",
        &_Magick_ColorYUV_templ::_wrap_ColorYUV__wrap_Magick_ColorYUV_v,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("y");
  members.insert({
    "y",
      _Magick_ColorYUV_templ::InstanceMethod("y",
        &_Magick_ColorYUV_templ::_wrap_ColorYUV__wrap_Magick_ColorYUV_y,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_CMYKPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("CMYKPixel");
    staticMembers.insert({
      "CMYKPixel", StaticValue("CMYKPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_CMYKAPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("CMYKAPixel");
    staticMembers.insert({
      "CMYKAPixel", StaticValue("CMYKAPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_RGBPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("RGBPixel");
    staticMembers.insert({
      "RGBPixel", StaticValue("RGBPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  // jsnapi_register_static_constant
  do {
    Napi::Function f = Napi::Function::New(env, Magick_Color_RGBAPixel_get);
    Napi::Value value;
    NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
    staticMembers.erase("RGBAPixel");
    staticMembers.insert({
      "RGBAPixel", StaticValue("RGBAPixel", value,
          static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable))
      });
  } while (0);
  
}


// js_global_overloaded_function
Napi::Value _wrap_equal__SWIG_1(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Geometry *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equal" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Geometry * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equal" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator ==((Magick::Geometry const &)*arg1,(Magick::Geometry const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_notEqual__SWIG_1(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Geometry *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Geometry * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator !=((Magick::Geometry const &)*arg1,(Magick::Geometry const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_gt__SWIG_1(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Geometry *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gt" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Geometry * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gt" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gt" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator >((Magick::Geometry const &)*arg1,(Magick::Geometry const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_lt__SWIG_1(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Geometry *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lt" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Geometry * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lt" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lt" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator <((Magick::Geometry const &)*arg1,(Magick::Geometry const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_gte__SWIG_1(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Geometry *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gte" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Geometry * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gte" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gte" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator >=((Magick::Geometry const &)*arg1,(Magick::Geometry const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_lte__SWIG_1(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Geometry *arg1 = 0 ;
  Magick::Geometry *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Geometry,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lte" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "1"" of type '" "Magick::Geometry const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Geometry * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Geometry,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lte" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "lte" "', argument " "2"" of type '" "Magick::Geometry const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Geometry * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator <=((Magick::Geometry const &)*arg1,(Magick::Geometry const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


/* Class: Geometry (_Magick_Geometry) */
// jsnapi_getclass
Napi::Function _Magick_Geometry_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_Geometry_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_Geometry_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_Geometry_inst>::DefineClass(env, "Geometry", symbolTable);
}

void _Magick_Geometry_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_Geometry_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_Geometry_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("toString");
  members.insert({
    "toString",
      _Magick_Geometry_templ::InstanceMethod("toString",
        &_Magick_Geometry_templ::_wrap_Magick_Geometry_toString,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("aspect");
  members.insert({
    "aspect",
      _Magick_Geometry_templ::InstanceMethod("aspect",
        &_Magick_Geometry_templ::_wrap_Geometry__wrap_Magick_Geometry_aspect,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("fillArea");
  members.insert({
    "fillArea",
      _Magick_Geometry_templ::InstanceMethod("fillArea",
        &_Magick_Geometry_templ::_wrap_Geometry__wrap_Magick_Geometry_fillArea,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("greater");
  members.insert({
    "greater",
      _Magick_Geometry_templ::InstanceMethod("greater",
        &_Magick_Geometry_templ::_wrap_Geometry__wrap_Magick_Geometry_greater,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("height");
  members.insert({
    "height",
      _Magick_Geometry_templ::InstanceMethod("height",
        &_Magick_Geometry_templ::_wrap_Geometry__wrap_Magick_Geometry_height,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("isValid");
  members.insert({
    "isValid",
      _Magick_Geometry_templ::InstanceMethod("isValid",
        &_Magick_Geometry_templ::_wrap_Geometry__wrap_Magick_Geometry_isValid,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("less");
  members.insert({
    "less",
      _Magick_Geometry_templ::InstanceMethod("less",
        &_Magick_Geometry_templ::_wrap_Geometry__wrap_Magick_Geometry_less,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("limitPixels");
  members.insert({
    "limitPixels",
      _Magick_Geometry_templ::InstanceMethod("limitPixels",
        &_Magick_Geometry_templ::_wrap_Geometry__wrap_Magick_Geometry_limitPixels,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("percent");
  members.insert({
    "percent",
      _Magick_Geometry_templ::InstanceMethod("percent",
        &_Magick_Geometry_templ::_wrap_Geometry__wrap_Magick_Geometry_percent,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("width");
  members.insert({
    "width",
      _Magick_Geometry_templ::InstanceMethod("width",
        &_Magick_Geometry_templ::_wrap_Geometry__wrap_Magick_Geometry_width,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("xOff");
  members.insert({
    "xOff",
      _Magick_Geometry_templ::InstanceMethod("xOff",
        &_Magick_Geometry_templ::_wrap_Geometry__wrap_Magick_Geometry_xOff,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("yOff");
  members.insert({
    "yOff",
      _Magick_Geometry_templ::InstanceMethod("yOff",
        &_Magick_Geometry_templ::_wrap_Geometry__wrap_Magick_Geometry_yOff,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("clone");
  members.insert({
    "clone",
      _Magick_Geometry_templ::InstanceMethod("clone",
        &_Magick_Geometry_templ::_wrap_Geometry__wrap_Magick_Geometry_clone,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}


// js_global_overloaded_function
Napi::Value _wrap_equal__SWIG_2(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Offset *arg1 = 0 ;
  Magick::Offset *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Offset,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equal" "', argument " "1"" of type '" "Magick::Offset const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "1"" of type '" "Magick::Offset const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Offset * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Offset,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equal" "', argument " "2"" of type '" "Magick::Offset const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "2"" of type '" "Magick::Offset const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Offset * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator ==((Magick::Offset const &)*arg1,(Magick::Offset const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_notEqual__SWIG_2(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Offset *arg1 = 0 ;
  Magick::Offset *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Offset,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Offset const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Offset const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Offset * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Offset,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Offset const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Offset const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Offset * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator !=((Magick::Offset const &)*arg1,(Magick::Offset const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


/* Class: Offset (_Magick_Offset) */
// jsnapi_getclass
Napi::Function _Magick_Offset_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_Offset_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_Offset_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_Offset_inst>::DefineClass(env, "Offset", symbolTable);
}

void _Magick_Offset_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_Offset_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_Offset_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("clone");
  members.insert({
    "clone",
      _Magick_Offset_templ::InstanceMethod("clone",
        &_Magick_Offset_templ::_wrap_Offset__wrap_Magick_Offset_clone,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("x");
  members.insert({
    "x",
      _Magick_Offset_templ::InstanceMethod("x",
        &_Magick_Offset_templ::_wrap_Magick_Offset_x,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("y");
  members.insert({
    "y",
      _Magick_Offset_templ::InstanceMethod("y",
        &_Magick_Offset_templ::_wrap_Magick_Offset_y,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}


// js_global_overloaded_function
Napi::Value _wrap_equal__SWIG_3(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Point *arg1 = 0 ;
  Magick::Point *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Point,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equal" "', argument " "1"" of type '" "Magick::Point const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "1"" of type '" "Magick::Point const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Point * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Point,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equal" "', argument " "2"" of type '" "Magick::Point const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "2"" of type '" "Magick::Point const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Point * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator ==((Magick::Point const &)*arg1,(Magick::Point const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_notEqual__SWIG_3(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Point *arg1 = 0 ;
  Magick::Point *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Point,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Point const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Point const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Point * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Point,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Point const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Point const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Point * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator !=((Magick::Point const &)*arg1,(Magick::Point const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


/* Class: Point (_Magick_Point) */
// jsnapi_getclass
Napi::Function _Magick_Point_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_Point_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_Point_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_Point_inst>::DefineClass(env, "Point", symbolTable);
}

void _Magick_Point_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_Point_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_Point_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("clone");
  members.insert({
    "clone",
      _Magick_Point_templ::InstanceMethod("clone",
        &_Magick_Point_templ::_wrap_Point__wrap_Magick_Point_clone,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("toString");
  members.insert({
    "toString",
      _Magick_Point_templ::InstanceMethod("toString",
        &_Magick_Point_templ::_wrap_Magick_Point_toString,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("isValid");
  members.insert({
    "isValid",
      _Magick_Point_templ::InstanceMethod("isValid",
        &_Magick_Point_templ::_wrap_Magick_Point_isValid,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("x");
  members.insert({
    "x",
      _Magick_Point_templ::InstanceMethod("x",
        &_Magick_Point_templ::_wrap_Magick_Point_x,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("y");
  members.insert({
    "y",
      _Magick_Point_templ::InstanceMethod("y",
        &_Magick_Point_templ::_wrap_Magick_Point_y,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: Coordinate (_Magick_Coordinate) */
// jsnapi_getclass
Napi::Function _Magick_Coordinate_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_Coordinate_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_Coordinate_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_Coordinate_inst>::DefineClass(env, "Coordinate", symbolTable);
}

void _Magick_Coordinate_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_Coordinate_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_Coordinate_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("x");
  members.insert({
    "x",
      _Magick_Coordinate_templ::InstanceMethod("x",
        &_Magick_Coordinate_templ::_wrap_Coordinate__wrap_Magick_Coordinate_x,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("y");
  members.insert({
    "y",
      _Magick_Coordinate_templ::InstanceMethod("y",
        &_Magick_Coordinate_templ::_wrap_Coordinate__wrap_Magick_Coordinate_y,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}


// js_global_overloaded_function
Napi::Value _wrap_equal__SWIG_4(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Coordinate *arg1 = 0 ;
  Magick::Coordinate *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Coordinate,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equal" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Coordinate * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Coordinate,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equal" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "equal" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Coordinate * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator ==((Magick::Coordinate const &)*arg1,(Magick::Coordinate const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}



// js_global_overloaded_function
Napi::Value _wrap_notEqual__SWIG_4(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  Magick::Coordinate *arg1 = 0 ;
  Magick::Coordinate *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  // js_locks_list
  SWIG_Locks_List SWIG_locks;
  int result;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    // js_guard
    SWIG_Guard SWIG_guard(SWIG_locks);
    
    res1 = SWIG_ConvertPtr(info[0], &argp1, SWIGTYPE_p_Magick__Coordinate,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "1"" of type '" "Magick::Coordinate const &""'"); 
    }
    arg1 = reinterpret_cast< Magick::Coordinate * >(argp1);res2 = SWIG_ConvertPtr(info[1], &argp2, SWIGTYPE_p_Magick__Coordinate,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "notEqual" "', argument " "2"" of type '" "Magick::Coordinate const &""'"); 
    }
    arg2 = reinterpret_cast< Magick::Coordinate * >(argp2);
    
    
    // js_lock
    SWIG_guard.lock();
    
    
    
    {
      try {
        result = (int)Magick::operator !=((Magick::Coordinate const &)*arg1,(Magick::Coordinate const &)*arg2);
      } catch (const Magick::Exception &e) {
        do {
          SWIG_NAPI_Raise(env, e.what()); SWIG_fail; 
        } while (0);
        SWIG_fail;
      }
    }
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(result));
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
#endif
  return Napi::Value();
}


