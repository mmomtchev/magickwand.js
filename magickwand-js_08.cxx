/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.2.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

#include "swig/magickwand-js.h"

/* Class: normalizeImage (_Magick_normalizeImage) */
// jsnapi_getclass
Napi::Function _Magick_normalizeImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_normalizeImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_normalizeImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_normalizeImage_inst>::DefineClass(env, "normalizeImage", symbolTable);
}

void _Magick_normalizeImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_normalizeImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_normalizeImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_normalizeImage_templ::InstanceMethod("callAsync",
        &_Magick_normalizeImage_templ::_wrap_Magick_normalizeImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_normalizeImage_templ::InstanceMethod("call",
        &_Magick_normalizeImage_templ::_wrap_Magick_normalizeImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: oilPaintImage (_Magick_oilPaintImage) */
// jsnapi_getclass
Napi::Function _Magick_oilPaintImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_oilPaintImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_oilPaintImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_oilPaintImage_inst>::DefineClass(env, "oilPaintImage", symbolTable);
}

void _Magick_oilPaintImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_oilPaintImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_oilPaintImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_oilPaintImage_templ::InstanceMethod("callAsync",
        &_Magick_oilPaintImage_templ::_wrap_Magick_oilPaintImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_oilPaintImage_templ::InstanceMethod("call",
        &_Magick_oilPaintImage_templ::_wrap_Magick_oilPaintImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: alphaImage (_Magick_alphaImage) */
// jsnapi_getclass
Napi::Function _Magick_alphaImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_alphaImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_alphaImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_alphaImage_inst>::DefineClass(env, "alphaImage", symbolTable);
}

void _Magick_alphaImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_alphaImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_alphaImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_alphaImage_templ::InstanceMethod("callAsync",
        &_Magick_alphaImage_templ::_wrap_Magick_alphaImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_alphaImage_templ::InstanceMethod("call",
        &_Magick_alphaImage_templ::_wrap_Magick_alphaImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: opaqueImage (_Magick_opaqueImage) */
// jsnapi_getclass
Napi::Function _Magick_opaqueImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_opaqueImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_opaqueImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_opaqueImage_inst>::DefineClass(env, "opaqueImage", symbolTable);
}

void _Magick_opaqueImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_opaqueImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_opaqueImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_opaqueImage_templ::InstanceMethod("callAsync",
        &_Magick_opaqueImage_templ::_wrap_Magick_opaqueImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_opaqueImage_templ::InstanceMethod("call",
        &_Magick_opaqueImage_templ::_wrap_Magick_opaqueImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: quantizeImage (_Magick_quantizeImage) */
// jsnapi_getclass
Napi::Function _Magick_quantizeImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_quantizeImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_quantizeImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_quantizeImage_inst>::DefineClass(env, "quantizeImage", symbolTable);
}

void _Magick_quantizeImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_quantizeImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_quantizeImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_quantizeImage_templ::InstanceMethod("callAsync",
        &_Magick_quantizeImage_templ::_wrap_Magick_quantizeImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_quantizeImage_templ::InstanceMethod("call",
        &_Magick_quantizeImage_templ::_wrap_Magick_quantizeImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: raiseImage (_Magick_raiseImage) */
// jsnapi_getclass
Napi::Function _Magick_raiseImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_raiseImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_raiseImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_raiseImage_inst>::DefineClass(env, "raiseImage", symbolTable);
}

void _Magick_raiseImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_raiseImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_raiseImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_raiseImage_templ::InstanceMethod("callAsync",
        &_Magick_raiseImage_templ::_wrap_Magick_raiseImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_raiseImage_templ::InstanceMethod("call",
        &_Magick_raiseImage_templ::_wrap_Magick_raiseImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: ReadOptions (_Magick_ReadOptions) */
// jsnapi_getclass
Napi::Function _Magick_ReadOptions_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_ReadOptions_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_ReadOptions_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_ReadOptions_inst>::DefineClass(env, "ReadOptions", symbolTable);
}

void _Magick_ReadOptions_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_ReadOptions_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_ReadOptions_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("density");
  members.insert({
    "density",
      _Magick_ReadOptions_templ::InstanceMethod("density",
        &_Magick_ReadOptions_templ::_wrap_ReadOptions__wrap_Magick_ReadOptions_density,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("depth");
  members.insert({
    "depth",
      _Magick_ReadOptions_templ::InstanceMethod("depth",
        &_Magick_ReadOptions_templ::_wrap_ReadOptions__wrap_Magick_ReadOptions_depth,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("ping");
  members.insert({
    "ping",
      _Magick_ReadOptions_templ::InstanceMethod("ping",
        &_Magick_ReadOptions_templ::_wrap_ReadOptions__wrap_Magick_ReadOptions_ping,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("quiet");
  members.insert({
    "quiet",
      _Magick_ReadOptions_templ::InstanceMethod("quiet",
        &_Magick_ReadOptions_templ::_wrap_ReadOptions__wrap_Magick_ReadOptions_quiet,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("size");
  members.insert({
    "size",
      _Magick_ReadOptions_templ::InstanceMethod("size",
        &_Magick_ReadOptions_templ::_wrap_ReadOptions__wrap_Magick_ReadOptions_size,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("imageInfo");
  members.insert({
    "imageInfo",
      _Magick_ReadOptions_templ::InstanceMethod("imageInfo",
        &_Magick_ReadOptions_templ::_wrap_Magick_ReadOptions_imageInfo,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: reduceNoiseImage (_Magick_reduceNoiseImage) */
// jsnapi_getclass
Napi::Function _Magick_reduceNoiseImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_reduceNoiseImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_reduceNoiseImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_reduceNoiseImage_inst>::DefineClass(env, "reduceNoiseImage", symbolTable);
}

void _Magick_reduceNoiseImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_reduceNoiseImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_reduceNoiseImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_reduceNoiseImage_templ::InstanceMethod("callAsync",
        &_Magick_reduceNoiseImage_templ::_wrap_Magick_reduceNoiseImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_reduceNoiseImage_templ::InstanceMethod("call",
        &_Magick_reduceNoiseImage_templ::_wrap_Magick_reduceNoiseImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: resizeImage (_Magick_resizeImage) */
// jsnapi_getclass
Napi::Function _Magick_resizeImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_resizeImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_resizeImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_resizeImage_inst>::DefineClass(env, "resizeImage", symbolTable);
}

void _Magick_resizeImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_resizeImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_resizeImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_resizeImage_templ::InstanceMethod("callAsync",
        &_Magick_resizeImage_templ::_wrap_Magick_resizeImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_resizeImage_templ::InstanceMethod("call",
        &_Magick_resizeImage_templ::_wrap_Magick_resizeImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: rollImage (_Magick_rollImage) */
// jsnapi_getclass
Napi::Function _Magick_rollImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_rollImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_rollImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_rollImage_inst>::DefineClass(env, "rollImage", symbolTable);
}

void _Magick_rollImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_rollImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_rollImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_rollImage_templ::InstanceMethod("callAsync",
        &_Magick_rollImage_templ::_wrap_Magick_rollImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_rollImage_templ::InstanceMethod("call",
        &_Magick_rollImage_templ::_wrap_Magick_rollImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: rotateImage (_Magick_rotateImage) */
// jsnapi_getclass
Napi::Function _Magick_rotateImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_rotateImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_rotateImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_rotateImage_inst>::DefineClass(env, "rotateImage", symbolTable);
}

void _Magick_rotateImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_rotateImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_rotateImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_rotateImage_templ::InstanceMethod("callAsync",
        &_Magick_rotateImage_templ::_wrap_Magick_rotateImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_rotateImage_templ::InstanceMethod("call",
        &_Magick_rotateImage_templ::_wrap_Magick_rotateImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: sampleImage (_Magick_sampleImage) */
// jsnapi_getclass
Napi::Function _Magick_sampleImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_sampleImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_sampleImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_sampleImage_inst>::DefineClass(env, "sampleImage", symbolTable);
}

void _Magick_sampleImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_sampleImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_sampleImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_sampleImage_templ::InstanceMethod("callAsync",
        &_Magick_sampleImage_templ::_wrap_Magick_sampleImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_sampleImage_templ::InstanceMethod("call",
        &_Magick_sampleImage_templ::_wrap_Magick_sampleImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: scaleImage (_Magick_scaleImage) */
// jsnapi_getclass
Napi::Function _Magick_scaleImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_scaleImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_scaleImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_scaleImage_inst>::DefineClass(env, "scaleImage", symbolTable);
}

void _Magick_scaleImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_scaleImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_scaleImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_scaleImage_templ::InstanceMethod("callAsync",
        &_Magick_scaleImage_templ::_wrap_Magick_scaleImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_scaleImage_templ::InstanceMethod("call",
        &_Magick_scaleImage_templ::_wrap_Magick_scaleImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: segmentImage (_Magick_segmentImage) */
// jsnapi_getclass
Napi::Function _Magick_segmentImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_segmentImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_segmentImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_segmentImage_inst>::DefineClass(env, "segmentImage", symbolTable);
}

void _Magick_segmentImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_segmentImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_segmentImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_segmentImage_templ::InstanceMethod("callAsync",
        &_Magick_segmentImage_templ::_wrap_Magick_segmentImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_segmentImage_templ::InstanceMethod("call",
        &_Magick_segmentImage_templ::_wrap_Magick_segmentImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: shadeImage (_Magick_shadeImage) */
// jsnapi_getclass
Napi::Function _Magick_shadeImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_shadeImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_shadeImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_shadeImage_inst>::DefineClass(env, "shadeImage", symbolTable);
}

void _Magick_shadeImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_shadeImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_shadeImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_shadeImage_templ::InstanceMethod("callAsync",
        &_Magick_shadeImage_templ::_wrap_Magick_shadeImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_shadeImage_templ::InstanceMethod("call",
        &_Magick_shadeImage_templ::_wrap_Magick_shadeImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: shadowImage (_Magick_shadowImage) */
// jsnapi_getclass
Napi::Function _Magick_shadowImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_shadowImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_shadowImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_shadowImage_inst>::DefineClass(env, "shadowImage", symbolTable);
}

void _Magick_shadowImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_shadowImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_shadowImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_shadowImage_templ::InstanceMethod("callAsync",
        &_Magick_shadowImage_templ::_wrap_Magick_shadowImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_shadowImage_templ::InstanceMethod("call",
        &_Magick_shadowImage_templ::_wrap_Magick_shadowImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: sharpenImage (_Magick_sharpenImage) */
// jsnapi_getclass
Napi::Function _Magick_sharpenImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_sharpenImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_sharpenImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_sharpenImage_inst>::DefineClass(env, "sharpenImage", symbolTable);
}

void _Magick_sharpenImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_sharpenImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_sharpenImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_sharpenImage_templ::InstanceMethod("callAsync",
        &_Magick_sharpenImage_templ::_wrap_Magick_sharpenImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_sharpenImage_templ::InstanceMethod("call",
        &_Magick_sharpenImage_templ::_wrap_Magick_sharpenImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: shaveImage (_Magick_shaveImage) */
// jsnapi_getclass
Napi::Function _Magick_shaveImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_shaveImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_shaveImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_shaveImage_inst>::DefineClass(env, "shaveImage", symbolTable);
}

void _Magick_shaveImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_shaveImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_shaveImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_shaveImage_templ::InstanceMethod("callAsync",
        &_Magick_shaveImage_templ::_wrap_Magick_shaveImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_shaveImage_templ::InstanceMethod("call",
        &_Magick_shaveImage_templ::_wrap_Magick_shaveImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: shearImage (_Magick_shearImage) */
// jsnapi_getclass
Napi::Function _Magick_shearImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_shearImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_shearImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_shearImage_inst>::DefineClass(env, "shearImage", symbolTable);
}

void _Magick_shearImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_shearImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_shearImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_shearImage_templ::InstanceMethod("callAsync",
        &_Magick_shearImage_templ::_wrap_Magick_shearImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_shearImage_templ::InstanceMethod("call",
        &_Magick_shearImage_templ::_wrap_Magick_shearImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: solarizeImage (_Magick_solarizeImage) */
// jsnapi_getclass
Napi::Function _Magick_solarizeImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_solarizeImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_solarizeImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_solarizeImage_inst>::DefineClass(env, "solarizeImage", symbolTable);
}

void _Magick_solarizeImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_solarizeImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_solarizeImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_solarizeImage_templ::InstanceMethod("callAsync",
        &_Magick_solarizeImage_templ::_wrap_Magick_solarizeImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_solarizeImage_templ::InstanceMethod("call",
        &_Magick_solarizeImage_templ::_wrap_Magick_solarizeImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: spliceImage (_Magick_spliceImage) */
// jsnapi_getclass
Napi::Function _Magick_spliceImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_spliceImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_spliceImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_spliceImage_inst>::DefineClass(env, "spliceImage", symbolTable);
}

void _Magick_spliceImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_spliceImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_spliceImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_spliceImage_templ::InstanceMethod("callAsync",
        &_Magick_spliceImage_templ::_wrap_Magick_spliceImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_spliceImage_templ::InstanceMethod("call",
        &_Magick_spliceImage_templ::_wrap_Magick_spliceImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: spreadImage (_Magick_spreadImage) */
// jsnapi_getclass
Napi::Function _Magick_spreadImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_spreadImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_spreadImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_spreadImage_inst>::DefineClass(env, "spreadImage", symbolTable);
}

void _Magick_spreadImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_spreadImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_spreadImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_spreadImage_templ::InstanceMethod("callAsync",
        &_Magick_spreadImage_templ::_wrap_Magick_spreadImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_spreadImage_templ::InstanceMethod("call",
        &_Magick_spreadImage_templ::_wrap_Magick_spreadImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: steganoImage (_Magick_steganoImage) */
// jsnapi_getclass
Napi::Function _Magick_steganoImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_steganoImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_steganoImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_steganoImage_inst>::DefineClass(env, "steganoImage", symbolTable);
}

void _Magick_steganoImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_steganoImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_steganoImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_steganoImage_templ::InstanceMethod("callAsync",
        &_Magick_steganoImage_templ::_wrap_Magick_steganoImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_steganoImage_templ::InstanceMethod("call",
        &_Magick_steganoImage_templ::_wrap_Magick_steganoImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: stereoImage (_Magick_stereoImage) */
// jsnapi_getclass
Napi::Function _Magick_stereoImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_stereoImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_stereoImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_stereoImage_inst>::DefineClass(env, "stereoImage", symbolTable);
}

void _Magick_stereoImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_stereoImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_stereoImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_stereoImage_templ::InstanceMethod("callAsync",
        &_Magick_stereoImage_templ::_wrap_Magick_stereoImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_stereoImage_templ::InstanceMethod("call",
        &_Magick_stereoImage_templ::_wrap_Magick_stereoImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: strokeColorImage (_Magick_strokeColorImage) */
// jsnapi_getclass
Napi::Function _Magick_strokeColorImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_strokeColorImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_strokeColorImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_strokeColorImage_inst>::DefineClass(env, "strokeColorImage", symbolTable);
}

void _Magick_strokeColorImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_strokeColorImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_strokeColorImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_strokeColorImage_templ::InstanceMethod("call",
        &_Magick_strokeColorImage_templ::_wrap_Magick_strokeColorImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: swirlImage (_Magick_swirlImage) */
// jsnapi_getclass
Napi::Function _Magick_swirlImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_swirlImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_swirlImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_swirlImage_inst>::DefineClass(env, "swirlImage", symbolTable);
}

void _Magick_swirlImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_swirlImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_swirlImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_swirlImage_templ::InstanceMethod("callAsync",
        &_Magick_swirlImage_templ::_wrap_Magick_swirlImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_swirlImage_templ::InstanceMethod("call",
        &_Magick_swirlImage_templ::_wrap_Magick_swirlImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: textureImage (_Magick_textureImage) */
// jsnapi_getclass
Napi::Function _Magick_textureImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_textureImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_textureImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_textureImage_inst>::DefineClass(env, "textureImage", symbolTable);
}

void _Magick_textureImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_textureImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_textureImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_textureImage_templ::InstanceMethod("callAsync",
        &_Magick_textureImage_templ::_wrap_Magick_textureImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_textureImage_templ::InstanceMethod("call",
        &_Magick_textureImage_templ::_wrap_Magick_textureImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: thresholdImage (_Magick_thresholdImage) */
// jsnapi_getclass
Napi::Function _Magick_thresholdImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_thresholdImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_thresholdImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_thresholdImage_inst>::DefineClass(env, "thresholdImage", symbolTable);
}

void _Magick_thresholdImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_thresholdImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_thresholdImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_thresholdImage_templ::InstanceMethod("callAsync",
        &_Magick_thresholdImage_templ::_wrap_Magick_thresholdImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_thresholdImage_templ::InstanceMethod("call",
        &_Magick_thresholdImage_templ::_wrap_Magick_thresholdImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: transparentImage (_Magick_transparentImage) */
// jsnapi_getclass
Napi::Function _Magick_transparentImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_transparentImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_transparentImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_transparentImage_inst>::DefineClass(env, "transparentImage", symbolTable);
}

void _Magick_transparentImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_transparentImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_transparentImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_transparentImage_templ::InstanceMethod("callAsync",
        &_Magick_transparentImage_templ::_wrap_Magick_transparentImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_transparentImage_templ::InstanceMethod("call",
        &_Magick_transparentImage_templ::_wrap_Magick_transparentImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: trimImage (_Magick_trimImage) */
// jsnapi_getclass
Napi::Function _Magick_trimImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_trimImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_trimImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_trimImage_inst>::DefineClass(env, "trimImage", symbolTable);
}

void _Magick_trimImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_trimImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_trimImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_trimImage_templ::InstanceMethod("callAsync",
        &_Magick_trimImage_templ::_wrap_Magick_trimImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_trimImage_templ::InstanceMethod("call",
        &_Magick_trimImage_templ::_wrap_Magick_trimImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: waveImage (_Magick_waveImage) */
// jsnapi_getclass
Napi::Function _Magick_waveImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_waveImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_waveImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_waveImage_inst>::DefineClass(env, "waveImage", symbolTable);
}

void _Magick_waveImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_waveImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_waveImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_waveImage_templ::InstanceMethod("callAsync",
        &_Magick_waveImage_templ::_wrap_Magick_waveImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_waveImage_templ::InstanceMethod("call",
        &_Magick_waveImage_templ::_wrap_Magick_waveImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: zoomImage (_Magick_zoomImage) */
// jsnapi_getclass
Napi::Function _Magick_zoomImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_zoomImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_zoomImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_zoomImage_inst>::DefineClass(env, "zoomImage", symbolTable);
}

void _Magick_zoomImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_zoomImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_zoomImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_zoomImage_templ::InstanceMethod("callAsync",
        &_Magick_zoomImage_templ::_wrap_Magick_zoomImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_zoomImage_templ::InstanceMethod("call",
        &_Magick_zoomImage_templ::_wrap_Magick_zoomImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: adjoinImage (_Magick_adjoinImage) */
// jsnapi_getclass
Napi::Function _Magick_adjoinImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_adjoinImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_adjoinImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_adjoinImage_inst>::DefineClass(env, "adjoinImage", symbolTable);
}

void _Magick_adjoinImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_adjoinImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_adjoinImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_adjoinImage_templ::InstanceMethod("callAsync",
        &_Magick_adjoinImage_templ::_wrap_Magick_adjoinImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_adjoinImage_templ::InstanceMethod("call",
        &_Magick_adjoinImage_templ::_wrap_Magick_adjoinImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: animationDelayImage (_Magick_animationDelayImage) */
// jsnapi_getclass
Napi::Function _Magick_animationDelayImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_animationDelayImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_animationDelayImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_animationDelayImage_inst>::DefineClass(env, "animationDelayImage", symbolTable);
}

void _Magick_animationDelayImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_animationDelayImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_animationDelayImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_animationDelayImage_templ::InstanceMethod("callAsync",
        &_Magick_animationDelayImage_templ::_wrap_Magick_animationDelayImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_animationDelayImage_templ::InstanceMethod("call",
        &_Magick_animationDelayImage_templ::_wrap_Magick_animationDelayImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: animationIterationsImage (_Magick_animationIterationsImage) */
// jsnapi_getclass
Napi::Function _Magick_animationIterationsImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_animationIterationsImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_animationIterationsImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_animationIterationsImage_inst>::DefineClass(env, "animationIterationsImage", symbolTable);
}

void _Magick_animationIterationsImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_animationIterationsImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_animationIterationsImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_animationIterationsImage_templ::InstanceMethod("callAsync",
        &_Magick_animationIterationsImage_templ::_wrap_Magick_animationIterationsImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_animationIterationsImage_templ::InstanceMethod("call",
        &_Magick_animationIterationsImage_templ::_wrap_Magick_animationIterationsImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: backgroundColorImage (_Magick_backgroundColorImage) */
// jsnapi_getclass
Napi::Function _Magick_backgroundColorImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_backgroundColorImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_backgroundColorImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_backgroundColorImage_inst>::DefineClass(env, "backgroundColorImage", symbolTable);
}

void _Magick_backgroundColorImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_backgroundColorImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_backgroundColorImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_backgroundColorImage_templ::InstanceMethod("call",
        &_Magick_backgroundColorImage_templ::_wrap_Magick_backgroundColorImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: backgroundTextureImage (_Magick_backgroundTextureImage) */
// jsnapi_getclass
Napi::Function _Magick_backgroundTextureImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_backgroundTextureImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_backgroundTextureImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_backgroundTextureImage_inst>::DefineClass(env, "backgroundTextureImage", symbolTable);
}

void _Magick_backgroundTextureImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_backgroundTextureImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_backgroundTextureImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_backgroundTextureImage_templ::InstanceMethod("callAsync",
        &_Magick_backgroundTextureImage_templ::_wrap_Magick_backgroundTextureImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_backgroundTextureImage_templ::InstanceMethod("call",
        &_Magick_backgroundTextureImage_templ::_wrap_Magick_backgroundTextureImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: borderColorImage (_Magick_borderColorImage) */
// jsnapi_getclass
Napi::Function _Magick_borderColorImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_borderColorImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_borderColorImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_borderColorImage_inst>::DefineClass(env, "borderColorImage", symbolTable);
}

void _Magick_borderColorImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_borderColorImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_borderColorImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_borderColorImage_templ::InstanceMethod("call",
        &_Magick_borderColorImage_templ::_wrap_Magick_borderColorImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: boxColorImage (_Magick_boxColorImage) */
// jsnapi_getclass
Napi::Function _Magick_boxColorImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_boxColorImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_boxColorImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_boxColorImage_inst>::DefineClass(env, "boxColorImage", symbolTable);
}

void _Magick_boxColorImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_boxColorImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_boxColorImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_boxColorImage_templ::InstanceMethod("call",
        &_Magick_boxColorImage_templ::_wrap_Magick_boxColorImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: chromaBluePrimaryImage (_Magick_chromaBluePrimaryImage) */
// jsnapi_getclass
Napi::Function _Magick_chromaBluePrimaryImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_chromaBluePrimaryImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_chromaBluePrimaryImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_chromaBluePrimaryImage_inst>::DefineClass(env, "chromaBluePrimaryImage", symbolTable);
}

void _Magick_chromaBluePrimaryImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_chromaBluePrimaryImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_chromaBluePrimaryImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_chromaBluePrimaryImage_templ::InstanceMethod("callAsync",
        &_Magick_chromaBluePrimaryImage_templ::_wrap_Magick_chromaBluePrimaryImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_chromaBluePrimaryImage_templ::InstanceMethod("call",
        &_Magick_chromaBluePrimaryImage_templ::_wrap_Magick_chromaBluePrimaryImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: chromaGreenPrimaryImage (_Magick_chromaGreenPrimaryImage) */
// jsnapi_getclass
Napi::Function _Magick_chromaGreenPrimaryImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_chromaGreenPrimaryImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_chromaGreenPrimaryImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_chromaGreenPrimaryImage_inst>::DefineClass(env, "chromaGreenPrimaryImage", symbolTable);
}

void _Magick_chromaGreenPrimaryImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_chromaGreenPrimaryImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_chromaGreenPrimaryImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_chromaGreenPrimaryImage_templ::InstanceMethod("callAsync",
        &_Magick_chromaGreenPrimaryImage_templ::_wrap_Magick_chromaGreenPrimaryImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_chromaGreenPrimaryImage_templ::InstanceMethod("call",
        &_Magick_chromaGreenPrimaryImage_templ::_wrap_Magick_chromaGreenPrimaryImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: chromaRedPrimaryImage (_Magick_chromaRedPrimaryImage) */
// jsnapi_getclass
Napi::Function _Magick_chromaRedPrimaryImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_chromaRedPrimaryImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_chromaRedPrimaryImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_chromaRedPrimaryImage_inst>::DefineClass(env, "chromaRedPrimaryImage", symbolTable);
}

void _Magick_chromaRedPrimaryImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_chromaRedPrimaryImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_chromaRedPrimaryImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_chromaRedPrimaryImage_templ::InstanceMethod("callAsync",
        &_Magick_chromaRedPrimaryImage_templ::_wrap_Magick_chromaRedPrimaryImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_chromaRedPrimaryImage_templ::InstanceMethod("call",
        &_Magick_chromaRedPrimaryImage_templ::_wrap_Magick_chromaRedPrimaryImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: chromaWhitePointImage (_Magick_chromaWhitePointImage) */
// jsnapi_getclass
Napi::Function _Magick_chromaWhitePointImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_chromaWhitePointImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_chromaWhitePointImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_chromaWhitePointImage_inst>::DefineClass(env, "chromaWhitePointImage", symbolTable);
}

void _Magick_chromaWhitePointImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_chromaWhitePointImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_chromaWhitePointImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_chromaWhitePointImage_templ::InstanceMethod("callAsync",
        &_Magick_chromaWhitePointImage_templ::_wrap_Magick_chromaWhitePointImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_chromaWhitePointImage_templ::InstanceMethod("call",
        &_Magick_chromaWhitePointImage_templ::_wrap_Magick_chromaWhitePointImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: colorFuzzImage (_Magick_colorFuzzImage) */
// jsnapi_getclass
Napi::Function _Magick_colorFuzzImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_colorFuzzImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_colorFuzzImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_colorFuzzImage_inst>::DefineClass(env, "colorFuzzImage", symbolTable);
}

void _Magick_colorFuzzImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_colorFuzzImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_colorFuzzImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_colorFuzzImage_templ::InstanceMethod("callAsync",
        &_Magick_colorFuzzImage_templ::_wrap_Magick_colorFuzzImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_colorFuzzImage_templ::InstanceMethod("call",
        &_Magick_colorFuzzImage_templ::_wrap_Magick_colorFuzzImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: colorMapImage (_Magick_colorMapImage) */
// jsnapi_getclass
Napi::Function _Magick_colorMapImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_colorMapImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_colorMapImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_colorMapImage_inst>::DefineClass(env, "colorMapImage", symbolTable);
}

void _Magick_colorMapImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_colorMapImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_colorMapImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_colorMapImage_templ::InstanceMethod("callAsync",
        &_Magick_colorMapImage_templ::_wrap_Magick_colorMapImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_colorMapImage_templ::InstanceMethod("call",
        &_Magick_colorMapImage_templ::_wrap_Magick_colorMapImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: composeImage (_Magick_composeImage) */
// jsnapi_getclass
Napi::Function _Magick_composeImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_composeImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_composeImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_composeImage_inst>::DefineClass(env, "composeImage", symbolTable);
}

void _Magick_composeImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_composeImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_composeImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_composeImage_templ::InstanceMethod("callAsync",
        &_Magick_composeImage_templ::_wrap_Magick_composeImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_composeImage_templ::InstanceMethod("call",
        &_Magick_composeImage_templ::_wrap_Magick_composeImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: compressTypeImage (_Magick_compressTypeImage) */
// jsnapi_getclass
Napi::Function _Magick_compressTypeImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_compressTypeImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_compressTypeImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_compressTypeImage_inst>::DefineClass(env, "compressTypeImage", symbolTable);
}

void _Magick_compressTypeImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_compressTypeImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_compressTypeImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_compressTypeImage_templ::InstanceMethod("callAsync",
        &_Magick_compressTypeImage_templ::_wrap_Magick_compressTypeImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_compressTypeImage_templ::InstanceMethod("call",
        &_Magick_compressTypeImage_templ::_wrap_Magick_compressTypeImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: densityImage (_Magick_densityImage) */
// jsnapi_getclass
Napi::Function _Magick_densityImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_densityImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_densityImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_densityImage_inst>::DefineClass(env, "densityImage", symbolTable);
}

void _Magick_densityImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_densityImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_densityImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_densityImage_templ::InstanceMethod("callAsync",
        &_Magick_densityImage_templ::_wrap_Magick_densityImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_densityImage_templ::InstanceMethod("call",
        &_Magick_densityImage_templ::_wrap_Magick_densityImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: depthImage (_Magick_depthImage) */
// jsnapi_getclass
Napi::Function _Magick_depthImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_depthImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_depthImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_depthImage_inst>::DefineClass(env, "depthImage", symbolTable);
}

void _Magick_depthImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_depthImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_depthImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_depthImage_templ::InstanceMethod("callAsync",
        &_Magick_depthImage_templ::_wrap_Magick_depthImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_depthImage_templ::InstanceMethod("call",
        &_Magick_depthImage_templ::_wrap_Magick_depthImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: endianImage (_Magick_endianImage) */
// jsnapi_getclass
Napi::Function _Magick_endianImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_endianImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_endianImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_endianImage_inst>::DefineClass(env, "endianImage", symbolTable);
}

void _Magick_endianImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_endianImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_endianImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_endianImage_templ::InstanceMethod("callAsync",
        &_Magick_endianImage_templ::_wrap_Magick_endianImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_endianImage_templ::InstanceMethod("call",
        &_Magick_endianImage_templ::_wrap_Magick_endianImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: fileNameImage (_Magick_fileNameImage) */
// jsnapi_getclass
Napi::Function _Magick_fileNameImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_fileNameImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_fileNameImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_fileNameImage_inst>::DefineClass(env, "fileNameImage", symbolTable);
}

void _Magick_fileNameImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_fileNameImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_fileNameImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_fileNameImage_templ::InstanceMethod("callAsync",
        &_Magick_fileNameImage_templ::_wrap_Magick_fileNameImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_fileNameImage_templ::InstanceMethod("call",
        &_Magick_fileNameImage_templ::_wrap_Magick_fileNameImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: filterTypeImage (_Magick_filterTypeImage) */
// jsnapi_getclass
Napi::Function _Magick_filterTypeImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_filterTypeImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_filterTypeImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_filterTypeImage_inst>::DefineClass(env, "filterTypeImage", symbolTable);
}

void _Magick_filterTypeImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_filterTypeImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_filterTypeImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_filterTypeImage_templ::InstanceMethod("callAsync",
        &_Magick_filterTypeImage_templ::_wrap_Magick_filterTypeImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_filterTypeImage_templ::InstanceMethod("call",
        &_Magick_filterTypeImage_templ::_wrap_Magick_filterTypeImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: fontImage (_Magick_fontImage) */
// jsnapi_getclass
Napi::Function _Magick_fontImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_fontImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_fontImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_fontImage_inst>::DefineClass(env, "fontImage", symbolTable);
}

void _Magick_fontImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_fontImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_fontImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_fontImage_templ::InstanceMethod("callAsync",
        &_Magick_fontImage_templ::_wrap_Magick_fontImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_fontImage_templ::InstanceMethod("call",
        &_Magick_fontImage_templ::_wrap_Magick_fontImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: fontPointsizeImage (_Magick_fontPointsizeImage) */
// jsnapi_getclass
Napi::Function _Magick_fontPointsizeImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_fontPointsizeImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_fontPointsizeImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_fontPointsizeImage_inst>::DefineClass(env, "fontPointsizeImage", symbolTable);
}

void _Magick_fontPointsizeImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_fontPointsizeImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_fontPointsizeImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_fontPointsizeImage_templ::InstanceMethod("callAsync",
        &_Magick_fontPointsizeImage_templ::_wrap_Magick_fontPointsizeImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_fontPointsizeImage_templ::InstanceMethod("call",
        &_Magick_fontPointsizeImage_templ::_wrap_Magick_fontPointsizeImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: gifDisposeMethodImage (_Magick_gifDisposeMethodImage) */
// jsnapi_getclass
Napi::Function _Magick_gifDisposeMethodImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_gifDisposeMethodImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_gifDisposeMethodImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_gifDisposeMethodImage_inst>::DefineClass(env, "gifDisposeMethodImage", symbolTable);
}

void _Magick_gifDisposeMethodImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_gifDisposeMethodImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_gifDisposeMethodImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_gifDisposeMethodImage_templ::InstanceMethod("callAsync",
        &_Magick_gifDisposeMethodImage_templ::_wrap_Magick_gifDisposeMethodImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_gifDisposeMethodImage_templ::InstanceMethod("call",
        &_Magick_gifDisposeMethodImage_templ::_wrap_Magick_gifDisposeMethodImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: interlaceTypeImage (_Magick_interlaceTypeImage) */
// jsnapi_getclass
Napi::Function _Magick_interlaceTypeImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_interlaceTypeImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_interlaceTypeImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_interlaceTypeImage_inst>::DefineClass(env, "interlaceTypeImage", symbolTable);
}

void _Magick_interlaceTypeImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_interlaceTypeImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_interlaceTypeImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_interlaceTypeImage_templ::InstanceMethod("callAsync",
        &_Magick_interlaceTypeImage_templ::_wrap_Magick_interlaceTypeImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_interlaceTypeImage_templ::InstanceMethod("call",
        &_Magick_interlaceTypeImage_templ::_wrap_Magick_interlaceTypeImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: magickImage (_Magick_magickImage) */
// jsnapi_getclass
Napi::Function _Magick_magickImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_magickImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_magickImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_magickImage_inst>::DefineClass(env, "magickImage", symbolTable);
}

void _Magick_magickImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_magickImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_magickImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_magickImage_templ::InstanceMethod("callAsync",
        &_Magick_magickImage_templ::_wrap_Magick_magickImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_magickImage_templ::InstanceMethod("call",
        &_Magick_magickImage_templ::_wrap_Magick_magickImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: alphaFlagImage (_Magick_alphaFlagImage) */
// jsnapi_getclass
Napi::Function _Magick_alphaFlagImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_alphaFlagImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_alphaFlagImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_alphaFlagImage_inst>::DefineClass(env, "alphaFlagImage", symbolTable);
}

void _Magick_alphaFlagImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_alphaFlagImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_alphaFlagImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_alphaFlagImage_templ::InstanceMethod("callAsync",
        &_Magick_alphaFlagImage_templ::_wrap_Magick_alphaFlagImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_alphaFlagImage_templ::InstanceMethod("call",
        &_Magick_alphaFlagImage_templ::_wrap_Magick_alphaFlagImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: matteColorImage (_Magick_matteColorImage) */
// jsnapi_getclass
Napi::Function _Magick_matteColorImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_matteColorImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_matteColorImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_matteColorImage_inst>::DefineClass(env, "matteColorImage", symbolTable);
}

void _Magick_matteColorImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_matteColorImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_matteColorImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_matteColorImage_templ::InstanceMethod("call",
        &_Magick_matteColorImage_templ::_wrap_Magick_matteColorImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: monochromeImage (_Magick_monochromeImage) */
// jsnapi_getclass
Napi::Function _Magick_monochromeImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_monochromeImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_monochromeImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_monochromeImage_inst>::DefineClass(env, "monochromeImage", symbolTable);
}

void _Magick_monochromeImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_monochromeImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_monochromeImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_monochromeImage_templ::InstanceMethod("callAsync",
        &_Magick_monochromeImage_templ::_wrap_Magick_monochromeImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_monochromeImage_templ::InstanceMethod("call",
        &_Magick_monochromeImage_templ::_wrap_Magick_monochromeImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: pixelColorImage (_Magick_pixelColorImage) */
// jsnapi_getclass
Napi::Function _Magick_pixelColorImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_pixelColorImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_pixelColorImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_pixelColorImage_inst>::DefineClass(env, "pixelColorImage", symbolTable);
}

void _Magick_pixelColorImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_pixelColorImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_pixelColorImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_pixelColorImage_templ::InstanceMethod("call",
        &_Magick_pixelColorImage_templ::_wrap_Magick_pixelColorImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: pageImage (_Magick_pageImage) */
// jsnapi_getclass
Napi::Function _Magick_pageImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_pageImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_pageImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_pageImage_inst>::DefineClass(env, "pageImage", symbolTable);
}

void _Magick_pageImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_pageImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_pageImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_pageImage_templ::InstanceMethod("callAsync",
        &_Magick_pageImage_templ::_wrap_Magick_pageImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_pageImage_templ::InstanceMethod("call",
        &_Magick_pageImage_templ::_wrap_Magick_pageImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: qualityImage (_Magick_qualityImage) */
// jsnapi_getclass
Napi::Function _Magick_qualityImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_qualityImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_qualityImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_qualityImage_inst>::DefineClass(env, "qualityImage", symbolTable);
}

void _Magick_qualityImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_qualityImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_qualityImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("callAsync");
  members.insert({
    "callAsync",
      _Magick_qualityImage_templ::InstanceMethod("callAsync",
        &_Magick_qualityImage_templ::_wrap_Magick_qualityImage_callAsync,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_qualityImage_templ::InstanceMethod("call",
        &_Magick_qualityImage_templ::_wrap_Magick_qualityImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: quantizeColorsImage (_Magick_quantizeColorsImage) */
// jsnapi_getclass
Napi::Function _Magick_quantizeColorsImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_quantizeColorsImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_quantizeColorsImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_quantizeColorsImage_inst>::DefineClass(env, "quantizeColorsImage", symbolTable);
}

void _Magick_quantizeColorsImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_quantizeColorsImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_quantizeColorsImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_quantizeColorsImage_templ::InstanceMethod("call",
        &_Magick_quantizeColorsImage_templ::_wrap_Magick_quantizeColorsImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

/* Class: quantizeColorSpaceImage (_Magick_quantizeColorSpaceImage) */
// jsnapi_getclass
Napi::Function _Magick_quantizeColorSpaceImage_inst::GetClass(Napi::Env env) {
  std::map<std::string, _Magick_quantizeColorSpaceImage_templ::PropertyDescriptor> members, staticMembers;
  GetMembers(env, members, staticMembers);
  
  std::vector<_Magick_quantizeColorSpaceImage_inst::PropertyDescriptor> symbolTable;
  for (auto it = members.begin(); it != members.end(); it++)
  symbolTable.push_back(it->second);
  for (auto it = staticMembers.begin(); it != staticMembers.end(); it++)
  symbolTable.push_back(it->second);
  
  return Napi::ObjectWrap<_Magick_quantizeColorSpaceImage_inst>::DefineClass(env, "quantizeColorSpaceImage", symbolTable);
}

void _Magick_quantizeColorSpaceImage_inst::GetMembers(
  Napi::Env env,
  std::map<std::string, _Magick_quantizeColorSpaceImage_templ::PropertyDescriptor> &members,
  std::map<std::string, _Magick_quantizeColorSpaceImage_templ::PropertyDescriptor> &staticMembers
  ) {
  std::map<std::string, SWIG_NAPI_ObjectWrap_templ<SWIG_NAPI_ObjectWrap_inst>::PropertyDescriptor> baseMembers, baseStaticMembers;
  SWIG_NAPI_ObjectWrap_inst::GetMembers(env, baseMembers, baseStaticMembers);
  members.insert(baseMembers.begin(), baseMembers.end());
  staticMembers.insert(staticMembers.begin(), staticMembers.end());
  
  /* register wrapper functions */
  // jsnapi_register_member_function
  members.erase("call");
  members.insert({
    "call",
      _Magick_quantizeColorSpaceImage_templ::InstanceMethod("call",
        &_Magick_quantizeColorSpaceImage_templ::_wrap_Magick_quantizeColorSpaceImage_call,
        static_cast<napi_property_attributes>(napi_writable | napi_configurable))
    });
  
  /* add static class functions and variables */
  
}

